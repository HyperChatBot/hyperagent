"id","tag","like","pv","is_public","poster_url","title","summary","content","created_at","updated_at"
"e4983f18-6f1d-4d1f-834e-75396a7fd8fe","{CSS3}",0,0,False,"https://edge.yancey.app/beg/Grid-Layout.png","Grid 布局","Grid布局应该是迄今为止最全面最强大的布局方式。从九宫格到圣杯布局、再到响应式设计，Grid提供了一套完美的解决方案。效果说起来很诱人，但学起来还是需要点儿时间，因为属性超级多，而且每个都有新花样，需要慢慢消化。ps: 多图预警，长篇预警，高能预警。","## Introduction

用过BootStrap之类的应该对Grid不陌生，BootStrap3划分栅格主要使用`百分比`，顺便去看了一下第四代，发现使用的是弹性布局了。

不知道大家看到一个小细节没，打开Chrome开发者工具，选择查看元素，将鼠标移动到html页面，发现浏览器自动给栅格标上了虚线，看下图。

![Chrome开发者工具自动标注栅格线](https://edge.yancey.app/beg/6ec00c5f-cb40-4d56-9835-fd57d4c7805b.jpg)

既然是写CSS3相关的属性，按惯例先去[Can I Use](https://caniuse.com/#search=grid)了解一下浏览器的支持情况，发现主流浏览器都能完美使用了。

![Can i use Grid?](https://edge.yancey.app/beg/5dbd661e-b8d9-4691-a429-ce976c7c74db.jpg)

## Terminology

和`弹性布局`一样，Grid布局也有一些独特的术语，这些务必要理解清楚。

### Grid Container

栅格容器是栅格项(Grid Items)的父级元素，也就是那个需要定义`display: grid;`的那个元素。看下面这个例子，class为`grid-container`的那个div就是一个栅格容器。

```html
<div class=""grid-container"">
  <div class=""grid-item grid-item-1""></div>
  <div class=""grid-item grid-item-2""></div>
  <div class=""grid-item grid-item-3"">
    <p>我不是grid-container的直接子元素</p>	
  </div>
</div>
```

### Grid Item

栅格项是栅格容器的`直接子元素`，注意`直接`这两个字，因此上面代码示例中class为`grid-item`的元素是栅格项，而里面的`p`标签则不是。

### Grid Line

栅格线是构成网格结构的分界线：垂直的叫做`列栅格线(column grid lines)`，水平的叫做`行栅格线(row grid lines)`，栅格线的概念很重要，后面定义`grid-column`和`grid-row`都会直接用到栅格线的概念，如下图黄线即为一条栅格线。

![Grid Line](https://edge.yancey.app/beg/8d19574c-3a92-4caa-8bb5-c8a9db29af42.png)

### Grid Track

栅格轨道是由两条`相邻`网格线构成的一个`单行`或`单列`的区域。注意`相邻`这个概念，从词法来说，`轨道`一般都是单条的，如下黄色区域则为一条栅格轨道。

![Grid Track](https://edge.yancey.app/beg/54636927-1746-4529-8401-6933d20a2cba.png)

### Grid Cell

要注意和`Grid Item`的区别，一个Grid Cell包含其对应的Grid Item和Grid Item里面的内容，如下图黄色区域即为一个栅格元。

![Grid Cell](https://edge.yancey.app/beg/c145158d-8aa5-46c8-a106-d0f0cb89eb70.png)

### Grid Area

最后一个术语则是栅格区域，可以说栅格轨道和栅格区域是包含和被包含的关系，如下图的黄色区域就是行栅格线1和3与列栅格线1和3之间圈出来的网格区域。

![Grid Area](https://edge.yancey.app/beg/8273252d-9714-4029-8572-65eaa719a446.png)

## List of Grid Attributes

### List of Grid Container Attributes

* display
 
* grid-template-columns
 
* grid-template-rows
 
* grid-template-areas
 
* grid-template
 
* grid-column-gap
 
* grid-row-gap
 
* grid-gap
 
* justify-items
 
* align-items
 
* justify-content
 
* align-content
 
* grid-auto-columns
 
* grid-auto-rows
 
* grid-auto-flow
 
* grid

### List of Grid Item Attributes

* grid-column-start
 
* grid-column-end
 
* grid-row-start
 
* grid-row-end
 
* grid-column
 
* grid-row
 
* grid-area
 
* justify-self
 
* align-self

似曾相识吧，如`justify-items`、`align-items`在弹性布局中都是核心概念，所以Grid布局则是一个更加全面的布局模式。

ps: 看到这么多属性头都大了，突然想到某考研名师的名言：

![やめてよ！！！](https://edge.yancey.app/beg/6ea92be3-bd18-4886-9985-db6d9a53f539.jpeg)

BUT! 考虑到梦想、~~钱~~(大误)前途。

嗯，真香...（手动王境泽.jpg）

## Grid Container Attributes

首先一一介绍栅格容器的各个属性。

### display

```css
display: grid | inline-grid
```

[CSS Grid 布局完全指南\(图解 Grid 详细教程\)](http://www.css88.com/archives/8510#prop-grid-template-areas)还讲到有一个`subgrid`的属性值，是在Grid布局里嵌套Grid布局，不过我的WebStorm提示没有这个属性值，那就忽略好了，感觉也没什么卵用。

当容器定义了grid布局之后，**容器元素**上定义的`column`，`float`，`clear`， `vertical-align`将失效，注意是**容器元素**，这些属性不会影响Grid Cell, 亲测，嗯。

### grid-template-columns / grid-template-rows

这个属性定义Grid Item的大小，有两个属性值：一个是`track-size`，另一个是`line-name`。

```css
.grid-container {
  grid-template-columns: <track-size> ... | <line-name> <track-size> ...;
  grid-template-rows: <track-size> ... | <line-name> <track-size> ...;
}
```

#### track-size

`track-size`单位很自由，可以是px、em、rem、vw、vh、百分数、auto等等，特别注意这个`auto`，看下面这个代码,假设`grid-container`外面还包着一层`grid-wrapper`，宽度是500px，那么`grid-template-columns`属性的`auto`就会被计算成500-300-100=100px

```css
.grid-wrapper {
  width: 500px;
  .grid-container {
    display: grid;
    grid-template-columns: 300px auto 100px;
  }
}
```

还有一种情况是`grid-container`的总宽或总高大于了`grid-wrapper`的总宽或总高，看下面代码。

```css
.grid-wrapper {
  width: 500px;
  .grid-container {
    display: grid;
    grid-template-columns: 300px 200px 100px;
  }
}
```

这里的解释是个人的想法，留个坑，看下图。

![当grid-container的总宽或总高大于grid-wrapper的总宽或总高](https://edge.yancey.app/beg/970aea7f-40b7-4f7b-9e99-3b65c744187c.jpg)

#### line-name

这个属性值就比较骚气了，可以定义Grid Line的名称，注意要用`中括号`包起来，第一次见。可以看一个综合示例。

```css
.grid-container {
  display: grid;
  grid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end];
  grid-template-rows: [row1-start] 25% [row1-end] 100px [third-line] auto [last-line];
}
```

![一个综合例子](https://edge.yancey.app/beg/dd956aaf-cdc2-4749-aabd-bd5f328d3aa3.png)

更骚气的是，一条Grid Line还可以有多个名称，看代码，这里的第二条row-grid-line将会有两个名字，分别是`row1-end`和`row2-start`。

```css
.grid-container {
  display: grid;
  grid-template-rows: [row1-start] 25% [row1-end row2-start] 25%;
}
```

BUT! 还没骚完...还有一个repeat语法，看下面的代码。

```css
.grid-container {
  display: grid;
  grid-template-columns: repeat(3, 33.33333vw [col]);
  grid-template-rows: repeat(3, 33.33333vh [row]);
}
```

卧槽，什么概念，三句话搞了一个视口九宫格！想想用传统方式写个九宫格，甚至用弹性布局写个九宫格，而如今...

![感动ing...](https://edge.yancey.app/beg/57005890-f4bc-44ed-a9c9-85453da6b098.jpeg)

最后... 还有一个单位... 叫fr...

fr允许你用等分网格容器剩余可用空间来设置Grid Track的大小，看代码。

总宽度是500px，分了三列，其中第一列占了100px，所以后两列占400px，后两列一共是4fr,因此1fr是100px，所以下面的例子等价于`grid-template-columns: 100px 300px 100px;`

```css
.grid-wrapper {
  width: 500px;
  .grid-container {
    display: grid;
    grid-template-columns: 100px 3fr 1fr;
    grid-template-rows: repeat(3, 100px [row]);
  }
}
```

蛤？你以为这样就完了？

Naive！

下面要讲到一个属性叫`grid-column-gap / grid-row-gap`，这个东西很流弊，它用来设置每个Grid Item的间距。

设个间距有什么流弊的？`margin`不就得了？

但是考虑一个常见的场景，看代码。这是一个常见的navbar，要使用`margin-right`分隔的话，需要把最后一个`li`的`margin-right`设为`0`.

```html
<nav>
  <ul>
    <li>home</li>
    <li>blog</li>
    <li>music</li>
    <li>photo</li>
    <li>about</li>
  </ul>
</nav>

li {
  list-style-type: none;
  display: inline-block;
  margin-right: 10px;
  &:last-child {
    margin-right: 0;
  }
}
```

BUT！`grid-column-gap / grid-row-gap`只会在 列/行 之间创建间距，两侧不会有这个间距。看代码。

```css
ul {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  grid-column-gap: 10px;
  li {
    list-style-type: none;
    display: inline-block;
  }
}
```

当然这个例子不太好，目前实在也想不出太好的例子来，总之就是`grid-column-gap / grid-row-gap`可以避免左右边界也给创建间隔。

那`grid-column-gap / grid-row-gap`跟`fr`有毛线关系？看下面这个例子。假设总宽度为500px，现在列分成了5份，每份占20%.

当没有间隔时，正好每个Grid Item的宽为`100px`；

但有了10px的列间隔后，看下面的图，会发现每个Grid Item的宽仍为`100px`，但右边溢出了一部分。

```css
.grid-wrapper {
  width: 500px;
  .grid-container {
    display: grid;
    grid-template-columns: repeat(5, 20%);
    grid-template-rows: repeat(2, 100px [row]);
    grid-column-gap: 10px;
}
```

![右边溢出了一部分](https://edge.yancey.app/beg/f41d6d46-64da-4e31-845a-c07a6ed95d7c.jpg)

当然你可以考虑使用计算属性，看代码。

```css
.grid-wrapper {
  width: 500px;
  .grid-container {
    display: grid;
    grid-template-columns: repeat(5, calc((500px - 10px * 4) / 5));
    grid-template-rows: repeat(2, 100px [row]);
    grid-column-gap: 10px;
}
```

但是还是很麻烦，所以fr就派上了用场（卧槽前面居然这么多铺垫），以列这个方向为例，fr是总宽度减去固定Grid Track的宽度，如果有间隔，再减去间隔的总宽度，最后再去平分剩余宽度，看代码。完美解决。

```css
.grid-wrapper {
  width: 500px;
  .grid-container {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    grid-template-rows: repeat(2, 100px [row]);
    grid-column-gap: 10px;
}
```

### grid-template-areas

这是用来定义模版区域的一个属性，有三个属性值，分别是：

* \<grid-area-name>：由网格项的 grid-area 指定的网格区域名称
* .（点号） ：代表一个空的网格单元
* none：不定义网格区域

还是直接看例子。

```css
.grid-item-1 {
  grid-area: header;
}
.grid-item-2 {
  grid-area: main;
}
.grid-item-3 {
  grid-area: aside;
}
.grid-item-4 {
  grid-area: footer;
}
.grid-container {
  display: grid;
  grid-template-columns: 50px 50px 50px 50px;
  grid-template-rows: auto;
  grid-template-areas:
          ""header header header header""
          ""main main . aside""
          ""footer footer footer footer"";
}
```

整个栅格系统分了四列，每列宽50px，第一行四个全被定义成了`header`；第二行从左右到右，`main`占了列，第三列`未定义`名称，所以用`.`来占位，最后一个则被定义为`aside`；最后一行则被`footer`所占据。

![grid-template-areas示例示意图](https://edge.yancey.app/beg/a9e15001-8241-4acb-ae90-764e4bdbab98.png)

看到这里，就有种`模块化的味道了`，比如在class为`grid-item-1`的部分去定义`header`的相关属性；在class为`grid-item-4`的部分去定义`footer`的相关属性。

放一个我写的例子。

### grid-template

这个属性是`grid-template-rows` ，`grid-template-columns`，`grid-template-areas`的合体版。

私以为本来就很复杂了，合起来更麻烦了，而且`grid-template`不会重置`隐式`栅格属性，即`grid-auto-column`、 `grid-auto-rows`、`grid-auto-flow`，而且`auto`又很常见，所以少用为妙，而且下面还有跟好用的办法。

### grid-column-gap / grid-row-gap

不多说，上面已经介绍到了。这里重复一下，`grid-column-gap / grid-row-gap`只会在 列/行 之间创建间距，两侧不会有这个间距。

### grid-gap

这是`grid-column-gap`和`grid-row-gap`的合体写法，具体语法如下：

```css
.grid-container {
  grid-gap: <grid-row-gap> <grid-column-gap>;
}
```

看一个特殊情况：

```css
.grid-container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: repeat(3, 100px [row]);
  grid-gap: 10px;
}
```

当`grid-gap`只写了一个值，这个值会被认作是`grid-column-gap`的属性值，这个时候相当于`grid-row-gap`没有定义，因此`grid-row-gap`也会被赋给这个值，相当于`grid-gap: 10px 10px;`.

因此，如果只想要列间距，就写成`grid-gap: 0 10px;`即可。

### justify-items

_注：这个属性的细节，包括下面的`align-items`就不详细写了，这一块和我以前写过的一篇文章[弹性布局](https://www.yanceyleo.com/blog/CSS/flexible-box/)一模一样，那里对每个属性值都做了分析，这里只是简单贴一下介绍和属性值list._

justify-items为沿着行轴线(row axis) 对齐网格项(grid items) 内的内容。

* start：将内容对齐到网格区域(grid area)的左侧
 
* end：将内容对齐到网格区域的右侧
 
* center：将内容对齐到网格区域的中间（水平居中）
 
* stretch：填满网格区域宽度（默认值）

### align-items

align-items为沿着列轴线(column axis) 对齐网格项(grid items) 内的内容。

* tart：将内容对齐到网格区域(grid area)的顶部
 
* end：将内容对齐到网格区域的底部
 
* center：将内容对齐到网格区域的中间（垂直居中）
 
* stretch：填满网格区域高度（默认值）

### justify-content

此属性沿着行轴线(row axis) 对齐网格。

* start：将网格对齐到 网格容器(grid container) 的左边
 
* end：将网格对齐到 网格容器 的右边
 
* center：将网格对齐到 网格容器 的中间（水平居中）

* stretch：调整 网格项(grid items) 的宽度，允许该网格填充满整个 网格容器 的宽度
 
* space-around：在每个网格项之间放置一个均匀的空间，左右两端放置一半的空间
 
* space-between：在每个网格项之间放置一个均匀的空间，左右两端没有空间
 
* space-evenly：在每个栅格项目之间放置一个均匀的空间，左右两端放置一个均匀的空间

### align-content

此属性沿着列轴线(column axis) 对齐网格。

* start：将网格对齐到 网格容器(grid container) 的顶部
 
* end：将网格对齐到 网格容器 的底部
 
* center：将网格对齐到 网格容器 的中间（垂直居中）
 
* stretch：调整 网格项(grid items) 的高度，允许该网格填充满整个 网格容器 的高度
 
* space-around：在每个网格项之间放置一个均匀的空间，上下两端放置一半的空间
 
* space-between：在每个网格项之间放置一个均匀的空间，上下两端没有空间
 
* space-evenly：在每个栅格项目之间放置一个均匀的空间，上下两端放置一个均匀的空间

### grid-auto-columns / grid-auto-rows

此属性用于自动生成**非**`grid-template-rows`或 `grid-template-columns`创建的Grid Track。

有些绕，看例子，很显然会生成下图这样一个栅格系统。

```css
.grid-container {
  display: grid;
  grid-template-columns: 60px 60px;
  grid-template-rows: 90px 90px;
}
```

![显式栅格](https://edge.yancey.app/beg/01347098-a600-4585-9593-f952ffe540f0.png)

这里暂时用一下Grid Items的语法`grid-column`和`grid-row`，以区域2为例，它在垂直方向由`第一根线`和`第二根线`围成；在水平方向由`第二根线`和`第三根线`围成。因此区域2可以用一下代码表示：

```css
.area-2{
  grid-column: 1 / 2;
  grid-row: 2 / 3;
}
```

![提前了解一下grid-column和grid-row](https://edge.yancey.app/beg/4331b23b-52b0-4d6d-8d23-5ff85782dac1.png)

回到正题，看下面代码，`item-a`是在真正的栅格系统里，而`item-b`不再原栅格系统。

```css
.item-a {
  grid-column: 1 / 2;
  grid-row: 2 / 3;
}
.item-b {
  grid-column: 5 / 6;
  grid-row: 2 / 3;
}
```

![item-b不在正常的栅格系统里](https://edge.yancey.app/beg/5d47a3a7-b70c-4693-8511-97f124a57b02.png)

因此就可以用`grid-auto-columns`和`grid-auto-rows`来定义隐式创建的Grid Track的大小。私以为这种出格的事情，还是不要去做的好。

### grid

`grid`是在一个声明中设置所有以下属性的简写：`grid-template-rows`, `grid-template-columns`, `grid-template-areas`, `grid-auto-rows`, `grid-auto-columns`, 和 `grid-auto-flow` 。

合起来写还是有些头大，我还是分开写（手动债见.jpg）

## Grid Items Attributes

呼～终于把Grid Container的属性全写完了，下面再写Grid Item的。

### grid-column-start / grid-column-end / grid-row-start / grid-row-end

上面有简单介绍过`grid-column`和`grid-row`，其实这四个属性就是这两种分开写的形式。因为合着写要方便很多，所以这里一笔带过，直接看语法。

```css
.grid-item {
  grid-column-start: <number> | <name> | span <number> | span <name> | auto
  grid-column-end: <number> | <name> | span <number> | span <name> | auto
  grid-row-start: <number> | <name> | span <number> | span <name> | auto
  grid-row-end: <number> | <name> | span <number> | span <name> | auto
}
```

### grid-column/ grid-row

这里还是要单拎出来再次解释一下，因为有一些好玩的东西。

```html
<div class=""grid-wrapper"">
  <main class=""grid-container"">
    <section class=""grid-item grid-item-1"">1</section>
    <section class=""grid-item grid-item-2"">2</section>
    <section class=""grid-item grid-item-3"">3</section>
    <section class=""grid-item grid-item-4"">4</section>
    <section class=""grid-item grid-item-5"">5</section>
    <section class=""grid-item grid-item-6"">6</section>
    <section class=""grid-item grid-item-7"">7</section>
    <section class=""grid-item grid-item-8"">8</section>
    <section class=""grid-item grid-item-9"">9</section>
  </main>
</div>

.grid-container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: [row-1] 100px [row-2] 100px [row-3] 100px;
  .grid-item-1 {
    grid-column: 1 / span 2;
    grid-row: row-2 / 4;
  }
}
```

先看`grid-column`，`span`就是该网格项将跨越所提供的网格轨道数量，所以这句等价于`grid-column: 1 / 3;`

再看`grid-row`，我们在上面定义的第二条row的名称就叫做`row-2`，因此`row-2`就指代`2`，所以这句等价于`grid-row: 2 / 4;` 所以这就是定义`Grid Line`的名称的意义。

比起`grid-template-areas`的写法，我觉得这个更加方便，因为在HTML中已经做了语义化，再用`grid-template-areas`定义一遍语义不见得是最好的选择。

在线代码在下面：

### grid-area

`grid-area`为网格项提供一个名称，以便可以被使用网格容器`grid-template-areas`属性创建的模板进行引用。 另外，这个属性可以用作`grid-row-start` + `grid-column-start` + `grid-row-end` + `grid-column-end`的缩写。

这里就说一下缩写好了，看代码和图片。

```css
.grid-item-d {
  grid-area: 1 / col4-start / last-line / 6
}
```

![grid-area](https://edge.yancey.app/beg/364db01f-48f2-4101-9f73-cff0a7e5baf1.png)

### justify-self

`justify-self`是沿着行轴线(row axis) 对齐网格项内的内容。

这又回到了和弹性布局类似的地方，照例写一下所有属性值：

* start：将内容对齐到网格区域的左侧
 
* end：将内容对齐到网格区域的右侧
 
* center：将内容对齐到网格区域的中间（水平居中）
 
* stretch：填充整个网格区域的宽度（这是默认值）

### align-self

`align-self`是沿着列轴线(column axis) 对齐网格项内的内容。

* start：将内容对齐到网格区域的顶部
 
* end：将内容对齐到网格区域的底部
 
* center：将内容对齐到网格区域的中间（垂直居中）
 
* stretch：填充整个网格区域的高度（这是默认值）

## References

[CSS Grid 布局完全指南\(图解 Grid 详细教程\)](http://www.css88.com/archives/8510#prop-grid-column-row)

[CSS 新的长度单位 fr 你知道么？
](https://zhuanlan.zhihu.com/p/27502596)

_注：文章很多图片来自[CSS Grid 布局完全指南\(图解 Grid 详细教程\)](http://www.css88.com/archives/8510#prop-grid-template-areas)，如有侵权，将于联系后删除。_

## Summarize

终于写完了，个人觉得Grid布局更像是一种全局性质的布局方案，一些小的部件如果用的话反倒可能会像Table系的布局一样被限制住。

当然优点显而易见，比如让`grid-template-columns`和`grid-template-rows`使用百分比或视口单位，做响应式开发可谓是方便了太多。

以上、よろしく。
","2025-02-02 03:07:38.903614","2025-02-02 03:07:38.903614"
"cd0df6bf-0dd9-4307-af86-2116e940cdee","{CSS3,""CSS3 Animation""}",0,0,False,"https://edge.yancey.app/beg/a-simple-guide-to-understanding-css-animations-in-email.png","你可能不知道的 CSS3 Animation","前端创建动画有三种，分别是 **定时器**, **requestAnimationFrame** 以及 **CSS3 Animation**，而 requestAnimationFrame 的出现基本秒杀了定时器。虽然 Animation 暂无法处理如三次方缓动、指数衰减正弦曲线缓动等需要高级数学运算的动画（貌似 CSS3 要支持三角函数了），但在绝大多数情况下依旧可以做出非常优秀的动画效果，这里对 Animation 各属性做个总结。","## 属性一览

目前 animation 有下面 9 种属性，其中第一个是后面属性的简写形式。

| 属性                      | 描述                                          |
| ------------------------- | --------------------------------------------- |
| animation                 | 下面各属性的简写（除了 animation-play-state） |
| animation-name            | 指定 @keyframes 动画的名称                    |
| animation-duration        | 动画完成一个周期的时间，默认为 0s             |
| animation-timing-function | 动画运行的'节奏'，默认是 ease                 |
| animation-delay           | 动画开始播放的延迟时间，默认是 0              |
| animation-iteration-count | 动画播放的次数，默认是 1                      |
| animation-direction       | 规定动画是否在下一个周期逆向播放              |
| animation-fill-mode       | 规定动画的填充模式                            |
| animation-play-state      | 控制动画的运行或暂停，默认是 running          |

## animation-name

该属性用于指定 @keyframes 动画的名称。定义关键帧需要使用 `@keyframes` 规则。样式块语句中可以使用 **from...to** 结构，也可以使用**百分比**来定义。

如下面这段代码，它在动画开始运行时将元素放大 1.1 倍，在动画运行到一半时将元素缩小为 0.8 倍，在动画结束时将元素再放大为 1.1 倍，配合上后面要讲到的 infinite 和贝塞尔曲线，就可以模拟出不错的心跳动画效果。

```css
.heart {
  animation: heartbeat cubic-bezier(0.2, 0.73, 0.71, 0.44) infinite;
}

@keyframes heartbeat {
  0% {
    transform: scale(1.1);
  }
  50% {
    transform: scale(0.8);
  }
  100% {
    transform: scale(1.1);
  }
}
```

![HEART BEAT](https://edge.yancey.app/beg/169e6d3fb65af29d.gif)

## animation-duration

该属性定义一个动画周期的时长。

- 默认值为 0s，表示无动画

- 单位为秒或者毫秒，无单位值无效

## animation-timing-function

该属性用于定义动画的'节奏'，默认值为 ease.

| 属性值      | 描述                       |
| ----------- | -------------------------- |
| ease        | 缓慢开始，缓慢结束         |
| ease-in     | 先慢后快                   |
| ease-out    | 先快后慢                   |
| ease-in-out | 以慢速开始和结束的过渡效果 |
| linear      | 平滑效果   |
| step-start  | 步进，忽略第一帧           |
| step-end    | 步进，忽略最后一帧         |
| step-middle | 步进，从第一帧到最后一帧   |

不管是在 Animation 还是 Transition 里，前 5 个应该很常见，我们可以直接在 Chrome Dev 中查看具体的函数图像（其实这五个就是贝塞尔曲线的几种特殊形式）。

![贝塞尔曲线](https://edge.yancey.app/beg/169e6d3fb6658dac.jpg)

step-start, step-end 和 step-middle 表示步进动画。

其中 step-start 会忽略相应 @keyframs 规则的第一帧，而 step-end 会忽略最后一帧, step-middle 在一个周期内会从**第一帧一直步进到最后一帧**。

看下面这个例子，当使用 `step-start` 时，元素的初始状态就是 1.2 倍（对应着 25%），一个周期内步进执行 25% -> 50% -> 75% -> 100%

当使用 `step-end` 时，元素的初始状态是 1.1 倍（对应着 0%），一个周期内步进执行 0% -> 25% -> 50% -> 75%

当使用 `step-middle` 时，元素的初始状态就是元素的初始状态，一个周期内步进执行 0% -> 25% -> 50% -> 75% -> 100%

```css
@keyframes someEffect {
  0% {
    transform: scale(1.1);
  }
  25% {
    transform: scale(1.2);
  }

  50% {
    transform: scale(1.3);
  }

  75% {
    transform: scale(1.4);
  }

  100% {
    transform: scale(1.5);
  }
}
```

此外该属性还有三个内置函数，分别是 cubic-bezier(), steps() 以及 frames()。

这里简单谈一谈 steps()。如果你用过 Twitter，你应该知道它的点赞效果很酷，可以看下图。这个效果完全可以用 steps() 模拟出来，我的博客中点赞模块也有这个效果，不过是用的 box-shadow，你可以看源码 [Like Component](https://github.com/Yancey-Blog/BLOG_FE/tree/master/src/components/Post/Like)

![like](https://edge.yancey.app/beg/169e6d3fb696cfa6.gif)

首先你要下载下面这张图片，可以看到它是一张 **未点赞状态 -> 生成礼花 -> 礼花消失 -> 点赞状态** 的雪碧图。

![1_MTZW1G1mE7LSX1CnhTYeHA.png](https://edge.yancey.app/beg/169e6d3fb6a474b2.png)

在初始化时，我们通过 `background-position: left` 和 `background-size: 2900%` 将初始背景定位到上图中第一个灰色的 icon.

接着我们创建一个 @keyframes，用于在一个动画周期内将上面的图片从左到右一次性走完。

为了每一帧都会“跳”到下一个 icon，而不是平滑的移动。我们使用 steps() 函数，因为共有 29 张小 icon，其中默认是第一个，所以传递参数 28.

在点击背景图片时，将 `is_animating` 添加到 heart 元素上，即可实现点赞礼花效果。

```html
<div class=""heart""></div>
```

```css
.heart {
  cursor: pointer;
  height: 50px;
  width: 50px;
  background-image: url('heart-locus.png');
  background-position: left;
  background-repeat: no-repeat;
  background-size: 2900%;
}

.is_animating {
  animation-name: heart-burst;
  animation-duration: 800ms;
  animation-timing-function: steps(28);
  animation-iteration-count: 1;
}

@keyframes heart-burst {
  from {
    background-position: left;
  }
  to {
    background-position: right;
  }
}
```

```js
const heartDOM = document.querySelector('.heart');

heartDOM.addEventListener('click', function() {
  this.classList.toggle('is_animating');
});

heartDOM.addEventListener('animationend', function() {
  this.classList.toggle('is_animating');
});
```

## animation-delay

该属性用于将动画延迟执行，默认值为 0s。当该属性的属性值为负值会出现一些好玩的事情，我们直接看 MDN 上的定义。

> 定义一个负值会让动画立即开始。但是动画会从它的动画序列中某位置开始。例如，如果设定值为-1s，动画会从它的动画序列的第 1 秒位置处立即开始。
> 如果为动画延迟指定了一个负值，但起始值是隐藏的，则从动画应用于元素的那一刻起就获取起始值。

我们看下面这个例子：

```css
.cube {
  margin-bottom: 10px;
  width: 100px;
  height: 100px;
  background: #ccc;
  animation: colorChange 10s linear;
}

.has-delay {
  animation-delay: 2s;
}

.has-ng-delay {
  animation-delay: -2s;
}

@keyframes colorChange {
  20% {
    background-color: #f8e81c;
  }

  40% {
    background-color: #d0011b;
  }

  60% {
    background-color: #7ed321;
  }

  80% {
    background-color: #509ce3;
  }

  100% {
    background-color: #ccc;
  }
}
```

html 结构如下：

```html
<div class=""cube""></div>
<div class=""cube has-ng-delay""></div>
<div class=""cube has-delay""></div>
```

这个例子中，我们将 cube 的动画总时长设为 10s，且初始颜色都是灰色。不同的是，第一个 cube 正常执行，第二个 cube ""延迟"" -2s 执行，第三个 cube 延迟 2s 执行。

根据下面这张图可以看出，第二个 cube 虽然是负数，但从动画一开始就会执行，只不过它是从第二帧开始的。

这是因为定义在 @keyframes 中的动画需要执行 animation-time 时间长度。animation-delay 为正数的时候，动画就要要延迟开始，animation-time 都还没有开始计算，正数的 delay 不会被计算到 animation-time 中，因此我们看到的动画就是从第一帧开始的；animation-delay 为负数的时候，意味着动画是提前开始的，animation-time 已经开始计算了，负数的 delay 是被算入 animation-time 中的，所以我们看到的动画是从某一帧开始的。

![animation-time](https://edge.yancey.app/beg/169e6d3fb6beadce.jpg)

所以我们可以尝试写个 loading 组件出来。源码贴在下面。

```css
.loader-container {
  width: 210px;
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-template-rows: 1fr 1fr;
  grid-template-rows: 1fr 1fr;
  grid-row-gap: 10px;
  grid-column-gap: 10px;
}

.cube {
  width: 100px;
  height: 100px;
  background: #ccc;
  animation: colorChange 5s linear infinite;
}

.delay-neg-1 {
  animation-delay: -1s;
}

.delay-neg-2 {
  animation-delay: -2s;
}

.delay-neg-3 {
  animation-delay: -3s;
}

.delay-neg-4 {
  animation-delay: -4s;
}
```

下面是 HTML

```html
<div class=""loading-container"">
  <div class=""cube delay-neg-1""></div>
  <div class=""cube delay-neg-2""></div>
  <div class=""cube delay-neg-3""></div>
  <div class=""cube delay-neg-4""></div>
</div>
```

![169e6d3fb6ab4253.gif](https://edge.yancey.app/beg/169e6d3fb6ab4253.gif)

## animation-iteration-count

该属性定义循环播放动画的次数，默认值为 1

- 不可以为负数

- infinite 表示无限循环

- 可以为小数，比如 0.5 代表播放动画的一半即结束

## animation-direction

该属性表示动画是否反向播放，共有 4 个值：

- normal: 每次从 @keyframes 0% 执行到 100%，一个周期结束后立即回到 0% 的位置

- alternate: 假设 `animation-iteration-count: infinite`，从 @keyframes 0% 执行到 100%后，再从 100% 的位置 回到 0%，周而复始

- reverse: 每次从 @keyframes 100% 执行到 0%，，一个周期结束后立即回到 100% 的位置

- alternate-reverse: 假设 `animation-iteration-count: infinite`，从 @keyframes 100% 执行到 0%后，再从 0% 的位置 回到 100%，周而复始

## animation-fill-mode

用于设定动画时间外的属性，也就是说一个动画周期开始之前或结束之后，元素的状态应该是什么样的。该属性有四个属性值，分别是 none, forwards, backwards, both.

- none 是默认值，表示动画播放完成后，恢复到初始的状态。

- forwards 表示动画播放完成后，保持 @keyframes 里最后一帧的样式。

- backwards 表示开始播放动画之前，元素的样式将设置为动画第一帧的样式

- both 相当于同时配置了 forwards 和 backwards。也就是说，动画开始前，元素样式将设置为动画第一帧的样式；而在动画线束状态，元素样式将设置为动画最后一帧样式。

## animation-play-state

该属性用于让一个动画的暂停与启动，有两个属性值，分别是 running 和 pause，当设置为 pause 时，动画会立即会停在当前位置，当取消暂停后会在**停住的位置**继续执行，而不会回到原点（或终点）重新执行。

## animation

最后说一下 animation 属性，它是上述属性的简写形式，animation 属性暂时还没有收录 `animation-play-state`，如若使用需要单独来写，语法如下。

```css
animation: name duration timing-function delay iteration-count direction fill-mode;
```

## 多动画

上面我们看到了每个属性都可以添加多个属性值，他们之间用逗号隔开，其实就是给一个元素添加多个动画。

## 参考

[CSS3 动画实践](https://aotu.io/notes/2016/01/04/css3-animation/index.html)

[CSS 动画简介](http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html)

[复习 animation-delay 负值以及 delay 正值在 iOS 上的坑](https://zhuanlan.zhihu.com/p/23982450)

[前端 Talkking CSS 系列 —— 一步一步带你认识 animation 动画效果](https://juejin.im/post/5a50bc24518825734859c597)

[CSS3 animation 属性中的 steps 功能符深入介绍](https://www.zhangxinxu.com/wordpress/2018/06/css3-animation-steps-step-start-end/)

[你所不知道的 animation-fill-mode 细节](https://www.w3cplus.com/css3/css-animation-fill-mode-property.html)
","2025-02-02 03:07:40.783293","2025-02-02 03:07:40.783293"
"57701c79-4351-43b5-9d76-ce1c1a2b3c32","{CSS}",0,0,False,"https://edge.yancey.app/beg/68747470733a2f2f79616e6365792d6173736574732e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f64613832643065392d653434352d343331652d393234382d3862303538646562643836652e6a7067.jpeg","关于 css 优先级","css 优先级需要关注两个维度：一个是样式距离，分别是内联样式、内部样式、外联样式；另一个则是根据属性的权重来判断。前者不用多说，这里详细分析一下后者。","## 一种思路

曾经有一种计算权重的方法，是将 id 的权值设为 100，class 权值设为 10，dom 元素的权值设为 1……

但这种思路不见的严谨，可以看下面这个例子：

```css
#j {
	color: red;
}

.a .b .c .d .e .f .g .h .i .j {
	color: green;
}

<div class=""a"">
	<div class=""b"">
		<div class=""c"">
			<div class=""d"">
				<div class=""e"">
					<div class=""f"">
						<div class=""g"">
							<div class=""h"">
								<div class=""i"">
									<div id=""j"" class=""j"">
										yanceyleo
									</div>
								</div>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>
	</div>
</div>
```

按上面那种说法，两个 css 的权值都是 100，但实际上最后颜色显示为红色。

## 一个靠谱的方法

- 元素/伪元素: (0,0,0,1)

- 类/伪类/属性: (0,0,1,0)

- ID: (0,1,0,0)

- 内联样式: (1,0,0,0)

这个方法`从左到右，逐位比较`。

回到一开始那个例子：

当使用 id 时，它的坐标是(0,1,0,0)

当使用 class 时，它的坐标是(0,0,10,0)

因为是`从左到右，逐位比较`，所以到了第二位，使用 class 的那个就被 pass 掉了，所以文字显示红色也就一目了然了。

## 有用的总结

- !important 最大，哪怕她的优先级不及其他的写法；

- 如果根据上面的计算法则，仍然权重相同，那后声明的覆盖先声明的；

- 要考虑到继承的样式

- 外部样式 < 内部样式 < 内联样式
","2025-02-02 03:07:42.96732","2025-02-02 03:07:42.96732"
"ec273e18-9e85-4a84-b55e-07ad80c3e449","{CSS,""CSS 垂直居中""}",0,0,False,"https://edge.yancey.app/beg/5d85c750c8937703.jpg","各种垂直居中总结","这里总结各种垂直居中的方法。重点是在不知道宽高的情况下如何设置垂直居中。面试和平时工作会常用到，尤其是flex布局的垂直居中法将在未来会成为主流。","## 确保只有一行文字的垂直居中

```html
.wrap-text {
    line-height: 100px;
    text-align: center;
    height: 100px;
    background-color: red;
}

<div class='wrap-text'>
    <p>只适合纯文本且只有一行</p>
</div>
```

关键点在于line-height的属性值要和父元素的高度相等，且文本只能一行。

## padding法垂直居中

```html
.wrap-padding {
    width: 400px;
    height: 200px;
    background-color: blue;
}

.wrap-padding-content {
    width: 100px;
    height: 100px;
    padding: 50px 150px;
    background-color: green;
    background-clip: content-box;
}

<div class=""wrap-padding"">
    <div class=""wrap-padding-content""></div>
</div>
```

在子元素中，padding的属性值：上下=<mark>(父元素高度-子元素高度)/2</mark>;左右=<mark>(父元素宽度-子元素宽度度)/2</mark>，即50=(200-100)/2 150=(400-100)/2.且要设置background-clip的属性值为<mark>content-box</mark>.此方法**需要知道父元素的宽高**。

## margin法垂直居中

```html
.wrap-margin {
    overflow: hidden; 
    width: 400px;
    height: 200px;
    background-color: pink;
}

.wrap-margin-content {
    width: 100px;
    height: 100px;
    /* 50=(200-100)/2 左右设为auto margin-bottom设为0 */
    margin: 50px auto 0 auto;
    background-color: orange;
}

<div class=""wrap-margin"">
    <div class=""wrap-margin-content""></div>
</div>
```

此方法需要在父元素设置overflow的属性值为<mark>hidden</mark> ，且子元素的margin-top的值=<mark>(父元素高度-子元素高度)/2</mark>,margin-left和margin-right设为<mark>auto</mark>, margin-bottom设为<mark>0</mark>.此方法**需要知道父元素的宽高**。

## 父元素设为相对对位，子元素设为绝对定位（但需要用到子元素的宽高）

```html
.wrap-relative {
    position: relative;
    width: 400px;
    height: 200px;
    background-color: coral;
}

.wrap-absolute-content {
    position: absolute;
    width: 100px;
    height: 100px;
    /* 先让top和left设为50% */
    top: 50%;
    left: 50%;
    /*这里的-50px是子元素宽高的一半*/
    margin-top: -50px;
    margin-left: -50px;
    background-color: #fff;
}

<div class=""wrap-relative"">
    <div class=""wrap-absolute-content""></div>
</div>
```

父元素设为相对对位，子元素设为绝对定位，子元素的top和left的属性值设为<mark>50%</mark>,并且margin-top的属性值设为<mark>(-子元素的高度/2)</mark>，即-50px;margin-left的属性值设为<mark>(-子元素的宽度度/2)</mark>，即-50px.**这里就不用关心父元素的宽高**，但仍然要计算子元素的宽高，牙败牙败。

## 父元素设为相对对位，子元素设为绝对定位（无需知道任何元素的宽高）

```html
.wrap-relative-1 {
    position: relative;
    width: 400px;
    height: 200px;
    background-color: black;
}

.wrap-absolute-content-1 {
    position: absolute;
    width: 100px;
    height: 100px;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    margin: auto;
    background-color: #f2f2f2;
}

<div class=""wrap-relative-1"">
    <div class=""wrap-absolute-content-1""></div>
</div>
```

这里将父元素设为相对对位，子元素设为绝对定位，而子元素的top, right, bottom, left的属性值都设为<mark>0</mark>, 且margin设为<mark>auto</mark>.这里**无需关注任何相关元素的宽高**。撒花 (✿◕‿◕✿)

## 父元素设为相对对位，子元素设为绝对定位（利用CSS3新属性，无需知道任何元素的宽高）

```html
.wrap-relative-2 {
    position: relative;
    width: 400px;
    height: 200px;
    background-color: yellow;
}

.wrap-absolute-content-2 {
    position: absolute;
    width: 100px;
    height: 100px;
    left: 50%;
    top: 50%;
    transform: translate3d(-50%, -50%, 0);
    background-color: purple;
}

<div class=""wrap-relative-2"">
    <div class=""wrap-absolute-content-2""></div>
</div>
```

这里利用了CSS3的新属性，先将父元素设为相对对位，子元素设为绝对定位。子元素的left和top的属性值分别设为<mark>50%</mark>，并且将 transform的属性值设为<mark>translate3d(-50%, -50%, 0)</mark>.

## 憋大招 弹性布局垂直居中

```html
.container {
    display: flex;
    /* 垂直居中 */
    align-items: center;
    /* 水平居中 */
    justify-content: center;
    width: 400px;
    height: 200px;
    background-color: black;
}

.item {
    width: 100px;
    height: 100px;
    background-color: pink;
}

*********************************************

/* 还可以这样写 */
.container {
    display: flex;
    width: 400px;
    height: 200px;
    background-color: black;
}

.item {
    width: 100px;
    height: 100px;
    margin: auto;
    background-color: pink;
}


<div class=""container"">
    <div class=""item""></div>
</div>
```

这大抵是垂直居中的最优解决方案了，我在另一篇文章，[弹性布局](https://www.yanceyleo.com/blog/CSS/flexible-box/)介绍了弹性布局的常见属性。

## PS：

vh布局方式可以让元素相对于视口居中，特别是模态框这种东西更加适合，尤其在HTNML5.2新标准中增加了dialog标签之后。

```html
dialog {
    position: fixed;
    margin-top: 50vh;
    margin-left: 50vw;
    transform: translate(-50%, -50%);
}

<dialog open>
    <h1>我是模态框</h1>
    用户名：<input type=""text""><br>


    密码：<input type=""password""><br data-tomark-pass>
    提交：<input type=""submit"">
</dialog>

/*这里假定一个高度，因为dialog的position设为了fixed，因为无论鼠标滚轮怎么变化，模态框都是相对于视口垂直居中*/

/*而且卧槽，浏览器窗口在resize时，仍然能保持垂直居中，js可以拜拜了*/
<div style=""height: 1000px""></div>
```

_注意：截至目前只有Chrome支持了dialog标签吼~_
","2025-02-02 03:07:44.06945","2025-02-02 03:07:44.06945"
"b950282b-9439-4b95-a772-fca4a8644b7e","{CSS3}",0,0,False,"https://edge.yancey.app/beg/bg2015071002.png","弹性布局","本文是在学习阮一峰大神的《Flex 布局教程：语法篇》之后写成的，去年系统的学了一遍，但没有总结成博文，这次算是弥补一下，并对一些错误加以修正。","## 使用范围

块级元素和内联元素都可以使用，但当声明了弹性布局后，其子元素的**float**、**clear**和**vertical-align**属性将无效。

```
.block-el{
  display: flex;
}

.inline-block-el{
  display: inline-flex;
}


```

## 基本概念

被声明了弹性布局的元素叫做**弹性容器**（flex container）,其子元素被称作**弹性项目**（flex item）。

其中整个弹性容器默认存在两个轴，水平的叫做**主轴**(main axis)，垂直的叫做**侧轴**(cross axis)

主轴的起始端点称为**主轴起点**(main start)，结束端点称为**主轴终点**(main end)

侧轴的起始端点称为**侧轴起点**(cross start)，结束端点称为**侧轴终点**(cross end)

_注：主轴的起点终点不一定是在左右，同理侧轴的起点终点不一定是在上下，因为弹性盒子的方向有可能是垂直的，下面会说到。_

![基本概念示意图](https://edge.yancey.app/beg/856b309b-bb31-437c-a284-ceb3ad6ce383.png)

## 容器属性

整个外容器有6个属性，一个一个来：

1. flex-direction

* flex-wrap

* flex-flow

* justify-content

* align-items

* align-content

### flex-direction属性

```
.container {
  flex-direction: row | row-reverse | column | column-reverse;
}


```

flex-direction决定**主轴的方向**，这也解决了上面那个注的问题。其中：

* row（默认值）：主轴为水平方向，起点在左端。

* row-reverse：主轴为水平方向，起点在右端。

* column：主轴为垂直方向，起点在上端。

* column-reverse：主轴为垂直方向，起点在下端。

### flex-wrap属性

这里每个item占70px(margin+width)，我让container的宽度为140px。

当 flex-wrap: nowrap时，三个item不准许换行，因此每个item只有被挤压的份儿了，经计算每个应该是26.666666px。<mark>注意：这里的每个元素是按等比例缩小的。如示例，我将第一个item的宽度设为100px，其余两个还是50px，140px减去横向的margin值(一共60px)，此时剩下80px，100x+50x+50x=80，得到缩小比例是40%，因此第一个item变成40px，其余两个是20px</mark>

当flex-wrap: wrap时，第三个正好被挤了下去

当flex-wrap: wrap-reverse时，原本应该在第一行的跑到了最下边去，最后一行得到了最上边，三个元素不见得好理解，下图写了7个item，这样就好理解了。

```
.container	{
  flex-wrap: nowrap | wrap | wrap-reverse;
}


```

### flex-flow属性

flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。

```
.container {
  flex-flow: <flex-direction> || <flex-wrap>;
}


```

### justify-content属性

justify-content属性定义了项目在主轴上的对齐方式。

```
.container {
  justify-content: flex-start | flex-end | center | space-between | space-around;
}


```

![一切尽在图中](https://edge.yancey.app/beg/5a605497-df9a-4a10-9a3b-3a67bed28379.jpg)

### align-items属性

align-items属性定义项目在交叉轴上如何对齐。

```
.container{
  align-items: flex-start | flex-end | center | baseline | stretch;
}


```

![align-item示意图](https://edge.yancey.app/beg/cabd33dc-047c-4b96-8cc7-6ef45b246534.jpg)

### align-content属性

align-content属性定义了多根轴线的对齐方式。**如果项目只有一根轴线，该属性不起作用**。因此应给container这歌class增加flex-wrap:wrap;

```
.container {
  align-content: flex-start | flex-end | center | space-between | space-around | stretch;
}


```

![align-content属性](https://edge.yancey.app/beg/b5611c83-1087-4c11-a363-5f60b27bcfff.jpg)

## 项目属性

项目有6个属性，一个一个来：

1. order

* flex-grow

* flex-shrink

* flex-basis

* flex

* align-self

### order属性

order属性定义项目的排列顺序。权值越小，排列越靠前，默认为0。

```
.item {
  order: <integer>;
}


```

### flex-grow属性

flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。当每个item的flex-grow都设为1时，他们将平均分配剩余空间（如果存在剩余空间的话）。

.item {
flex-grow: <number>;<br>
</number>

}

### flex-shrink属性

flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。该属性要与容器属性flex-wrap: nowrap;配合使用。当对某个item的flex-shrink:0;时，这个项目将不会等缩小（在容器空间不足的情况下），这样就会导致元素溢出。

```
.item {
  flex-shrink: <number>; 
}


```

### flex-basis属性

flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。也可以设置一个长度值，感觉就像是重定义了这个项目的尺寸。

```
.item {
  flex-basis: <length> | auto; 
}


```

### flex属性

flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。在大多数情况下，应使用下列几个简写值：

* auto 等价于 flex: 1 1 auto

* initial 等价于 flex: 0 1 auto

* none 等价于 flex: 0 0 auto

### align-self属性

align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。

```
.item {
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
}


```

## 小示例

### 简单模拟BootStrap栅格系统

#### HTML

```
<div class=""container"">
    <div class=""col-lg-8 col-xs-12"">
        <div class=""item item-1"">80%</div>
    </div>
    <div class=""col-lg-4 col-xs-12"">
        <div class=""item item-2"">20%</div>
    </div>
</div>

<p class=""cur-width"">当前宽度：<span class=""cur-width-val""></span></p>


```

#### CSS

```
    .container {
        display: flex;
        border: 1px solid #000;
        width: 100%;
    }

    .col-lg-8 {
        flex: 0 0 66.66666666%;
    }

    .col-lg-4 {
        flex: 0 0 33.33333333%;
    }

    .item {
        background-color: #ccc;
        height: 50px;
        flex: 1;
        margin: 10px;
    }

    @media (max-width: 768px) {

        .container {
            flex-flow: wrap;
        }

        .col-xs-12 {
            flex: 0 0 100%;
        }
    }


```

#### JS

```
$('.cur-width-val').text($(window).width());
$(window).on('resize', function () {
    $('.cur-width-val').text($(this).width());
    if ($(this).width() <= 768) {
        $('.item-1').text('我现在占一行');
        $('.item-2').text('我现在占一行');
    } else {
        $('.item-1').text('我现在占80%');
        $('.item-2').text('我现在占20%');
    }
})	


```

## 写在最后

flex布局确实学起来有些复杂，用熟了就好了。还有很多属性没有涉及到，不过常用的貌似就那么几个。

以上、よろしく。
","2025-02-02 03:07:45.901724","2025-02-02 03:07:45.901724"
"c5015757-8bc1-4fc5-b161-78abbc2bba04","{HTML5}",0,0,False,"https://edge.yancey.app/beg/68747470733a2f2f79616e6365792d6173736574732e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f66653535363439632d386663662d343635352d386132662d3061306666663431343335652e706e67.png","HTML5.2 新特性","平成 29 年 12 月 14 日，W3C 发布 HTML 规范 5.2 更新版本，并官方建议用户使用。此次更新增加了 dialog 标签等新功能、弃用了一些其他功能，比如废除了 keygen 标签。并对 iframe 增加了支付请求 API、演示 API 等。支付请求 API 啊卧槽！！！！
","## 说明

本文翻译自国外某大触的文章，原文戳[这里](https://bitsofco.de/whats-new-in-html-5-2/?utm_source=tuicool&utm_medium=referral)。第一次翻译别人文章，想想还有点儿小激动呢。乌干达乡下的えいご水平，见谅见谅。

### HTML 5.2 中有什么新玩意儿？

不到一个月前，HTML 5.2 成为正式的 W3C 推荐标准（REC）。当一个规范到达 REC 阶段时，这意味着它已经得到了 W3C 成员和指导者的正式认可，并且 W3C 正式推荐它由用户代理部署，并且由网页作者执行。

在 REC 阶段，任何新的应该至少有 2 个独立的实现。这对于我们作为网页开发人员来说是开始实施任何新功能的好时机。

在 HTML 5.2 中，有一些增加和删除，所有这些都可以在官方的 HTML 5.2 Changes 页面上看到。在本文中，我将介绍一些我认为会影响我的发展的变化。

### 一个原生的 dialog 标签

在所有的 HTML5.2 新特性中，最令我~~高潮~~兴奋的就是\<dialog>标签了，这货在网页中炒鸡常见，然而每个实现在某种程度上是不同的，对话框也很难以可访问的方式进行，导致网页上的大多数对话框对于以不可视方式浏览网页的用户是不可用的。

新的\<dialog>元素旨在改变这一点，它提供了一个简单的方式来包含一个模态框，而不必担心很多缺陷。我将写一篇关于这个元素如何工作的单独的，详细的文章，但这里有一些基础知识。

```
<dialog>
  <h2>Dialog Title</h2>
  <p>Dialog content and other stuff will go here</p>
</dialog>




```

默认这货是关闭的，除非给 dialog 标签增加一个**open**属性

```
<dialog open>




```

open 属性可以通过调用 show（）和 close（）方法来切换，任何 HTMLDialogElement 都可以使用这个方法。

```
<button id=""open"">Open Dialog</button>
<button id=""close"">Close Dialog</button>

<dialog id=""dialog"">
  <h2>Dialog Title</h2>
  <p>Dialog content and other stuff will go here</p>
</dialog>

<script>
const dialog = document.getElementById(""dialog"");

document.getElementById(""open"").addEventListener(""click"", () => {
  dialog.show();
});

document.getElementById(""close"").addEventListener(""click"", () => {
  dialog.close();
});
</script>




```

\<dialog>标签已经被 Chrome 支持（Chrome 大法好！！！），火狐也立了梗马上要支持了。

![Data on support for the dialog feature across the major browsers](//edge.yancey.app/beg/caniuse-dialog.png)

_注：鄙人在 2 月 8 号测试时，火狐以及火狐开发者版本都木有支持 dialog 标签_

_再注：🤮🤮🤮 都 9102 年了，FF 和 Safari 还没支持，而且如果用了 dialog，Safari 没眼看了_

### 在 iframe 中使用 Payment Request API

Payment Request API 是 checkout 表单的一种原生替代方案，它旨在通过将检索支付信息的处理移动到浏览器，而不是在每个网站上的使用单独的 checkout 表单，以此来提供用户在网络上进行支付的标准化和一致的方法。

在 HTML 5.2 之前，这些支付请求不能通过嵌入在文档中的 iframe 来完成。这使得第三方嵌入式支付解决方案（例如 Stripe，Paystack）基本上不可能利用这个 API，因为他们的支付接口通常是在 iframe 中处理的。

HTML 5.2 引入了 allowpaymentrequest 属性，该属性应用于 iframe 时，将允许它在用户处于托管网页时使用 Payment Request API.

```
<iframe allowpaymentrequest>




```

### 苹果设备的图标尺寸

_注：这里就不全翻译了，简单写_

远古时期，声明 Apple 图标尺寸是酱婶儿的~

```
<link href=""images/57x57.png"" rel=""apple-touch-icon-precomposed"" sizes=""57x57""/>
<link href=""images/72x72.png"" rel=""apple-touch-icon-precomposed"" sizes=""72x72""/>




```

而如今。嗯，就是这么傲娇：

```
<link href=""images/57x57.png"" rel=""icon"" sizes=""57x57""/>
<link href=""images/72x72.png"" rel=""icon"" sizes=""72x72""/>




```

## 最新的有效做法

### 支持多 main 标签

```
<!--表示一脸懵逼，真心没用过这个-->
<main>...</main>
<main hidden>...</main>
<main hidden>...</main>




```

_注：当页面中有多个 main 标签，只能有一个是显示的，其他的都必须用**hidden**属性给隐藏掉，并且**只能用 hidden 属性**，像**display: none; or visibility: hidden; **是不允许的_。

妈的，好傲娇。

### style 可以写在 body 里

```
<body>
    <p>I’m cornflowerblue!</p>
    <style>
        p { color: cornflowerblue; }
    </style>
    <p>I’m cornflowerblue!</p>
</body>




```

私以为，这样不太好吧...

### legend 标签里可以嵌套 header 标签

```
<fieldset>
    <legend><h2>Basic Information</h2></legend>
    <!-- Form fields for basic information -->
</fieldset>
<fieldset>
    <legend><h2>Contact Information</h2></legend>
    <!-- Form fields for contact information -->
</fieldset>




```

## 移除的功能

\<keygen> \<menu> \<menuitem>这三个标签已扑街。

## 最新的无效做法

### p 标签不应嵌套内联、浮动、块级子元素

在 HTML 5.2 中，p 标签唯一有效子元素应该是措辞内容。这意味着以下类型的元素不应该嵌套在一个段落中：

- Inline blocks

- Inline tables

- Floated and positioned positioned blocks

### 废除严格文本类型

```
<!--下面两条文本类型声明已死，有事烧纸。ヾ(￣▽￣)Bye~Bye~-->

<!DOCTYPE HTML PUBLIC ""-//W3C//DTD HTML 4.01//EN"" ""http://www.w3.org/TR/html4/strict.dtd"">

<!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.0 Strict//EN"" ""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"">




```

## 最后

谷歌翻译真心不错，嗯，真心不错。

以上、よろしく。
","2025-02-02 03:07:47.51325","2025-02-02 03:07:47.51325"
"74750260-0db8-4d2e-9c38-1b9fd7e27d28","{HTML}",0,0,False,"https://edge.yancey.app/beg/68747470733a2f2f79616e6365792d6173736574732e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f77686174732d7468652d646966666572656e63652d6265747765656e2d6173796e632d76732d64656665722d617474726962757465732e6a7067.jpeg","关于 script 标签 async 和 defer 属性分析","折腾了半个来月的时间，终于把工作的事情稳定了下来。分析了一下现状，还是不要急着玩一些新鲜的东西。遂定了个计划，在工作之余重新学习 JavaScript 的基础，每周学一章高程，做好总结和笔记。頑張ります！
","## 前言

async 和 defer 是高程第二章的两个概念，印象里没有主动用过这俩属性，特别是写 SPA 之后，更没什么合适机会操作 script 标签。

文字很难表述两者间的差异，至少我是这么认为，网上有张图很不错，可以用来解释这两个属性间的差异。

## 正文

![defer和async的差异](//edge.yancey.app/beg/2151798436-59da4801c6772_articlex.png)

## 当不加 aysnc 和 defer 时

- 在解析 HTML 的过程中

- 如果遇到 script 标签

- 浏览器将暂停解析 HTML

- 开始`下载`script 标签里的内容

- 待`下载`完成后，立即执行 script 标签里的内容

- 执行完毕后，再去解析 HTML 标签

## 当使用 async 属性时

- 在解析 HTML 的过程中

- 如果遇到 script 标签

- 解析 HTML 将和`下载`script 标签的内容同时进行

- 当此 script 标签`下载`完成后

- **HTML 将停止解析，转而`执行`此 script 标签的内容**

- 执行完毕后，再去解析 HTML 标签

## 当使用 defer 属性时

- 在解析 HTML 的过程中

- 如果遇到 script 标签

- 解析 HTML 将和`下载`script 标签的内容同时进行

- 当 script 标签`下载`完成后

- **仍然等到 HTML 全部解析完毕**

- 再去执行此 script 标签的内容

## 思考

高程上说当多个 script 都有 defer 属性时，最后会按顺序执行，但实际上不一定；而 async 肯定不一定按顺序执行。

现实场景中可以说 100%都把 script 标签扔到 body 的最后，也就是最后下载，最后执行，在引入三方插件时倒是经常用到，比如：

- Twitter share button

- Google Analytics

- LiveRe / Disqus

这些的一个特点都是以动态创建 script 标签的形式来引入外部 js，类似于 JSONP，而内容上都是和项目整体关联不大的模块。

## 补充

平成 31 年 1 月 2 日做下补充，无论是 defer 还是 async，都只对外部脚本有效。

## 最后

以上、よろしく。
","2025-02-02 03:07:48.932639","2025-02-02 03:07:48.932639"
"6f395255-cf69-482f-ac86-acb4b05d3b2c","{JavaScript,轮播图}",0,0,False,"https://edge.yancey.app/beg/68747470733a2f2f79616e6365792d6173736574732e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f393439363837392d373736643430616163646638643033652e706e67.png","原生 JS 实现轮播图效果","如果爱情能跟用原生 JS 写一个轮播图那么简单该多好啊。嗯，虽然也不简单。虽然很多优秀的第三方轮播图插件（如 Swiper）在业界广受好评，但掌握轮播图的原理还是尤为重要的。","## 说明

- 整个轮播图是跟着 x 课网的视频做的，放上[链接地址](https://www.imooc.com/learn/18)；

- 图片来自 QQ 音乐，大小为 1080\*482;

- 若有侵权，~~contact me~~ 话说您讯不就是“%&\*（&#（￥&#）{：@#“%；

- 我在原有的基础上增加了左下角动态显示图片 alt 里的值；

- 目前只能放 5 张图片，图片扩充后期再改吧，心情不好；

- 视频里有个不太好的地方，就是在图片显示第一张时，我 onmouseover 第五张对应的小圆圈，它会从第一张一直向右划四张来得到第五张图，反之亦然。我做了改动，当触发上述事件时，是直接向左划一张来得到第五张图，反之亦然。

## HTML

```
<header>
<div id=""banner"">
    <div id=""banner-img"" style=""left:-1080px"">
        <!--头部放第五张图-->
        <a href=""../blog/index.html""><img src=""images/222417.jpg"" alt=""AI·爱""></a>
        <a href=""../blog/index.html""><img src=""images/151139.jpg"" alt=""绿钻豪华版""></a>
        <a href=""../blog/index.html""><img src=""images/221876.jpg"" alt=""MIXNINE""></a>
        <a href=""../blog/index.html""><img src=""images/222089.jpg"" alt=""偷故事的人""></a>
        <a href=""../blog/index.html""><img src=""images/222353.jpg"" alt=""红蔷薇""></a>
        <a href=""../blog/index.html""><img src=""images/222417.jpg"" alt=""AI·爱""></a>
        <!--尾部放第一张图-->
        <a href=""../blog/index.html""><img src=""images/151139.jpg"" alt=""绿钻豪华版""></a>
    </div>
    <!--左右两个箭头，记得包在a标签里-->
    <a href=""javascript:"" id=""arrow-prev"" class=""arrow""></a>
    <a href=""javascript:"" id=""arrow-next"" class=""arrow""></a>
    <!--左下角显示图片alt的值->
    <span id=""img-info""></span>
    <!--底部的遮罩，可以不用->
    <div id=""mask""></div>
    <!--小圆圈 用border-radius:50%足够了-->
    <ul id=""slide-switch-circle"">
        <li class=""circle-1""></li>
        <li class=""circle-2""></li>
        <li class=""circle-3""></li>
        <li class=""circle-4""></li>
        <li class=""circle-5""></li>
    </ul>
</div>
</header>



```

- 我看到有的地方把图片列表放到 ul li 中，这个确实更加合理一些。
- **敲重点：首尾分别放置图片 list 的第五张和第一张，目的是实现无缝循环**
- 在#banner-img 中写一个内联的 left: -1080px，因为我们把第五张图放到了图片列表的第一个位置，因此 left: -1080px 是得到真正的第一张图片

## CSS

\* \{
padding: 0;
margin: 0;
list-style-type: none;
text-decoration: none;
}

```
#banner {
    width: 1080px;
    height: 482px;
    position: relative;
    margin: 100px auto;
    overflow: hidden;
  }

#banner-img {
    width: 7560px;
    height: 482px;
    position: absolute;
    display: block;
    z-index: 1;
    left: -1080px
  }

#banner-img a img {
    float: left;
}

#mask {
    position: absolute;
    width: 1080px;
    height: 40px;
    top: 392px;
    background: #000;
    opacity: 0.3;
    z-index: 2;
}

#img-info {
    position: absolute;
    font-size: 20px;
    top: 401px;
    left: 30px;
    font-family: Consolas, sans-serif;
    color: #fff;
    z-index: 2;
}

#arrow-prev, #arrow-next {
    position: absolute;
    width: 80px;
    height: 140px;
    top: 131px;
    z-index: 2;
}

#arrow-prev {
    left: -80px;
    transition:500ms left ease;

    background: rgba(0, 0, 0, 0.3) url(""../images/left40.png"") no-repeat 28px 50px;
}

#arrow-next {
    right: -80px;
    transition:500ms right ease;
    background: rgba(0, 0, 0, 0.3) url(""../images/right40.png"") no-repeat 28px 50px;
}

#banner:hover #arrow-prev {
    display: block;
    left: 0;
    transition:500ms left ease;
}

#banner:hover #arrow-next {
    display: block;
    right: 0;
    transition:500ms right ease;
}

#arrow-prev:hover {
    background: rgba(0, 0, 0, 0.5) url(""../images/left80.png"") no-repeat 28px 50px;
}

#arrow-next:hover {
    background: rgba(0, 0, 0, 0.5) url(""../images/right80.png"") no-repeat 28px 50px;
}

#slide-switch-circle {
    position: absolute;
    top: 410px;
    left: 470px;
    z-index: 3;
}

#slide-switch-circle li {
    height: 15px;
    width: 15px;
    background: #ccc;
    opacity: 0.3;
    border-radius: 50%;
    float: left;
    margin-left: 10px;
}



```

- CSS 中四张背景图是在酷我音乐的网站首页拿的
- 将图片设为左浮动，并把 img 标签设为 block
- banner 的 width 设为 1080px
- 将#banner-img 的宽度设为 5\*1080 = 7560px，同时写一个 left: -1080px，后面要把它当做常量来用；
- 要体现出各个组件的层次感，设置绝对位置和 z-index 权值
- 14 号做了一次修改，箭头加入了渐入渐出效果

## JS

```
window.onload = function () {

let banner = document.getElementById('banner');
let img_list = document.getElementById('banner-img');
let arrow_prev = document.getElementById('arrow-prev');
let arrow_next = document.getElementById('arrow-next');
let switch_circle = document.getElementById('slide-switch-circle').children;
let img_info = document.getElementById('img-info');
//初始化第一个圆圈是亮的
switch_circle[0].style.opacity = '1';
//初始化第一个img_info的名字
img_info.innerHTML = document.getElementsByTagName('img')[1].getAttribute('alt');
//1080 获取图片宽度
let img_width = parseInt(window.getComputedStyle(banner, null).width);
//5 获取图片个数 记得减去2
let img_num = img_list.children.length - 2;

//初始化索引值
let index = 1;
//当快速点击左右箭头或快速鼠标滑动底部小圆圈快造成卡帧
let animated = false;
let timer;


//动画效果
function animate(offset, time, interval) {
    //这边呼应下面小圆圈那个部分
    //假设图片显示的是第一张，你又用鼠标触发第一个小圆圈
    //直接获得偏移量是0，就不会执行下面动画的代码了
    if (offset === 0) {
        return;
    }
    //动画不动时animated设为true
    //再去点击左右箭头或者小圆圈时才会继续移动
    //否则当为false时，不允许执行动画、箭头点击、鼠标移入小圆圈这三个函数的代码
    animated = true;
    let current_left = parseInt(img_list.style.left) + offset;
    let speed = offset / (time / interval);

    let go = function () {
        //判断图片是否停止了下来
        if ((speed < 0 && parseInt(img_list.style.left) > current_left) || (speed > 0 && parseInt(img_list.style.left) < current_left)) {
            img_list.style.left = parseInt(img_list.style.left) + speed + 'px';
            setTimeout(go, interval);
        } else {
            img_list.style.left = current_left + 'px';
            //处理在第一张和第五章时 将偏移量重置
            if (current_left > -img_width) {
                img_list.style.left = -(img_width * img_num) + 'px';
            } else if (current_left < -(img_width * img_num)) {
                img_list.style.left = -img_width + 'px';
            }
            animated = false;
        }
    };
    go();
}

//自动轮播 每三秒自动执行右箭头点击事件
function autoPlay() {
    timer = setInterval(function () {
        arrow_next.onclick();
    }, 3000);
}

//停止轮播
function stopPlay() {
    clearInterval(timer);
}

//
function switchCircle() {
    for (let i = 0; i < switch_circle.length; i++) {
        //如果不加判断 在苏表离开某个底部小圆圈时，它的透明度不会恢复0.3
        if (switch_circle[i].style.opacity === '1') {
            switch_circle[i].style.opacity = '0.3';
            break;
        }
    }
    //给onmouseover的小圆圈透明度变1
    switch_circle[index - 1].style.opacity = '1';
}

//左下角填充图片alt里的文字
function showInfo(index) {
    //这边直接获取img标签是为了偷懒 更合理的方法不写了
    img_info.innerHTML = document.getElementsByTagName('img')[index].getAttribute('alt');
}

//点击左箭头
arrow_prev.onclick = function () {
    //防止卡帧
    if (animated) {
        return;
    }

    if (index === 1) {
        index = img_num;
    } else {
        index -= 1;
    }
    //增加动画效果
    animate(img_width, 600, 10);
    //小圆圈变化
    switchCircle();
    //文字变化
    showInfo(index);


};

//点击右箭头
arrow_next.onclick = function () {
    //防止卡帧
    if (animated) {
        return;
    }
    if (index === img_num) {
        index = 1;
    } else {
        index += 1;
    }
    animate(-img_width, 600, 10);
    switchCircle();
    showInfo(index);

};

//鼠标移入小圆圈事件
for (let i = 0; i < switch_circle.length; i++) {
    switch_circle[i].onmouseover = function () {
        //防止卡帧
        if (animated) {
            return;
        }
        //假设图片显示的是第一张，你又用鼠标触发第一个小圆圈，加了如下判断就不会执行下面计算偏移量之类的的语句，提高性能
        if (this.style.opacity === '1') {
            return;
        }
        //给小圆圈的的每个li加上了class，获取其中的数字
        let click_index = parseInt(this.getAttribute('class').slice(-1));
        //偏移量计算
        let offset = -img_width * (click_index - index);
        //这里就是我开篇所说的 原视频在从第一张移入最后一张的问题
        //加上下述判断，就可以实现从第一张移入最后一张是向左移动一张的效果
        if (offset === -((img_num - 1) * img_width)) {
            offset = img_width;
        } else if (offset === ((img_num - 1) * img_width)) {
            offset = -img_width;
        }
        animate(offset, 600, 10);
        index = click_index;
        switchCircle();
        showInfo(index);


    }
}

//当鼠标移出图片的div之外停止自动轮播
img_list.onmouseover = stopPlay;
//当鼠标移出图片的div之外开始自动轮播
img_list.onmouseout = autoPlay;
autoPlay();
};



```

以上、よろしく。
","2025-02-02 03:07:49.87212","2025-02-02 03:07:49.87212"
"d8564b92-82ad-4d88-8de9-cfae5acd4782","{React,汇率计算器}",0,0,False,"https://edge.yancey.app/beg/68747470733a2f2f79616e6365792d6173736574732e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f30316633623830312d616564352d343365622d383235642d6464373964623262623765382e706e67.png","React 练习——汇率计算器","这是学习 React 时候自己设计的一个小项目，居然折腾了一天。暂且不谈组件化，React 做多级联动简直爽到飞起。项目重点涉及了 React 组件间通讯，这个地方练熟了写 React 基本就无敌了。当然前提是能够合理的划分出 UI 组件层级。","## 先来一段动图

![动图演示](https://edge.yancey.app/beg/3c05a686-5fd7-4410-9eb2-42a79c674973.gif)

##　昨天的面试

昨天面试问到“你是如何学习新知识的？“

1. 就以 React 为例吧，先去拉勾找到学习 React 的动力（你懂的）；

2. 去知乎搜索”React 能做什么“，看大牛们的解释（个人很喜欢他们精辟的比喻），大致知道 React 的思想是什么，能做哪些事，比起传统做法有什么优点；

3. 简单纵向比较一下相关框架（如 vue、angular）的异同、优缺点（虽然 vue 还是要学的）；

４. 根据官方文档学习语法，利用 Google、Stack Overflow、Github 等填坑。这期间会学到很多除 React 本身的新东西，比如 fetch、axois、superagent 等等。总之这个阶段还是很难很难的，想从一楼跳下去的心都有啊喂;

5. 分阶段自行设计项目，检验学习成果。随着深入学习，进行项目的迭代与优化；

6. 作文以记之。

## 功能实现

![组件分割示意图](//edge.yancey.app/beg/23001024-d8f4-43e7-a976-73337b65591f.png)

既然 React 的卖点是组件化（话说昨天面试小姐姐问 React 除了组件化还有什么，我居然忘了**声明式**，悔しい）。上图是自己的划分思路：

1. 首先粉色部分（① 区）显示的是实时汇率，初始值是美元和欧元的汇率比，当改变 ④ 或 ⑤，或者点击 ⑥ 时，① 区根据当前状态进行实时切换，而 ② 和 ③ 区的改变是不会影响 ① 区的；

2. ② 和 ③ 区可以输入数字，根据目前选定的汇率，来实时换算货币值，比如就上图来说，在 ② 区输入 10，③ 区会实时变成 8.12304；

3. ④ 和 ⑤ 区是整个组件的核心，它们的值决定着其他各组件的方方面面；

4. 当点击 ⑥ 区时，④ 和 ⑤ 当前选定的值会交换，② 区值不会变，但因为汇率发生了变化，③ 区的值将发生变动，此时 ① 区的汇率也将发生反转；

5. 当然最外层的 App 类控制 api 的异步加载。

## 关于 API

这里必须得多说几句，简直炸毛。

首先是在[fixer](https://fixer.io/)申请了 key，还不错，看下图。然鹅坑爹的是，他们家不提供**货币全称 API**(比如 USD 对应 United States Dollor；CNY 对应 Chinese Yuan 酱紫)。虽然做这个项目只需要实时汇率就足够了，但是只显示干巴巴的简称肯定是不友好滴。

然后又去了[currencylayer](https://currencylayer.com/)申请了 key，货币全称倒是有了，看下图，但他家的汇率 api 超级坑爹，免费用户只能以美金为 base 货币，不像 fixer 无限制。遂两家 api 一起用...

## 具体实现

### App 类

名字懒得起了，就叫 App 好了，这个类主要用来异步加载两个 json 文件，第一次用到了 fetch，听说能代替传统的 Ajax，与之类似的还有什么 axois、superagent,忙过这几天依次做一下研究。

```
class App extends React.Component {
    constructor(props) {
        super(props);
        this.state = {ratesObj: '', countriesObj: ''};
    }

    componentDidMount() {

        // 注意fetch的语法，其实跟Promise差不多少
        this.getCurrencyRates = fetch(this.props.api.getCurrencyRatesAPI).then(res => {
            res.json().then(resJSON => this.setState({ratesObj: resJSON.rates}));

        });

        this.getCountries = fetch(this.props.api.getCountriesAPI).then(res => {
            res.json().then(resJSON => this.setState({countriesObj: resJSON.currencies}));

        });
    }

	componentWillUnmount() {
        this.getCurrencyRates.abort();
        this.getCountries.abort();
    }

    render() {
        return (
            <div>
                <CountryChoice ratesObj={this.state.ratesObj} countriesObj={this.state.countriesObj}/>
            </div>
        )
    }
}

ReactDOM.render(
    // 这里的api是个对象，存放上面所说的两个url，这里就不贴出来了
    <App api={api}/>,
    document.getElementById('root'),
);

```

###实时汇率展示类

这个类就是个受，自己啥都干不了。当 select 元素触发**onchange 事件**抑或 button 被点击(触发**onclick 事件**)时，这里就会发生变动。这个类只需要接受**CountryChoice 类**（就是上面说到的核心类）的三个参数，分别是示意图中 ④ 和 ⑤ 区正在被选中的那两个币种，还有就是两个币种之间的汇率。

```
class CurrentExchangeRate extends React.Component {
    constructor(props) {
        super(props);
    }

    render() {
        return (
            <h1>1 <span
                className=""exchange-country-name"">{this.props.firstSelectedCountry}</span> = {this.props.latestRates + ' '}
                <span className=""exchange-country-name"">{this.props.secondSelectedCountry}</span>
            </h1>
        );
    }
}

```

### exchange 按钮类

这个类接受一个 Boolean 类型的 flag，flag 的定义同样是在**CountryChoice 类**里面，每点击一次按钮，flag 值就会从 true 和 false 之间切换，然后通过**this.props.buttonToggle**这个方法将实时的 flag 值传递回**CountryChoice 类**，当然**this.props.buttonToggle**方法定义在**CountryChoice 类**里，下面会说到。

```
// exchange按钮交换两个select，同时会改变 实时汇率展示 模块
class ChangeCountry extends React.Component {
    constructor(props) {
        super(props);
        this.state = {currentFlag: this.props.currentFlag};
        this.buttonClick = this.buttonClick.bind(this);
    }

    buttonClick() {
        // 一定要把 !this.state.currentFlag 先存到一个变量，再把这个变量赋值到setState里
        // 否则第一次点击按钮还是true，第二次才变成false
        const currentFlag = !this.state.currentFlag;
        this.setState({
            currentFlag: currentFlag
        });
        this.props.buttonToggle(currentFlag);
    }

    render() {
        return (
            <button className=""button"" onClick={this.buttonClick}>Exchange</button>
        )
    }
}

```

### 金额输入类

首先先写一个 isNumber 方法，是为了阻止用户输入**非数字**，且只能输入一个**小数点**。因为有两个 input 元素，所以先给两个元素命名。因为在任意一个 input 中输入值都会实时影响到另一个，所以这里就涉及到了<mark>状态提升</mark>问题，可以去研究[官方文档-状态提升](https://doc.react-china.org/docs/lifting-state-up.html)的这个例子。

```
// 命名两个input输入框
const inputNames = {f: 'firstInput', s: 'secondInput'};

function isNumber(input) {
    if (/^[0-9]+([.][0-9]*)?$/.test(input) === false) {
        return input.slice(0, -1)
    } else {
        return input
    }
}

class MoneyInput extends React.Component {

    constructor(props) {
        super(props);
        this.handleChange = this.handleChange.bind(this);
    }

    handleChange(ev) {
        this.props.onInputChange(isNumber(ev.target.value));
    }

    render() {
        const inputName = this.props.inputName;
        const inputValue = this.props.inputValue;

        return (
            // 这里用到了ES6的计算属性名
            <input name={inputNames[inputName]} className=""input-value"" type=""text"" value={inputValue}
                   placeholder=""0"" onChange={this.handleChange}/>
        );
    }
}

```

### 币种（国家）选择类

高潮来了，额，重点来了。这个类控制着币种的选择，解释都放在了注释里，代码写得有点儿绕，都是 exchange 按钮惹的祸。写下来发现 React 的一个重点就是**React 组件间通讯**:

- 【父组件】向【子组件】传值；

- 【子组件】向【父组件】传值；

- 没有任何嵌套关系的组件之间传值（如：兄弟组件之间传值）

这里推荐两篇文章，一个是淘宝前端团队的[React 组件间通讯](http://taobaofed.org/blog/2016/11/17/react-components-communication/);另一个是在 SegmentFault 的一篇文章[React 组件之间如何交流](https://segmentfault.com/a/1190000004044592)，把人家演示的例子敲一敲，基本上就能理解了。

```
// 货币选择：初始化第一个选中的是美刀，第二个选中的欧元
// 货币选择的变化影响着 汇率展示 和 汇率计算
class CountryChoice extends React.Component {
    constructor(props) {
        super(props);

        // 初始化状态
        this.state = {
            firstSelectedCountry: 'USD',// 第一个默认被选中的币种是美金
            secondSelectedCountry: 'EUR',// 第二个默认被选中的币种是欧元
            flag: true,// 立一个flag，初始是true，button被点击时在true和false之间切换
            inputName: 'f',// 默认选中的是第一个input标签
            inputValue: ''// 默认input标签的值是空
        };

        this.handleChange = this.handleChange.bind(this);
        this.buttonToggle = this.buttonToggle.bind(this);
        this.firstInputChange = this.firstInputChange.bind(this);
        this.secondInputChange = this.secondInputChange.bind(this);
    }

    // 通过ChangeCountry类传递过来的flag值来设置成当前状态
    buttonToggle(flag) {
        this.setState({flag: flag})
    }

    // 设置select标签的状态

    // 当flag是true时，把firstSelectedCountry的状态设置为name属性为“first-select”的value，
    // 把secondSelectedCountry的状态设置为name属性为“second-select”的value

    // 当flag是true时，把firstSelectedCountry的状态设置为name属性为“first-select”的value，
    // 把secondSelectedCountry的状态设置为name属性为“second-select”的value

    // 也就是说当flag是false时，此时name属性为“first-select”的select标签控制的是name属性为“second-select”的select标签
    // 当然我这里设计的不合理，应该通过动态修改name值才好，放在下一次的项目迭代吧，留个坑先
    handleChange(ev) {
        const target_name = ev.target.name;

        if (this.state.flag) {
            if (target_name === 'first-select') {
                this.setState({firstSelectedCountry: ev.target.value});
            } else if (target_name === 'second-select') {
                this.setState({secondSelectedCountry: ev.target.value});
            }

        } else {
            if (target_name === 'first-select') {
                this.setState({secondSelectedCountry: ev.target.value});
            } else if (target_name === 'second-select') {
                this.setState({firstSelectedCountry: ev.target.value});
            }
        }
    }

    // 获取第一个input输入的值
    firstInputChange(inputValue) {
        this.setState({inputName: 'f', inputValue});
    }

    // 获取第二个input输入的值
    secondInputChange(inputValue) {
        this.setState({inputName: 's', inputValue});
    }


    render() {

        const inputName = this.state.inputName;
        const inputValue = this.state.inputValue;

        // 因为要用到用户输入的值乘以汇率来进行计算
        // 当用户清空某个input标签的值时，这里就成了NaN
        // 这个函数就是当检测到输入的值为空时，自动设为数字0
        // 啊啊啊，肯定有更好的方法
        function formatInputValue(inputValue) {
            if (inputValue === '') {
                inputValue = 0;
                return inputValue
            } else {
                return parseFloat(inputValue)
            }
        }

        // 这边就写的很笨重了，汇率是根据flag的状态定的
        // 如果是true，汇率是第二个select标签选中的值除以第一个select
        // 假设当前在第一个input输入数值，那么下面的 inputName === 'f' 就是true， 所以第二个input的值（sI）就会被实时计算
        // 反正就是很绕，如果不加exchange按钮要省很多事儿，一切都是为了学习...
        const fI = inputName === 's' ? formatInputValue(inputValue) * (!this.state.flag ? this.props.ratesObj[this.state.secondSelectedCountry] / this.props.ratesObj[this.state.firstSelectedCountry] : this.props.ratesObj[this.state.firstSelectedCountry] / this.props.ratesObj[this.state.secondSelectedCountry]) : inputValue;
        const sI = inputName === 'f' ? formatInputValue(inputValue) * (this.state.flag ? this.props.ratesObj[this.state.secondSelectedCountry] / this.props.ratesObj[this.state.firstSelectedCountry] : this.props.ratesObj[this.state.firstSelectedCountry] / this.props.ratesObj[this.state.secondSelectedCountry]) : inputValue;

        return (
            <div className=""container"">
                {/*这边就是把当前状态（两个被选中的货币全称和之间的汇率）传递给①区来显示*/}
                <CurrentExchangeRate
                    firstSelectedCountry={this.state.flag ? this.props.countriesObj[this.state.firstSelectedCountry] : this.props.countriesObj[this.state.secondSelectedCountry]}
                    secondSelectedCountry={!this.state.flag ? this.props.countriesObj[this.state.firstSelectedCountry] : this.props.countriesObj[this.state.secondSelectedCountry]}
                    latestRates={this.state.flag ? this.props.ratesObj[this.state.secondSelectedCountry] / this.props.ratesObj[this.state.firstSelectedCountry] : this.props.ratesObj[this.state.firstSelectedCountry] / this.props.ratesObj[this.state.secondSelectedCountry]}
                />

                {/*当在第二个input输入数字时，换算出来的值会实时显示在第一个input里*/}
                <div className=""item"">
                    <MoneyInput
                        inputName='f'
                        inputValue={fI}
                        onInputChange={this.firstInputChange}
                    />

                    {/*传统设置默认选项是在option标签设置selected=selected, 现在放在select标签里，当然还有个Select的三方库*/}
                    {/*通过map将option标签循环添加到第一个select标签里面*/}
                    <select className=""select"" name=""first-select""
                            value={this.state.flag ? this.state.firstSelectedCountry : this.state.secondSelectedCountry}
                            onChange={this.handleChange}>
                        {
                            Object.keys(this.props.ratesObj).map((key) => (
                                <option key={key.toString()}
                                        value={key}>{key} - {this.props.countriesObj[key]}</option>))
                        }
                    </select>
                </div>
                <div className=""item"">
                    // 当在第一个input输入数字时，换算出来的值会实时显示在第二个input里
                    <MoneyInput
                        inputName='s'
                        inputValue={sI}
                        onInputChange={this.secondInputChange}
                    />

                    {/*通过map将option标签循环添加到第一个select标签里面*/}
                    <select className=""select"" name=""second-select""
                            value={!this.state.flag ? this.state.firstSelectedCountry : this.state.secondSelectedCountry}
                            onChange={this.handleChange}>
                        {
                            Object.keys(this.props.ratesObj).map((key) => (
                                <option key={key.toString()}
                                        value={key}>{key} - {this.props.countriesObj[key]}</option>))
                        }
                    </select>

                    {/*exchange按钮 将当前flag值传递给ChangeCountry类，同时将ChangeCountry类改变的flag值作为参数，通过buttonToggle方法传回当前这个类*/}
                    <ChangeCountry currentFlag={this.state.flag} buttonToggle={flag => this.buttonToggle(flag)}/>
                </div>

            </div>
        )
    }
}

```

##　写在最后

项目写的很丑，随着学习的深入还要进行迭代，加油吧。项目传到了[github](https://github.com/yanceyleo/currency-exchange-component-by-react)上了，没有劳驾 node 服务器，fork 下来直接打开 html 文件就能使用了。躲过了风头，服务器也重新开了，请戳这里=>[在线演示](https://api.leoyancey.com/currency_exchange/root.html)。

至于为什么当时想到了做一个汇率计算器，可能就是下图吧：

![哦](//edge.yancey.app/beg/cc96791d-d215-47b3-8b75-24d4840008ee.jpeg)

以上、よろしく。

## PS

4 月 14 号把网站升级成了 HTTPS 协议，发现这个项目不能用了，查了一下资料，原来是浏览器默认阻止 https 协议请求 http 资源，项目中国家名称那个 api 使用的 http 协议，于是又找了一家，项目也恢复使用了。欢迎戳=>[汇率计算器在线演示](https://api.leoyancey.com/currency_exchange/root.html)。
","2025-02-02 03:07:51.549818","2025-02-02 03:07:51.549818"
"ad130b7e-094d-4b9e-9483-327da820c982","{Git}",0,0,False,"https://edge.yancey.app/beg/68747470733a2f2f79616e6365792d6173736574732e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f736f6369616c2e6a7067.jpeg","Git 学习笔记","这篇文章作为 Git 的学习笔记, 持续更新中...","## 全局配置

安装完 Git 后要给自己的机器做一下标识，便于多人协作时互相区分，一般设为全局即可，命令如下所示：

```
$ git config --global user.name ""输入一个用户名""
$ git config --global user.email ""输入一个邮箱""
```

查看本机用户名、邮箱配置：

```
$ git config user.name
$ git config user.email
```

## 创建版本库

在合适的文件夹（本文新建一个名为 learnGit 的文件夹）下执行下句，Git 仓库就创建好了，其中所有的跟踪信息被保存到隐藏文件夹.git`中，_注意这个文件夹里面的内容不要乱动吼_。

```
$ git init
```

随后我向 learnGit 文件夹中添加一个名为 HotKeys 的 txt 文件\*（注：本文均以这个文件为例，这里面主要记录一些 Mac 常用快捷键）\*，然而此时 Git 并不能确定你是否要将这个文件添加到版本库，执行`git status`，看下图：

![Git提示你将文件添加到版本库](//edge.yancey.app/beg/c54c9dda-3e05-4091-a187-b17ff3c2d9a1.jpg)

因此执行下面两句：

```
$ git add HotKeys.txt
$ git commit -m ""增加一个名字叫做HotKeys的文本文件""
```

其中 add 命令是告诉 Git 本次要添加哪些文件，可以一次性添加多个，中间用**空格**隔开即可；commit 命令用于告诉 Git 本次提交的说明，因此言简意赅的摘要尤为重要。

此时再次执行一遍`git status`，看下图，嗯，已经洗白白了：

![已经没有待提交的文件了](//edge.yancey.app/beg/1e7cc831-5e1f-4739-95d8-7f0efb4ea6e3.jpg)

## 时光机穿梭

我向 HotKeys 文件添加几行文字：

```
截图工具：

区域截图：shift+control+a
录屏：shift+control+r
```

执行一遍`git status`，它丫告诉我们文件已被修改，但还没被提交。

![文件已被修改，但还没被提交](//edge.yancey.app/beg/543a6ec0-a6e9-45ac-ad8d-566f91f1fd56.jpg)

我们可以通过`git diff`来查看我们到底修改了什么。好吧，增加了 5 行文字：

![看看我们修改了什么](//edge.yancey.app/beg/0c683427-1940-4486-a59f-c40239ef168a.jpg)

然后，我们再次执行一遍 add 和 commit 命令：

```
$ git add HotKeys.txt
$ git commit -m ""增加关于截图工具的快捷键""
```

再次执行一遍`git status`，看下图，嗯，已经洗白白了：

![已经没有待提交的文件了](//edge.yancey.app/beg/1e7cc831-5e1f-4739-95d8-7f0efb4ea6e3.jpg)

### 版本回退

通过`git log`可以查看当前分支所有日志：

![所有日志](//edge.yancey.app/beg/4da268c2-feaa-4be4-bb3a-34f4cb1ab037.jpg)

当然使用`git log --pretty=oneline`命令可以美化 log 输出，话说也不见得美化啊喂！！！

```
c334b0c2656ebd588696711c05b73520fb3f10b5 (HEAD -> master) 增加关于截图工具的快捷键

d9cdc6fede4c82c1c488494fd1e64c4cb1abbd8b 增加一个名字叫做HotKeys的文本文件
```

在 Git 中，用`HEAD`表示当前版本，那么上一个版本就是 `HEAD^`，上上一个版本就是`HEAD^^`，当然要想回溯到第前 100 个版本，写 100 个^显然太牙败了，所以可以写成 `HEAD~100`

下面我们回到上一个版本，也就是“增加一个名字叫做 HotKeys 的文本文件”那一版：

```
$ git reset --hard HEAD^
```

![一觉回到解放前](//edge.yancey.app/beg/02501c3a-8c8b-4cf0-833a-6e037e64e2ef.jpg)

我们使用`cat HotKeys.txt`打开这个文件，发现新增的**关于截图快捷键**那部分给消失了，说明我们成功会退到了上一版本。

但是蛋疼的是，当我们再次输入`git log`时，发现最新的那条记录已经木有了，而且你在磁盘打开 HotKeys 这个文件，发现新增的那五行也消失了卧槽。苦呀西不可说。

莫方，办法还是有的，往上看两张图，能看到""增加关于截图工具的快捷键""那个 commit id，就是**c334b0c2656ebd588696711c05b73520fb3f10b5**，依靠这串 id，我们就可以回到未来了，Let's go.

```
git reset --hard c334b0c
```

ok, 查看一下`git log`和文件，我胡汉三又回来了，注意这个 commit id 可以不用写全，写个前几位就行，Git 帮你匹配。

但是另一个问题粗线了，要是找不着 commit id 怎么办呢？莫方，下面这个命令用来记录你的每一次命令：

```
$ git reflog
```

![命令日志](//edge.yancey.app/beg/6689ed54-2c87-4c51-8e69-e105ce59ed31.jpg)

酱紫，你就找到所对应的版本号了。

### 工作区和暂存区

![工作区和版本库](//edge.yancey.app/beg/02de5473-0e0a-4e7d-9d3e-aa6d4ce5514f.jpeg)

这里盗用廖雪峰聚聚的一张图，所谓工作区(Working Directory)，就是 learnGit 文件夹下**我们自己编写的那一部分**，而版本库\(Repository\)就是那个隐藏文件\*\*\.git\*\*了。

Git 的版本库里存了很多东西，其中最重要的就是称为 stage（或者叫 index）的暂存区，还有 Git 为我们自动创建的第一个分支 master，以及指向 master 的一个指针叫 HEAD。

`git add`命令实际上就是把要提交的所有修改放到暂存区（Stage）。`git commit`一次性把暂存区的所有修改提交到分支。

### 管理修改

一言以蔽之，如果不 add 到暂存区，那就不会加入到 commit 中，因此 add 命令要和 commit 命令同时食用。

### 撤销修改

突然你诗性大发，在 HotKeys 文件里写了首诗：

```
鸣神の　少しとよみて　さし昙り　雨も降らんか　君を留めん
鸣神の　少しとよみて　降らずとも　我は止まらん　妹し留めば
```

哈哈哈蛇精病啊有木有。咳咳，不过还是要删掉这一段的：

\$ git checkout -- Hotkeys.txt

这句指令仅限于两种情况：

- 你在写了这两句后，没有使用`git add`命令，也就是还没把最新修改 add 到暂存区，执行切克闹后它将退回到当前版本库；
- 你在写了这两句之前已经使用了`git add`命令，但没使用`git commit`命令，也就是已经把这两句之前的修改 add 到了暂存区，但没把修改提交到分支，执行切克闹后它就回到添加到暂存区后的状态。

当然上面说了 add 命令要和 commit 命令同时食用，所以第二种情况基本上也不会出现。

然鹅，你在写了这两句话之后使用了`git add`命令，但突然幡然醒悟，立即删掉了打了一半的`git commit`，那么 reset 一下就好了。

```
$ git reset HEAD HotKeys.txt
```

### 删除文件

一般我们就直接右键把文件删除了，但是 Git 会把删除理解为修改，我们尝试将 HotKeys 文件丢弃到废纸篓，输入命令`git status`，发现如下图所示：

![移除文件](//edge.yancey.app/beg/0cdf4afe-64bc-487f-b62c-6fdb5c210fd6.jpg)

假设你确实要删除此文件，那么执行下面两句：

```
$ git rm HotKeys.txt
$ git commit -m ""移除HotKeys文件""
```

但如果是误删，你也可以轻松找回：

\$ git checkout -- HotKeys.txt

## 远程仓库

由于本地 Git 仓库和 GitHub 仓库之间的传输是通过 SSH 加密的，所以创建 SSH Key：

```
$ ssh-keygen -t rsa -C ""你的电子邮箱""
```

Mac OS 中，在用户主目录里找到`.ssh`这个隐藏文件夹，点进去可以找到刚刚生成的`id_rsa`和`id_rsa.pub`两个文件。这两个就是 SSH Key 的秘钥对，`id_rsa`是私钥，不能泄露出去；`id_rsa.pub`是公钥，可以放心地告诉任何人。

然后在 GitHub 中绑定生成的公钥即可，当然如果是公司自己搭的 Git 服务器，那就把密钥告诉服务器管理员即可，他会把你的密钥绑定到 Git 服务器上。

### 添加远程库

这时本地和远端就可以进行通信了，我在我的 GitHub 建立一个名字叫 learnGit 的远端仓库，然后在本地的 learnGit 文件夹下运行如下命令：

```
$ git remote add origin git@github.com:yancey_leo/learnGit.git
```

这样，本地仓库就和远端仓库关联上了，origin 就是远程库的名字，这是 Git 默认的叫法，一般就用这个名字即可。

### 将本地仓库推送到远程

下面将本地的 master 分支推送到远端，下面这个命令是第一次推送，需要加\*\*\-u\*\*：

```
$ git push -u origin master
```

以后推送分支时就不需要加\*\*\-u\*\*了，下面是将本地的 master 分支推送到远端的 master 分支，实际就是本地把远端的给覆盖掉了：

```
$ git push origin master
```

### 克隆现有远端数据库

```
$ git clone git@github.com:yancey_leo/learnGit.git
```

当然 URL 不仅仅限于形如 github.com:yancey_leo 的这种形式，很多公司自己搭 Git，会走 https 等。

### 从远程拉取最新更新

当别人在远端更新了提交，你需要把最新的更新拉下来：

```
$ git pull
```

## 分支管理

一开始只有 master 分支，它是一条线，HEAD 指向最新的提交的那一版本，每次提交，master 分支都会向前移动一步，随着不断提交，master 分支的线也越来越长：

为了独立开发，我们在从远程拉取仓库后，切出一个分支，比如命名为 loginPage.

```
$ git checkout -b loginPage
```

上句实际执行了两句指令，分别创建分支和切换到被创建的这条分支:

```
$ git branch loginPage
$ git checkout loginPage
```

当我们创建并指向 loginPage 分支时，Git 新建了一个指针叫 loginPage，指向 master 相同的提交，再把 HEAD 指向 loginPage，就表示当前分支在 loginPage 上了。

通过命令`git branch`查看**本地**所有分支，其中前面标有**星号**的是当前分支；通过命令`git branch -a`查看**本地和远端**所有分支。

从现在开始，对工作区的修改和提交就是针对 loginPage 分支了，比如新提交一次后，loginPage 指针往前移动一步，而 master 指针不变。当 loginPage 分支的工作完成了，那就可以合并到 master 分支了，具体操作有两步：**先切到 master 分支，再将 loginPage 分支合并**:

```
$ git checkout master
$ git merge loginPage
```

此时 master 的内容就和 loginPage 的一样了，然后就可以删除 loginPage 分支了：

```
$ git branch -d loginPage
```

当然有时会显示并没有完全转移，如下图所示，如果确定没什么冲突，那就直接`git branch -D loginPage`好了。

![没有完全转移](//edge.yancey.app/beg/8738933d-3ee5-4e8d-a0b4-a35960d193a0.jpg)
注意：`git branch -d loginPage`这个命令是删除本地的 loginPage，若远端还保留着这个分支，用下面这个命令：

```
$ git push origin :loginPage
```

做一个简单梳理，多人协作中基本就是这些命令，分支名以“loginPage”为例：

```
查看本地分支：git branch

查看远程分支：git branch -a

创建分支：git branch loginPage

切换分支：git checkout loginPage

创建+切换分支：git checkout -b loginPage

合并分支到master： ① git checkout master  ② git merge loginPage

将某分支推送到远端：git push origin loginPage

删除本地某分支：git branch -d loginPage

删除远端某分支：git push origin :loginPage
```

## 忽略特殊文件

在 Git 工作区的根目录下创建一个特殊的`.gitignore`文件，比如我现在用的 IDE 是 WebStorm，这货会自动在工程下生成隐藏的配置文件夹`.idea`。所以我可以创建这个名字叫做`.gitignore`的文件，用 Atom 打开，键入：

```
.idea
DS_Store
...
```

## 一些常见场景

### 当别人把你远端的分支删除了

当别人在你不知情的情况下把你远端的分支给删除了，你执行`git branch -a`会发现这个分支还在远端显示着。当你想删除这个远端分支时，执行`git push origin :taggoods2`就会报错：

![远端的分支被别人删除](//edge.yancey.app/beg/d89a9d94-b126-4555-b97e-5640443c5e6d.jpg)

_注意这是我工作中遇到的问题，所以关键地方打了码_。

因此需要删除本地跟踪：

```
$ git branch -dr origin/taggoods2
```

这个**--dr**是**--delete --remotes**的缩写，若你不怕麻烦，下面的代码同等效益：

```
$ git branch --delete --remotes origin/taggoods2
```
","2025-02-02 03:07:53.682165","2025-02-02 03:07:53.682165"
"e969ef25-3597-40c5-820d-59334ab61f71","{上传}",0,0,False,"https://edge.yancey.app/beg/l8i05hgm-1631683229556.jpg","聊一聊前端上传那些事","Web 上传一直是前端绕不开的话题，同是也是一个难点。关于上传需求多种多样：立即上传，非立即上传、文件预览、大文件上传、断点问题... 虽说大部分遇到的场景直接用 UI 组件都能搞定，但一些特殊需求还是需要手动来写，这里把上传相关总结一下。","## 前提

[文章源码戳这里](https://github.com/YanceyOfficial/Front-End-Upload)

为了能够模拟真实上传，遂起一个 server。这里用 Express + [formidable](https://github.com/felixge/node-formidable)来简单写一个上传接口:

```js
app.post('/uploads', (req, res, next) => {

  const form = new formidable.IncomingForm();

  form.uploadDir = './files';
  form.keepExtensions = true;
  form.multiples = true;
  form.hash = 'md5';

  form.parse(req, async (error, fields, files) => {
    res.status(200).send({
      success: true
    })
  });
});

app.listen(3001, function () {
  console.log('app is listening at port 3001')
})
```

下面统一调用`http://localhost:3001/uploads`这个接口，文件会上传到`./files这个文件夹里`。

## 传统 Form 表单上传

### 谈一谈 multipart/form-data

直接上代码：

```html
<form action=""http://localhost:3036/uploads"" method=""post"" enctype=""multipart/form-data"" target=""_blank"">
    <fieldset>
      <legend>Upload File:</legend>
      <label for=""upload""><input id=""upload"" type=""file"" name=""formFile"" multiple /></label>
      <input type=""submit"" value=""Upload"">
    </fieldset>
  </form>
```

需要注意的是，当做表单上传时，要在 form 标签添加`enctype=""multipart/form-data""`，而普通文本表单上传则不需要刻意定义，因为 form 的`enctype`存在一个默认值，即`x-www-form-urlencoded`。

### 谈一谈 boundary

这里探讨一下`multipart/form-data`和`x-www-form-urlencoded`的区别：

```js
// 普通文本的Content-Type
Content-Type: application/x-www-form-urlencoded

// 上传文件的Content-Type
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryj38DKRgyVvwG8PYC
```

可见`multipart/form-data`多了一个`boundary`.

先思考普通文本表单，无论是 get 请求还是 post，实际都是以`username=222&password=222&age=18`这种形式传递给后端的，只不过前者用 req.query 拿到，后者解析后用 req.body 拿到。所以，普通文本表单用于分割每个实体的 **""boundary""** 就是 **&** 符。

同理在 multipart 下，也需要边界来分隔每个实体，如下图这种形式：

![multipart](//edge.yancey.app/beg/Jietu20190111-171803%402x.jpg)

在点击提交按钮时，实际上只会给后端发送一件“包裹”，但包裹里即有`文件`也有`文本`，但显然`文件`和`文本`不可能简单的用`&`符分割，所以需要 boundary 来做分隔。

最后来看[rfc1341](https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html)的第一段：

> In the case of multiple part messages, in which one or more different sets of data are combined in a single body, a ""multipart"" Content-Type field must appear in the entity's header. The body must then contain one or more ""body parts,"" each preceded by an encapsulation boundary, and the last one followed by a closing boundary. Each part starts with an encapsulation boundary, and then contains a body part consisting of header area, a blank line, and a body area. Thus a body part is similar to an RFC 822 message in syntax, but different in meaning.

关于实现原理，先种草，今天先搞清`boundary`的意义是什么。

### 谈一谈优缺点

先谈缺点吧，因为不涉及 JS，所以没有 onChange、onProgress 之类的事件监听，也就无法实现一些过程的交互；此外 form 提交会发生页面跳转，现代网页一般很难容忍这种方式。

当然 form 上传仍有有它存在的场景，印象里最近一次用到 form 表单还是在上家公司，为了安全考虑，请求接口会拿到一个后端写好的 form，这个 form 里面除了上传相关的标签，还有一些 input[type=""hidden""]的加密标签。思考一下这个场景，form 上传还是有它的用武之地。

## FormData

FormData 是 XMLHttpRequest Level 2 新增的一个接口，它用一些键值对来模拟一系列表单控件，FormData 的最大优点就是可以异步上传一个二进制文件。

首先在 body 里创建一个 input 标签：

```html
<input type=""file"" accept=""application/java-archive, image/jpeg"" multiple />
```

然后在 script 写：

```js
const fileTag = document.querySelector('input[type=""file""]');

fileTag.addEventListener('change', () => {

  // 创建一个FormData实例
  const formData = new FormData();

  // 拿到input标签上传的file
  const fileList = fileTag.files;
  if (fileList) {

    // 将input标签上传的file追加到FormData对象里
    Object.values(fileList).map(item => formData.append('file', item));

    // 请求上传接口
    fetch('http://localhost:3036/uploads', {
        method: 'POST',
        body: formData,
        // headers: {
        //   'Content-Type': 'multipart/form-data'
        // }
      })
      .then(res => {
        if (res.ok) {
          console.log('success');
          return res.json();
        } else {
          console.log('error');
        }
      })
      .then(res => {
        console.log('res is', res);
      });
  }
});
```

⚠️ 注意：当使用 FormData 上传时，fetch 的 header 中就不能再包含 `'Content-Type': 'multipart/form-data'` 了。这里涉及到了上面所说到的 boundary，FormData 默认已经包含了 multipart/form-data，因此在执行 formData.append()时已经设置好了 boundary，所以当你在 fetch 里重复声明了 `'Content-Type': 'multipart/form-data'` ，就会造成错误而不能正常上传了。

至于为什么会发生错误，而不是覆盖，再种个草。

同理用原生 xhr，也是不能加`'Content-Type': 'multipart/form-data'`的，有兴趣的可以试试。在 jQuery 中，也要手动将 contentType 设为 false.

但是在用 axios 的时候是没问题的，遂翻了一下 [axios 的源码](https://github.com/axios/axios/blob/master/dist/axios.js)，原来它会预检请求体是否为 FormData，如果是，且又在请求头设置了 `'Content-Type': 'multipart/form-data'` ，就把它删除掉！

![axios可以写上'Content-Type': 'multipart/form-data'](//edge.yancey.app/beg/Jietu20190112-213556%402x.jpg)

### FormData 方法一览

#### apend()

apend()应该是最核心的方法了，用于向 FormData 中追加文件，接受三个参数 name, value, filename(可选)，其中 name 是字段名，value 一般来讲就是文件实体了，第三个参数可以为文件设置一个文件名，如果为空则是上传文件的原文件名。

```js
formData.append('file', File, '小黄图') ;
```

#### delete()

不多说，用于删除指定 name 的文件，接受一个参数即为 name

```js
formData.delete(name);
```

#### keys()、values()、entries()

返回一个 iterator 对象 ，entries()可以遍历访问 FormData 中的键值对，values()可以遍历访问 FormData 中的值，keys()可以遍历访问 FormData 中的键，用途的话我觉得可以做文件上传信息预览的功能。

```js
for (const item of formData.entries()){
  console.log(item)
}
```

#### get()、getAll()

用于返回 FormData 对象中和指定的键关联的第一个值，如果想要返回和指定键关联的全部值，那么可以使用 getAll()方法，接受一个参数 name.

```js
formData.geAll('file') ;
```

⚠️ 注意：console.log(formData)是打印不出 formData 的信息的，必须使用 get 或 getAll 方法。

#### has()

用于查询 FormData 对象是否存在某个 name, 接受一个参数 name, 返回 Boolean 值。

#### set()

它和 append()用法一致，不同的是，set()会覆盖原有的文件某个 name 的全部文件，而 append()不会破坏既有的，只会追加。

## FileReader

FileReader 直接用做上传并不常见，它最常见的场景文件预览。直接看代码：

```html
<input type='file' multiple>
  <ul id='image_list'></ul>

  <script>
    const fileTag = document.querySelector('input[type=""file""]');
    const ulTag = document.querySelector('#image_list');

    fileTag.addEventListener('change', function () {
      const fileList = this.files;

      Object.values(fileList).map(file => {
        const reader = new FileReader();
        reader.addEventListener('load', function (e) {
          const li = `<li><img src='${e.target.result}' alt='${file.name}'></li>`
          ulTag.insertAdjacentHTML('beforeend', li);
        });
        reader.readAsDataURL(file);
      })
    });
  </script>
```

在触发 onChange 事件后，创建一个 FileReader 的实例。当 FileReader 读取文件的方式为 readAsArrayBuffer, readAsBinaryString, readAsDataURL 或者 readAsText 的时候，会触发一个 load 事件，从而可以使用 FileReader.onload 属性对该事件进行处理。

例子中使用`readAsDataURL`方法，也就是将上传的图片转变为 base64 格式，然后将 base64 文件指向 img 标签的 src 属性，最后追加到 ul 标签中作为预览。

FileReader 有 5 个方法，分别是

- abort()
- readAsArrayBuffer()
- readAsBinaryString()
- readAsDataURL()
- readAsText()

当传图片时，可以使用 readAsDataURL()转变为 base64 做预览，其他格式考虑其他方法，但个人来讲除了图片预览其他基本没用过。

## 总结

其实还有一些方式，比如 iframe、flash、websocket 等方式，但用得最多的肯定还是传统表单和 FormData 这两种形式，当然很多 UI 组件已经封装的很好了（不知道 Eelment UI 为啥这么变态...）。

以上、よろしく。

## 参考

[踩坑篇--使用 fetch 上传文件](https://zhuanlan.zhihu.com/p/34291688)

[File 对象，FileList 对象，FileReader 对象](https://wangdoc.com/javascript/bom/file.html#filelist-%E5%AF%B9%E8%B1%A1)

[聊聊 Web 上传](http://www.devsai.com/2016/11/08/talk-web-upload/#H5%E2%80%94xhr2%EF%BC%88XmlHttpRequest-level-2%EF%BC%89%E4%B8%8A%E4%BC%A0)
","2025-02-02 03:07:55.357744","2025-02-02 03:07:55.357744"
"e101db4a-23ef-492f-80c3-5a8de67fe259","{React}",0,0,False,"https://edge.yancey.app/beg/68747470733a2f2f79616e6365792d6173736574732e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f436f7665722e39333935336164333736653734393330396134383363386231316234303130362e6a7067.jpeg","React 配置全局 Sass 和 CSS Module","接下来的业余时间要做个人博客 Wap 端，这次打算尝试一下 TypeScript、持续集成、自动化等以前没有实践过的技术栈...当然大前提还是要把架子搭好，上次记录了一下 Vue 配置全局 Sass 变量的方法，这次把 React 的配置方法记录一下，显然比 Vue-cli 麻烦了一些。","## 前提

一开始本来打算用微软的[TypeScript-React-Starter](https://github.com/Microsoft/TypeScript-React-Starter)来创建脚手架，正好省了初始化`TypeScript`那一套，但是这个 CLI 貌似对`CSS Mudule`配置不是支持得很好，看了社区一些 hack 方法感觉也不太好用。遂还是用`create-react-app`创建一个 React 工程，然后把`TypeScript-React-Starter`的配置拷了过来。

以前用`React-app-rewired`去给 webpack 添加配置，但总有种隔靴搔痒的感觉，这次决定`yarn eject`这个工程。

在`src`目录下创建`assets`文件夹，然后在`assets`文件夹里创建一个`styles`文件夹，添加一个 sass 文件叫`_color.scss`，里面先简单加几个颜色变量，以备测试：

```
$white: #fff;
$black: #000;
$gray: #666;




```

下面先说怎么做 CSS Module，然后再往全局 Sass 迁移。

## CSS Module

### 安装配置

首先安装依赖:

```
yarn add node-sass




```

使用`create-react-app`默认会创建一个`App.js`和`App.css`，我们需要将`App.css`**重命名为**`App.module.css`，

<mark>这点非常关键，只要想做`CSS Module`，css 文件必须要改成`*.module.css`的形式。</mark>

然后打开`App.js`文件，引入`App.module.css`，可以发现引入 css 的方式也和以前不一样了，下面的`styles`名字随便起，看你个人喜好了：

```
import styles from './App.module.css';




```

这里我建议在 class 命名的时候，要以下划线的形式连接每个单词，比如`App_common_logo`，这也是[鹅厂 aotu 实验室推荐的的命名方式](https://guide.aotu.io/docs/name/classname.html)，其实这样对使用 CSS Module 也有好处，一会儿会说到。

![CSS Module使用图例](//edge.yancey.app/beg/Jietu20181201-212344%402x.jpg)

### 使用方法

关于使用方法，这里直接上图吧，实际上就是把以前的`className=""App_intro""`变成了`className={styles.App_intro}`。

我们回到上面 class 命名那个话题，如果你的类名叫做`App-intro`，那你就得写成`className={styles['App-intro']}`，写多了项目也不清晰了。

我们再看一下 Dev Tool 的渲染情况：

![渲染出来的类名](//edge.yancey.app/beg/Jietu20181201-213207.jpg)

这是 Webpack 的默认配置，默认就是`模块名_类名__5位hash`，好处一目了然，不会用重复的 class 了，我个人决定在开发环境直接使用 Webpack 的默认配置，在生产环境再做一些改变，打开`config/webpack.config.prod.js`文件，搜索关键字`getLocalIndent`，我个人打算 build 之后的类名直接是`6位hash`，所以配置如下图：

![修改Webpack配置](//edge.yancey.app/beg/Jietu20181201-214147%402x.jpg)

### 题外话

在使用 CSS Module 的过程中相信你一定会遇到其他的问题，比如一个标签如果有多个 class，以前可以写成`className=""App_icon App_select""`，但是 CSS Module 是不允许的，所以需要安装依赖`yarn add classnames`，使用方式如下：

```
import cs from 'classnames';

className={cs(styles.social_media_motto, styles.no_user_select)}




```

此外，如果你的模块里不得不操作 DOM，如果继续用`className={styles.App_intro}`的方式，`document.querySelector('.App_intro')`将不会如你所愿，因为此时的 App_intro 已经被被 hash 所“污染，因此你还是需要命名为`className=""App_intro""这种形式`。

但是新的问题来了，你在`App.mudule.css`中给`App_intro`定义的任何样式将不会起作用，所以需要在 css 里做写文章：

```
:global(.App_intro) {
    outline: none;
    border-radius: 50%;
  }




```

## Sass 全局变量、函数、Mixin...

如果定义了一个关于颜色变量的 Sass 文件，按以前的做法，那就得在每个模块的 Sass 文件中`@import '../assets/styles/_color.scss'`，显然这种方式很不(e)科(xin)学。尤其在写移动端的时候，肯定得定义一些全局的函数，要是每个文件都要引一次，天啦噜...

首先安装依赖`yarn add sass-resources-loader --dev`，然后打开`config/webpack.config.dev.js`，注意是开发环境的 Webpack 配置文件。

检索关键词`sass-loader`，看下图：

![配置全局Sass](//edge.yancey.app/beg/Jietu20181201-221430.jpg)

下面把代码贴出来，注意一定是`../src/assets/styles/_colors.scss'`，网上教程坑得一逼，全给写成`./src/assets/styles/_colors.scss'`，结果一直报错。

```
use: [{
  loader: require.resolve('style-loader'),
},
{
  loader: require.resolve('css-loader'),
  options: {
    importLoaders: 2
  },
},
{
  loader: require.resolve('sass-loader'),
},
{
  loader: require.resolve('sass-resources-loader'),
  options: {
    resources: [path.resolve(__dirname, '../src/assets/styles/_colors.scss'), path.resolve(__dirname, '../src/assets/styles/_function.scss')],
  }
}],




```

因为我们做了 CSS Module，所以我们也要为 CSS Module 支持引入全局 Sass 变量。

![为CSS Module配置全局Sass](//edge.yancey.app/beg/Jietu20181201-222133%402x.jpg)

这时我们将上面的`App.mudule.css`重命名为`App.mudule.scss`，然后随便找个 class 添加个颜色，发现生效了：

```
.App_header {
  display: flex;
  align-items: center;
  justify-content: center;
  color: $gray;
}




```

## 最后

在前几个月写 PC 端的博客前台时，已经用上了 CSS Module，但没去考虑全局 Sass 变量，这次也算是一次温故和知新吧。计划 Wap 端会用上 TypeScript，同构个 PWA 什么的，然后尝试用 Trvis 做持续集成和自动化部署，任重道远啊。

明天又要苦逼的加班去了，日了。

以上、よろしく。
","2025-02-02 03:07:57.33918","2025-02-02 03:07:57.33918"
"d51d5dc1-a3f9-4e08-b6fa-0cc06992c158","{React,""Google Analytics""}",0,0,False,"https://edge.yancey.app/beg/68747470733a2f2f79616e6365792d6173736574732e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f676f6f676c655f616e616c79746963732e706e67.png","React 单页应用添加 GA 埋点","Blog2.0 已经上线一个多月了，突然想起还没把 GA 从 1.0 迁移过来，但 2.0 是一个 SPA 应用，不能跟以前那样简单引一段 JS 代码。折腾了一小会儿搞了出来，这里做个记录。","## 概览

单页应用 (SPA) 指的是在首次加载网页时加载浏览整个网站所需所有资源的网络应用或网站。当用户点击链接并与网页互动时，系统将以动态方式加载后续内容。应用会经常更新地址栏中的网址来模仿传统的网页导航，但始终不会再发出整个网页加载请求。

在传统网站上运行默认的 JavaScript 跟踪代码段没有任何问题，因为该代码段在用户每次加载新页面时都会运行。但是，对于单页应用，网站以动态方式加载新的网页内容，而不采用整个网页加载方式，因此 analytics.js 代码段仅运行一次。也就是说，当有新内容加载时，必须通过人工方式跟踪后续的（虚拟）网页浏览。

—— 节(cou)选(zi)自(shu)Google 原文

## 前提

这里基于 react-router-4.x，需要用到`history`模式。

首先你的 src 目录下要有一个`history.js`,内容如下：

```
import createHistory from 'history/createBrowserHistory';

export default createHistory();

```

## 安装依赖

```
 yarn add react-ga

```

## 使用

我是在`App.js`import `history`和`react-ga`这两个包；

然后写如下这个方法：

```
 reactGA() {
    ReactGA.initialize('YOUR_GA_KEY');
    history.listen((location, action) => {
      ReactGA.pageview(window.location.pathname + window.location.search);
    });
  }

```

让这个方法放在`componentWillMount`钩子下执行即可，打开 GA，发现能监测到路由的变化了。
","2025-02-02 03:07:58.943956","2025-02-02 03:07:58.943956"
"a2c3c17e-1512-4a9f-9beb-1f3ac01b20c5","{""Natsuha Weather "",微信小程序}",0,0,False,"https://edge.yancey.app/beg/dm47xloi-1631683171932.jpg","Natsuha - 用 Taro 写个天气微信小程序","去年年底 o2 开源了 Taro，一直手痒痒没去玩。考虑到 wx 的审核制度，所以决定写个工具类小程序。赶在 Taro 喜提第 2000 个 issues 之际 😂，Natsuha 终于上线了 🥳。源码全部释出（除涉及私钥部分，GitHub 有说明），文章后面会贴出一些仍需优化的点，欢迎大家一起讨论。","## 前言

[源码看这里](https://github.com/YanceyOfficial/Natsuha-Weather)

![Scan the QR Code by WeChat](https://edge.yancey.app/beg/natsuha_344.jpg)

![效果图](//edge.yancey.app/beg/barcelona.jpg)

项目的技术栈是 `Taro + mobx + TypeScript`，接口来自 [Yahoo Weather API](https://developer.yahoo.com/weather/documentation.html)，当然设计也是参 (chao) 考 (xi) 的 [Yahoo Weather](https://www.yahoo.com/news/weather/china/beijing/beijing-2151330)

## 功能

- 下拉刷新
- 华氏温度、摄氏温度切换
- 分时展示一天的天气预报
- 展示未来 10 天的天气预报
- 展示当前风向、风速
- 展示日出日落、月相等信息
- 展示一天内的降水预报
- 城市天气检索

## TODO

- 国际化
- 性能优化
- 图片加载优化
- Jest 搞起来（初始化已搭好）
- Travis CI 搞起来（初始化已搭好）
- 将搜索模块放到一个新页面（强行加个路由 😂）

## 踩坑

### 小程序篇

#### 云开发解决 Bei An 问题

由于众所周知的原因，wx 小程序无法调用未 **bei an** 的接口，哪怕是在开发环境。所以我们用[云开发](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html)的**云函数**来 “反代” 接口，下面通过一个例子说一下技术要点。

首先在根目录的 `project.config.json` 文件里添加 `""cloudfunctionRoot"": ""functions/""`，然后在根目录创建文件夹 `functions`. 并点击右键创建一个新的云函数，比如我们叫 `getRegion`。

![云函数开发](//edge.yancey.app/beg/Jietu20190309-114128%402x.jpg)

因为我们的目标是**通过云函数请求一个未 bei an 的接口**，所以为了更方便的处理异步请求，我们引入 `request-promise` 这个库。

通过`硬盘打开`进入到这个云函数的文件夹，然后安装依赖：

```
yarn add request request-promise

```

接下来我们在 `index.js` 中写逻辑，直接上代码。云函数通过 `event` 对象来获取前端传过来的参数，然后通过 Promise 对象将结果返回。这个例子中我们需要拿到`region`，

```
// 云函数入口文件
const cloud = require('wx-server-sdk')
const rp = require('request-promise')

cloud.init()

exports.main = async (event, context) => {
  const region = event.region;
  const res = await rp({
    method: 'get',
    uri: `https://www.yahoo.com/news/_tdnews/api/resource/WeatherSearch;text=${region}`,
    json: true
  }).then((body) => {
    return {
      regionList: body
    }
  }).catch(err => {
    return err;
  })
  return res;
}

```

接下来是前端发请求了，注意这里不能再用 `Taro.request()`, 而是云函数独有的 `wx.cloud.callFunction()`, 因为我现在的 Taro 版本尚未实现 `Taro.cloud.callFunction()`，所以直接用 `wx` 打头即可。

首先封装一下 `wx.cloud.callFunction()`，其实感觉什么卵用 🤪：

```
export const httpClient = (url: string, data: any) => new Promise((resolve, reject): void => {
  wx.cloud.callFunction({
    name: url,
    data,
  }).then(res => {
    resolve(res.result);
  }).catch(e => {
    reject(e)
  });
});

```

然后我们在 store 里面写逻辑，这样基本上就解决了数据请求的坑。

```
  public getRegion = (text: string) => {
    httpClient('getRegion', {
        region: encodeURI(text),
      })
      .then((res: any) => {
        runInAction(() => {
          if (res.regionList) {
            this.regionList = res.regionList;
          }
        });
      })
      .catch(() => {
        setToast(toastTxt.cityFail);
      });
  };

```

🔔 题外话：因为当前版本尚未实现 `Taro.cloud.callFunction()`，所以 lint 会报错，虽然不影响使用，大家有什么好的方法，可以说一下。

#### 地理信息授权问题

在这个项目里，我们需要通过小程序拿到的**经纬度**来反查城市信息，而小程序获取**经纬度**需要用户授权。这里有个坑，**当用户拒绝授权后，小程序默认询问授权的 dialog 在一段时间内不会重复弹出**，所以我们必须手动将用户引导到授权页面。

以前小程序有个接口叫做 `wx.openSetting()`，但 tx 把它废掉了，现在只能让用户点击一个特定的按钮。

为此我做了一个 modal，这里贴出关键代码。

```
<Button openType='openSetting' onOpenSetting={() => this.onOpenSetting()}>
  OK
</Button>

```

首先我们必须给按钮声明 `openType='openSetting'`，这样当用户点击了之后就会跳转到设置页面。

其次，我们需要在用户**离开**授权页面时，也就是点击了左上角那个返回按钮时，再次去检查一下用户的授权情况。所以我们要添加
`onOpenSetting={() => this.onOpenSetting()`，不得不吐槽这个事件命名，明明应该叫做 `onLeaveSetting`才合理。

在 `onOpenSetting()` 方法中我们再次执行**判断用户是否授权**的方法，未授权的话接着弹 modal，否则放行请求相应的数据接口。

文字有些累，直接看图。

![授权图解](//edge.yancey.app/beg/%E6%9C%AA%E5%91%BD%E5%90%8D_meitu_1.jpg)

#### 无法用传统方式清空文本框文字

当用户关闭`搜索` dialog 时，文本框的文字应当被清空，所以一开始写成了这样。本计划在 d 点击关闭按钮时触发 hideSearchDialog(), 里面将 `inputValue = ''` 完事，发现不行。

```
<Input
  type='text'
  value={inputValue}
  placeholder='Enter City or ZIP code'
  onInput={e => handleInputTextChange(e)}
/>

<Button onClick={() => hideSearchDialog()}>Close</Button>

```

查了一下官方文档，必须将 `Input` 和 `Button` 包裹在一个 `Form` 下，且要给关闭按钮加上 `formType='reset'`，最后给 `Form` 添加 `onReset` 事件指向关闭 dialog 的方法。

```
<Form onReset={() => hideSearchDialog()}>
  <Input
    className={styles.input}
    type='text'
    placeholder='Enter City or ZIP code'
    onInput={e => handleInputTextChange(e)}
  />
  <Button formType='reset'>Close</Button>
</Form>;

```

### Taro 篇

大多是编译问题和它 webpack 配的问题，相应的我都提了 issue，有兴趣的话可以跟进。

#### Taro 编译会忽略模版两个之间的空格

举个例子，`<Text>day - night</Text>`，可以正常编译，页面可以正常看到 `day - night`，但是假如是变量，就会被编译成 `day- night`，注意，空格被吃掉了。

```
const day = 'day'
const night = 'night'

<Text>{day} - {night}</Text>

```

我提了个 issue [#2261](https://github.com/NervJS/taro/issues/2261)，然并没人鸟我，有兴趣可以跟进一下。

#### ts 不能识别`wx`

因为用到了云开发，而 Taro 现阶段还没有`Taro.cloud(...)`,所以在使用原生的`wx.cloud(...)`时,
ts 肯定会报错。

#### css module 等静态文件 找不到路径

一开始用的`import`来引入静态文件，但报“找不到路径”，可以看下图（但不影响使用）。提了个 issue [#2213](https://github.com/NervJS/taro/issues/2213),
按照大佬的回复修改也没解决问题，实在受不了一片红，索性改成了`commonJS`.

![找不到模块](https://edge.yancey.app/beg/Jietu20190219-142504@2x.jpg)

## Problem

下面是项目中存在的一些问题，有兴趣的话欢迎大家一起讨论。

### 图片加载不友好

接口图片的 url 来自`aws`，因为众所周知的原因，图片经常会挂掉，
所以有必要在图片挂掉的时候触发`onError`事件，然后给用户一个提示。

因为小程序不支持`new Image()`，所以只能用官方提供的`Image`组件，幸好这个
组件支持`onLoad`和`onError`事件。

加载失败的问题解决了，但因为`aws`的速度太慢，所以正常加载时也很不友好（可以自行体会）

做了一些尝试，比如先加载缩略图，再展示完整图片，但接口提供的最小尺寸的图片也已经达到了
70 多 k，并且该死的 Yahoo 恰好将图片 url 控制大小的那段用了加密，所以这个方式 pass 掉了。

### 搜索输入框加个节流

现在的做法是在 store 的 构造器加个节流，但不知道这样合不合理。

```
  construtor() {
    this.getRegion = _.debounce(this.getRegion, 150);
  }

```

## 最后

![老子再也不写小程序了！](//edge.yancey.app/beg/FD200112FC037CDE3AC366B45288EA61.jpg)
","2025-02-02 03:07:59.525182","2025-02-02 03:07:59.525182"
"408353f6-bc09-49d6-95fb-da78fc7c9540","{TypeScript}",0,0,False,"https://edge.yancey.app/beg/68747470733a2f2f79616e6365792d6173736574732e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f62616e6e65722e706e67.png","聊一聊 TypeScript 的工程引用","工程引用是 TypeScript 3.0 的新特性, 它支持将 TypeScript 程序的结构分割成更小的组成部分. 这样可以改善构建时间 (打开 composite 会自动开启增量编译), 强制在逻辑上对组件进行分离, 更好地组织你的代码.","## 不使用工程引用引发的痛点

考察下面的代码结构: 假设这是一个前后端未分离的项目, client 目录下存放的是**客户端**代码; server 目录下存放的**服务端**代码; common 存放的是一些**共用**代码, 比如一些 util 方法, `client/index.ts` 和 `server/index.ts` 会引用这里的代码.

\_\_test\_\_ 目录则存放的是一些单元测试的代码\, 它会分别引用 `src/client/index.ts` 和 `src/server/index.ts`.

并且整个工程只有一个 `tsconfig.json`, 它主要的配置是 `""outDir"": ""./dist""`, 也就是将编译后的文件存放到根目录的 dist 文件夹.

```ts
.
├── src
│   ├── client
│   │   ├── index.ts
│   ├── common
│   │   ├── index.ts
│   ├── server
│   │   ├── index.ts
├── __test__
│   ├── client.spec.ts
│   ├── server.spec.ts
├── package.json
├── tsconfig.json
└── yarn.lock
├── README.md

```

通过 `tsc` 命令进行编译, dist 文件下大致如下.

```ts
.
├── dist
│   ├── src
│   │   ├── client
│   │   ├── common
│   │   ├── server
│   ├── __test__

```

通过上面的 code structure, 可以罗列出几个痛点:

- 我们希望 src 下面的文件直接被编译到 dist 目录下\, 但由于 \_\_test\_\_ 的存在而达不到这样的效果\.

- 我们无法单独构建 client 端, 或者 server 端的代码.

- 我们不希望把 \_\_test\_\_ 构建到 dist 目录下\.

## 使用工程引用改造上面的项目

通过上面的代码, 我们能感受到仅仅一个 tsconfig.json 文件无法灵活的 hold 住个性化的编译配置, 因此尝试给每个目录都增加一个 tsconfig.json. (为了便于区分每个 tsconfig.json 文件, 下面将使用 ①②③④⑤ 序号代替)

```ts
.
├── src
│   ├── client
│   │   ├── index.ts
│   │   ├── tsconfig.json // ①
│   ├── common
│   │   ├── index.ts
│   │   ├── tsconfig.json // ②
│   ├── server
│   │   ├── index.ts
│   │   ├── tsconfig.json // ③
├── __test__
│   ├── client.spec.ts
│   ├── server.spec.ts
│   ├── tsconfig.json // ④
├── package.json
├── tsconfig.json // ⑤
└── yarn.lock
├── README.md

```

接下来改造一下根 tsconfig.json 文件, 也就是 ⑤.

```json
{
  ""compilerOptions"": {
    ""target"": ""es5"",
    ""module"": ""commonjs"",
    ""strict"": true,
    // ""outDir"": ""./dist""  关闭 outDir 选项, 即不在根配置中指定输入目录

    ""composite"": true, // 使用 composite, 它意味着工程可以被引用, 并支持增量编译
    ""declaration"": true // 使用 composite 选项必须开启 declaration
  }
}
```

接下来改造 ①, 因为 ① 和 ③ 的配置大致相同, 这里不再赘述.

```json
{
  ""extends"": ""../../tsconfig.json"", // 首先导入 ⑤
  ""compilerOptions"": {
    ""outDir"": ""../../dist/client"" // 指定输入目录
  },
  ""references"": [{ ""path"": ""../common"" }] // 因为 client 引用了 common, 故需要将 common 引入进来
}
```

对于 ②, 因为它没有引用其他的模块, 因此只需要配置好 outDir 即可, 代码如下:

```json
{
  ""extends"": ""../../tsconfig.json"",
  ""compilerOptions"": {
    ""outDir"": ""../../dist/common""
  }
}
```

对于 ④\, 为了不让测试文件被编译到 dist 目录下\, 就让编译后的文件也存放到 \_\_test\_\_ 好了\.

```json
{
  ""extends"": ""../tsconfig.json"",
  ""references"": [{ ""path"": ""../src/client"" }, { ""path"": ""../src/server"" }]
}
```

## 编译

既然配置写好了, 下面就可以愉快的编译了. 为了支持工程引用, TypeScript 使用了 `build` 的构建模式, 它可以构建单独的工程, 相关依赖也可以被自动构建, 下面我们构建 server 端的应用, 其中 -b 是 build 的简写, `verbose` 可以打印出一些构建信息.

```ts
tsc -b src/server --verbose

```

当 server 端被构建完毕后, server 文件夹和它所依赖的 common 文件夹就会被编译到 dist 目录下, 因此当你再编译 client 时, common 就不用被重复编译, 这样就提升了编译效率. 此外, 它会在每个目录下生成增量编译文件, 这样下次编译时就很快了.

此外, 你可以通过 `--clean` 参数来清除某个工程已构建的文件\, 下面是清理 \_\_test\_\_ 产生的文件\.

```ts
tsc -b __test__ --clean

```

## 总结

工程引用的优点如下:

- 解决了输出目录的结构问题

- 解决了单个工程的构建问题

- 通过增量编译提高了编译效率

其实 TypeScript 的[官方源码](https://github.com/microsoft/TypeScript)已经使用了工程引用技术, 在 src 目录下有一个根 tsconfig-base.json, 在其他的目录下, 如[server](https://github.com/microsoft/TypeScript/tree/master/src/server)目录下又有自己的 tsconfig.json, 摘录如下:

```json
{
  ""extends"": ""../tsconfig-base"",
  ""compilerOptions"": {
    ""removeComments"": false,
    ""outFile"": ""../../built/local/server.js"",
    ""preserveConstEnums"": true,
    ""types"": [""node""]
  },
  ""references"": [
    { ""path"": ""../compiler"" },
    { ""path"": ""../jsTyping"" },
    { ""path"": ""../services"" }
  ],
  ""files"": [
    ""types.ts"",
    ""utilities.ts"",
    ""protocol.ts"",
    ""scriptInfo.ts"",
    ""typingsCache.ts"",
    ""project.ts"",
    ""editorServices.ts"",
    ""packageJsonCache.ts"",
    ""session.ts"",
    ""scriptVersionCache.ts""
  ]
}
```
","2025-02-02 03:08:01.577342","2025-02-02 03:08:01.577342"
"049c4aad-6984-4cb3-bf98-773fb19523c5","{""Travis CI"",持续集成和持续部署}",0,0,False,"https://edge.yancey.app/beg/Travis-CI-Feature-Image-800x445.jpg","用 Travis CI 打造大前端持续集成和自动化部署","很早之前我就在用 Travis CI 做持续集成了，虽然只是停留在 zhuang bi 的阶段，但或多或少也保证了代码的提交质量。最近在写一个 《JavaScript API 全解析》系列的 Book，需要经常把文章部署到服务器上，手动部署实在是烦，索性花了一天时间研究了一下自动化部署。这篇文章是对 Travis CI 持续集成和自动化部署的总结，以飨社区。","## 前戏

Travis CI 目前有两个网站，一个是 travis-ci.com，另一个是 travis-ci.org. 前者用于企业级和私有仓库，后者用于开源的公有仓库。实际上 free plan 也可以使用 travis-ci.com，但优先级很低，跑个自动化动辄两个小时，因此我们使用 travis-ci.org.

首先打开 [Travis CI 官网](https://travis-ci.org/)，并用 GitHub 账号登录，授权后 Travis CI 会同步你的仓库信息。接下来把需要做自动化的工程授权给 Travis CI.

![授权仓库信息](https://user-gold-cdn.xitu.io/2019/3/28/169c2b195a2ade05?w=1022&h=602&f=jpeg&s=64354)

最好有一台 Linux 的服务器，我的是 Cent OS 7.6.x 64bit.

我们点开一个工程，再切到设置，可以看到在 push 代码和 PR 时都会触发持续集成，当然可以根据需求手动配置。

![设置页面](https://user-gold-cdn.xitu.io/2019/3/28/169c2b195a12e4c6?w=3076&h=566&f=jpeg&s=96025)

## 持续集成

为了让持续集成像那么回事儿，我们先在 master 上切一个 develop 分支，再在 develop 上切一个 featur/ci 分支。

接着我们再用 Jest 写几个测试用例，注意如果项目中没有测试脚本而 `.travis.yml` 文件里面包含 `yarn test`，自动化 **一定** 报错。关于 Jest 这里不详细说，只贴出几个示例代码。

```js
import * as utils from '../utils/util';

test('should get right date', () => {
  expect(utils.formatJSONDate('2019-03-10T04:15:40.629Z')).toBe(
    '2019-03-10 12:15:40',
  );
});

test('should get right string', () => {
  expect(utils.upperFirstLetter('AFTERNOON')).toBe('Afternoon');
  expect(utils.upperFirstLetter('YANCEY_LEO')).toBe('Yancey Leo');
});
```

然后我们在工程的根目录下新建一个文件 `.travis.yml`，并复制下面的代码。

```yml
language: node_js
node_js:
  - 8
branchs:
  only:
    - master
cache:
  directories:
    - node_modules
install:
  - yarn install
scripts:
  - yarn test
  - yarn build
```

简单解释一下，工程使用 Node.js 8.x，并且只在 `master` 分支有变动时触发 **自动化部署**（正常的提交、PR 都会正常走持续集成），接着将 node_modules 缓存起来（你懂的），最后安装依赖、跑测试脚本、在沙箱部署。

因此，理论上只要跑通这套流程，我们就可以放心的部署到真实环境了。

提交一下代码，并 pull request 到 develop 分支。在此过程中我们触发了 push 和 PR，所以会跑两个 CI。待到两个都成功跑完后，我们就可以放心的合到 develop 分支了。（这里我还做了代码质量检测，有兴趣可以戳 [Codacy](https://app.codacy.com)）

![跑 CI](https://user-gold-cdn.xitu.io/2019/3/28/169c2b195a31a02c?w=770&h=354&f=jpeg&s=63538)

最后我们回到 Travis CI 的官网，可以看到一套完整的构建流程：安装依赖 -> 测试 -> 沙箱部署

![CI 结果](https://user-gold-cdn.xitu.io/2019/3/28/169c2b195a4fe813?w=3010&h=1700&f=jpeg&s=322175)

## 持续部署

### 创建 rsa 对，并给予权限

首先登录你的服务器，一般来讲我们不会直接在 root 上操作，所以这里新增一个 caddy 的用户 。具体怎样在 Linux 新建用户请自行谷歌。

接下来 cd 到 \~/\.ssh，看看有没有一对 id_rsa 和 id_rsa\.pub，如果没有就用 `ssh-keygen` 生成。

给予 \.ssh 文件夹 700 权限，给予 \.ssh 里的文件 600 权限。（看下面这张图，你的文件夹里可能暂时没有 authorized_keys、 known_host、config 这三个文件，后面会说到。）

```
$ sudo chmod 700 ~/.ssh/

$ sudo chmod 600 ~/.ssh/*
```

![给予 .ssh 权限](https://user-gold-cdn.xitu.io/2019/3/28/169c2b195aa84a5d?w=1242&h=366&f=jpeg&s=122061)

### 将生成的公钥添加到受信列表

进入到 `.ssh` 文件夹里，执行下面的命令，可以看到公钥被添加到受信列表。

```
$ cat id_rsa.pub >> authorized_keys

$ cat authorized_keys
```

### 测试登录

在 `.ssh` 目录下创建一个文件 `config`，输入如下代码并保存。

```
Host test
HostName 当前服务器的IP
User 当前用户名
IdentitiesOnly yes
IdentityFile ~/.ssh/id_rsa
```

因为 `authorized_keys` 和 `config` 文件都是新增的，它们还没被赋予 600 权限，所以重新执行一遍 `sudo chmod 600 ~/.ssh/*`.

然后我们输入 `ssh test`，不出意外会重新登录 ssh。如果你的公钥从来没有被使用过，会提示 `Are you sure you want to continue connecting (yes/no)?` ，输入 yes 后也会正常重新登录，并且在`.ssh` 文件夹下还会生成一个 `known_hosts` 文件.

### 安装 Ruby

因为 Travis 客户端是用 Ruby 写的，所以我们得先安装 Ruby.

首先安装需要的依赖包：

```
$ yum install gcc-c++ patch readline readline-devel zlib zlib-devel \
   libyaml-devel libffi-devel openssl-devel make \
   bzip2 autoconf automake libtool bison iconv-devel sqlite-devel
```

接下来安装 RVM，并载入 RVM 环境。RVM 是 Ruby 的版本管理工具，类似于 Node 的 NVM.

```
$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3

$ \curl -sSL https://get.rvm.io | bash -s stable

# 载入 rvm 环境
$ source ~/.rvm/scripts/rvm
```

安装完之后输入 `rvm -v` 做下检查，如果有 rvm 1.29.1 (latest) by Michal Papis, Piotr Kuczynski, Wayne E. Seguin [https://rvm.io/] 的字样证明安装成功。

最后安装 Ruby，这里选择 v2.4.1 版本，安装需要一段时间，完成后记得将此版本设为默认。

```
$ rvm install 2.4.1

$ rvm 2.4.1 --default
```

执行一下 `ruby -v` 和 `gem -v`，如果和下图差不多证明安装成功。

![安装 ruby 成功](https://user-gold-cdn.xitu.io/2019/3/28/169c2b195aba267b?w=1542&h=204&f=jpeg&s=66085)

### 安装 Travis 客户端

执行下面的命令以安装 Travis 客户端。

```
$ gem install travis
```

安装完成后执行 `travis`，它会让你安装相应的 Shell, 输入 yes 即可。

![安装 shell](https://user-gold-cdn.xitu.io/2019/3/28/169c2b198fe3978b?w=1692&h=642&f=jpeg&s=161260)

### 配置免密登录

将你的工程克隆下来，并进入到工程目录，然后登录你的 GitHub 账号。

```
$ travis login --auto
```

![登录 GitHub](https://user-gold-cdn.xitu.io/2019/3/28/169c2b198fdfadaa?w=1840&h=404&f=jpeg&s=124861)

执行下面这句，它会利用服务器的私钥加密成一个叫做 `id_rsa.enc` 的文件，这个文件被用于 travis 登录你服务器的凭证，从而达到免密的目的。

```
$ travis encrypt-file ~/.ssh/id_rsa --add
```

![生成 id_rsa.enc 文件](https://user-gold-cdn.xitu.io/2019/3/28/169c2b199025a5e3?w=1682&h=364&f=jpeg&s=140289)

我们执行一下 `ll`，可以看到根目录下多出一个 `id_rsa.enc` 文件来，并且 `cat .travis.yml`，发现多出了 `before_install`.

为了更好地组织代码，我们在项目的根目录新建一个文件夹 `.travis`，然后将 `id_rsa.enc` 放到里面。

![添加了 before_install 钩子](https://user-gold-cdn.xitu.io/2019/3/28/169c2b19903f3f77?w=1720&h=760&f=jpeg&s=145700)

### 配置 after_success 钩子

在写这一小节之前，我们先看一看 Travis 的生命周期：

1. before_install 安装依赖前
2. install 安装依赖时
3. before_script 执行脚本前
4. script 执行脚本时
5. after_success 或 after_failure 执行脚本成功（失败）后
6. before_deploy 部署前
7. deploy 部署时
8. after_deploy 部署后
9. after_script 执行脚本后

因此 `after_success` 可用在成功通过测试脚本之后执行部署相关的脚本。当然细一点可以使用 deploy 相关的钩子，这里不做太复杂。

打开 `.travis.yml`文件，直接上全部代码。

```yml
language: node_js
sudo: true
node_js:
  - 8
branchs:
  only:
    - master
# 这里填写服务器的ip，若端口号不是22，后面要注明端口号
addons:
  ssh_known_hosts:
    - 你的服务器IP
cache:
  directories:
    - node_modules
before_install:
  # 因为我们把 id_rsa.enc 移到了.travis 文件夹下，所以 -in 后面要改成 .travis/id_rsa.enc
  # 其次，-out 后面自动生成的是 ~\/.ssh/id_rsa，要把 \ 去掉，否则会编译失败
  - openssl aes-256-cbc -K $encrypted_XXXXXXXXXXXX_key -iv $encrypted_XXXXXXXXXXXX_iv -in .travis/id_rsa.enc -out ~/.ssh/id_rsa -d
  # 开启 ssh-agent，即允许使用 ssh 命令
  - eval ""$(ssh-agent -s)""
  # 给予 id_rsa 文件权限，避免警告
  - chmod 600 ~/.ssh/id_rsa
  # 将私钥添加到 ssh
  - ssh-add ~/.ssh/id_rsa
install:
  - yarn install
scripts:
  - yarn test
  - yarn build
after_success:
  # 登录服务器，执行部署脚本，其实最好把后面一串写成 shell 文件
  - ssh caddy@你的服务器IP -o StrictHostKeyChecking=no 'cd /var/www/jsapi/JavaScript-APIs-Set && git pull && yarn install && yarn build'
```

## 走一遍正式的流程

至此，搭建 Travis CI 持续集成和自动化部署就算完成了，可能不太严谨，但基本是这么一个思路。下面我们梳理一遍流程。

1. 我们先在 feature/ci 分支修改一段代码，提交分支，并 PR 到 develop，此时会运行两个 CI。当两个 CI 都跑通了，我们可以放心的 merge request 到 develop 分支。

2. 接下来让 develop PR 到 master，此时会运行两个 CI（一个是 develop 分支，一个是测试合并到 master 的 CI）。当两个 CI 都跑通了，我们可以放心的 merge request 到 master 分支。

3. merge request 之后会跑最后一个流程, 也就是自动部署，部署成功后线上代码就会更新了。

## 加入徽章

别忘了把 build passing 徽章添加到你的 README.md 文件中。

![badge](https://user-gold-cdn.xitu.io/2019/3/28/169c2b19aae7b810?w=652&h=306&f=jpeg&s=27223)

## 最后

不知道你有没有发现，Travis CI 支持 LGBT...

![LGBT](https://user-gold-cdn.xitu.io/2019/3/28/169c2b19ac17acc7?w=1308&h=210&f=jpeg&s=25865)

以上、よろしく。

## 参考

[How to Encrypt/Decrypt SSH Keys for Deployment](https://github.com/dwyl/learn-travis/blob/master/encrypted-ssh-keys-deployment.md#6-test-it-on-travis-ci)

[Travis-CI 自动化测试并部署至自己的 CentOS 服务器](https://juejin.im/post/5a9e1a5751882555712bd8e1#heading-9)

[CentOS 7 使用 rvm 安装 ruby 搭建 jekyll 环境](https://qizhanming.com/blog/2017/05/31/install-rvm-and-ruby-buid-jeklly-env-on-centos-7)
","2025-02-02 03:08:02.966209","2025-02-02 03:08:02.966209"
"1a6b343d-7d16-4dea-8fa7-d9a7d85dbd1e","{Poem}",0,0,False,"https://edge.yancey.app/beg/68747470733a2f2f79616e6365792d6173736574732e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f62646464643265642d383435652d343730652d623666662d6538383864353636633461352e6a7067.jpeg","离殇赋","木槿萦窗，蔚为离殇。","近平貳年，歲在甲午。三月初霽，青雲裊裊，繚若流蘇。乍暖還寒時節，最是無言。

念今昔。浮生若夢，韶華易逝流光淺。鉛華未盡，不覺期已翩然。如花美眷，那堪似水流年。愴然，昨夜猶寄忘川也，愀無眠。仰宇宙之冷月，夕夕成玦；撫殘木之紋理，遙以千年。吾喟然，何之以暫？妄故心之未央，然荒蕪一片，徒有悲添。

曰：“曼珠沙華，渺渺瘖啞；曼陀羅華，杳杳無涯。花開葉落，剎那輕擦，不為來世，只為她。” 嗚呼！悲未至兮，唾之渣渣;悲之來兮，唏以無瑕。

噫！ 木槿縈窗， 蔚為離殤。","2025-02-02 03:08:05.65758","2025-02-02 03:08:05.65758"
"9753229e-5b74-4667-ab2f-5e041af49c14","{Poem}",0,0,False,"https://edge.yancey.app/beg/68747470733a2f2f79616e6365792d6173736574732e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f36616137636231352d636633302d346433302d616262322d6339343936383539396630392e6a7067.jpeg","千世喑哑","我曾经所憎恶的，这些年都没在变，可能这一生也不会变...","五、六个月，Y 重复着从家到学校，从学校到家的单调旅程。出家门，西走十步，北转，十几株乱竹赫然斜插在石子路的两旁，奄奄一息，倾向大地。叶上依稀可见昨夜红雨的痕迹，给这寂静又平添几番寂静。透过叶子的晨光在地上映出一片斑驳，像过往的烟花，转瞬而已。Y 还没来得及惋惜，踏着泥泞，便匆匆而去。

如此反复着，一排排新建的政府大楼极力吸允着钢筋水泥的快感，惶恐留给其他地方见到阳光的余地，而阻碍了自己得天独厚的享受。Y 喜欢下雨，藉着风雨雷电，不管它是否洗尽了铅华，但总能带来江南烟雨抑或决战沙场的想象空间，进而付诸笔墨，自娱自乐。但 Y 似乎是太疲倦了，一天不足 7 小时的睡眠，昨夜竟睡得很甜蜜。路上人很少，也许时间还太早。几棵行道树仄歪在路中央，凌乱的叶子和贞操一样，散落一地，可谓是毕恭毕敬一世，终不过一抔土灰；机关算尽，终不过一败涂地。正要绕过树，霎那间，Y 灵光一现，随口脱出一句“倏然雨下，一夜谢了梨花，花~~ 啪的一声，人随车飞了出去……Y 痛苦的揉着屁股，不服的骂这该死的树，但心里还是很爽。这树对 Y 来说俨然成了一种新意：沿着这条街走了两年多，街边的建筑，那条狗，除了人，都是老样子，视觉上的厌恶感早已变得索然无味。”毁灭偶尔也是创意嘛“，Y 想。随即车速也放慢了许多，盘算着：“往下该怎么写？闺怨？反战？曲风？调式？……”恍惚间，才发现迟到，狂奔，最终逃不过迟到，罚站，怆然！

可怜巴巴的假期打乱了 Y 所有的计划，本打算晚起早睡，练练琴唱唱歌，补补身子，以备高三的摧残。各种应该被和谐的事儿占据着白天，所以与拜厄、哈农、车尔尼等人搞基的工作只好安排到了晚上了。这样，除了去学校的那条路，Y 已全然不知小城的新面貌了。

Y 突然想出去转转，不带什么目的，只是感觉若有所失而已。虽然音乐就是个大世界，但还是应该去现实中走走，纵使污秽。

天黑，看不清竹子，但在瑟瑟的晚风下显得格外喑哑。愈来愈靠近小城中心，劣质音响发出的 DJ 伴着“刺刺”的电流声刺痛着双耳，各处灯红酒绿，哭闹声，叫卖声，汽车的鸣笛声，总是找不到耳机里的纯洁与安宁。灯光比起郊区亮起了好多倍，橱窗里的模特被照的发腻起来，霓虹灯刺的 Y 迷失了方向，茫茫人海中，Y 感觉到自己的渺小。半年前的地基如今成了高楼，摇摇欲坠，好像血盆大口欲要吞噬着万物生灵。Y 感觉大地在颤动，高楼在向自己方向倾倒，各种不详的灯光打在自己的身上，人也愤然靠近……Y 害怕了，耳边反复环绕起村上村树的话：死并非生的对立面，而作为生的一部分永存。他真的恐惧了，他想躲避，他想躲避那些所谓“变态”的嘴脸，而闪躲不及则让他愈加的害怕，他四处奔逃，想找个安全的地方躲起来，但这浮世，没有什么神奇的玩意儿让他瞬间走脱……终于，Y 跌跌撞撞跑向他喑哑的家。路人纷纷惊奇的看着这小丑般的家伙灰溜溜的逃走，甚至都没有拿出手机微博来找乐子，只是不久，大家又开始享受自己的美好时光……

眼前昏暗的灯光苟且让他平复了心情，只是双手还在颤抖，惊心动魄，心有余悸。于是，Y 用被子蒙着头，长舒一口气，很快进入了梦乡……

居于都市，却与城市脱节了这么久， 换谁都会彷徨。泯灭人性的生活定势，不知谁将苦苦在都市的一隅埋葬。

风吹竹叶，依然喑哑，只是上面溅满了无奈的泪花，它知道 Y 不再来赏。因为 Y，则继续着他空虚的千世喑哑……
","2025-02-02 03:08:06.461557","2025-02-02 03:08:06.461557"
"5d7e7742-6ab8-4dc3-9ec6-6f6d99b0e73e","{Poem,Music}",0,0,False,"https://edge.yancey.app/beg/68747470733a2f2f79616e6365792d6173736574732e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f78313038302d4b6e612e6a7067.jpeg","なごり雪","而現在春天來了，妳變得美麗了，比去年更加美麗了。","初聞此曲是在前年的冬天，曾經為了一首歌買下了德永英明桑的專輯「ALL TIME BEST」，然而最先學會的卻是這首。

詞曲是由「かぐや姫」樂團中的伊勢正三創作，收錄於他們 1974 年發行的專輯「三階建の詩」裡，卻在隔年由女歌手イルカ做為單曲發行而在全日本走紅。

1997 年 4 月～ 12 月，日本 NHK 以「二十世紀感動全日本的歌曲」展開全國投票調查，每人最多投 3 票。隔年 1 月 19 日發表的百大歌曲中，イルカ唱的「なごり雪」是第 60 名。

2002 年，導演大林宣彥以「なごり雪」歌詞為基礎發展了一段感人故事，拍攝了一部同名電影來詮釋自己對這首歌的想像。

昭和 49 年的歌啊，即便現在聽起來都恍如昨日。

新年號發表了，「令和」。

平成也将要結束了。

平井一夫宣布在 6 月 18 日退休，誰來守護“後姨夫”時代的微笑呢？

春秋織序、時序荏苒。

汽車を待つ君の横で僕は

在一旁陪著妳等候火車

時計を気にしてる

我正注意著時間

季節はずれの雪が降ってる

不合時節的雪正悄然落下

「東京で見る雪はこれが最後ね」と

「這是最後一次在東京看到雪了吧」

さみしそうに君はつぶやく

妳傷感地喃喃說著

なごり雪も降るときを知り

未消溶的雪也開玩笑地

ふざけすぎた季節のあとで

知道飄落之時 在季節過後

今 春が来て 君はきれいになった

而現在春天來了 妳變得美麗了

去年よりずっときれいになった

比去年更加美麗了

動き始めた汽車の窓に 顔をつけて

臉頰貼在已開動的火車窗上

君は何か言おうとしている

妳好像將要說些什麼

君の口びるが「さようなら」と動くことが

妳振動的唇似是說著「再見」 我卻只是害怕地低著頭

時が行けば 幼ない君も

即使時間飛逝的話 年幼的妳

大人になると気づかないまま

也如此沒發覺自己已經長大了吧

今 春が来て 君はきれいになった

而現在春天來了 妳變得美麗了

去年よりずっときれいになった

比去年更加美麗了

君が去った ホームにのこり

留在妳離去的月台

落ちてはとける雪を見ていた

正看著飄落後即融化的雪

今 春が来て 君はきれいになった

而現在春天來了 妳變得美麗了

去年よりずっときれいになった

比去年更加美麗了

去年よりずっときれいになった

比去年更加美麗了

去年よりずっときれいになった

比去年更加美麗了

","2025-02-02 03:08:07.612391","2025-02-02 03:08:07.612391"
"4654f555-3888-4bfb-8bfa-8951000027e2","{HTTP}",0,0,False,"https://edge.yancey.app/beg/exi1dkl8-1649091480077.jpg","[HTTP 系列]  第 1 篇 —— 从 TCP/UDP 到 DNS 解析","这里是《写给前端工程师的 HTTP 系列》，记得有位大佬曾经说过：“大厂前端面试对 HTTP 的要求比 CSS 还要高”，由此可见 HTTP 的重要程度不可小视。文章写作计划如下，视情况可能有一定的删减，本篇是该系列的第 1 篇 —— 《从 TCP/UDP 到 DNS 解析》。","- [\[HTTP 系列\] 第 1 篇 —— 从 TCP/UDP 到 DNS 解析](https://www.yanceyleo.com/post/3a9d3d47-9977-4579-a756-4bf5af4a3fd4)
- [\[HTTP 系列\] 第 2 篇 —— HTTP 协议那些事](https://www.yanceyleo.com/post/efd566e9-4ee3-4ee2-8448-628414659480)
- [\[HTTP 系列\] 第 3 篇 —— HTTP 缓存那些事](https://www.yanceyleo.com/post/89731d8e-5510-4094-8962-462b127ed5d0)
- [\[HTTP 系列\] 第 4 篇 —— HTTPS](https://www.yanceyleo.com/post/f976717f-9e40-4849-a73f-86c63c0c45e1)
- [\[HTTP 系列\] 第 5 篇 —— 网络安全](https://www.yanceyleo.com/post/953ccf20-7f3b-4d3f-816e-b6e98b26a4da)
- [\[HTTP 系列\] 第 6 篇 —— 从输入 URL 回车到页面呈现](https://www.yanceyleo.com/post/05daeef2-2caf-4ebe-89f0-2ad9cae286c4)

## TCP/IP 通信传输流

### TCP/IP 五层协议

在讲解 TCP/IP 通信传输流之前, 首先复习一下 TCP/IP 的五层协议.

**应用层**: 决定向用户提供应用服务时通信的活动. TCP/IP 协议族内预存了各类通用的应用服务. 比如: FTP, DNS, HTTP 协议.

**传输层**: 传输层对上层应用层, 提供处于网络连接中的两台计算机之间的数据传输. 在传输层有两个性质不同的协议, 分别是 TCP (Transmission Control Protocol, 传输控制协议) 和 UDP (User Data Protocol, 用户数据报协议)

**网络层**: 网络层用来处理在网络上流动的数据包. 数据包是网络传输的最小数据单位. 该层规定了通过怎样的路径到达对方计算机, 并把数据包传送给对方. 与对方计算机通过多台计算机或网络设备进行传输时, 网络层所起的作用就是在众多的选项内选择一条传输路线.

**数据链路层**: 在物理层提供比特流服务的基础上, 建立相邻结点之间的数据链路, 通过差错控制提供数据帧 (Frame)在信道上无差错的传输, 并进行各电路上的动作系列. 数据的单位称为帧 (frame)

**物理层**: 物理层建立在物理通信介质的基础上, 作为系统和通信介质的接口, 用来实现数据链路实体间透明的比特 (bit) 流传输. 只有该层为真实物理通信, 其它各层为虚拟通信.

### TCP/IP 数据传输流程

IP 协议是**Internet Protocol**的缩写, 主要目的是解决寻址和路由问题, 以及如何在两点间传送数据包. TCP 协议是**Transmission Control Protocol**的缩写, 意思是**传输控制协议**, 它位于 IP 协议之上, 基于 IP 协议提供可靠的, 字节流形式的通信, 是 HTTP 协议得以实现的基础. **可靠**是指保证数据不丢失, **字节流**是指保证数据完整, 所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据, 就像是读写在一个密闭的管道里**流动**的字节.

客户端在应用层 (HTTP 协议) 发出一个 HTTP 请求. 为了方便传输, 在传输层 (TCP 协议) 把从应用层处收到的数据 (HTTP 请求报文) 进行分割, 并在各个报文上打上标记序号及端口号后转发给网络层. 在网络层 (IP 协议), 增加作为通信目的地的 MAC 地址后转发给数据链路层. 这样, 发送给服务端的请求就准备齐全了. 当服务端在链路层接收到数据时, 按序往上层发送, 一直到应用层. **当传输到应用层时, 才算真正的接收到由客户端发送过来的请求**.

你可以把 HTTP 利用 TCP/IP 协议栈传输数据想象成一个发快递的过程.

假设你想把一件毛绒玩具送给朋友, 但你要先拿个塑料袋套一下, 这件玩具就相当于 HTTP 协议里要传输的内容, 比如 HTML, 然后 HTTP 协议为它加一个 HTTP 专用附加数据.

你把玩具交给快递小哥, 为了保护货物, 他又加了层包装再贴了个标签, 相当于在 TCP 层给数据再次打包, 加上了 TCP 头.

接着快递小哥下楼, 把包裹放进了三轮车里, 运到集散点, 然后再装进更大的卡车里, 相当于在 IP 层, MAC 层对 TCP 数据包加上了 IP 头, MAC 头.

之后经过漫长的运输, 包裹到达目的地, 要卸货再放进另一位快递员的三轮车, 就是在 IP 层, MAC 层传输后拆包.

快递员到了你朋友的家门口, 撕掉标签, 去除了 TCP 层的头, 你朋友再拆掉塑料袋包装, 也就是 HTTP 头, 最后就拿到了玩具, 也就是真正的 HTML 页面.

![TCP/IP 传输](https://edge.yancey.app/beg/Jietu20190422-142841%402x.jpg)

### TCP/IP 网络分层模型和 OSI 网络分层模型

对于 TCP/IP 网络分层模型和 OSI 网络分层模型, 以及它俩的对应关系如下图所示: 由于 OSI 的分层模型在四层以上分的太细, 而 TCP/IP 实际应用时的会话管理, 编码转换, 压缩等和具体应用经常联系的很紧密, 很难分开. 所谓的四层负载均衡就是指工作在传输层上, 基于 TCP/IP 协议的特性, 例如 IP 地址, 端口号等实现对后端服务器的负载均衡. 所谓的七层负载均衡就是指工作在应用层上, 看到的是 HTTP 协议, 解析 HTTP 报文里的 URI, 主机名, 资源类型等数据, 再用适当的策略转发给后端服务器.

![TCP/IP 网络分层模型和 OSI 网络分层模型](https://edge.yancey.app/beg/yr22v7wu-1646658092682.webp)

对于 TCP/IP 网络分层模型:

第一层叫**链接层**(link layer), 负责在以太网, WiFi 这样的底层网络上发送原始数据包, 工作在网卡这个层次, 使用 MAC 地址来标记网络上的设备, 所以有时候也叫 MAC 层.

第二层叫**网际层**或者**网络互连层**(internet layer), IP 协议就处在这一层. 因为 IP 协议定义了**IP 地址**的概念, 所以就可以在**链接层**的基础上, 用 IP 地址取代 MAC 地址, 把许许多多的局域网, 广域网连接成一个虚拟的巨大网络, 在这个网络里找设备时只要把 IP 地址再**翻译**成 MAC 地址就可以了.

第三层叫**传输层**(transport layer), 这个层次协议的职责是保证数据在 IP 地址标记的两点之间**可靠**地传输, 是 TCP 协议工作的层次, 另外还有它的一个**小伙伴**UDP. TCP 是一个有状态的协议, 需要先与对方建立连接然后才能发送数据, 而且保证数据不丢失不重复. 而 UDP 则比较简单, 它无状态, 不用事先建立连接就可以任意发送数据, 但不保证数据一定会发到对方. 两个协议的另一个重要区别在于数据的形式. TCP 的数据是连续的**字节流**, 有先后顺序, 而 UDP 则是分散的小数据包, 是顺序发, 乱序收.

协议栈的第四层叫**应用层**(application layer), 由于下面的三层把基础打得非常好, 所以在这一层就**百花齐放**了, 有各种面向具体应用的协议. 例如 Telnet, SSH, FTP, SMTP 等等, 当然还有我们的 HTTP.

MAC 层的传输单位是帧(frame), IP 层的传输单位是包(packet), TCP 层的传输单位是段(segment), HTTP 的传输单位则是消息或报文(message). 但这些名词并没有什么本质的区分, 可以统称为数据包.

对于 OSI 网络分层模型, OSI 全称是开放式系统互联通信参考模型(Open System Interconnection Reference Model).

- 第一层: 物理层, 网络的物理形式, 例如电缆, 光纤, 网卡, 集线器等等;
- 第二层: 数据链路层, 它基本相当于 TCP/IP 的链接层;
- 第三层: 网络层, 相当于 TCP/IP 里的网际层;
- 第四层: 传输层, 相当于 TCP/IP 里的传输层;
- 第五层: 会话层, 维护网络中的连接状态, 即保持会话和同步;
- 第六层: 表示层, 把数据转换为合适, 可理解的语法和语义;
- 第七层: 应用层, 面向具体的应用传输数据.

## 扩展: 二层转发和三层路由

二层转发: 设备工作在链路层, 帧在经过交换机设备时, 检查帧的头部信息, 拿到目标 mac 地址, 进行本地转发和广播.

三层路由: 设备工作在 ip 层, 报文经过有路由功能的设备时, 设备分析报文中的头部信息, 拿到 ip 地址, 根据网段范围, 进行本地转发或选择下一个网关.

## DNS

在 TCP/IP 协议中使用 IP 地址来标识计算机, 数字形式的地址对于计算机来说是方便了, 但对于人类来说却既难以记忆又难以输入. 于是**域名系统**(Domain Name System)出现了, 用有意义的名字来作为 IP 地址的等价替代. 在 DNS 中, **域名**(Domain Name)又称为**主机名**(Host).

### DNS 报文格式

请求报文和 DNS 服务器返回的应答报文都是统一的格式:

![dns-protocol-format.png](https://edge.yancey.app/beg/dns-protocol-format.png)

- **会话标识 (2 字节)**: 它是 DNS 报文的 ID 标识, 对于请求报文和其对应的应答报文, 这个字段是相同的, 通过它可以区分 DNS 应答报文是哪个请求的响应.

- **标志 (2 字节)**: 它有 8 个部分, 如下图所示:

  ![dns-header-flags.png](https://edge.yancey.app/beg/dns-header-flags.png)

  | 字段          | 说明                                                                                                                              |
  | ------------- | --------------------------------------------------------------------------------------------------------------------------------- |
  | QR (1bit)     | 查询/响应标志, 0 为查询报文, 1 为响应报文                                                                                         |
  | opcode (4bit) | 0 表示标准查询, 1 表示反向查询, 2 表示服务器状态请求, 3-15 是保留值                                                               |
  | AA (1bit)     | 表示授权回答, 该字段在应答的时候才有意义, 指出给出应答的服务器是查询域名的授权解析服务器;                                         |
  | TC (1bit)     | 表示可截断的, 用来指出报文比允许的长度还要长, 导致被截断                                                                          |
  | RD (1bit)     | 表示期望递归, 该字段被请求设置, 应答的时候使用的相同的值返回. 如果设置了 RD, 就建议域名服务器进行递归解析, 递归查询的支持是可选的 |
  | RA (1bit)     | 表示可用递归, 该字段在应答中设置或取消, 用来代表服务器是否支持递归查询                                                            |
  | RCODE (4bit)  | 应答码, 0 表示没有差错, 3 表示名字差错, 2 表示服务器错误                                                                          |
  | Z             | 保留值                                                                                                                            |

- Questions 查询字段

  - **QNAME** 无符号 8bit 为单位长度不限表示查询名.

  - **QTYPE** 无符号 16bit 整数表示查询的协议类型.

  - **QCLASS** 无符号 16bit 整数表示查询的类.

- Answer/Authority/Additional

  三者的格式相同, 如下所示:

  - **NAME** 资源记录包含的域名.

  - **TYPE** 表示 DNS 协议的类型.

  - **CLASS** 表示 RDATA 的类.

  - **TTL** 表示资源记录可以缓存的时间. 0 代表只能被传输, 但是不能被缓存.

  - **RDLENGTH** 表示 RDATA 的长度.

  - **RDATA** 不定长字符串来表示记录, 格式根 TYPE 和 CLASS 有关. 比如, TYPE 是 A, CLASS 是 IN, 那么 RDATA 就是一个 4 个字节的 ARPA 网络地址.

### DNS 解析记录

折腾过搭建网站的小伙伴们一定对 DNS 解析记录不会陌生, 下面通过表格复习一下.

| 类型 | 助记词 | 说明                        |
| ---- | ------ | --------------------------- |
| 1    | A      | 由域名获得 IPv4 地址 (常用) |
| 2    | NS     | 查询域名服务器 (常用)       |
| 5    | CNAME  | 设置域名别名 (常用)         |
| 6    | SOA    | 开始授权                    |
| 11   | WKS    | 熟知服务                    |
| 12   | PTR    | 把 IP 地址转换成域名        |
| 13   | HINFO  | 主机信息                    |
| 15   | MX     | 邮件交换 (常用)             |
| 28   | AAAA   | 由域名获得 IPv6 地址 (常用) |
| 252  | AXFR   | 传送整个区的请求            |
| 255  | ANY    | 对所用记录的请求            |

### 域名解析过程

- 系统会检查浏览器缓存中有没有这个域名对应的解析过的 IP 地址, 如果缓存中有, 这个解析过程就将结束. 浏览器缓存是受这个域名的失效时间和缓存的空间大小控制的.

- 如果用户的浏览器缓存中没有, 浏览器会查找操作系统缓存中即为本地的 Host 文件.

- 路由器也可能会有缓存.

- 如果前几步都没有找到, 就会到运营商 LDNS (Local DNS) 中查找, 大部分情况下域名都会在这里得到解析.

- 如果在 LDNS 没有找到, 那就要去 Root Server 域名服务器请求解析了. 根域名服务器返回给本地域名服务器一个 `查询主域名服务器(gTLD Server)地址`. gTLD 是国际顶级域名服务器, 如.com, .cn, .org 等, 全球只有 13 台左右.

- 本地域名服务器会向 gTLD Server 地址发送请求, 它会返回一个 Name Server(又叫 Top-level DNS, 顶级域名服务器) 域名服务器的地址, 这个 Name Server 通常就是你注册域名的厂家, 比如 NameCheap, 狗爹, 万网等等.

- Name Server 域名服务器会查询存储域名和 IP 的关系映射表, 正常情况下都可以根据域名得到目标 IP 记录, 并连同一个 TTL 返回给本地域名服务器.

- 本地域名服务器根据 TTL 缓存这个 IP, 并将解析结果返回给客户端, 客户端再根据 TTL 将 IP 信息缓存到本地系统缓存里. 至此, 域名解析过程结束.

![域名解析过程](https://edge.yancey.app/beg/faff9bb6a46a8114d87de846342e3e9c.jpg)

上面说到 Root DNS Server 只有 13 台左右, 为了防止拥挤就有了各种缓存策略, 比如域名厂商都有自己的 DNS 解析服务器, 作为用户 DNS 查询的代理, 代替用户访问核心 DNS 系统, 这称为**非权威域名服务器**. 比较知名有 Google 的 `8.8.8.8`, CloudFare 的 `1.1.1.1` 等等. 当然上面也写到了浏览器, Host, 甚至路由器都会有缓存策略.

### 基于域名系统的负载均衡

第一种方式, 因为域名解析可以返回多个 IP 地址, 所以一个域名可以对应多台主机, 客户端收到多个 IP 地址后, 就可以自己使用轮询算法依次向服务器发起请求, 实现负载均衡.

第二种方式, 域名解析可以配置内部的策略, 返回离客户端最近的主机, 或者返回当前服务质量最好的主机, 这样在 DNS 端把请求分发到不同的服务器, 实现负载均衡.

## 区分 URI 和 URL

有了 TCP/IP 协议和 DNS 协议, 我们可以定位到一台主机, 但只定位到主机还没完, 需要定位到主机具体的资源才行. 所以就出现了 URI(Uniform Resource Identifier), 中文名称是统一资源标识符, 使用它就能够唯一地标记互联网上资源, 由**协议名 + 主机名 + 路径**构成. URI 另一个更常用的表现形式是 URL(Uniform Resource Locator), 统一资源定位符, 也就是我们俗称的**网址**, 它实际上是 URI 的一个子集.

URI 不完全等同于网址, 它包含有 URL 和 URN 两个部分, 在 HTTP 世界里用的网址实际上是 URL——统一资源定位符(Uniform Resource Locator).

### 多说一点 URI

如下图片是完整的 URI 元素, 分别由协议名, 身份信息, 主机, 端口, 路径, 查询参数, 片段标识符构成.

![URI 的完整格式](https://edge.yancey.app/beg/ep0ihyd9-1646738692748.webp)

此外, URI 中只可以使用 ASCII 码, 对于其他字符会被转义, 具体操作就是直接把非 ASCII 码或特殊字符转换成十六进制字节值, 然后前面再加上一个 `%`.

## 什么是 MAC 地址?

媒体访问控制地址 (Media Access Control Address), 也称为局域网地址
(LAN Address), 以太网地址 (Ethernet Address) 或物理地址 (Physical Address), 它是一个用来确认网上设备位置的地址. ARP (Address Resolution Protocol) 是一种用来解析地址的协议, 它可以根据 IP 地址反查出对应的 MAC 地址.

下图展示了一台电脑内网 IP 和 MAC 地址. 在终端 (MAC OS 环境) 输入 `ifconfig`, 找到 `en0`, 便可查找本地以太网的信息.

![内网IP / MAC地址](https://edge.yancey.app/beg/t3m4u7g7-1648001081671.jpg)

那么什么是 MAC 地址呢? 我们知道 IP 地址是可变的, 可以通过各种方式分配 IP 地址给一个设备, 比如 DHCP, PPP, 静态 IP 等. 而 MAC 地址一般来讲是不会变的, 设备在生产时就被**烙**上了 `唯一的标识`, 这个 `唯一的标识` 就是 MAC 地址.

逼乎上有个很有趣的例子: 你中午在公司点了份外卖, 收货地址一定是写公司的地址; 晚上回到家, 再点外卖时就得把地址写成家 (IP 是动态的). 但无论在哪儿点外卖, 订单上的姓名和手机号一定是你自己的 (MAC 地址).

中午外卖小哥把午餐送到公司门口, 但收外卖的人肯定不止你一个 (多台设备在同一个 broadcast 网络里), 因此他会通过手机号和姓名来找到你.

## UDP 协议

用户数据报协议 (User Datagram Protocol), 又称使用者资料包协议, 是一个简单的面向数据报的传输协议. 在 TCP/IP 模型中, UDP 为网络层以上和应用层以下提供了一个简单的接口. UDP 只提供数据的 `不可靠传递`, 它一旦把应用程序发给网络层的数据发送出去, 就不保留数据备份. UDP 在 IP 数据报的头部仅仅加入了复用和数据校验 (字段).

它的特点如下:

- UDP 缺乏可靠性. UDP 本身不提供确认序号, 序列号, 超时重传等机制. UDP 数据报可能在网络中被复制, 被重新排序. 即 UDP 不保证数据报会到达其最终目的地, 也不保证各个数据报的先后顺序, 也不保证每个数据报只到达一次.

- UDP 头部开销小, 它包含以下几个数据:

  - 两个十六位的端口号, 分别是源端口和目的端口.

  - 整个数据报文的长度.

  - 整个数据报文的校验和, 用于发现头部信息和数据中的错误

- UDP 是面向无连接的. UDP 客户端和服务器之前不必存在长期的关系. UDP 发送数据报之前也不需要经过握手创建连接的过程.

- UDP 不仅支持单播, 还支持多播和广播.

![UDP 头部](https://edge.yancey.app/beg/9dtjgkil-1648001170483.jpeg)

基于 UDP 协议的有:

- 域名系统 (DNS)

- 简单网络管理协议 (SNMP)

- 动态主机配置协议 (DHCP)

- 路由信息协议 (RIP)

- 自举协议 (BOOTP)

- 简单文件传输协议 (TFTP)

## TCP 协议

TCP (Transmission Control Protocol, 传输控制协议) 是一种面向连接的, 可靠的, 基于字节流服务的传输层通信协议, 由 IETF 的 RFC 793 定义. 其中字节流服务 (Byte Stream Service) 是指为了方便传输, 将大块数据分割成以报文段 (segment) 为单位的数据包进行管理.

- TCP 提供一种面向连接的, 可靠的字节流服务

- 在一个 TCP 连接中, 仅有两方进行彼此通信. 广播和多播不能用于 TCP

- TCP 使用校验和, 确认和重传机制来保证可靠传输

- TCP 给数据分节进行排序, 并使用累积确认保证数据的顺序不变和非重复

- TCP 使用滑动窗口机制来实现流量控制, 通过动态改变窗口的大小进行拥塞控制

### TCP 报文

![TCP 报文](https://edge.yancey.app/beg/20170227111849763-0000.jpg)

**端口号**: 包括源端口号和目的端口号, 用来标识同一台计算机的不同的应用进程. TCP 报头中的源端口号和目的端口号同 IP 数据报中的源 IP 与目的 IP 唯一确定一条 TCP 连接.

- **源端口号**: 源端口和 IP 地址的作用是标识报文的返回地址.

- **目的端口号**: 目的端口指明接收方计算机上的应用程序接口.

**序号**: 它是当前报文段发送的数据组的第一个字节的序号. 在 TCP 传送的流中, 每一个字节一个序号. 比如一个报文段的序号为 300, 此报文段的数据部分共有 100 字节, 则下一个报文段的序号为 400. **序号** 确保了 TCP 传输的有序性.

**确认号**: 即 ACK(acknowledgement), 指明下一个期待收到的字节序号, 表明该序号之前的所有数据已经正确无误的收到. 确认号只有当 ACK 标志为 1 时才有效. 比如建立连接时, SYN 报文的 ACK 标志位为 0.

**首部长度**: 由于首部可能含有可选项内容, 因此 TCP 报头的长度是不确定的, 报头不包含任何任选字段则长度为 20 字节, 4 位首部长度字段所能表示的最大值为 1111, 转化为 10 进制为 15, 15\*32/8 = 60, **故报头最大长度为 60 字节**. 首部长度也叫数据偏移, 是因为首部长度实际上指示了数据区在报文段中的起始偏移值.

**保留**: 为将来定义新的用途保留, 现在一般置 0.

| 控制位                | 说明                                                                                                                                  |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| URG                   | 紧急指针标志, 为 1 时表示紧急指针有效, 为 0 则忽略紧急指针.                                                                           |
| ACK (acknowledgement) | 确认序号标志, 为 1 时表示确认号有效, 为 0 表示报文中不含确认信息, 忽略确认号字段.                                                     |
| PSH                   | push 标志, 为 1 表示是带有 push 标志的数据, 指示接收方在接收到该报文段以后, 应尽快将这个报文段交给应用程序, 而不是在缓冲区排队.       |
| RST                   | 重置连接标志, 用于重置由于主机崩溃或其他原因而出现错误的连接. 或者用于拒绝非法的报文段和拒绝连接请求.                                 |
| SYN (synchronize)     | 同步序号, 用于建立连接过程, 在连接请求中, SYN=1 和 ACK=0 表示该数据段没有使用捎带的确认域, 而连接应答捎带一个确认, 即 SYN=1 和 ACK=1. |
| FIN (Finish)          | finish 标志, 用于释放连接, 为 1 时表示发送方已经没有数据发送了, 即关闭本方数据流.                                                     |

**窗口**: 滑动窗口大小, 用来告知发送端接受端的缓存大小, 以此控制发送端发送数据的速率, 从而达到流量控制. 窗口大小是一个 16bit 字段, 因此窗口大小最大为 65535.

**校验和**: 奇偶校验, 此校验和是对整个的 TCP 报文段, 包括 TCP 头部和 TCP 数据, 以 16 位字进行计算所得. 由发送端计算和存储, 并由接收端进行验证.

**紧急指针**: 只有当 URG 标志置 1 时紧急指针才有效. 紧急指针是一个正的偏移量, 和顺序号字段中的值相加表示紧急数据最后一个字节的序号. TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式.

**选项和填充**: 最常见的可选字段是最长报文大小, 又称为 MSS (Maximum Segment Size), 每个连接方通常都在通信的第一个报文段 (为建立连接而设置 SYN 标志为 1 的那个段)中指明这个选项, 它表示本端所能接受的最大报文段的长度. 选项长度不一定是 32 位的整数倍, 所以要加填充位, 即在这个字段中加入额外的零, 以保证 TCP 头是 32 的整数倍.

**数据部分**: TCP 报文段中的数据部分是可选的. 在一个连接建立和一个连接终止时, 双方交换的报文段仅有 TCP 首部. 如果一方没有数据要发送, 也使用没有任何数据的首部来确认收到的数据. 在处理超时的许多情况中, 也会发送不带任何数据的报文段.

### TCP 建立连接 (三次握手)

所谓三次握手 (three-way handshaking) 是指建立一个 TCP 连接时, 需要客户端和服务端共发送三个包. 它的目的是连接服务器指定端口, 建立 TCP 连接, 并同步双方的 `序列号` 和 `确认号`, 交换 TCP 窗口大小信息. 在 socket 编程中, 当客户端执行 connect() 函数时, 将触发三次握手.

- 第一次握手

  客户端首先发送一个 SYN 为 1 的包给服务端, 指明客户端要连接服务端的哪个接口以及初始序号 x. 发送完毕后, 客户端进入 `SYN_SEND` 状态.

- 第二次握手

  服务端收到后, 回传一个带有 SYN/ACK 的确认包以示应答. 即 SYN=1, ACK=1. 服务端选择自己的 ISN 序列号, 放到 seq 中, 同时将确认序号 ack 设置为客户端的 ISN+1, 即 x+1. 发送完毕后, 服务端进入 `SYN_RCVD (同步收到)` 状态.

- 第三次握手

  客户端收到确认后, 再次发送一个带 ACK 标志的数据包. 即 ACK=1, ack=y+1, 并将自己的序列号 seq=x+1. 发送完毕后, 客户端和服务器双双进入 `ESTABLISHED` 状态. 至此, 三次握手结束.

![三次握手](https://edge.yancey.app/beg/20170607205709367.jpg)

### TCP 关闭连接 (四次挥手)

- 第一次挥手

  客户端调用 close() 函数, 并发送一个 FIN (finish) 标志为 1 的数据包给服务端, 来表示本方的数据已经全部发送完毕, 此时客户端进入 `FIN-WAIT-1` 状态. TCP 规定, FIN 报文段即使不携带数据, 也要消耗一个序号.

- 第二次挥手

  服务端收到客户端的释放报文后, 发出确认报文, 其中 ACK=1, ack=u+1, 并且带上自己的序列号 seq=v. 表明自己接受到了客户端关闭连接的请求, 但还没准备好关闭连接 (半关闭状态), **也就是说客户端已经没有数据要发送了, 但服务端仍有可能会发送数据**. 发送完毕后, 服务端进入 `CLOSE_WAIT` 状态.

  当客户端收到该报文后, 客户端就进入 `FIN-WAIT-2` 状态, 等待服务器发送连接释放报文.

- 第三次挥手

  服务器端准备好关闭连接时, 会向客户端发送一个连接释放报文, 其中 FIN=1, ack=u+1. 由于在半关闭状态, 服务器很可能又发送了一些数据, 假定此时的序列号为 seq=w. 发送完毕后, 服务端便进入 `LAST-ACK`(最后确认) 状态.

- 第四次挥手

  客户端收到服务器的连接释放报文后, 需要发送一个确认包, 其中 ACK=1, ack=w+1, 而自己的序列号是 seq=u+1, 并进入了 `TIME-WAIT` (时间等待)状态, 等待过程可能出现的要求重传的 ACK 包.

  此时 TCP 连接还没有释放, 必须经过 2 \* MSL (Maximum Segment Lifetime, 最长报文段寿命) 时间后, 当客户端撤销相应的 TCB 后, 才会进入 `CLOSED` 状态.

  而服务器只要收到了客户端发出的确认, 立即进入 `CLOSED` 状态. 同样, 撤销 TCB 后, 就结束了这次的 TCP 连接. 因此, 服务器结束 TCP 连接的时间要比客户端早一些.

![四次挥手](https://edge.yancey.app/beg/20170606084851272.png)

## 短连接和长连接

在 HTTP 0.9 和 1.0 的时候, 因为客户端与服务器的整个连接过程很短暂, 不会与服务器保持长时间的连接状态, 所以就被称为**短连接**(short-lived connections). 早期的 HTTP 协议也被称为是**无连接**的协议.

短连接的缺点相当严重, 因为在 TCP 协议里, 建立连接和关闭连接都是非常**昂贵**的操作. TCP 建立连接要有**三次握手**, 发送 3 个数据包, 需要 1 个 RTT(round trip time, 往返时间, 实在第三次握手时客户端就可以发送数据了, 这种情况下是 1 个 RTT); 关闭连接是**四次挥手**, 4 个数据包需要 2 个 RTT. 所以说很大一部分时间浪费在协议确认上.

针对短连接暴露出的缺点, HTTP 协议就提出了**长连接**的通信方式, 也叫**持久连接**(persistent connections), **连接保活**(keep alive), **连接复用**(connection reuse). 其实解决办法也很简单, 用的就是**成本均摊**的思路, 既然 TCP 的连接和关闭非常耗时间, 那么就把这个时间成本由原来的一个**请求 - 应答**均摊到多个**请求 - 应答**上.

![短连接 vs 长连接](https://edge.yancey.app/beg/wwbl3aj2-1647246703723.webp)

### 连接相关的头字段

在 HTTP/1.1 中的连接都会默认启用长连接. 不需要用什么特殊的头字段指定, 只要向服务器发送了第一次请求, 后续的请求都会重复利用第一次打开的 TCP 连接, 也就是长连接, 在这个连接上收发数据. 当然你也也可在请求头中指定 **Connection: keep-alive**.

不过长连接一直不关闭也不好, 因为服务器必须在内存里保存它的状态, 这就占用了服务器的资源. 在客户端可手动通过 **Connection: close** 告诉服务端在这次通信后就关闭连接.

服务端通常不会主动关闭连接, 但 Nginx 有两种方式:

- 使用**keepalive_timeout**指令, 设置长连接的超时时间, 如果在一段时间内连接上没有任何数据收发就主动断开连接, 避免空闲连接占用系统资源.
- 使用**keepalive_requests**指令, 设置长连接上可发送的最大请求次数. 比如设置成 1000, 那么当 Nginx 在这个连接上处理了 1000 个请求后, 也会主动断开连接.

## 队头阻塞

**队头阻塞**与短连接和长连接无关, 而是由 HTTP 基本的**请求 - 应答**模型所导致的. 因为 HTTP 规定报文必须是**一发一收**, 这就形成了一个先进先出的**串行**队列. 队列里的请求没有轻重缓急的优先级, 只有入队的先后顺序, 排在最前面的请求被最优先处理.

如果队首的请求因为处理的太慢耽误了时间, 那么队列里后面的所有请求也不得不跟着一起等待, 结果就是其他的请求承担了不应有的时间成本.

### 优化队头阻塞

因为**请求-应答**的模型不能变, 所以只能通过数量来改善质量问题.

第一种方式是通过**并发连接(concurrent connections)**, 也就是同时对一个域名发起多个长连接, 但缺点是如果每个客户端都想自己快, 建立很多个连接, **用户数 \* 并发数**就会是个天文数字. 服务器的资源根本就扛不住. 因此 RFC2616 里明确限制每个客户端最多并发 2 个连接, 不过这个太小了, 后面浏览器把上限提高到 6 - 8.

第二种方式是域名分片, 比如让原本 www.yanceyleo.com 指向的服务器, 开通多个域名 如 1.yanceyleo.com, 2.yanceyleo.com... 都指向这个服务器, 那么每个域名都可以开启自己的长连接, 自然长连接数量就上了去了.

## TCP 和 UDP 的对比

|              | UDP                                        | TCP                                    |
| ------------ | ------------------------------------------ | -------------------------------------- |
| 是否连接     | 无连接                                     | 面向连接                               |
| 是否可靠     | 不可靠传输, 不使用流量控制和拥塞控制       | 可靠传输, 使用流量控制和拥塞控制       |
| 连接对象个数 | 支持一对一, 一对多, 多对一和多对多交互通信 | 只能是一对一通信                       |
| 传输方式     | 面向报文                                   | 面向字节流                             |
| 首部开销     | 首部开销小, 仅 8 字节                      | 首部最小 20 字节, 最大 60 字节         |
| 适用场景     | 适用于实时应用 (IP 电话, 视频会议, 直播等) | 适用于要求可靠传输的应用, 例如文件传输 |

## 浅谈 CDN

在谈 CDN 之前, 先谈一谈为什么要有网络加速.

首先, 虽然光速很快, 真空可达 30 万公里/秒, 但在光缆环境下会衰减到 20 万公里/秒, 北京到广东距离 2000 公里, 往返就有了 20 毫秒的消耗.

第二, 互联网从逻辑上看是一张大网, 但实际上是由许多小网络组成的, 这其中就有小网络**互连互通**的问题, 典型的就是各个电信运营商的网络, 比如国内的电信, 联通, 移动三大家. 这些小网络内部的沟通很顺畅, 但网络之间却只有很少的联通点. 因此跨运营商的带宽会很小, 进而减弱连接速度. 下面这个图片想必大家都很熟悉, 下载站会根据你的 IP 来建议你使用哪家运营商的下载节点.

![互连互通](https://edge.yancey.app/beg/2gycpxpv-1649108168484.jpg)

此外, 网络中还存在许多的路由器, 网关, 数据每经过一个节点, 都要停顿一下, 在二层, 三层解析转发, 这也会消耗一定的时间, 带来延迟. 把这些因素再放到全球来看, 地理距离, 运营商网络, 路由转发的影响就会成倍增加.

这个时候 CDN 就出现了, 它就是专门为解决**长距离**上网络访问速度慢而诞生的一种网络应用服务.

### 什么是 CDN

CDN 全称为内容分发网络 (Content Delivery Network), 它会同步源站点的内容并负责响应用户的访问请求, 并且实时地根据网络流量和各节点的连接, 负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上, 以提高用户访问网站的相应速度. 通俗来讲, 原本用户访问的资源是存放在你自己的服务器, 而现在访问的资源来自 CDN 缓存服务器. 在实际操作中, 我们只需要将域名的 DNS 解析指向 CDN 服务商提供的域名服务器即可.

为了用户更快地就近访问资源, 这需要 CDN 厂商在世界各地部署大量拥有高存储高带宽的节点, 构建了一个专用网络. 这个网络是跨运营商, 跨地域的, 虽然内部也划分成多个小网络, 但它们之间用高速专有线路连接, 是真正的**信息高速公路**, 基本上可以认为不存在网络拥堵.

有了这个高速的专用网之后, CDN 就要**分发**源站的**内容**, 通过**缓存代理**技术. 使用**推**或者**拉**的手段, 把源站的内容逐级缓存到网络的每一个节点上. 于是, 用户在上网的时候就不直接访问源站, 而是访问离他**最近的**一个 CDN 节点, 即**边缘节点**(edge node). 这些边缘节点就是缓存了源站内容的代理服务器, 这样一来就省去了**长途跋涉**的时间成本, 实现了**网络加速**.

当然, 只有静态资源才能够被缓存加速, 就近访问, 而动态资源只能由源站实时生成, 即使缓存了也没有意义. 不过, 如果动态资源指定了 **Cache-Control**, 允许缓存短暂的时间, 那它在这段时间里也就变成了**静态资源**, 可以被 CDN 缓存加速.

![CDN 流程](https://edge.yancey.app/beg/4edc00b0-dcb9-11e6-9663-ed19a3fa3182.png)

### CDN 的负载均衡系统

全局负载均衡(Global Sever Load Balance)一般简称为 GSLB, 主要的职责是当用户接入网络的时候在 CDN 专网中挑选出一个**最佳**节点提供服务, 解决的是用户如何找到**最近的**边缘节点, 对整个 CDN 网络进行**负载均衡**.

GSLB 最常见的实现方式是**DNS 负载均衡**. 原来没有 CDN 的时候, 权威 DNS 返回的是网站自己服务器的实际 IP 地址, 浏览器收到 DNS 解析结果后直连网站.

但加入 CDN 后就不一样了, 权威 DNS 返回的不是 IP 地址, 而是一个 CNAME( Canonical Name ) 别名记录, 指向的就是 CDN 的 GSLB. 它有点像是 HTTP/2 里 **Alt-Svc** 的意思, 告诉外面: **我这里暂时没法给你真正的地址, 你去另外一个地方再查查看吧.**

因为没拿到 IP 地址, 于是本地 DNS 就会向 GSLB 再发起请求, 这样就进入了 CDN 的全局负载均衡系统, 开始**智能调度**, 主要的依据有这么几个:

- 看用户的 IP 地址, 查表得知地理位置, 找相对最近的边缘节点;
- 看用户所在的运营商网络, 找相同网络的边缘节点;
- 检查边缘节点的负载情况, 找负载较轻的节点;
- 其他, 比如节点的**健康状况**, 服务能力, 带宽, 响应时间等.

GSLB 把这些因素综合起来, 找出一台**最合适**的边缘节点, 把这个节点的 IP 地址返回给用户, 用户就可以**就近**访问 CDN 的缓存代理了.

### CDN 的缓存代理

缓存系统是 CDN 的另一个关键组成部分, 它需要将源站的资源缓存起来, 以便用户可以从 CDN 的缓存代理中访问到. 这里就有两个 CDN 的关键概念: **命中**和**回源**. **命中**就是指用户访问的资源恰好在缓存系统里, 可以直接返回给用户; **回源**则正相反, 缓存里没有, 必须用代理的方式回源站取.

相应地, 也就有了两个衡量 CDN 服务质量的指标: **命中率**和**回源率**. 命中率就是命中次数与所有访问次数之比, 回源率是回源次数与所有访问次数之比. 显然, 好的 CDN 应该是命中率越高越好, 回源率越低越好. 现在的商业 CDN 命中率都在 90% 以上. 为了提高命中率就有了以下策略:

首先, 最基本的方式就是在存储系统上下功夫, 硬件用高速 CPU, 大内存, 万兆网卡, 再搭配 TB 级别的硬盘和快速的 SSD. 软件方面则不断**求新求变**, 各种新的存储软件都会拿来尝试, 比如 Memcache, Redis, Ceph, 尽可能地高效利用存储, 存下更多的内容.

其次, 缓存系统也可以划分出层次, 分成一级缓存节点和二级缓存节点. 一级缓存配置高一些, 直连源站, 二级缓存配置低一些, 直连用户. 回源的时候二级缓存只找一级缓存, 一级缓存没有才回源站, 这样最终**扇入度**就缩小了, 可以有效地减少真正的回源.

第三个就是使用高性能的缓存服务, 最常用的是专门的缓存代理软件 Squid, Varnish, 还有新兴的 ATS(Apache Traffic Server), 而 Nginx 和 OpenResty 作为 Web 服务器领域的**多面手**, 凭借着强大的反向代理能力和模块化, 易于扩展的优点, 也在 CDN 里占据了不少的份额.

### CDN 节点有缓存场景

HTTP 请求流程说明:

1, 用户在浏览器输入要访问的网站域名, 向本地 DNS 发起域名解析请求.

2, 域名解析的请求被发往网站授权 DNS 服务器.

3, 网站 DNS 服务器解析发现域名已经 CNAME 到了www.example.com.c.cdnhwc1.com.

4, 请求被指向 CDN 服务.

5, CDN 对域名进行智能解析, 将响应速度最快的 CDN 节点 IP 地址返回给本地 DNS.

6, 用户获取响应速度最快的 CDN 节点 IP 地址.

7, 浏览器在得到速度最快节点的 IP 地址以后, 向 CDN 节点发出访问请求.

8, CDN 节点将用户所需资源返回给用户.


![CDN 节点有缓存场景](https://edge.yancey.app/beg/e6xuco55-1696769020056.jpg)


### CDN 节点无缓存场景

HTTP 请求流程说明:

1, 用户在浏览器输入要访问的网站域名, 向本地 DNS 发起域名解析请求.

2, 域名解析的请求被发往网站授权 DNS 服务器.

3, 网站 DNS 服务器解析发现域名已经 CNAME 到了www.example.com.c.cdnhwc1.com.

4, 请求被指向 CDN 服务.

5, CDN 对域名进行智能解析, 将响应速度最快的 CDN 节点 IP 地址返回给本地 DNS.

6, 用户获取响应速度最快的 CDN 节点 IP 地址.

7, 浏览器在得到速度最快节点的 IP 地址以后, 向 CDN 节点发出访问请求.

8, CDN 节点回源站拉取用户所需资源.

9, 将回源拉取的资源缓存至节点.

10, 将用户所需资源返回给用户.

![CDN 节点无缓存场景](https://edge.yancey.app/beg/rdyzbar2ky-1625718616181)

## 几道面试题

### 三次握手和四次挥手详细介绍 (重点)

见上文.

### TCP 有哪些手段保证可靠交付

- 为了方便传输, TCP 协议将大块数据分割成以报文段为单位的数据块进行管理.

- 当 TCP 发出一个报文段时, 它会启动一个定时器, 等待目的端确认收到这个报文段. 如果不能及时收到一个确认, 将重发这个报文段.

- 当收到来自另一端的数据时, 它会发送一个确认, 但该确认不是立即发送的, 之所以推迟, 是要对包做完整校验.

- TCP 通过检验 `校验和` 的方式来检测数据的准确性, 当检测到数据出错后, 会丢给客户端一个携带 NCK 标志的包, 当客户端收到后会重现发送一遍数据包.

- TCP 协议给每一个字节设置一个序号, 序号确保了 TCP 传输的有序性, 当报文段出现失序的问题, TCP 会根据序号重新排序.

- IP 数据报有可能会发生重复, TCP 接收端会丢弃重复的数据.

- TCP 提供流量控制. TCP 连接的每一方都有固定大小的缓冲空间, TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据. TCP 使用的流量控制协议是可变大小的滑动窗口协议.

### 为什么是三次握手, 两次不行吗?

为了实现可靠数据传输, TCP 协议的通信双方, 都必须维护一个序列号, 以标识发送出去的数据包中, 哪些是已经被对方收到的. 三次握手的过程即是通信双方相互告知序列号起始值, 并确认对方已经收到了序列号起始值的必经步骤

如果只是两次握手, 至多只有连接发起方的起始序列号能被确认, 另一方选择的序列号则得不到确认.

### 如果已经建立了连接, 但是客户端突然出现故障了怎么办?

TCP 还设有一个保活计时器 (keep-alive), 如果客户端出现故障, 服务器不能一直等下去, 白白浪费资源. 服务器每收到一次客户端的请求后都会重新复位这个计时器, 时间通常是设置为 2 小时, 若两小时还没有收到客户端的任何数据, 服务器就会发送一个探测报文段, 以后每隔 75 秒发送一次. 若一连发送 10 个探测报文仍然没反应, 服务器就认为客户端出了故障, 接着就关闭连接.

### DNS 解析流程 (重点)

见上文.

## 最后

欢迎关注我的微信公众号: 进击的前端

![进击的前端](https://edge.yancey.app/beg/qrcode_for_gh_541158abcb21_344.jpg)

## 参考

《图解 HTTP》 -- 上野 宣

[TCP 和 UDP](https://juejin.im/post/583d2d6a67f356006bb7d535)

[有了 IP 地址, 为什么还要用 MAC 地址?](https://www.zhihu.com/question/21546408)

[[面试 ∙ 网络] TCP/IP (四): TCP 与 UDP 协议简介](https://juejin.im/post/5a2ff1f36fb9a04500030771)

[TCP 报文格式详解](https://blog.csdn.net/Mary19920410/article/details/58030147)

[TCP 和 UDP 比较](https://juejin.im/post/5c6fbf54f265da2db718216a)

[hit-alibaba TCP](https://hit-alibaba.github.io/interview/basic/network/TCP.html)

[TCP 的三次握手与四次挥手 (详解+动图)](https://blog.csdn.net/qzcsu/article/details/72861891)

[当我们谈网络时, 我们谈些什么 (4)-- TCP 和 UDP](https://segmentfault.com/a/1190000004138638)

[DNS 协议详解及报文格式分析](https://jocent.me/2017/06/18/dns-protocol-principle.html)

[DNS 请求报文详解](https://juejin.im/post/5ab719c151882577b45ef9d9)

[深入理解 Http 请求, DNS 劫持与解析.](https://juejin.im/post/59ba146c6fb9a00a4636d8b6)

[CDN 与 DNS 知识汇总](http://hpoenixf.com/DNS%E4%B8%8ECDN%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB.html)
","2025-02-02 03:08:08.849216","2025-02-02 03:08:08.849216"
"863af748-6ae6-4f58-b02d-9bd9937056a2","{HTTP}",0,0,False,"https://edge.yancey.app/beg/h3gbcwtj-1649091318770.jpg","[HTTP 系列] 第 2 篇 —— HTTP 协议那些事","这里是《写给前端工程师的 HTTP 系列》, 记得有位大佬曾经说过: 大厂前端面试对 HTTP 的要求比 CSS 还要高, 由此可见 HTTP 的重要程度不可小视. 文章写作计划如下, 视情况可能有一定的删减, 本篇是该系列的第 2 篇 —— 《HTTP 协议那些事》. 这篇文章会涉及到 HTTP 协议, cookie 和 session, HTTP 首部/方法/状态码, HTTP/2 等.","- [\[HTTP 系列\] 第 1 篇 —— 从 TCP/UDP 到 DNS 解析](https://www.yanceyleo.com/post/3a9d3d47-9977-4579-a756-4bf5af4a3fd4)
- [\[HTTP 系列\] 第 2 篇 —— HTTP 协议那些事](https://www.yanceyleo.com/post/efd566e9-4ee3-4ee2-8448-628414659480)
- [\[HTTP 系列\] 第 3 篇 —— HTTP 缓存那些事](https://www.yanceyleo.com/post/89731d8e-5510-4094-8962-462b127ed5d0)
- [\[HTTP 系列\] 第 4 篇 —— HTTPS](https://www.yanceyleo.com/post/f976717f-9e40-4849-a73f-86c63c0c45e1)
- [\[HTTP 系列\] 第 5 篇 —— 网络安全](https://www.yanceyleo.com/post/953ccf20-7f3b-4d3f-816e-b6e98b26a4da)
- [\[HTTP 系列\] 第 6 篇 —— 从输入 URL 回车到页面呈现](https://www.yanceyleo.com/post/05daeef2-2caf-4ebe-89f0-2ad9cae286c4)

## HTTP 的发展历程

1989 年, 任职于欧洲核子研究中心(CERN)的蒂姆·伯纳斯 - 李(Tim Berners-Lee)发表了一篇论文, 提出了在互联网上构建超链接文档系统的构想. 这篇论文中他确立了三项关键技术.

- URI: 即统一资源标识符, 作为互联网上资源的唯一身份;
- HTML: 即超文本标记语言, 描述超文本文档;
- HTTP: 即超文本传输协议, 用来传输超文本.

`HTTP/0.9` 标准于 1990 年问世, 因为当时的 HTTP 没有作为正式的标准被确立, 该版本含有 HTTP/1.0 之前版本的意味.

`HTTP/1.0` 标准于 1996 年 5 月作为第一份标准被公布, 它被记载于 [RFC1945 - Hypertext Transfer Protocol -- HTTP/1.0](http://www.ietf.org/rfc/rfc1945.txt)

- 增加了 HEAD, POST 等新方法;
- 增加了响应状态码, 标记可能的错误原因;
- 引入了协议版本号概念;
- 引入了 HTTP Header(头部)的概念, 让 HTTP 处理请求和响应更加灵活;
- 传输的数据不再仅限于文本.

`HTTP/1.1` 标准于 1999 年 6 月被公布, 截止到目前它应该是最主流的 HTTP 协议版本, 它被记载于 [RFC2616 - Hypertext Transfer Protocol -- HTTP/1.1](http://www.ietf.org/rfc/rfc2616.txt)

- 增加了 PUT, DELETE 等新的方法;
- 增加了缓存管理和控制;
- 明确了连接管理, 允许持久连接;
- 允许响应数据分块(chunked), 利于传输大文件;
- 强制要求 Host 头, 让互联网主机托管成为可能.

HTTP/1.1 的主要问题是对带宽的利用率并不理想. 带宽是指每秒最大能发送或者接收的字节数. 我们把每秒能发送的最大字节数称为上行带宽, 每秒能够接收的最大字节数称为下行带宽. 之所以会出现这个问题, 主要是由以下三个原因导致的:

- **TCP 的慢启动**: 一旦一个 TCP 连接建立之后, 就进入了发送数据状态, 刚开始 TCP 协议会采用一个非常慢的速度去发送数据, 然后慢慢加快发送数据的速度, 直到发送数据的速度达到一个理想状态, 我们把这个过程称为慢启动.
- **同时开启了多条 TCP 连接, 那么这些连接会竞争固定的带宽**: 如果系统同时建立了多条 TCP 连接, 当带宽充足时, 每条连接发送或者接收速度会慢慢向上增加；而一旦带宽不足时, 这些 TCP 连接又会减慢发送或者接收的速度. 而多条 TCP 连接之间又不能协商让哪些关键资源优先下载, 这样就有可能影响那些关键资源的下载速度了.
- **HTTP/1.1 队头阻塞**: 在 HTTP/1.1 中使用持久连接时, 虽然能公用一个 TCP 管道, 但是在一个管道中同一时刻只能处理一个请求, 在当前的请求没有结束之前, 其他的请求只能处于阻塞状态

`HTTP/2` 标准于 2015 年 5 月被正式发布, 它被记载于 [RFC7540 - Hypertext Transfer Protocol -- HTTP/2](http://www.ietf.org/rfc/rfc7540.txt), 它的特点是 ① 采用二进制而非明文来打包, ② 多路复用, ③ 修复队头堵塞, ④ 允许设置设定请求优先级, ⑤ 服务器推送, ⑥ WebSocket 等等.

据 [w3techs](https://w3techs.com/technologies/details/ce-http2/all/all) 统计, 截止到 2019/04/22, HTTP/2 的全球占有率为 36%. 我的 [个人博客](https://yanceyleo.com) 在上线之初就支持了 HTTP/2.

![My Website](https://edge.yancey.app/beg/Jietu20190422-104131%402x.jpg)

`HTTP/3`, 于 2018 年, 互联网标准化组织 IETF 提议将**HTTP over QUIC**更名为**HTTP/3**并获得批准, HTTP/3 正式进入了标准化制订阶段.

## HTTP 协议

![HTTP 协议学习图谱](https://edge.yancey.app/beg/8e70rur9-1646643798972.webp)

超文本传输协议(HyperText Transfer Protocol)是基于 TCP/IP 协议, 用于分布式, 协作式和超媒体信息系统的应用层协议. 它依靠 IP 协议实现寻址和路由, TCP 协议实现可靠数据传输, DNS 协议实现域名查找, SSL/TLS 协议实现安全通信. HTTP 是万维网的数据通信的基础, 它是 `无状态` 的协议, 默认端口为 80. HTTP 在 TCP 的基础上, 规定了 Request-Response 的模式, 这个模式决定了通讯必定由浏览器首先发起.

这里稍微谈一下超文本(HyperText), 所谓**文本**(Text), 就表示 HTTP 传输的不是 TCP/UDP 这些底层协议里被切分的杂乱无章的二进制包(datagram), 而是完整的, 有意义的数据, 可以被浏览器, 服务器这样的上层应用程序处理. 而所谓**超文本**, 就是**超越了普通文本的文本**, 它是文字, 图片, 音频和视频等的混合体, 最关键的是含有**超链接**, 能够从一个**超文本**跳跃到另一个**超文本**, 形成复杂的非线性, 网状的结构关系.

HTTP 的本质是对实际传输的数据(entity)做了一层包装, 加上一个头, 然后调用 Socket API, 通过 TCP/IP 协议栈发送或者接收.

抛去一些复杂的层面, 浏览器开发者只需要一个 TCP 库就可以搞定浏览器的网络通讯部分. 我们可以用 `telnet` 来做个实验. 首先连接到 `yanceyleo.com` 的主机.

```shell
telnet yanceyleo.com 80
```

此时, 三次握手完成, TCP 连接已经建立. 输入下面内容, 并 **双击回车**, 就可以得到服务端响应的内容. 下面的报文中, 第一行的开头 `GET` 为请求访问服务器的类型, 称为 `方法 (method)`; 后面的 `/` 指明了请求访问的资源对象, 也叫做请求 URI (request-URI); 最后为 HTTP 版本号, 用来表示客户端使用的 HTTP 版本. 第二行则是请求的主机名.

```shell
GET / HTTP/1.1
Host: yanceyleo.com
```

![telnet 下的请求和响应](https://edge.yancey.app/beg/Jietu20190428-191318%402x.jpg)

### HTTP 是无连接, 无状态协议

HTTP 是无状态 (stateless) 协议, 它不会对请求和响应之间通信状态进行保存, 也就是说 HTTP 协议不会对发送过的请求或响应做持久化处理. 使用 HTTP 协议, 每当有新的请求发送时, 就会有对应的新响应产生. 协议本身并不保留之前一切的请求或响应报文信息. 这是为了更快地处理大量事务, 确保协议的可伸缩性.

- 无连接: 每次连接只处理一个请求, 服务端处理完客户端一次请求, 等到客户端作出回应之后便断开连接.

- 无状态: 是指服务端对于客户端每次发送的请求都认为它是一个新的请求, 上一次会话和下一次会话没有联系.

## Cookie

### cookie 原理

何为 cookie 呢? 我们在上面了解到 HTTP 是无状态的, 但随着 Web 的不断发展, 这种 **无状态** 的特性出现了弊端. 当你登录到一家购物网站, 在跳转到该站的其他页面时也应该继续保持登录状态. 但是因为 HTTP 是无状态的, 所以必须得在浏览器端存储一些信息来标识当前用户, 因此 cookie 应运而生, 它一种浏览器管理状态的文件.

![cookie 原理](https://edge.yancey.app/beg/07ecb36c4820a66de90013f303cac8c0.jpg)

浏览器第一次发出请求, 服务器会将 cookie 放入到响应请求中, 在浏览器第二次发请求的时候, 会把 cookie 带过去, 于是服务端就会辨别用户身份. 注意: 单个 cookie 保存的数据不能超过 4K, 很多浏览器都限制一个站点最多保存 20 个 cookie.

cookie 在请求头中有一个 `cookie` 字段, 在响应头里有一个 `set-cookie` 字段.

### cookie 是不可跨域的

cookie 本身就是用来保存一些隐私性的字段, 基于安全性的考量, 必须要保证它是 **不可跨域的**. 我们可以做个实验: 先打开 `https://google.com`, 然后在开发者工具中输入以下代码:

```js
document.cookie = ""hello=world;path=/;domain=.baidu.com"";

document.cookie = ""world=hello;path=/;domain=.google.com"";
```

打开 Application 选项卡, 在侧边栏找到 Cookies, 可以发现只有 domain 为 `.google.com` 的被成功添加.

![cookie 是不可跨域的](https://edge.yancey.app/beg/Jietu20190429-123624.jpg)

### cookie 的属性

我们通过一个登录的小例子来了解服务端设置 cookie. 首先通过 express application generator 生成一个 Express 工程. **本示例的源码请访问 [express-cookies](https://github.com/YanceyOfficial/express-cookies).**

接着在 index.html 文件中输入以下代码, 我们创建一个输入用户名和密码的界面, 在点击按钮的时候, 通过 fetch 将输入的值发送给后端.

```html
<fieldset>
  <legend>Login</legend>
  <input id=""userName"" type=""text"" placeholder=""请输入用户名"" />
  <input id=""userPwd"" type=""password"" placeholder=""请输入密码"" />
  <button id=""loginBtn"">登录</button>
</fieldset>

<p>登录状态: <span id=""result""></span></p>
<script>
  const userName = document.getElementById(""userName"");
  const userPwd = document.getElementById(""userPwd"");
  const loginBtn = document.getElementById(""loginBtn"");
  const result = document.getElementById(""result"");

  loginBtn.addEventListener(""click"", function () {
    const data = {
      userName: userName.value,
      userPwd: userPwd.value,
    };

    fetch(""/login"", {
      method: ""POST"",
      headers: new Headers({
        ""Content-Type"": ""application/json"",
      }),
      body: JSON.stringify(data),
    })
      .then((res) => {
        return res.json();
      })
      .then((json) => {
        result.innerHTML = json.msg;
      });
  });
</script>
```

当用户名和密码匹配时 (假设用户名和密码都是 `yancey`), 返回给客户端一个 cookie 以及登录成功的 json; 否则返回登录失败的 json. 下面是模拟服务端登录的接口.

```js
router.post(""/login"", (req, res, next) => {
  const body = req.body;
  if (body.userName === ""yancey"" && body.userPwd === ""yancey"") {
    // 设置 cookie
    res.cookie(""yancey"", ""success"");
    res.json({
      success: true,
      msg: ""登录成功"",
    });
  } else {
    res.status(401).json({
      success: false,
      msg: ""用户名或密码错误"",
    });
  }
});
```

通过这个例子可以看到, 在 express 中, setCookie 的方式为: 第一个参数传递 `name`, 第二个参数传递 `value`, **注意浏览器会将元字符和语义字符之外的字符进行转义**. 打开 Chrome 的开发者工具, 就可以看到该 cookie 被添加到浏览器上了. 或者你在控制台输入 `document.cookie`, 同样可以看到 cookie 字符串.

这只是一个设置 cookie 的简单例子, cookie 有 7 种属性可供使用, 我们一一来了解.

![cookie 的属性](https://edge.yancey.app/beg/2340002414-566cde733b2cd_articlex.png)

#### domain

该属性给 cookie 设置 `域名`, 默认为当前网站的域名, 下面的例子将 domain 设为 **yanceyleo.com**, 由于前端页面是 `127.0.0.1`, 根据同源策略, 该条 cookie 不会生效.

```js
res.cookie(""domain"", ""domian"", { domain: ""yanceyleo.com"" });
```

#### expires / maxAge

这两个属性都是设置 cookie 的 `过期时间`. 不同的是, `expires` 接收一个 Date 格式的时间, 而 `maxAge` 接收一个 `毫秒时间戳`. 因为后者更加直观和简便, 所以建议使用 `maxAge`.

两个属性都可以传递一个 `负值` 或者 `0`, 如果浏览器已存在同名 cookie, 则会清除此 cookie, 否则该条 cookie 不会被创建.

下面这个例子是创建一条 cookie, 并将该 cookie 的过期时间设为一天后.

```js
res.cookie(""expires"", ""expires"", {
  expires: new Date(Date.now() + 24 * 60 * 60 * 1000),
});
```

![设置过期时间](https://edge.yancey.app/beg/Jietu20190430-095753.jpg)

接着给该条 cookie 设置一个 **负数**, 那么这条 cookie 就被清除了.

```js
res.cookie(""expires"", ""expires"", {
  expires: new Date(Date.now() - 8 * 60 * 60 * 1000),
});
```

maxAge 的用法同理, 它直接传递一个 `过期时间` 的毫秒数即可. 下面的例子是将该条 cookie 的过期时间设为 7 天后.

```js
res.cookie(""maxAge"", ""maxAge"", {
  maxAge: 7 * 24 * 60 * 60 * 1000,
});
```

那么不设置过期时间的 cookie 会怎样呢? 当你关闭该网站的时候, 这些没有被设置过期时间的 cookie 就死翘翘了 (这种情况的 cookie 就好像是 session).

#### httpOnly

当该属性设为 true 时, `document.cookie` 将无法获取该条 cookie, 但服务端可以照常获得. 该属性可以有效的避免跨站脚本攻击 (XSS). 关于网络安全方面的话题, 后面会专门写一篇文章去讲.

```js
res.cookie(""httpOnly"", ""httpOnly"", {
  // 只能被 web server 访问到, 也就是说在浏览器输入 document.cookie 无法取到该条 cookie, 目的是防止 xss
  httpOnly: true,
});
```

#### path

该属性给 `指定的路径` 添加此 cookie, 默认为 `/`. 如下代码就是给 `users` 这个路由设置 cookie (即便在服务端该路径不存在也会被添加上).

```js
res.cookie(""path"", ""path"", {
  path: ""/users"",
});
```

![path 属性](https://edge.yancey.app/beg/Jietu20190430-145804.jpg)

#### secure

只有当连接是 HTTPS 协议, 该 cookie 才会被添加. 该属性默认为 fasle. 因为我本地的 express 是 HTTP 协议, 因此该条 cookie 不会生效.

```js
res.cookie(""secure"", ""secure"", {
  secure: true,
});
```

#### signed (防篡改签名)

该属性是给浏览器发送一个加密的 cookie, 该属性默认为 false. 在 express 中, 我们可以使用 `cookie-parser` 插件来创建一个加密后的 cookie. 服务端通过该 cookie 的内容和签名来检验它是否 `被篡改`

首先给 `cookieParser` 传入一个 secret.

```js
app.use(cookieParser(""forcabarca""));
```

然后返回一个 sign 后的 cookie.

```js
res.cookie(""signed"", ""signed"", {
  signed: true,
});
```

![sign 属性](https://edge.yancey.app/beg/Jietu20190430-160532.jpg)

在 express 中, 我们可以使用 `req.cookies` 来获得 `未加密` 的 cookie 对象, 可以通过 `req.signedCookies` 来获得 `已加密` 的 cookie 对象.

```js
console.log(req.cookies); // { httpOnly: 'httpOnly' }
console.log(req.signedCookies); // { signed: 'signed' }
```

#### sameSite

它允许您声明该 Cookie 是否仅限于第一方或者同一站点上下文. SameSite 接受下面三个值:

- **Lax**: Cookies 允许与顶级导航一起发送, 并将与第三方网站发起的 GET 请求一起发送. 这是浏览器中的默认值.
- **Strict**: Cookies 只会在第一方上下文中发送, 不会与第三方网站发起的请求一起发送.
- **None**: Cookie 将在所有上下文中发送, 即允许跨域发送.

### cookie 的缺点

Cookie 上限只有 4kb;

同一个域名下的所有请求, 都会携带 Cookie, 这意味着大量不需要 Cookie 传输的 HTTP 请求都被迫携带 Cookie, 造成极大的性能浪费.

### document.cookie 字符串转对象的函数

关于 cookie 就说这么多, 最后附赠一个 `document.cookie` 字符串转对象的函数, 如果你有更好的实现方式, 请在下面留言.

```js
const parseCookie = (str) =>
  str.split("";"").reduce((cookies, cookie) => {
    const [name, value] = cookie.split(""="").map((c) => c.trim());
    cookies[name] = decodeURIComponent(value);
    return cookies;
  }, {});
```

## Session

session 是服务端使用的一种记录客户端状态的机制, 与 cookie 不同的是, session 保存在 服务端. 当客户端初次发送请求时 (比如登录成功), 服务端会将用户信息以某种形式保存在服务端, 当再次访问时只需从该 session 中找到该客户的状态即可.

因此, cookie 机制就是通过检查客户身上的 **通行证** 来确定客户身份, 而 session 则是通过检查服务器上的 **客户明细表** 来确认客户身份. session 相当于程序在服务器上建立的一份客户档案, 客户来访的时候只需要查询客户档案表就可以了.

因为 HTTP 是无状态的, 所以单纯的 session 仍不能判断是否为到底是哪个用户. 因此服务端仍要向客户端发送一个 maxAge 为 `-1` 的 cookie 来作为不同用户的唯一标识.

当然你也可以不使用 cookie, 你可以通过重写 URL 地址的方式来实现. 它的原理是将用户的 seesion id 写入到 URL 中, 当浏览器解析新的 URL 时就可以定位到是哪位用户.

万变不离其宗, 两种方式都是要保证用户信息以某种形式保存到客户端. 更先进的 localStorage, sessionStorage, IndexedDB 也是同样的道理, 这里不去细说.

## HTTP 报文

用于 HTTP 协议交互的信息被称为 HTTP 报文. 客户端的报文叫做请求报文, 服务端的报文叫做响应报文. HTTP 报文本身是有多行数据构成的字符串文本.

### 报文格式

报文格式由下面四个部分组成:

- 起始行(start line): 描述请求或响应的基本信息(有请求行和状态行两种);
- 头部字段集合(header): 使用 key-value 形式更详细地说明报文;
- 空行: 也叫 CRLF, 十六进制的 0D0A.
- 消息正文(entity): 实际传输的数据, 它不一定是纯文本, 可以是图片, 视频等二进制数据.

![报文格式](https://edge.yancey.app/beg/160c90cb78e72587.jpg)

### 请求行和状态行

起始行分为两种, 分别是请求行和状态行. 对于起始行, 如果是来自 Request, 叫做请求行; 如果来自 Response, 就做状态行(并不叫做响应行).

请求行有三部分构成:

1. 请求方法: 是一个动词, 如 GET/POST, 表示对资源的操作;
2. 请求目标: 通常是一个 URI, 标记了请求方法要操作的资源;
3. 版本号: 表示报文使用的 HTTP 协议版本.

```ts
GET / HTTP / 1.1;
```

状态行有三部分构成:

1. 版本号: 表示报文使用的 HTTP 协议版本;
2. 状态码: 一个三位数, 用代码的形式表示处理的结果, 比如 200 是成功, 500 是服务器错误;
3. 原因: 作为数字状态码补充, 是更详细的解释文字, 帮助人理解原因.

### 压缩报文

HTTP 协议中有一种被称为 `内容编码` 的功能, 可以有效的压缩报文的体积. 内容编码指明应用在实体内容上的编码格式, 并保持实体信息原样压缩. 内容编码后的实体由客户端接收并负责解码. 常见的内容编码有以下几种:

- identity (不做压缩)

- compress (UNIX 系统的标准压缩)

- gzip (GNU zip, 最常见, 对文本压缩率较高, 对图片, 音视频等二进制数据压缩率较低, 甚至会变大)

- deflate (zlib)

- brotli (Google 出品, 必属精品. 比 gzip 的压缩率还要高 37%+, 我的网站已使用 brotli, 看下图)

![压缩报文](https://edge.yancey.app/beg/Jietu20190501-212843.jpg)

### 分割发送的分块传输编码

从 HTTP 请求回来, 就产生了流式的数据, 后续的 DOM 树构建, CSS 计算, 渲染, 合成, 绘制, 都是尽可能地流式处理前一步的产出: 即不需要等到上一步骤完全结束, 就开始处理上一步的输出, 这样我们在浏览网页时, 才会看到逐步出现的页面.

本质上来说, 在 HTTP 通信过程中, 请求的编码实体资源尚未全部传输完成之前, 浏览器无法显示请求页面. 在传输大容量数据时, 通过把数据分割成多块, 能让浏览器逐步显示页面. 这种把实体主体分块的功能称为分块传输编码 (Chunked Transfer Code).

分块传输编码会将实体主体分为多个块, 每个块都会使用十六进制来标记大小, 而实体主体的最后一块会使用 `0 (CR+LF)` 来标记. 使用分块传输编码的实体主体会由接收的客户端负责解码, 恢复到编码前的实体主体.

## HTTP 报文首部

对于请求报文, 它的首部由方法, URL, HTTP 版本, HTTP 首部字段等部分构成.

![Jietu20190501-224131@2x.jpg](https://edge.yancey.app/beg/Jietu20190501-224131%402x.jpg)

对于响应报文, 它的首部分别由 HTTP 版本, 状态码, HTTP 首部字段等部分构成.

![Jietu20190501-224131@2x.jpg](https://edge.yancey.app/beg/Jietu20190501-224131%402x.jpg)

### 首部字段类型

- **通用首部字段 (General Header Field)** 请求报文和响应报文两方都会使用的首部.

- **请求首部字段 (Request Header Field)** 从客户端向服务端发送请求报文时使用的首部. 补充了请求的附加内容, 客户端信息, 响应内容相关优先级等信息.

- **响应首部字段 (Response Header Field)** 从服务端向客户端返回响应报文时使用的首部. 补充了响应的附加内容, 也会要求客户端附加额外的内容信息.

- **实体首部字段 (Entity Header Field)** 针对请求报文和响应报文的实体部分使用的首部. 补充了资源内容更新时间等与实体有关的信息.

### End-to-end 首部 和 Hop-by-hop 首部

HTTP 首部字段将定义成缓存代理和非缓存代理的行为, 分成 `端到端首部` 和 `逐条首部`.

分到 `端到端首部` 的首部会转发给请求/响应对应的最终接收目标, 且必须保存在由缓存生成的响应中, 并且它必须被转发.

分到 `逐跳首部` 的首部只对单次转发有效, 会因通过缓存或代理而不再转发. 在 HTTP/1.1 之后的版本, 如果使用逐跳首部, 则需要提供 Connection 首部字段. 其中 Connection, Keep-Alive, Proxy-Authenticate, , Proxy-Authorization, Trailer, TE, Transfer-Encoding, Upgrade 这 8 个为逐跳首部, 其余都为端到端首部.

### 通用首部字段

#### Cache-Control

该字段用于控制缓存的工作机制, 它接受多个参数, 中间用逗号隔开.

| 指令             | 参数                 | 类型                | 说明                                                                                                      |
| ---------------- | -------------------- | ------------------- | --------------------------------------------------------------------------------------------------------- |
| no-cache         | 无                   | 请求/响应都有该字段 | 若请求中包含该字段, 则表示客户端不接受缓存; 若服务端包含该字段, 缓存前必须先确认其有效性                  |
| no-store         | 无                   | 请求/响应都有该字段 | 不缓存请求或相应的任何内容. no-cache 响应实际上是可以存储到本地缓存区中的, 而 no-store 才是本地彻底不缓存 |
| max-age          | 单位为秒, 必需       | 请求/响应都有该字段 | 当缓存时间小于该值时, 客户端接受缓存的资源, 否则请求源服务器, 该指令的优先级高于 Expires                  |
| max-state        | 单位为秒, 可省略参数 | 只有请求拥有该字段  | 只要有该字段, 客户端就可以接受过期的缓存                                                                  |
| min-fresh        | 单位为秒, 必需       | 只有请求拥有该字段  | 该指令要求缓存服务器返回至少还未过指定时间的缓存资源                                                      |
| no-transform     | 无                   | 请求/响应都有该字段 | 无论在请求还是响应中, 都不允许缓存改变实体主体的媒体类型                                                  |
| only-if-cached   | 无                   | 只有请求拥有该字段  | 表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求去返回                                            |
| cache-extension  | -                    | 请求/响应都有该字段 | 新指令扩展                                                                                                |
| public           | 无                   | 只有响应拥有该字段  | 可向任意客户端提供相应的缓存                                                                              |
| private          | 可省略               | 只有响应拥有该字段  | 仅向特定用户返回响应                                                                                      |
| must-revalidate  | 无                   | 只有响应拥有该字段  | 可缓存, 但必须再向源服务器进行一次验证                                                                    |
| proxy-revalidate | 无                   | 只有响应拥有该字段  | 要求中间缓存服务器对缓存的响应有效性再进行确认                                                            |
| s-maxage         | 单位为秒, 必需       | 只有响应拥有该字段  | 与 max-age 相比, 该指令仅适用于公共服务器                                                                 |

#### Connection

Connection 用于控制不再转发给代理的首部字段, 还可以管理持久连接. HTTP/1.1 默认是持久连接, 当服务端明确表示断开连接时, 则将 Connection 设为 Close.

#### Date

Date 表示创建报文的日期和时间, 它的格式如下.

```shell
date: Sun, 05 May 2019 02:05:37 GMT
```

#### Trailer

该字段会事先说明在报文主体后记录了哪些首部字段, 可应用于 HTTP/1.1 分块传输编码.

#### Transfer-Encoding

用于分块传输编码, 即在响应报文里用头字段 `Transfer-Encoding: chunked` 来表示, `Transfer-Encoding: chunked` 和 `Content-Length` 这两个字段是互斥的, 也就是说响应报文里这两个字段不能同时出现, 一个响应报文的传输要么是长度已知, 要么是长度未知的.

1. 每个分块包含两个部分, 长度头和数据块;
2. 长度头是以 CRLF(回车换行, 即 `\r\n`)结尾的一行明文, 用 16 进制数字表示长度;
3. 数据块紧跟在长度头后, 最后也用 CRLF 结尾, 但数据不包含 CRLF;
4. 最后用一个长度为 0 的块表示结束, 即 `0\r\n\r\n`;

![Transfer-Encoding](https://edge.yancey.app/beg/pbn7zomq-1647237094634.webp)

#### Upgrade

该字段用于检测 HTTP 协议或者其他协议是否可以使用更高的版本通信, 该字段要和 Connection 字段一起使用. 下面的例子是询问是否可以使用 TLS/1.0 协议. 对于附有 Upgrade 字段的请求, 服务端可返回 101 的状态码.

```shell
connection: upgrade
upgrade: TLS/1.0
```

#### Via(后面还会详细讲)

该字段用于追踪客户端与服务器之间请求和响应报文的传输路径.

### 请求首部字段

#### Accept

该字段通知服务器, 用户代理能够处理的媒体类型及媒体类型的相对优先级, 或者说叫做内容协商, 即客户端用 Accept 头告诉服务器希望接收什么样的数据, 而服务器用 Content 头告诉客户端实际发送了什么样的数据. 其中用 q 表示权重. 下面的例子表示客户端可以接受纯文本类型或者 HTML, 以及两种图片类型, 并且接收纯文本类型的意愿 (权重)为 0.3. 相应的, 服务器会在响应报文里用头字段 Content-Type 告诉实体数据的真实类型.

```shell
Accept: text/plain; q=0.3, text/html, image/webp, image/png
```

![Accept](https://edge.yancey.app/beg/mu6zhjry-1646920296161.webp)

#### Accept-Charset

该字段通知服务器, 用户代理支持的字符集及字符集的相对优先级. 该字段应用于内容协商机制的服务器驱动协商. 如果服务器不能提供该字段的任何字符集, 会报 406 错误, 因此尽量不去使用该字段 (我试验了几个网站, 都没有此字段). 下面的例子表示客户端支持 utf-8 和 iso-8859-1, 且优先使用 utf-8.

```shell
Accept-Charset: utf-8, iso-8859-1;q=0.5
```

#### Accept-Encoding

该字段告知服务端, 客户端可使用的头部压缩算法. 上面 `压缩报文` 已经介绍了几种压缩方式, 这里不在赘述.

```shell
Accept-Encoding: gzip, deflate, br
```

#### Authorization

该字段用于告知服务器, 用户代理的认证信息. 下面是我博客后台管理系统的一个场景, 在请求一个需要认证的接口时, 需要在请求头上附带认证信息.

```shell
Authorization: Bearer JWT_TOKEN
```

#### Expect

客户端使用 Expect 来告知服务器, 期望出现的某种特定行为. 当服务器无法理解客户端的期望而发生错误时, 会返回 417 状态码.

该字段跟状态码 100 息息相关, 等待状态码 100 响应的客户端在发生请求时, 需要指定 `Expext: 100-continue`. 该状态码的用途主要是允许客户端发送带请求体的请求前, 判断服务器是否愿意接收请求.

```shell
Expect: 100-continue
```

#### From

该字段用来告知服务器使用用户代理的用户的 Email.

#### Host

当以单台服务器分配多个域名的虚拟主机时, Host 字段就可以用来确定相应的主机. 它属于请求字段, 只能出现在请求头里, 它同时也是唯一一个 HTTP/1.1 规范里要求必须出现的字段.

```shell
Host: www.abc.com
```

#### If-Match

形如 `If-xxx` 的请求字段都可称为条件请求. 服务器在收到该类请求后, 只有判断条件为真时才会执行请求.

服务器会比对 If-Match 的字段值和资源的 ETag 值, 仅当两者一致时, 才会执行请求, 否则返回 412 状态码. 当 If-Match 的字段值为 `*` 时, 服务器会忽略 ETag 值, 只要资源存在就处理请求.

```shell
If-Match: W/""pqxe5g29m4""
```

#### If-None-Match

与 If-Match 相反, 服务器会比对 If-None-Match 的字段值和资源的 ETag 值, 仅当两者 `不一致` 时, 才会执行请求. 在 GET 和 HEAD 方法中使用该字段会获取最新资源.

#### If-Modified-Since

如果在 If-Modified-Since 字段指定的日期时间后, 资源发生了更新, 服务器会接受请求. 如果资源没更新过, 则返回 304 状态码.

该字段值和响应首部字段的 Last-Modifie 字段做比较, 下面的例子中显然最后修改时间要新于 If-Modified-Since 的时间, 因此会响应新的资源.

```shell
// 请求首部字段
If-Modified-Since: Fri, 01 May 2019 11:20:04 GMT

// 响应首部字段
Last-Modified: Fri, 03 May 2019 11:20:04 GMT
```

#### If-Unmodified-Since

如果在 If-Modified-Since 字段指定的日期时间后, 资源 `未发生` 更新, 服务器才会接受请求. 如果资源在此之后发生了更新, 则报 412 错误.

#### If-Range

该字段值跟 相应头中的 ETag 或 Date 进行比较, 若一致, 就作为范围请求处理, 并返回状态码 206, 否则直接返回全部资源.

#### Range

对于只需获取部分资源的范围请求, 包含首部字段 Range 即可告知服务器资源的指定范围. 接收到附带 Range 字段的请求的服务器, 会在处理请求之后返回状态码为 206 的响应. 当无法处理该范围请求时, 返回 200 状态码及全部资源. 请求头 Range 是 HTTP 范围请求的专用字段, 格式是**bytes=x-y**, 其中的 x 和 y 是以字节为单位的数据范围. x, y 表示的是**偏移量**, 如**0-10**实际上是前 11 个字节.

Range 的格式也很灵活, 起点 x 和终点 y 可以省略, 能够很方便地表示正数或者倒数的范围. 假设文件是 100 个字节, 那么:

- **0-**表示从文档起点到文档终点, 相当于**0-99**, 即整个文件;
- **10-**是从第 10 个字节开始到文档末尾, 相当于**10-99**;
- **-1**是文档的最后一个字节, 相当于**99-99**;
- **-10**是从文档末尾倒数 10 个字节, 相当于**90-99**.

服务器收到 Range 字段后, 需要做四件事:

1. 查范围是否合法, 比如文件只有 100 个字节, 但请求 200-300, 这就是范围越界了, 返回 **416 Requested Range Not Satisfiable**
2. 如果范围正确, 服务器就可以根据 Range 头计算偏移量, 读取文件的片段了, 返回状态码 **206 Partial Content**
3. 服务器要添加一个响应头字段 Content-Range, 告诉片段的实际偏移量和资源的总大小, 格式为 **bytes x-y/z**, 其中 x 和 y 是片段的起点和终点, z 是资源的总大小.
4. 片段用 TCP 发给客户端

```shell
# 请求头
GET / HTTP/1.1
Host: www.yanceyleo.com
Range: bytes=0-31

# 响应头
HTTP/1.1 206 Partial Content
Content-Length: 32
Accept-Ranges: bytes
Content-Range: bytes 0-31/96
```

不仅看视频的拖拽进度需要范围请求, 常用的下载工具里的多段下载, 断点续传也是基于它实现的, 要点是:

- 先发个 HEAD, 看服务器是否支持范围请求, 同时获取文件的大小;
- 开 N 个线程, 每个线程使用 Range 字段划分出各自负责下载的片段, 发请求传输数据;
- 下载意外中断也不怕, 不必重头再来一遍, 只要根据上次的下载记录, 用 Range 请求剩下的那一部分就可以了.

范围不仅一次只获取一个片段, 其实它还支持在 Range 头里使用多个 **x-y**, 一次性获取多个片段数据. 这种情况需要使用一种特殊的 MIME 类型: **multipart/byteranges**, 表示报文的 body 是由多段字节序列组成的, 并且还要用一个参数 **boundary=xxx** 给出段之间的分隔标记.

![多个范围](https://edge.yancey.app/beg/1jz88ww9-1647244905799.webp)

每一个分段必须以 **--boundary** 开始, 之后要用 **Content-Type** 和 **Content-Range** 标记这段数据的类型和所在范围, 然后就像普通的响应头一样以回车换行结束, 再加上分段数据, 最后用一个 **--boundary--** 表示所有的分段结束.

```shell
# 请求头
GET /16-2 HTTP/1.1
Host: www.chrono.com
Range: bytes=0-9, 20-29

# 响应头
HTTP/1.1 206 Partial Content
Content-Type: multipart/byteranges; boundary=00000000001
Content-Length: 189
Connection: keep-alive
Accept-Ranges: bytes


--00000000001
Content-Type: text/plain
Content-Range: bytes 0-9/96

--00000000001
Content-Type: text/plain
Content-Range: bytes 20-29/96

--00000000001--
```

#### Proxy-Authorization

该字段用于告知代理服务器, 用户代理的认证信息.

#### Referer

告知服务器请求的 URI 是从哪儿发起的. 比如在我的博客 www.yanceyleo.com 请求了 AliOSS 上的一张图片, 那么请求 AliOSS 服务器的那个请求头就会附上:

```shell
Referer: https://www.yanceyleo.com
```

当然该单词正确的拼写应该是 `referrer`, 但 `referer` 却沿用至今. 想起一句歌词: **在漫天风沙里, 望着你远去, 我竟悲伤的不能自己 (已).**

#### TE

该字段会告知服务端, 客户端能够处理响应的传输编码方式及相对优先级. 它类似于 Accept-Encoding, 但用于传输编码. 除了指定传输编码, 还可以指定伴随 trailer 字段的分块传输编码方式.

```shell
TE: gzip, delate;q=0.5

TE: trailers
```

#### User-Agent

这个字段再不认识直接回炉重造吧, 这里不去赘述, 直接看例子.

```shell
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36
```

### 响应首部字段

#### Accept-Ranges

该字段用于告知客户端, 服务器是否能处理范围请求, 可处理时指定为 `bytes`, 否则为 `none`. 范围请求不是 Web 服务器必备的功能, 可以实现也可以不实现, 所以服务器必须在响应头里使用字段 **Accept-Ranges: bytes**, 明确告知客户端是支持范围请求的. 如果不支持的话, 服务器可以发送 **Accept-Ranges: none**, 或者干脆不发送 **Accept-Ranges**字段, 这样客户端就认为服务器没有实现范围请求功能, 只能老老实实地收发整块文件了.

```shell
Accept-Ranges: bytes
```

#### Age

该字段用于告知客户端, 源服务器在多久前创建了响应, 字段值的单位为秒. 若创建该响应的服务器是缓存服务器, Age 值指的是缓存后的响应再次发起认证到认证完成的时间值 (CDN).

```shell
Age: 500
```

#### ETag

ETag 是将资源以字符串的形式做唯一性标识, 服务器会为每份资源分配对应的 ETag 值. 当资源更新时, ETag 值也需要更新.

ETag 有 `强 Etag 值` 和 `弱 Etag 值` 之分. 前者是指无论实体发生多么细微的变化都会改变其值. 而弱 ETag 只用于提示资源是否相同. 只有资源发生了根本变化, 产生差异时才会改变 ETag 值, 弱 ETag 字段值前面会有 `W` 标识. 前者就好比使用了 `{deep: true}` 一样.

下面的代码是一张图片的 ETag, 显然一张图片改变意味着资源的彻底改变, 因此使用了强 ETag.

```shell
ETag: ""F8F155B13C6DA43723EEDE3EDBBB4D28""
```

下面的代码是请求一个数据接口的 ETag, 大多数情况不会发生根本性的改变, 因此使用弱 ETag.

```shell
etag: W/""300af-7JrdwEcHHeXMqn/UCrMO0zsO0SY""
```

#### Location

Location 字段标记了服务器要求重定向的 URI, 该字段一般会配合 3xx 的状态码使用.

```shell
Location: https://yanceyleo.com
```

#### Proxy-Authenticate

该字段会把由代理服务器所要求的认证信息发送给客户端.

#### Retry-After

该字段告知客户端应该在多久之后再次发送请求. 当服务器出错报 503 时, 如果服务端知道什么时候可以恢复, 那么就应该通过该字段告知客户端. 该字段的字段值可以是具体的日期时间, 也可以是创建响应后的秒数.

```shell
Retry-After: Sat, 04 May 2019 11:26:52 GMT
```

#### Server

该字段也是一个常见字段, 用于告知客户端, Web 服务器的名称. 比如我使用了 cloudflare 的 CDN, 因此服务器如下所示.

```shell
server: cloudflare
```

#### Vary

该字段可用于对缓存进行控制, 它的字段值接收一系列其他首部字段名.

```shell
vary: Accept-Encoding,Cookie
```

上面这个例子中, 源服务器向代理服务器发送了 vary 字段, 代理服务器若要进行缓存, 只能对 Accept-Encoding 和 Cookie 进行缓存.

以 **Vary: Accept-Encoding** 为例, 当一个资源启用了 gzip 压缩, 并且被代理服务器缓存, 客户端如果不支持 gzip 压缩, 那么在这样的情况下将会得到不正确的数据(也就是压缩过的数据). 这将会使代理服务器缓存两个版本的资源: 一个是压缩过的, 一个是没压缩过的. 正确版本的资源将在请求头发送之后进行传输.

此外, IE 浏览器不缓存任何带有 Vary 头但值不为 Accept-Encoding 和 User-Agent 的资源. 所以通过这种方式添加这个头, 才能确保这些资源在 IE 下被缓存.

同一个请求, 经过内容协商后可能会有不同的字符集, 编码, 浏览器等版本. 比如, **Vary: Accept-Encoding**, **Vary: User-Agent**, 缓存代理必须要存储这些不同的版本.

当再收到相同的请求时, 代理就读取缓存里的 **Vary**, 对比请求头里相应的 **Accept-Encoding**, **User-Agent** 等字段, 如果和上一个请求的完全匹配, 比如都是**gzip**, **Chrome**, 就表示版本一致, 可以返回缓存的数据.

#### WWW-Authenticate

该字段告知客户端适用于访问请求 URI 所指定资源的认证方案和带参数提示的质询.

### 实体首部字段

#### Allow

该字段会告知客户端所支持的所有 HTTP 请求方法, 当服务端接收到不支持的 HTTP 方法时, 会返回 405 状态码, 并将所有能支持的 HTTP 方法写入首部字段.

```shell
Allow: GET, PUT
```

#### Content-Encoding

告知客户端服务器使用的内容编码方式.

```shell
content-encoding: br
```

#### Content-Language

告知客户端实体主体使用的自然语言. 与之配套的客户端请求头是 Accept-Language.

```shell
content-language: zh-CN
```

#### Content-Length

该字段表明了实体主体部分的大小, 单位是字节.

```shell
Content-Length: 4871261
```

#### Content-MD5

该字段用于检查报文主体在传输过程中是否保持完整性, 以及确认传输到达. 服务端对报文主体执行 MD5 算法, 获取一个 128 位的二进制数, 再通过 base64 编码后将结果写入 Content-MD5 字段值. 因为 HTTP 首部无法记录二进制值, 因此需要通过 Base64 进行处理. 客户端在接收到响应后再对报文主体执行一次相同的 MD5 算法. 将计算值于该字段值比较, 即可判断出报文主体的准确性.

```shell
Content-MD5: +PFVsTxtpDcj7t4+27tNKA==
```

#### Content-Range

该字段告知客户端作为响应返回的实体的哪个部分符合范围请求, 字段值以字节为单位.

#### Content-Type

非常常见的字段, 用来说明实体主体内对象的媒体类型.

```shell
content-type: application/json; charset=utf-8
```

这里多说一嘴 MIME. 我们知道 HTTP 的 body 可以传输非文本, 比如可以是图片, 视频等, 这些通过 MIME 来区分, 早在 HTTP 协议诞生之前就已经有了针对这种问题的解决方案, 不过它是用在电子邮件系统里的, 让电子邮件可以发送 ASCII 码以外的任意数据, 方案的名字叫做**多用途互联网邮件扩展**(Multipurpose Internet Mail Extensions), 简称为 MIME. 下面举几个例子:

- text: 即文本格式的可读数据, 我们最熟悉的应该就是 text/html 了, 表示超文本文档, 此外还有纯文本 text/plain, 样式表 text/css 等.
- image: 即图像文件, 有 image/gif, image/jpeg, image/png 等.
- audio/video: 音频和视频数据, 例如 audio/mpeg, video/mp4 等.
- application: 数据格式不固定, 可能是文本也可能是二进制, 必须由上层应用程序来解释. 常见的有 application/json, application/javascript, application/pdf 等, 另外, 如果实在是不知道数据是什么类型, 就会是 application/octet-stream, 即不透明的二进制数据.

#### Expires

该字段将资源失败的日期告诉客户端, 在 Expires 指定的时间之前, 响应的副本会一直被保存. 当超过指定的时间后, 缓存服务器在请求发送过来时, 转向源服务器请求资源. 当首部字段 Cache-Control 有指定的 max-age 时, 会优先处理 max-age.

关于缓存机制下一章会详细去讲.

#### Last-Modified

该字段指明资源的最终修改时间, 一般来讲, 该值就是 Request-URI 指定资源的被修改的时间.

### 头部字段的几个注意点

1. 字段名不区分大小写, 例如**Host**也可以写成**host**, 但首字母大写的可读性更好;
2. 字段名里不允许出现空格, 可以使用连字符 **-**, 但不能使用下划线 **\_**. 例如, **test-name** 是合法的字段名, 而 **test name** 和 **test_name** 是不正确的字段名;
3. 字段名后面必须紧接着 **:**, 不能有空格, 而 **:** 后的字段值前可以有多个空格;
4. 字段的顺序是没有意义的, 可以任意排列不影响语义;
5. 字段原则上不能重复, 除非这个字段本身的语义允许, 例如 Set-Cookie.

## HTTP 方法

| 方法名  | 描述                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| GET     | GET 请求会显示请求指定的资源. 一般来说 GET 方法应该只用于数据的读取, 而不应当用于会产生副作用的非幂等的操作中. 它期望的应该是而且应该是安全的和幂等的. 这里的安全指的是, 请求不会影响到资源的状态. 此外, GET 还可以搭配 URI 和其他头字段就能实现对资源更精细的操作. 比如搭配 # 可以用作锚点, 与 If-Modified-Since 字段就变成了**有条件的请求**, 仅当资源被修改时才会执行获取动作; 使用 Range 字段就是**范围请求**, 只获取资源的一部分数据 . |
| HEAD    | HEAD 方法与 GET 方法一样, 都是向服务器发出指定资源的请求. 但是, 服务器在响应 HEAD 请求时不会回传资源的响应主体, 而只返回头部. 这样, 我们可以不传输全部内容的情况下, 就可以获取服务器的响应头信息. HEAD 方法常被用于客户端查看服务器的性能.                                                                                                                                                                                                  |
| PUT     | PUT 请求会身向指定资源位置上传其最新内容, PUT 方法是幂等的方法. 通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容.                                                                                                                                                                                                                                                                                                   |
| POST    | POST 请求会 向指定资源提交数据, 请求服务器进行处理, 如: 表单数据提交, 文件上传等, 请求数据会被包含在请求体中. POST 方法是非幂等的方法, 因为这个请求可能会创建新的资源或/和修改现有资源.                                                                                                                                                                                                                                                     |
| TRACE   | TRACE 请求服务器回显其收到的请求信息, 该方法主要用于 HTTP 请求的测试或诊断.                                                                                                                                                                                                                                                                                                                                                                 |
| OPTIONS | OPTIONS 请求与 HEAD 类似, 一般也是用于客户端查看服务器的性能. 这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法, 该方法会用'\*'来代替资源名称, 向服务器发送 OPTIONS 请求, 可以测试服务器功能是否正常. JavaScript 的 XMLHttpRequest 对象进行 CORS 跨域资源共享时, 就是使用 OPTIONS 方法发送嗅探请求, 以判断是否有对指定资源的访问权限.                                                                                                |
| DELETE  | DELETE 请求用于请求服务器删除所请求 URI(统一资源标识符, Uniform Resource Identifier)所标识的资源. DELETE 请求后指定资源会被删除, DELETE 方法也是幂等的.                                                                                                                                                                                                                                                                                     |
| PATCH   | PATCH 方法出现的较晚, 它在 2010 年的 RFC 5789 标准中被定义. PATCH 请求与 PUT 请求类似, 同样用于资源的更新. 二者有以下两点不同: 1.PATCH 一般用于资源的部分更新, 而 PUT 一般用于资源的整体更新. 2.当资源不存在时, PATCH 会创建一个新的资源, 而 PUT 只会对已在资源进行更新.                                                                                                                                                                    |
| CONNECT | CONNECT 方法是 HTTP/1.1 协议预留的, 能够将连接改为管道方式的代理服务器. 通常用于 SSL 加密服务器的链接与非加密的 HTTP 代理服务器的通信.                                                                                                                                                                                                                                                                                                      |

GET, HEAD, PUT 和 DELETE 是幂等方法, 而 POST 不是幂等的.

### GET 和 POST 的区别

数据传输方式不同: GET 请求通过 URL 传输数据, 而 POST 的数据通过请求体传输.

安全性不同: POST 的数据因为在请求主体内, 所以有一定的安全性保证, 而 GET 的数据在 URL 中, 通过历史记录, 缓存很容易查到数据信息.

数据类型不同: GET 只允许 ASCII 字符, 而 POST 无限制

GET 无害: 刷新, 后退等浏览器操作 GET 请求是无害的, POST 可能重复提交表单

特性不同: GET 是安全(这里的安全是指只读特性, 就是使用这个方法不会引起服务器状态变化)且幂等(幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同), 而 POST 是非安全非幂等

其他: GET 和 POST 本质上就是 TCP 链接, 并无差别. 但是由于 HTTP 的规定和浏览器/服务器 的限制, 导致他们在应用过程中体现出一些不同. GET 产生一个 TCP 数据包;POST 产生两个 TCP 数据包.

### 请求方法的安全与幂等

在 HTTP 协议里, 所谓的**安全**是指请求方法不会**破坏**服务器上的资源, 即不会对服务器上的资源造成实质的修改.所谓的**幂等**实际上是一个数学用语, 被借用到了 HTTP 协议里, 意思是多次执行相同的操作, 结果也都是相同的, 即多次**幂**后结果**相等**.

GET 和 HEAD 既是安全的也是幂等的, DELETE 可以多次删除同一个资源, 效果都是**资源不存在**, 所以也是幂等的. POST 是**新增或提交数据**, 多次提交数据会创建多个资源, 所以不是幂等的; 而 PUT 是**替换或更新数据**, 多次更新一个资源, 资源还是会第一次更新的状态, 所以是幂等的.

## HTTP 状态码

HTTP 状态码负责表示客户端 HTTP 请求的返回结果, 标记服务器端的处理是否正常, 通知出现的错误等工作.

### 1xx 信息类状态码

| 状态码 | 状态码英文名称      | 描述                                    |
| ------ | ------------------- | --------------------------------------- |
| 100    | Continue            | 服务器收到请求的初始部分, 请客户端继续. |
| 101    | Switching Protocols | 服务器根据客户端请求切换协议            |

1xx 的状态码表示一个临时的响应, 仅由状态行和可选头构成, 由空行结尾. 对该类状态码, 不需要头部. 该类状态码在 HTTP/1.1 引入, 因此服务器禁止向 HTTP1.0 的客户端响应 1xx 状态码.

对于 100 (Continue) 状态码, 客户端应该继续它的请求. 这个过渡的响应用于告知客户端, 请求的初始部分已经被服务器收到, 并且没有被服务器拒绝. 客户端应该继续发送剩余的请求, 如果请求已经完成, 就忽略这个响应. 服务器必须在请求完成后发送一个最终的响应.

100 状态码的用途主要是, 允许客户端发送带请求体的请求前, 判断服务器是否愿意接收请求 (通过请求头). 在某些情况下, 如果服务器在不看请求体的情况下就拒绝请求时, 客户端仍然发送请求体是不恰当的或低效的.

### 2xx 成功状态码

| 状态码 | 状态码英文名称                | 描述                                                                                                                                                                |
| ------ | ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 200    | OK                            | 请求成功, 响应主体包含了具体的数据. 最常见, 一般 GET 和 POST 请求会返回此状态码.                                                                                    |
| 201    | Created                       | 已创建, 一般 PUT 请求会返回此状态码.                                                                                                                                |
| 202    | Accepted                      | 服务器已接收到请求, 但还未处理完成.                                                                                                                                 |
| 203    | Non-Authoritative Information | 非授权信息. 请求成功, 但元信息不在原始服务器上, 而是资源的一个副本. 若中间节点上有一份资源副本, 但无法或没有对它发出的与资源有关的元信息进行验证, 就会出现这种情况. |
| 204    | No Content                    | 响应报文中无主体部分. 一般 DELETE 请求会返回此状态码.                                                                                                               |
| 205    | Reset Content                 | 负责告知浏览器清除当前页面中所有 HTML 元素.                                                                                                                         |
| 206    | Partial Content               | 成功执行一个部分或 Range 请求. 客户端可以在首部中指定请求某个范围内的文件. 该状态响应头部必须包含 Content-Range, Date, 以及 ETag 或 Content-Location.               |

206 状态码一般是在下载大文件时会遇到, 它表示请求已成功, 并且主体包含所请求的数据区间, 该数据区间是在请求的 Range 首部指定. 下图中, 我的博客在获取音频文件时返回了 206 状态码.

![206 状态码](https://edge.yancey.app/beg/Jietu20190503-223321.jpg)

### 3xx 重定向状态码

| 状态码 | 状态码英文名称     | 描述                                                                                                                                                                                                    |
| ------ | ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 300    | Multiple Choices   | 返回一个有多个链接选项的页面, 用户自行选择要跳转的页面. (啊我想到的某站, 好涩                                                                                                                           |
| 301    | Moved Permanently  | 永久重定向, 请求的 URL 已被移除. 响应的 Location 首部包含现在所处的位置.                                                                                                                                |
| 302    | Found              | 与 301 类似, 客户端本次应使用响应中的临时 URL, 将来的请求任使用以前的 URL. 响应的 Location 首部包含现在所处的位置. 浏览器看到这个 302 就知道这只是暂时的情况, 不会做缓存优化, 第二天还会访问原来的地址. |
| 303    | See Other          | 告知客户端使用另一个 URL 来获取资源. 其主要目的是, 允许 POST 请求的响应将客户端定向的某一个资源上去.                                                                                                    |
| 304    | Not Modified       | 若客户端发起一个有条件的 GET 请求, 而资源未被修改, 可以使用该状态码说明资源未被修改.                                                                                                                    |
| 305    | Use Proxy          | 必须通过代理来访问这一资源, 代理有 Location 首部给出. 需要知道的是, 客户端接收到这一状态时, 不应该假定所有请求都经过代理.                                                                               |
| 307    | Temporary Redirect | 和 302 相同, 但重定向后请求里的方法和实体不允许变动, 含义比 302 更明确                                                                                                                                  |
| 308    | Permanent Redirect | 不允许重定向后的请求变动, 但它是 301 永久重定向的含义                                                                                                                                                   |

### 4xx 客户端错误状态码

| 状态码 | 状态码英文名称                                   | 描述                                                                              |
| ------ | ------------------------------------------------ | --------------------------------------------------------------------------------- |
| 400    | Bad Request                                      | 告知客户端它发送了一个错误的请求.                                                 |
| 401    | Unauthorized                                     | 与适当首部一同返回, 告知客户端在请求之前先进行认证.                               |
| 403    | Forbidden                                        | 请求被拒绝.                                                                       |
| 404    | Not Found                                        | 服务器无法找到请求的 URL.                                                         |
| 405    | Method Not Allowed                               | 客户端使用不支持的方法请求 URL. 应该在首部使用 Allow 告知客户端正确的方法.        |
| 406    | Not Acceptable                                   | 服务器端无法提供与 Accept-Charset 以及 Accept-Language 消息头指定的值相匹配的响应 |
| 407    | Proxy Authentication Required                    | 代理服务器要求客户端验证.                                                         |
| 408    | Request Timeout                                  | 客户端完成请求时间过长, 服务器可以关闭链接.                                       |
| 409    | Conflict                                         | 服务器认为该请求可能引起冲突. 响应主体中应包含冲突的主体的描述.                   |
| 410    | Gone                                             | 与 404 类似, 只是服务器曾经拥有此资源, 后来被移除.                                |
| 411    | Length Required                                  | 服务器要求请求报文中包含 Content-Length 首部.                                     |
| 412    | Precondition Failed                              | 客户端发起条件请求, 其中有条件失败.                                               |
| 413    | Request Entity Too LargeRequest Entity Too Large | 客户端发送的主体部分比服务器能够活希望处理的要大.                                 |
| 414    | Request URI Too Long                             | URL 过长.                                                                         |
| 415    | Unsupported Media Type                           | 服务器无法理解或无法支持客户端发送的内容类型.                                     |
| 416    | Requested Range Not Satisfiable                  | 请求范围无效或无法满足.                                                           |
| 417    | Expectation Failed                               | 请求首部包含 Expect 期望, 但服务器无法满足.                                       |
| 429    | Too Many Requests                                | 短时间内发送了太多请求                                                            |
| 431    | Request Header Fields Too Large                  | 请求头太大                                                                        |

### 5xx 服务端错误状态码

| 状态码 | 状态码英文名称           | 描述                                                                                               |
| ------ | ------------------------ | -------------------------------------------------------------------------------------------------- |
| 500    | Internal Server Error    | 服务器遇到一个妨碍它提供服务的错误.                                                                |
| 501    | Not Implemented          | 客户端发起的请求超出服务器能力范围, 如使用了不支持的方法.                                          |
| 502    | Bad Gateway              | 无效网关. 通常不是这上游服务器关闭, 而是使用了上游服务器不同意协议交换数据.                        |
| 503    | Service Unavailable      | 服务器暂时无法提供服务. 若服务器知道服务什么时间可以使用, 可以在响应头中加入 Retry-After 首部说明. |
| 504    | Gateway Timeout          | 于 408 类似, 只是这里的响应来自一个网关或代理, 它们在等待另一个服务器响应对其请求响应时超时.       |
| 505    | HTTP Version Not Support | 服务器收到的请求使用了它无法支持的协议版本.                                                        |
|        |                          |                                                                                                    |

## Proxy

代理(Proxy)是 HTTP 协议中请求方和应答方中间的一个环节. 作为**中转站**. 既可以转发客户端的请求. 也可以转发服务器的应答. 常见的有四种:

- 匿名代理: 完全**隐匿**了被代理的机器. 外界看到的只是代理服务器;
- 透明代理: 顾名思义. 它在传输过程中是**透明开放**的. 外界既知道代理. 也知道客户端;
- 正向代理: 靠近客户端. 代表客户端向服务器发送请求;
- 反向代理: 靠近服务器端. 代表服务器响应客户端的请求;

比如 CDN 就是一种代理. 它代替源站服务器响应客户端的请求. 通常扮演着透明代理和反向代理的角色. 由于代理是在传输过程中插入了一个**中间层**, 它可以做很多事情:

- 负载均衡: 把访问请求均匀分散到多台机器. 实现访问集群化;
- 内容缓存: 暂存上下行的数据. 减轻后端的压力;
- 安全防护: 隐匿 IP, 使用 WAF 等工具抵御网络攻击. 保护被代理的机器;
- 数据处理: 提供压缩, 加密等额外的功能.

### HTTP 的代理服务

所谓的**代理服务**就是指服务本身不生产内容, 而是处于中间位置转发上下游的请求和响应, 具有双重身份: 面向下游的用户时, 表现为服务器, 代表源服务器响应客户端的请求; 而面向上游的源服务器时, 又表现为客户端, 代表客户端发送请求. 由于代理处在 HTTP 通信过程的中间位置, 相应地就对上屏蔽了真实客户端, 对下屏蔽了真实服务器, 简单的说就是**欺上瞒下**. 在这个中间层的**小天地**里就可以做很多的事情, 为 HTTP 协议增加更多的灵活性, 实现客户端和服务器的**双赢**.

代理最基本的一个功能是**负载均衡**. 因为在面向客户端时屏蔽了源服务器, 客户端看到的只是代理服务器, 源服务器究竟有多少台, 是哪些 IP 地址都不知道. 于是代理服务器就可以掌握请求分发的**大权**, 决定由后面的哪台服务器来响应请求. 代理中常用的负载均衡算法有随机, 轮询, 一致性 hash, 最近最少使用, 链接最少等等, 这些算法的目标都是尽量把外部的流量合理地分散到多台源服务器, 提高系统的整体资源利用率和性能.

![代理服务](https://edge.yancey.app/beg/n904g6f7-1647701515724.webp)

负载均衡的同时, 代理服务还可以执行更多的功能, 比如:

- 健康检查: 使用**心跳**等机制监控后端服务器, 发现有故障就及时**踢出**集群, 保证服务高可用;
- 安全防护: 保护被代理的后端服务器, 限制 IP 地址或流量, 抵御网络攻击和过载;
- 加密卸载: 对外网使用 SSL/TLS 加密通信认证, 而在安全的内网不加密, 消除加解密成本;
- 数据过滤: 拦截上下行的数据, 任意指定策略修改请求或者响应;
- 内容缓存: 暂存, 复用服务器响应.

当然代理也有他的缺点, 比如代理会增加链路长度, 在代理上做一些复杂的处理. 会很耗费性能, 增加响应时间.

### 代理相关头字段

#### Via

代理隐藏了真实客户端和服务器, 如果双方想要获得这些**丢失**的原始信息,需要用字段 **Via** 标明代理的身份. Via 是一个通用字段, 请求头或响应头里都可以出现. 每当报文经过一个代理节点, 代理服务器就会把自身的信息追加到字段的末尾, 就像是经手人盖了一个章. 如果通信链路中有很多中间代理, 就会在 Via 里形成一个链表, 这样就可以知道报文究竟走过了多少个环节才到达了目的地.

例如下图中有两个代理: proxy1 和 proxy2, 客户端发送请求会经过这两个代理, 依次添加就是 **Via:proxy1, proxy2**, 等到服务器返回响应报文的时候就要反过来走, 头字段就是 **Via:proxy2, proxy1**.

![Via](https://edge.yancey.app/beg/116rqpx3-1647707215943.webp)

#### X-Forwarded-For 和 X-Real-IP

Via 字段只解决了客户端和源服务器判断是否存在代理的问题, 还不能知道对方的真实信息. 但服务器的 IP 地址应该是保密的, 关系到企业的内网安全, 所以一般不会让客户端知道. 不过反过来, 通常服务器需要知道客户端的真实 IP 地址, 方便做访问控制, 用户画像, 统计分析. HTTP 标准里并没有为此定义头字段, 但常见的是 X-Forwarded-For 和 X-Real-IP.

**X-Forwarded-For** 的字面意思是**为谁而转发**, 形式上和 **Via** 差不多, 也是每经过一个代理节点就会在字段里追加一个信息. 但 **Via** 追加的是代理主机名(或者域名), 而 **X-Forwarded-For** 追加的是请求方的 IP 地址. 所以, 在字段里最左边的 IP 地址就是客户端的地址.

**X-Real-IP** 是另一种获取客户端真实 IP 的手段, 它的作用很简单, 就是记录客户端 IP 地址, 没有中间的代理信息, 相当于是 **X-Forwarded-For** 的简化版. 如果客户端和源服务器之间只有一个代理, 那么这两个字段的值就是相同的.

此外还有 **X-Forwarded-Host** 和 **X-Forwarded-Proto**, 它们的作用与 **X-Real-IP** 类似, 只记录客户端的信息, 分别是客户端请求的原始域名和原始协议名.

### 代理协议

有了 **X-Forwarded-For** 等头字段, 源服务器就可以拿到准确的客户端信息了. 但对于代理服务器来说它并不是一个最佳的解决方案. 因为通过 **X-Forwarded-For** 操作代理信息必须要解析 HTTP 报文头, 这对于代理来说成本比较高, 原本只需要简单地转发消息就好, 而现在却必须要费力解析数据再修改数据, 会降低代理的转发性能. 另一个问题是 **X-Forwarded-For** 等头必须要修改原始报文, 而有些情况下是不允许甚至不可能的(比如使用 HTTPS 通信被加密).

因此就出现了一个专门的**代理协议**(The PROXY protocol), 它由知名的代理软件 HAProxy 所定义. **代理协议**有 v1 和 v2 两个版本, v1 和 HTTP 差不多, 也是明文, 而 v2 是二进制格式. 以 v1 为例, 它相当于在 HTTP 报文头前又加了一个头. 例如下面的这个例子, 在 GET 请求行前多出了 PROXY 信息行, IP 地址类型是 TCP4, 客户端的真实 IP 地址是 1.1.1.1, 端口号是 55555; 而代理服务器的 IP 地址是 2.2.2.2, 端口号是 80.

```shell
PROXY TCP4 1.1.1.1 2.2.2.2 55555 80\r\n
GET / HTTP/1.1\r\n
Host: www.xxx.com\r\n
\r\n
```

## 谈一谈 keep-alive

在 http 早期, 每个 http 请求都要求打开一个 tcp socket 连接, 并且使用一次之后就断开这个 tcp 连接.

使用 keep-alive 可以改善这种状态, 即在一次 TCP 连接中可以持续发送多份数据而不会断开连接. 通过使用 keep-alive 机制, 可以减少 tcp 连接建立次数, 也意味着可以减少 TIME_WAIT 状态连接, 以此提高性能和提高 httpd 服务器的吞吐率.

但是, keep-alive 并不是银弹, 长时间的 tcp 连接容易导致系统资源无效占用. 配置不当的 keep-alive, 有时比重复利用连接带来的损失还更大. 所以, 正确地设置 `keep-alive timeout` 时间非常重要.

### keep-alive timeout

Httpd 守护进程, 一般都提供了 keep-alive timeout 时间设置参数. 比如 nginx 的 keepalive_timeout, 和 Apache 的 KeepAliveTimeout. 这个 keepalive_timout 时间值意味着:一个 http 产生的 tcp 连接在传送完最后一个响应后, 还需要 hold 住 keepalive_timeout 秒后, 才开始关闭这个连接.

当 httpd 守护进程发送完一个响应后, 理应马上主动关闭相应的 tcp 连接, 设置 keepalive_timeout 后, httpd 守护进程会想说:""再等等吧, 看看浏览器还有没有请求过来"", 这一等, 便是 keepalive_timeout 时间. 如果守护进程在这个等待的时间里, 一直没有收到浏览发过来 http 请求, 则关闭这个 http 连接.

## HTTP/2

在之前 HTTP 有 0.9, 1.0, 1.1, 但为什么不叫 HTTP 2.0? 工作组特别给出了解释, 他们认为以前的 **1.0**, **1.1** 造成了很多的混乱和误解, 让人在实际的使用中难以区分差异, 所以就决定 HTTP 协议不再使用小版本号(minor version), 只使用大版本号(major version), 从今往后 HTTP 协议不会出现 HTTP/2.0, 2.1, 只会有 **HTTP/2**, **HTTP/3**.

HTTP/2 首要目标是兼容 HTTP/1, 保留和 HTTP/1 一致的请求方法, URI, 状态码, 头字段等概念. 但在**语法**层做了**天翻地覆**的改造, 完全变更了 HTTP 报文的传输格式:

- 使用二进制格式传输:HTTP1.x 协议以换行符作为纯文本的分隔符, 而 HTTP2 将所有传输的信息分割为更小的消息和帧, 并采用二进制格式对它们编码.
- 头部压缩:使用 HPACK 算法
- 多路复用:多个请求可以共用一个 TCP 连接, 同一个请求和响应用一个流来表示, 并有唯一的流 ID 来标识. 多个请求和响应在 TCP 连接中可以乱序发送, 到达目的地后再通过流 ID 重新组建
- 服务器主动推送, 减少请求的延迟:除了对最初请求的响应外, 服务器还可以向客户端推送额外资源, 而无需客户端明确地请求
- 默认使用加密:虽然 HTTP/2 支持 HTTP, 但当下浏览器要求 HTTP/2 的必须使用 HTTPS, 因此在事实上 HTTP/2 必须是加密的.

下面是 HTTP, HTTPS, HTTP/2 的区别:

![HTTP, HTTPS, HTTP/2 的区别](https://edge.yancey.app/beg/g7fvsi0l-1649168121512.webp)

### 头部压缩

HTTP/1 里可以用头字段 **Content-Encoding** 指定 Body 的编码方式, 比如用 gzip 压缩来节约带宽, 但报文的另一个组成部分 Header 却被无视了, 没有针对它的优化手段. 由于报文 Header 一般会携带几百字节甚至上千字节, 且请求响应报文里有很多字段值都是重复的, 非常浪费, **长尾效应**导致大量带宽消耗在了这些冗余度极高的数据上.

为此, HTTP/2 开发了专门的 **HPACK** 算法, 它是一个**有状态**的算法, 需要客户端和服务器各自维护一份**索引表**, 压缩和解压缩就是查表和更新表的操作; 此外还釆用哈夫曼编码来压缩整数和字符串, 可以达到 50%-90% 的高压缩率. 该算法的基本原理如下:

- 客户端与服务端根据 [RFC 7541 的附录 A](https://datatracker.ietf.org/doc/html/rfc7541#appendix-A), 维护一份共同的静态字典(Static Table), 其中包含了常见头部名及常见头部名称与值的组合的代码;
- 客户端和服务端根据先入先出的原则, 维护一份可动态添加内容的共同动态字典(Dynamic Table);
- 客户端和服务端根据 [RFC 7541 的附录 B](https://datatracker.ietf.org/doc/html/rfc7541#appendix-B), 支持基于静态的霍夫曼编码(Huffman Coding).

为了方便管理和压缩, HTTP/2 废除了原有的起始行概念, 把起始行里面的请求方法, URI, 状态码等统一转换成了**头字段**的形式, 并且给这些**不是头字段的头字段**起了个特别的名字, **伪头字段**(pseudo-header fields). 而起始行里的版本号和错误原因短语因为没什么大用, 顺便也给废除了.

为了与**真头字段**区分开来, 这些**伪头字段**会在名字前加一个 **:**, 比如 **:authority**, **:method**, **:status**, 分别表示的是域名, 请求方法和状态码. 现在 HTTP 报文头就简单了, 全都是**Key-Value**形式的字段, 于是 HTTP/2 就为一些最常用的头字段定义了一个只读的**静态表**(Static Table).

![静态表](https://edge.yancey.app/beg/wcm2t3nc-1649165120526.jpg)

但如果表里只有 Key 没有 Value, 或者是自定义字段根本找不到该怎么办呢? 这就要用到**动态表**(Dynamic Table), 它添加在静态表后面, 结构相同, 但会在编码解码的时候随时更新. 比如说, 第一次发送请求时的**user-agent**字段长是一百多个字节, 用哈夫曼压缩编码发送之后, 客户端和服务器都更新自己的动态表, 添加一个新的索引号 **65**. 那么下一次发送的时候就不用再重复发那么多字节了, 只要用一个字节发送编号就好.

再谈一谈霍夫曼编码, 它的算法原理就是根据要处理的字符串, 获取每个 char 出现的频率, 出现频率**越高的**, 换算成哈夫曼编码(二进制)的长度就**越短**, 这便使编码之后的字符串的平均长度, 期望值降低, 从而达到无损压缩数据的目的. 霍夫曼树又称最优二叉树, 是一种带权路径长度最短的二叉树. 所谓树的带权路径长度, 就是树中所有的叶结点的权值乘上其到根结点的路径长度. [huffman visual](https://huffman.ooz.ie/) 这个网站用于根据字符串频率生成霍夫曼树, 并且把霍夫曼树绘制出来.

![霍夫曼编码](https://edge.yancey.app/beg/s48vf4ud-1649165130213.jpg)

### 二进制分帧

头部数据压缩之后, HTTP/2 就要把报文拆成二进制的帧准备发送. HTTP/1 使用的是纯文本形式的报文, 而 HTTP/2 不再使用肉眼可见的 ASCII 码, 转而使用二进制编码. 它把 TCP 协议的部分特性挪到了应用层, 把原来的 **Header+Body** 的消息**打散**为数个小片的二进制**帧**(Frame), 用 **HEADERS** 帧存放头数据, **DATA** 帧存放实体数据. 因此 HTTP/2 数据分帧后 **Header+Body** 的报文结构就完全消失了, 协议看到的只是一个个的**碎片**.

![二进制分帧](https://edge.yancey.app/beg/ay64kvym-1649165735074.webp)

HTTP/2 的帧结构有点类似 TCP 的段或者 TLS 里的记录, 但报头很小, 只有 9 字节, 非常地节省(可以对比一下 TCP 头, 它最少是 20 个字节).

帧开头是 3 个字节的**长度**(但不包括头的 9 个字节), 默认上限是 **2<sup>14</sup>**, 最大是 **2<sup>24</sup>**, 也就是说 HTTP/2 的帧通常不超过 16K, 最大是 16M.

长度后面的一个字节是**帧类型**, 大致可以分成**数据帧**和**控制帧**两类, HEADERS 帧和 DATA 帧属于数据帧, 存放的是 HTTP 报文, 而 SETTINGS, PING, PRIORITY 等则是用来管理流的控制帧. HTTP/2 总共定义了 10 种类型的帧, 但一个字节可以表示最多 256 种, 所以也允许在标准之外定义其他类型实现功能扩展. 这就有点像 TLS 里扩展协议的意思了, 比如 Google 的 gRPC 就利用了这个特点, 定义了几种自用的新帧类型.

第 5 个字节是非常重要的**帧标志**信息, 可以保存 8 个标志位, 携带简单的控制信息. 常用的标志位有 **END_HEADERS** 表示头数据结束, 相当于 HTTP/1 里头后的空行(`\r\n`), **END_STREAM** 表示单方向数据发送结束(即 EOS, End of Stream), 相当于 HTTP/1 里 Chunked 分块结束标志(`0\r\n\r\n`).

报文头里最后 4 个字节是流标识符, 也就是帧所属的**流**, 接收方使用它就可以从乱序的帧里识别出具有相同流 ID 的帧序列, 按顺序组装起来就实现了虚拟的**流**. 流标识符虽然有 4 个字节, 但最高位被保留不用, 所以只有 31 位可以使用, 也就是说, 流标识符的上限是 2^31, 大约是 21 亿.

![二进制帧结构](https://edge.yancey.app/beg/ttpuiy78-1649170205197.webp)

下面看一个实例分析:

![二进制帧分析](https://edge.yancey.app/beg/7uvvnb5w-1649259079642.webp)

在这个帧里, 开头的三个字节是**00010a**, 表示数据长度是 266 字节.

帧类型是 1, 表示 HEADERS 帧, 负载(payload)里面存放的是被 HPACK 算法压缩的头部信息.

标志位是 0x25, 转换成二进制有 3 个位被置 1. PRIORITY 表示设置了流的优先级, END_HEADERS 表示这一个帧就是完整的头数据, END_STREAM 表示单方向数据发送结束, 后续再不会有数据帧(即请求报文完毕, 不会再有 DATA 帧 /Body 数据).

最后 4 个字节的流标识符是整数 1, 表示这是客户端发起的第一个流, 后面的响应数据帧也会是这个 ID, 也就是说在 `stream[1]` 里完成这个请求响应.

### 流与多路复用

上面说到二进制分帧传输的是一个个零散的碎片, 但到达后需要组装起来方可使用. HTTP/2 为此定义了一个**流**(Stream)的概念, 它是**二进制帧的双向传输序列**, 同一个消息往返的帧会分配一个唯一的流 ID. 在一条 Connection 中, 不同的流可以穿插传递(多路复用), 但是同一条流的达到顺序必须是有序的, 一个流内的帧必须有序. 这就是**传输中无序, 接收时组装**.

因为**流**是虚拟的, 实际上并不存在, 所以 HTTP/2 就可以在一个 TCP 连接上用**流**同时发送多个**碎片化**的消息, 这就是常说的**多路复用**(Multiplexing), 即多个往返通信都复用一个连接来处理. 在**流**的层面上看, 消息是一些有序的**帧**序列, 而在**连接**的层面上看, 消息却是乱序收发的**帧**. 多个请求 / 响应之间没有了顺序关系, 不需要排队等待, 也就不会再出现**队头阻塞**问题, 降低了延迟, 大幅度提高了连接的利用率. 当然 TCP 还是存在队头阻塞的情况.

![多路复用](https://edge.yancey.app/beg/d7fd84kc-1649260136860.webp)

HTTP/2 的流比起 HTTP/1 并发多个连接有如下几点优势:

与 HTTP/1 **并发多个连接**不同, HTTP/2 的**多路复用**特性要求对一个域名(或者 IP)只用一个 TCP 连接, 所有的数据都在这一个连接上传输, 这样不仅节约了客户端, 服务器和网络的资源, 还可以把带宽跑满, 让 TCP 充分**吃饱**. 在 HTTP/1 里的长连接, 虽然是双向通信, 但任意一个时间点实际上还是单向的: 上行请求时下行空闲, 下行响应时上行空闲, 再加上**队头阻塞**, 实际的带宽打了个**对折**还不止. 而在 HTTP/2 里, **多路复用**则让 TCP 开足了马力, **全速狂奔**, 多个请求响应并发, 每时每刻上下行方向上都有流在传输数据, 没有空闲的时候, 带宽的利用率能够接近 100%. 所以, HTTP/2 只使用一个连接, 就能抵得过 HTTP/1 里的五六个连接.

HTTP/2 的流有如下特点:

- 流是可并发的, 一个 HTTP/2 连接上可以同时发出多个流传输数据, 也就是并发多请求, 实现**多路复用**;
- 客户端和服务器都可以创建流, 双方互不干扰;
- 流是双向的, 一个流里面客户端和服务器都可以发送或接收数据帧, 也就是一个**请求 - 应答**来回;
- 流之间没有固定关系, 彼此独立, 但流内部的帧是有严格顺序的;
- 流可以设置优先级, 让服务器优先处理, 比如先传 HTML/CSS, 后传图片, 优化用户体验;
- 流 ID 不能重用, 只能顺序递增, 客户端发起的 ID 是奇数, 服务器端发起的 ID 是偶数(客户端在一个连接里最多只能发出 **2<sup>30</sup>**, 也就是 10 亿个请求. 极端情况下, 如果 ID 用完了, 这个时候可以再发一个控制帧 **GOAWAY**, 真正关闭 TCP 连接);
- 在流上发送**RST_STREAM**帧可以随时终止流, 取消接收或发送;
- 第 0 号流比较特殊, 不能关闭, 也不能发送数据帧, 只能发送控制帧, 用于流量控制.

#### 流的状态

为了更好地描述运行机制, HTTP/2 借鉴了 TCP, 根据帧的标志位实现流状态转换.

- **idle**: 流空闲状态, 可以发送接收 HEADERS 帧;
- **open**: 流开启状态, idle 发送或者接受 HEADERS 帧后, 状态变更为开启;
- **half closed**: 发送包含 END_STREAM 帧的一端流转为本地半关闭 half closed(local), 表示客户端发送请求数据完毕, 等待服务端响应数据, 接受到服务端发送的 END_STREAM 进入 close 关闭状态. 接受 END_STREAM 帧的另一端称为远程半关闭状态 half closed(remote), 表示服务端知道客户端请求已经发送完毕, 处理结束后可以发送响应数据, 并发送 END_STREAM 到客户端, 进入 close 关闭状态;
- **close**: 流的关闭状态. 除了 half closed 数据发送结束关闭外, 发送 RST_STREAM(发生错误或取消)也可关闭流.

刚才也说过, 流 ID 不能重用, 所以流的生命周期就是 HTTP/1 里的一次完整的**请求 - 应答**, 流关闭就是一次通信结束. 下一次再发请求就要开一个新流(而不是新连接), 流 ID 不断增加, 直到到达上限, 发送 **GOAWAY** 帧开一个新的 TCP 连接, 流 ID 就又可以重头计数.

![流的状态](https://edge.yancey.app/beg/2xxucim5-1649260617976.webp)

#### 优先级控制

通过发送端向接收端发送优先级权重期待接收端给予资源分配支持, 接受端不保证一定遵守, 默认权重为 16. 优先级表达可以通过 HEADERS 或者单独发送 PRIORITY 帧实现.

![优先级控制](https://edge.yancey.app/beg/pz8qi0pl-1649302489872.jpeg)

#### 流依赖

客户端通过 PRIORITY 帧可以告诉服务端当前流所依赖的流, 形成流依赖树. 同一父级的各个字节点通过权重分配资源; 父级先分配资源传输结束后, 再分配子级资源.

#### 流量控制

流量控制是保护接收方的机制, 通过配额机制实现. 发送端每发送数据后 window 窗口大小相应的减少. 当发送端收到接收端 WINDOW_UPDATE 桢后 window 窗口增加. window 等于 0 则不可以进行发送, 窗口初始值为 65535 字节.

![流量控制](https://edge.yancey.app/beg/07g19489-1649302454219.jpeg)

### 服务端推送

HTTP/2 还在一定程度上改变了传统的**请求 - 应答**工作模式, 服务器不再是完全被动地响应请求, 也可以新建**流**主动向客户端发送消息. 比如, 在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS, CSS 文件发给客户端, 减少等待的延迟, 这被称为**服务器推送**(Server Push, 也叫 Cache Push).

### 强化安全

为兼容 HTTP/1, HTTP/2 可以使用 HTTP 也可以使用 HTTPS, 但浏览器要求 HTTP/2 必须使用 HTTPS, 因此**事实上**的 HTTP/2 是加密的. 不过, 为了区分**加密**和**明文**这两个不同的版本, HTTP/2 协议定义了两个字符串标识符:**h2** 表示加密的 HTTP/2, **h2c** 表示明文的 HTTP/2, 多出的那个字母 **c** 的意思是 **clear text**.

#### 连接前言

由于 HTTP/2**事实上**是基于 TLS, TLS 握手成功之后, 客户端必须要发送一个**连接前言**(connection preface), 用来确认建立 HTTP/2 连接. 这个**连接前言**是标准的 HTTP/1 请求报文, 使用纯文本的 ASCII 码格式, 请求方法是特别注册的一个关键字**PRI**, 全文只有 24 个字节. 连接前言是个 Magic String, 总之就是写死的一个字符串.

> PRISM 是棱镜的意思, 也就是斯诺登搞的那档子事.

```shell
PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n
```

#### 应用层协议协商 ALPN

在 HTTP/2 的末尾说一下**服务发现**. 在 URI 里用的都是 HTTPS 协议名, 没有版本标记, 浏览器怎么知道服务器支持 HTTP/2 呢? 为什么上来就能用 HTTP/2, 而不是用 HTTP/1 通信呢?

答案在 TLS 的扩展里, 有一个叫 **ALPN**(Application Layer Protocol Negotiation)的东西, 用来与服务器就 TLS 上跑的应用协议进行**协商**. 客户端在发起 **Client Hello** 握手的时候, 后面会带上一个 **ALPN** 扩展, 里面按照优先顺序列出客户端支持的应用协议.

服务器看到 ALPN 扩展以后就可以从列表里选择一种应用协议, 在 **Server Hello** 里也带上 **ALPN** 扩展, 告诉客户端服务器决定使用的是哪一种. 当然上面说道 HTTP/2 是可以不走 TLS 的, 故也不会有 ALPN 的过程. 它是通过头字段 `Connection: Upgrade` 配合 101 状态码来实现的.

![ALPN](https://edge.yancey.app/beg/f4dwtsz6-1649169172154.webp)

### HTTP/2 的缺点

以上就是 HTTP/2 的特点, 或者说优点. 但它仍然有一些不足.

- TCP 的队头阻塞并没有彻底解决. 在 HTTP/2 中, 多个请求是跑在一个 TCP 管道中的. 但当 HTTP/2 出现丢包时, 整个 TCP 都要开始等待重传, 那么就会阻塞该 TCP 连接中的所有请求, 有可能不如 HTTP1.1 的多个 TCP 连接 TCP 以及 TCP+TLS 建立连接的延时
- 在移动网络中发生 IP 地址切换的时候, 下层的 TCP 必须重新建连, 要再次**握手**, 经历**慢启动**, 而且之前连接里积累的 HPACK 字典也都消失了, 必须重头开始计算, 导致带宽浪费和时延.
- HTTP/2 对一个域名只开一个连接, 所以一旦这个连接出问题, 那么整个网站的体验也就变差了.
- 多路复用导致服务器压力上升, 多路复用没有限制同时请求数. 请求的平均数量与往常相同, 但实际会有许多请求的短暂爆发, 导致瞬时 QPS 暴增
- 多路复用容易 Timeout 大批量的请求同时发送, 由于 HTTP2 连接内存在多个并行的流, 而网络带宽和服务器资源有限, 每个流的资源会被稀释, 虽然它们开始时间相差更短, 但却都可能超时.

HTTP/2 不建议使用雪碧图, 这是因为 HTTP/2 中使用小颗粒化的资源, 优化了缓存, 而使用精灵图就相当于传输大文件, 但是大文件会延迟客户端的处理执行, 并且缓存失效的开销很昂贵, 很少数量的数据更新就会使整个精灵图失效, 需要重新下载(HTTP1 中使用精灵图是为了减少请求).

HTTP/2 不建议使用内联资源, HTTP1 中使用内联资源是为了减少请求, 内联资源没有办法独立缓存, 破坏了 HTTP/2 的多路复用和优先级策略.

HTTP/2 不建议使用域名分片, 域名分片是指利用多个域名和同一个 IP 地址建立 TCP 连接, 巧妙地避开了浏览器对并发连接数的限制

- 对于 HTTP/1 来说, 因为它没有多路复用, 所以这样能很好的缓解因为丢包重发而导致的队头阻塞
- 但对于 HTTP/2 来说, 多建立的 TCP 连接完全是浪费资源(两端的静态表和动态表, TCP 连接的成本等)

我们知道在 HTTP/2 中, 多个请求是跑在一个 TCP 管道中的, 如果其中任意一路数据流中出现了丢包的情况, 那么就会阻塞该 TCP 连接中的所有请求. 这不同于 HTTP/1.1, 使用 HTTP/1.1 时, 浏览器为每个域名开启了 6 个 TCP 连接, 如果其中的 1 个 TCP 连接发生了队头阻塞, 那么其他的 5 个连接依然可以继续传输数据. 所以随着丢包率的增加, HTTP/2 的传输效率也会越来越差. 有测试数据表明, 当系统达到了 2% 的丢包率时, HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好.

## HTTP/3

HTTP/2 虽然使用**帧**, **流**, **多路复用**, 没有了**队头阻塞**, 但这些手段都是在应用层里, 而在下层, 也就是 TCP 协议里, 还是会发生**队头阻塞**. 在 HTTP/2 把多个**请求 - 响应**分解成流, 交给 TCP 后, TCP 会再拆成更小的段(segment)依次发送.

在网络良好的情况下, 包可以很快送达目的地. 但如果网络质量比较差, 像手机上网的时候, 就有可能会丢包. 而 TCP 为了保证可靠传输, 有个特别的**丢包重传**机制, 丢失的包必须要等待重新传输确认, 其他的包即使已经收到了, 也只能放在缓冲区里, 上层的应用拿不出来, 只能**干着急**.

总之, 队头阻塞的万恶之源还是出在 TCP 协议上. Google 在推 SPDY 的时候就已经意识到了这个问题, 于是就又发明了一个新的**QUIC**协议, 让 HTTP 跑在 QUIC 上而不是 TCP 上. 而这个**HTTP over QUIC**就是 HTTP 协议的下一个大版本, HTTP/3.

![HTTP/3 协议栈](https://edge.yancey.app/beg/0l5whzf7-1649308022721.webp)

### QUIC

HTTP/3 有一个关键的改变, 那就是它把下层的 TCP**抽掉**了, 换成了 UDP. 因为 UDP 是无序的, 包之间没有依赖关系, 所以就从根本上解决了**队头阻塞**. UDP 是一个简单, 不可靠的传输协议, 只是对 IP 协议的一层很薄的包装, 和 TCP 相比, 它的结构更少. 而 HTTP/3 的官方传输层协议叫做 QUIC. QUIC 是集成了 TCP + HTTP/2 的多路复用 + TLS 等功能的一套综合协议.

QUIC 基于 UDP, 而 UDP 是**无连接**的, 根本就不需要**握手**和**挥手**, 所以天生就要比 TCP 快.

QUIC 也基于 UDP 实现了可靠传输, 保证数据一定能够抵达目的地. 它还引入了类似 HTTP/2 的**流**和**多路复用**, 单个**流**是有序的, 可能会因为丢包而阻塞, 但其他**流**不会受到影响.

为了防止网络上的中间设备(Middle Box)识别协议的细节, QUIC 全面采用加密通信, 可以很好地抵御窜改和**协议僵化**(ossification).

因为 TLS1.3 已于 2018 年正式发布, 所以 QUIC 就直接应用了 TLS1.3, 顺便也就获得了 0-RTT, 1-RTT 连接的好处. QUIC 内部**包含**了 TLS. 它使用自己的帧**接管**了 TLS 里的**记录**, 握手消息, 警报消息都不使用 TLS 记录, 直接封装成 QUIC 的帧发送, 省掉了一次开销.

QUIC 里的包分为**长包**和**短包**两类,**长包**的第一个字节高位是 1, 格式比较完整,而短包只有目标连接 ID.

QUIC 和 HTTP/3 的变长编码使用第一个字节的高两位决定整数的长度,最多是 8 个字节( 64 位),所以最大值是**2<sup>62</sup>**.

HTTP/3 的帧不再需要 ENDJHEADERS 标志位和 CONTINUATION 帧,因为帧的长度足够大(**2<sup>62</sup>**) ,无论是多大的头都可以用一个帧传输.

![QUIC](https://edge.yancey.app/beg/qc6x2dte-1649308370458.webp)

### QUIC 报文

QUIC 的基本数据传输单位是**包**(packet)和**帧**(frame), 一个包由多个帧组成, 包面向的是**连接**, 帧面向的是**流**.

QUIC 使用**不透明**的**连接 ID** 来标记通信的两个端点, 客户端和服务器可以自行选择一组 ID 来标记自己, 这样就解除了 TCP 里连接对 **IP 地址 + 端口**(即常说的四元组)的强绑定, 支持**连接迁移**(Connection Migration).

比如你下班回家, 手机会自动由 4G 切换到 WiFi. 这时 IP 地址会发生变化, TCP 就必须重新建立连接. 而 QUIC 连接里的两端连接 ID 不会变, 所以连接在**逻辑上**没有中断, 它就可以在新的 IP 地址上继续使用之前的连接, 消除重连的成本, 实现连接的无缝迁移.

![QUIC 报文](https://edge.yancey.app/beg/gcs9hgsc-1649310511324.webp)

QUIC 里的流与 HTTP/2 的流非常相似, 也是帧的序列. 但 HTTP/2 里的流都是双向的, 而 QUIC 则分为双向流和单向流.

QUIC 帧普遍采用变长编码, 最少只要 1 个字节, 最多有 8 个字节. 流 ID 的最大可用位数是 62, 数量上比 HTTP/2 的 **2<sup>31</sup>** 大大增加.

流 ID 还保留了最低两位用作标志, 第 1 位标记流的发起者, 0 表示客户端, 1 表示服务器；第 2 位标记流的方向, 0 表示双向流, 1 表示单向流. 所以 QUIC 流 ID 的奇偶性质和 HTTP/2 刚好相反, 客户端的 ID 是偶数, 从 0 开始计数.

### QUIC 如何实现可靠性的

- 纠错码： QUIC协议使用了类似于UDP协议的“单包丢失即所有数据包需要重新传输”的原则，并通过引入 FEC（Forward Error Correction）（前向纠错）机制根据一定的算法来构造冗余数据包以恢复丢失的数据包，提高数据传输可靠性。

- 拥塞控制： 为了避免网络的拥塞问题，QUIC协议在传输过程中引入了拥塞控制机制，且QUIC中的拥塞控制是面向连接的，即在连接的每个数据流上都运行拥塞控制算法，以保证连接中每个数据流可以公平分享网络带宽，从而使整个传输过程更加可靠。

- 流量控制： 与拥塞控制相对，流量控制主要是限制每个连接上的数据流的发送速率，避免过度发送对方无法处理的数据而导致数据的丢失或降低网络质量。QUIC协议中流量控制也是基于面向流的，即在每个数据流上单独进行流量控制处理。

### HTTP/3 协议

因为 QUIC 本身就已经支持了加密, 流和多路复用, 所以 HTTP/3 的工作减轻了很多, 把流控制都交给 QUIC 去做. 调用的不再是 TLS 的安全接口, 也不是 Socket API, 而是专门的 QUIC 函数.

HTTP/3 里仍然使用流来发送**请求 - 响应**, 但它自身不需要像 HTTP/2 那样再去定义流, 而是直接使用 QUIC 的流, 相当于做了一个**概念映射**.

HTTP/3 里的**双向流**可以完全对应到 HTTP/2 的流, 而**单向流**在 HTTP/3 里用来实现控制和推送, 近似地对应 HTTP/2 的 0 号流.

由于流管理被**下放**到了 QUIC, 所以 HTTP/3 里帧的结构也变简单了. 帧头只有两个字段：类型和长度, 而且同样都采用变长编码, 最小只需要两个字节.

HTTP/3 里的帧仍然分成数据帧和控制帧两类, HEADERS 帧和 DATA 帧传输数据, 但其他一些帧因为在下层的 QUIC 里有了替代, 所以在 HTTP/3 里就都消失了, 比如 RST_STREAM, WINDOW_UPDATE, PING 等.

![HTTP/3 报文](https://edge.yancey.app/beg/tn0swlz4-1649313879848.webp)

头部压缩算法在 HTTP/3 里升级成了 **QPACK**, 使用方式上也做了改变. 虽然也分成静态表和动态表, 但在流上发送 HEADERS 帧时不能更新字段, 只能引用, 索引表的更新需要在专门的单向流上发送指令来管理, 解决了 HPACK 的**队头阻塞**问题.

另外, QPACK 的字典也做了优化, 静态表由之前的 61 个增加到了 98 个, 而且序号从 0 开始, 也就是说 **:authority** 的编号是 0.

### HTTP/3 服务发现

和 HTTP/2 一样, HTTP/3 也需要支持服务发现功能. HTTP/3 没有指定默认的端口号, 也就是说不一定非要在 UDP 的 80 或者 443 上提供 HTTP/3 服务. 那么, 该怎么**发现** HTTP/3 呢?

这就要用到 HTTP/2 里的**扩展帧**了. 浏览器需要先用 HTTP/2 协议连接服务器, 然后服务器可以在启动 HTTP/2 连接后发送一个 **Alt-Svc** 帧, 包含一个 **h3=host:port** 的字符串, 告诉浏览器在另一个端点上提供等价的 HTTP/3 服务.

浏览器收到 **Alt-Svc** 帧, 会使用 QUIC 异步连接指定的端口, 如果连接成功, 就会断开 HTTP/2 连接, 改用新的 HTTP/3 收发数据.

### HTTP/3 的挑战

通过上面的分析, 我们相信在技术层面, HTTP/3 是个完美的协议. 不过要将 HTTP/3 应用到实际环境中依然面临着诸多严峻的挑战, 这些挑战主要来自于以下三个方面.

第一, 从目前的情况来看, 服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持. Chrome 虽然在数年前就开始支持 Google 版本的 QUIC, 但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异.

第二, 部署 HTTP/3 也存在着非常大的问题. 因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度, 这也是阻碍 QUIC 的一个重要原因.

第三, 中间设备僵化的问题. 这些设备对 UDP 的优化程度远远低于 TCP, 据统计使用 QUIC 协议时, 大约有 3% - 7% 的丢包率.

## 总结

### HTTP 的特点

- HTTP 是灵活可扩展的, 可以任意添加头字段实现任意功能;
- HTTP 是可靠传输协议, 基于 TCP/IP 协议尽量保证数据的送达;
- HTTP 是应用层协议, 比 FTP, SSH 等更通用功能更多, 能够传输任意数据;
- HTTP 使用了请求 - 应答模式, 客户端主动发起请求, 服务器被动回复请求;
- HTTP 本质上是无状态的, 每个请求都是互相独立, 毫无关联的, 协议不要求客户端或服务器记录请求相关的信息. 而 TCP 协议是有状态的, 一开始处于 CLOSED 状态, 连接成功后是 ESTABLISHED 状态, 断开连接后是 FIN-WAIT 状态, 最后又是 CLOSED 状态. 这些状态就需要 TCP 在内部用一些数据结构去维护.

## HTTP 优缺点

- HTTP 最大的优点是简单, 灵活和易于扩展;
- HTTP 拥有成熟的软硬件环境, 应用的非常广泛, 是互联网的基础设施;
- HTTP 是无状态的, 可以轻松实现集群化, 扩展性能, 但有时也需要用 Cookie 技术来实现有状态;
- HTTP 是明文传输, 数据完全肉眼可见, 能够方便地研究分析, 但也容易被窃听;
- HTTP 是不安全的, 无法验证通信双方的身份, 也不能判断报文是否被篡改;
- HTTP 的性能不算差, 但不完全适应现在的互联网, 还有很大的提升空间(队头阻塞).

欢迎关注我的微信公众号: 进击的前端

![进击的前端](https://edge.yancey.app/beg/qrcode_for_gh_541158abcb21_344.jpg)

## 参考

《图解 HTTP》 -- 上野 宣

[express 中 cookie 的使用和 cookie-parser 的解读](https://segmentfault.com/a/1190000004139342)

[谈谈 cookie](http://barryliu1995.studio/2017/10/11/谈谈cookie)

[把 cookie 聊清楚](https://juejin.im/post/59d1f59bf265da06700b0934)

[[读] 这一次,让我们再深入一点 - HTTP 报文](https://juejin.im/post/5a4f782c5188257326469d7c)

[HTTP 状态码详解之 100](https://blog.lyz810.com/article/2016/11/http-statuscode-100-continue/)

[你所知道的 3xx 状态码](https://aotu.io/notes/2016/01/28/3xx-of-http-status/index.html)
","2025-02-02 03:08:11.428294","2025-02-02 03:08:11.428294"
"ac74a711-bb4d-4c55-8610-4b8f20127b3b","{JavaScript}",0,0,False,"https://edge.yancey.app/beg/getty_578458917_2000133020009280183_117186.jpg","也谈 JavaScript 的 this","最近颇有些不宁静，时代的风吹得太猛烈，想到这一年已经过去四分之一，也差不多要准备未来的事情了。关于 this 的文章网上不胜枚举，这篇也无非是拾人牙慧，权当给自己留份资料，也希望能帮助到他人。从原理到用法到面试题，洋洋洒洒一万多字，基本上是够用了。","## 从一道面试题说起

这是一位京东小姐姐出的面试题, 不出意外这道题代表了大厂对于 this 的考察要求. 浏览器执行下面的代码, 会输出什么呢?

```js
var number = 5;
var obj = {
  number: 3,
  fn: (function() {
    var number;
    this.number *= 2;
    number = number * 2;
    number = 3;
    return function() {
      var num = this.number;
      this.number *= 2;
      console.log(num);
      number *= 3;
      console.log(number);
    };
  })(),
};
var fn = obj.fn;
fn.call(null);
obj.fn();
console.log(window.number);

```

## 什么是 this

this 是 JavaScript 中的一个关键字. 它一般用于函数体内, 依赖函数**调用时**的上下文条件.

所以 this 是在运行时绑定的, 而非在编写代码的过程. 随着函数使用场合的不同, this 的指向也会发生变化. 但是有一个总的原则: **那就是 this 总会指向调用函数的那个对象**.

_*本文只考虑浏览器非严格模式环境._

## 为什么会有 this

JavaScript 之所以有 this , 跟内存的数据结构有关, 这里直接引用阮一峰老师的例子.

```ts
const obj = { foo: 5 };
```

上述代码将一个对象赋值给变量 obj, JS 引擎会在内存里生成一个对象 `{ foo: 5 }`, 然后把这个对象的内存地址赋值给变量 obj. 因此, 变量 obj 只是个地址(指针), 如果要读取 `obj.foo`, 则需要 JavaScript 引擎从 `obj` 中拿到内存地址, 然后再从该地址读出原始的对象. 我们知道对象里的每个属性都对应着一个属性描述符对象, 因此上面的 foo 就是以下图方式保存的.

![普通对象保存到堆](https://edge.yancey.app/beg/bg2018061802.png)

关于属性描述符可以参照我的一篇文章 [Object.defineProperty() | JavaScript API 全解析](https://js.yanceyleo.com/ecmascript/Object/defineProperty/).

但当属性的属性值是一个**函数**时, 将不会按照上述方式来保存了.

```ts
const obj = { foo: function() {} };
```

JavaScript 引擎会将函数单独保存到内存中, 然后将函数的内存地址赋值给 `foo` 属性的 `value` 属性, 这也就说明了函数在内存中是个独立的个体, 调用它的方式不同, 结果也会不同.

![函数保存到单独内存](https://edge.yancey.app/beg/bg2018061803.png)

## this 的绑定规则

this 的绑定规则有四种, 分别是:

- 默认绑定
- 隐式绑定
- 显式绑定
- new 绑定

### 默认绑定

默认绑定是在不使用其他绑定规则时的规则, 通常是独立函数的调用.

```ts
function greeting() {
  console.log(`Hello, ${this.name}`);
}

var name = 'Yancey';

greeting(); // Hello, Yancey
```

### 隐式绑定

隐式绑定指的是在一个对象上调用函数.

在此示例中, 通过 obj 调用 greeting 方法, this 就指向了 obj

```ts
function greeting() {
  console.log(`Hello, ${this.name}`);
}

var name = 'Sayaka';

var obj = {
  name: 'Yancey',
  greeting,
};
obj.greeting(); // Hello, Yancey
```

下面的代码中, 将 obj.greeting 赋给了一个全局的变量 `otherGreeting`, 所以在执行 `otherGreeting` 时, `this` 会指向 `window`.

```ts
function greeting() {
  console.log(`Hello, ${this.name}`);
}

var name = 'Sayaka';

var obj = {
  name: 'Yancey',
  greeting,
};

var otherGreeting = obj.greeting;

otherGreeting(); // Hello, Sayaka
```

如果涉及到回调函数(异步操作), 就要小心隐式绑定的丢失问题. 看下面这个例子.

第一次调用, 因为涉及到异步, 所以 this 指向了 window, 此时 this.name 就是 Mitsuha

第二次调用, 可以理解为将 `obj2.greeting` 赋值给一个新的变量, 所以此时 this 也是指向了 window

第三次调用则是隐式绑定, 此时 this 指向 obj2

```ts
function greeting() {
  console.log(`Hello, ${this.name}`);
}
var obj1 = {
  name: 'Yancey',
  greeting() {
    setTimeout(function() {
      console.log(`Hello, ${this.name}`);
    });
  },
};
var obj2 = {
  name: 'Sayaka',
  greeting,
};
var name = 'Mitsuha';

obj1.greeting(); // Hello, Mitsuha

setTimeout(obj2.greeting, 100); // Hello, Mitsuha


setTimeout(function() {
  obj2.greeting(); // Hello, Sayaka
}, 200);
```

### 显式绑定

显示绑定就是通过 call, apply, bind 来显式地指定 this 的绑定对象. 三者的第一个参数都是传递 `this 指向的对象`, call 与 apply 的区别是前者从第二个参数起传递一个参数序列, 后者传递一个数组, call, apply 和 bind 的区别是前两个都会立即执行对应的函数, 而 bind 方法不会.

所以我们通过 call 显式绑定 this 指向的对象来解决隐式绑定丢失的问题.

```ts
function greeting() {
  console.log(`Hello, ${this.name}`);
}

var obj = {
  name: 'Sayaka',
  greeting,
};

var name = 'Mitsuha';

var otherGreeting = obj.greeting;

// 强制将 this 绑定到 obj
otherGreeting.call(obj); // Hello, Sayaka

setTimeout(obj.greeting.call(obj), 100); // Hello, Sayaka
```

但是显式绑定不一定保证能完全解决隐式绑定丢失的问题. 下面这个例子中, 虽然将 this 显式的指向了 obj, 但在执行 fn() 时, 相当于将 `obj.greeting` 赋值给了 fn, 所以此时又发生了隐式绑定丢失.

```ts
function greeting() {
  console.log('Hello,', this.name);
}
var obj = {
  name: 'Yancey',
  greeting,
};
var name = 'Sayaka';
var otherGreeting = function(fn) {
  fn();
};

otherGreeting.call(obj, obj.greeting); // Hello, Sayaka

// 我们可以直接传递函数的调用给 fn
otherGreeting.call(obj, obj.greeting()); // Hello, Yancey
```

除了直接传递函数的调用, 我们也可以给 fn() 也加上显式绑定, 看下面这个例子. 因为 otherGreeting 的 this 指向了 obj, 在调用时, `fn.call(this);` 等价于 `obj.greeting.call(this)`,  显然此时 this 指向的就是 obj.

```ts
function greeting() {
  console.log('Hello,', this.name);
}
var obj = {
  name: 'Yancey',
  greeting,
};
var name = 'Sayaka';
var otherGreeting = function(fn) {
  fn.call(this);
};

otherGreeting.call(obj, obj.greeting); // Hello, Yancey
```

在使用显式绑定时, 如果将 **null**, **undefined** 作为第一个参数传入 call, apply 或者 bind, 实际应用的是默认绑定.

```ts
function greeting() {
  console.log('Hello,', this.name);
}
var obj = {
  name: 'Yancey',
  greeting,
};
var name = 'Sayaka';

var otherGreeting = obj.greeting;

// this 仍然指向 window
otherGreeting.call(null); // Hello, Sayaka
```

最后看一个例子, foo 函数显式绑定到 bar 对象上, 会导致 bar 的 myName 的值发生变化.

```ts
let bar = {
  myName : ""A"",
  test1 : 1
}
function foo(){
  this.myName = ""B""
}
foo.call(bar)
console.log(bar) // { myName: 'B', test1: 1 }
```

### new 绑定

首先来回忆一下 new 做了什么:

- 首先创建一个空对象
- 将构造函数的 prototype 赋值给此对象的 \_\_proto\_\_
- 将构造函数的 this 指向此对象
- 返回此对象

```ts
function pollfillNew(Con, ...args) {
  let obj = {};
  Object.setPrototypeOf(obj, Con.prototype);
  let result = Con.apply(obj, args);
  return result instanceof Object ? result : obj;
}
```

在使用 new 创建实例时, 示例就会绑定到这个构造函数的 this.

```ts
function Dog(name) {
  this.name = name;
}

const husky = new Dog('Lolita');

husky.name; // Lolita
```

### 绑定优先级

new 绑定 > 显式绑定 > 隐式绑定 > 默认绑定

### 箭头函数

箭头函数的使用不必多说, 这里只贴一下其注意事项.

1. 函数体内的 this 对象, 继承的是外层代码块的 this.

2. 不可以当作构造函数, 也就是说, 不可以使用 new 命令, 否则会抛出一个错误.

3. 不可以使用 arguments 对象, 该对象在函数体内不存在. 如果要用, 可以用 rest 参数代替.

4. 不可以使用 yield 命令, 因此箭头函数不能用作 Generator 函数.

5. 箭头函数没有自己的 this, 因此不能使用 call(), apply(), bind()等方法改变 this 的指向.

```ts
var obj = {
  hi: function() {
    console.log(this);
    return () => {
      console.log(this);
    };
  },
  sayHi: function() {
    return function() {
      console.log(this);
      return () => {
        console.log(this);
      };
    };
  },
  say: () => {
    console.log(this);
  },
};

let hi = obj.hi(); // 输出 obj 对象
hi(); // 输出 obj 对象
let sayHi = obj.sayHi();
let fun1 = sayHi(); // 输出 window
fun1(); // 输出 window
obj.say(); // 输出 window
```

1. 第一步是隐式绑定, 此时 this 指向 obj, 所以打印出 obj 对象
2. 第二步执行 hi() 方法, 虽然看着像闭包, 但这是一个箭头函数, 它会继承上一层的 this, 也就是 obj, 所以打印出 obj 对象
3. 因为 obj.sayHi() 返回一个闭包, 所以 this 指向 window, 因此打印出 window 对象
4. 同样箭头函数继承上一层的 this, 所以 this 指向 window, 因此打印出 window 对象
5. 最后一次输出, 因为 obj 中不存在 this, 因此按作用域链找到全局的 this, 也就是 window, 所以打印出 window 对象

我们可以用箭头函数来解决上文的一个问题, 这里虽然 setTimeout 会将 this 指向全局, 但箭头函数继承上一层的 this, 也就是 obj.greeting() 的 this, 因为这是一个隐式绑定, 所以 this 指向 obj, 所以箭头函数的 this 也会指向 obj.

```ts
function greeting() {
  console.log(`Hello, ${this.name}`);
}
var obj = {
  name: 'Yancey',
  greeting() {
    setTimeout(() => {
      console.log(`Hello, ${this.name}`);
    });
  },
};

var name = 'Sayaka';

obj.greeting(); // Hello, Yancey
```

## 面试题解析

我们逐句分析一下开篇那道面试题.

因为 `obj.fn` 是一个立即执行函数(this 会指向 window), 所以在 obj 创建时就会执行一次, 并返回闭包函数.

```ts
var number; // 创建了一个私有变量 number 但未赋初值
this.number *= 2; // this.number 指向的是全局那个 number, 所以 window.number = 10
number = number * 2; // 因为私有变量 number 未赋初值, 所以乘以 2 会变为 NaN
number = 3; // 此时私有变量 number 变为 3

```

接着执行下面两句:

```ts
var fn = obj.fn;
fn.call(null);
```

因为将 `obj.fn` 赋值给一个全局变量 fn, 所以此时 this 指向 window. 接着, 当 call 的第一个参数是 null 或者 undefined 时, 调用的是默认绑定, 因此 this 仍然指向 window.

```ts
var num = this.number; // 因为 window.number = 10, 所以 num 也就是 10
this.number *= 2; // window.number 变成了 20
console.log(num); // 打印出 10
number *= 3; // 因为是闭包函数, 有权访问父函数的私有变量, 所以此时 number 为 9
console.log(number); // 打印出 9
```

当执行 `obj.fn();` 时, 此时的 this 指向的是 obj:

```ts
var num = this.number; // 因为 obj.number = 3, 所以 num 也就为 3
this.number *= 2; // obj.number 变为 6
console.log(num); // 打印出 3
number *= 3; // 上一轮私有变量为变成了 9, 所以这里变成 27
console.log(number); // 打印出 27
```

最后打印出 `window.number` 就是 20

```ts
// 最终结果: 
10
9
3
27
20
```

## 再来两个例子练练手

```ts
var length = 10;

function fn() {
  console.log(this.length);
}

var obj = {
  length: 5,
  method: function(fn) {
    fn();
    arguments[0]();
  },
};

obj.method(fn, 1);
```

传入了 fn 而非 fn(), 相当于把 fn 函数赋值给 method 里的 fn 执行, 所以这里是默认绑定, 此时 this 指向 window, 所以执行 fn() 时会打印出 10

arguments\[0\]\(\), 就相当于执行 fn\(\), 所以是隐式绑定, 此时 this 指向 arguments, 所以 `this.length` 就相当于 `arguments.length`, 因为我们传递了两个参数, 因此返回 2

```ts
window.val = 1;

var obj = {
  val: 2,
  dbl: function() {
    this.val *= 2;
    val *= 2;
    console.log('val:', val);
    console.log('this.val:', this.val);
  },
};

obj.dbl();
var func = obj.dbl;
func();
```

第一次调用是隐式调用, 因此 this 指向 obj, 所以 this.val 也就是 obj.val 变成了 4, 但是 dbl 方法中没有定义 val, 所以会沿着作用域链找到 window.val, 所以会依次打印出 2, 4

第二次是默认调用, this 指向 window, window.val 会经历两次乘 2 变成 8, 所以会依次打印出 8, 8

## this 设计的缺陷

看下面这个例子, 第一个 console 是一个默认绑定, 没什么好说的, 但里面 bar 函数的 this 居然是 window. 这是因为对于独立调用的函数, 如果未进行有效的 this 绑定的话, this 就会绑定到 window 对象(非严格模式)或者 undefined(严格模式).

```ts
var myObj = {
  name: ""极客时间"", 
  showThis: function() {
    console.log(this);
    function bar() {
      console.log(this);
    }
    bar();
  }
}

myObj.showThis();
```

有两种方式可以解决, 第一种使用 self 大法来解决.

```ts
var myObj = {
  name: ""极客时间"", 
  showThis: function() {
    console.log(this);
    const self = this;
    function bar() {
      console.log(self);
    }
    bar();
  }
}

myObj.showThis();
```

第二种方法就是把内部函数卷成一个箭头函数. 上面也说到了, ES6 中的箭头函数并不会创建其自身的执行上下文, 所以箭头函数中的 this 取决于它的外部函数.

```ts
var myObj = {
  name: ""极客时间"", 
  showThis: function() {
    console.log(this);
    const bar = () => {
      console.log(this);
    }
    bar();
  }
}

myObj.showThis();
```

## 总结

- 函数是否在 new 中调用(new 绑定), 如果是, 那么 this 绑定的是新创建的对象.
- 函数是否通过 call, apply 调用, 或者使用了 bind(即显式绑定), 如果是, 那么 this 绑定的就是指定的对象.
- 函数是否在某个上下文对象中调用(隐式绑定), 如果是的话, this 绑定的是那个上下文对象. 一般是 obj.foo().
- 如果以上都不是, 那么使用默认绑定. 如果在严格模式下, 则绑定到 undefined, 否则绑定到全局对象.
- 如果把 Null 或者 undefined 作为 this 的绑定对象传入 call, apply 或者 bind, 这些值在调用时会被忽略, 实际应用的是默认绑定规则.
- 如果是箭头函数, 箭头函数的 this 继承的是外层代码块的 this; 而普通嵌套函数中的 this 不会继承外层函数的 this 值.

## 参考

[嗨, 你真的懂 this 吗?](https://juejin.im/post/5c96d0c751882511c832ff7b)

[「前端面试题系列 4」this 的原理以及用法](https://juejin.im/post/5c428ce0f265da612b13dca7)

[JavaScript 的 this 原理](http://www.ruanyifeng.com/blog/2018/06/javascript-this.html)
","2025-02-02 03:08:20.405351","2025-02-02 03:08:20.405351"
"72df0caf-f79b-4823-bebb-3b49f2aa4f45","{Vite}",0,0,False,"https://edge.yancey.app/beg/mt8yojem-1698216876530.jpg","Vite 源码解析(3) - 插件篇","无论是 webpack 还是 vite, 插件机制都极大的扩展了这些打包器的深度和广度, 这一篇我们深入 Vite 的插件机制, 了解它是如何运作的.","第一篇文章我们讲了在配置中, 通过 `resolvePlugins` 来聚合和解析一票插件, 留了一个未展开讲的函数 `createPluginContainer`, 我们知道 vite 插件扩展了设计出色的 rollup 接口, 因此为了和 rollup 插件打通, vite 搞了个 `createPluginContainer` 函数, 其实这个函数来自 [wmr](https://github.com/preactjs/wmr/blob/main/packages/wmr/src/lib/rollup-plugin-container.js), 是 preact 打通 rollup 的包, vite 拿这个重新卷了一下.
这篇文章我们先来学习一下 `createPluginContainer` 的源码, 然后通过 `@rollup/plugin-alias`, `plugins/esbuild` 这两个库, 来看一看 `createPluginContainer` 是怎样与 rollup hooks 打通的.

## createPluginContainer
整体来讲, `createPluginContainer` 可以划分为 `前置逻辑`, `Context`, `TransformContext`, `container` 和, 其中我们重点讲的是后三个. 当 vite 在构建到某个阶段时, 会调用 `container` 中的钩子函数, 这些钩子函数会遍历你所有的插件, 如果你的某些插件在这个钩子中要做些什么, 那就执行它, 否则就跳过它, 而这些钩子函数是和 roullup 插件体系打通的. 而 `Context` 和 `TransformContext` 相当于一个工厂, 将 vite 的插件转换成 rollup 可用的.
### 前置代码
```ts
const isDebug = process.env.DEBUG;
const seenResolves: Record<string, true | undefined> = {};
const debugResolve = createDebugger(""vite:resolve"");
const debugPluginResolve = createDebugger(""vite:plugin-resolve"", {
  onlyWhenFocused: ""vite:plugin"",
});
const debugPluginTransform = createDebugger(""vite:plugin-transform"", {
  onlyWhenFocused: ""vite:plugin"",
});
const debugSourcemapCombineFlag = ""vite:sourcemap-combine"";
const isDebugSourcemapCombineFocused = process.env.DEBUG?.includes(
  debugSourcemapCombineFlag
);
const debugSourcemapCombineFilter =
  process.env.DEBUG_VITE_SOURCEMAP_COMBINE_FILTER;
const debugSourcemapCombine = createDebugger(""vite:sourcemap-combine"", {
  onlyWhenFocused: true,
});
// ---------------------------------------------------------------------------
const watchFiles = new Set<string>();
// TODO: use import()
// createRequire 上次说了, 用来加载 cjs 文件
const _require = createRequire(import.meta.url);
// get rollup version
// 先拿到 node_modules/rollup/package,json
const rollupPkgPath = resolve(_require.resolve(""rollup""), ""../../package.json"");
// 我们看到主要是取当前 rollup 的版本信息
const minimalContext: MinimalPluginContext = {
  meta: {
    rollupVersion: JSON.parse(fs.readFileSync(rollupPkgPath, ""utf-8"")).version,
    watchMode: true,
  },
};
// 不兼容的插件暴露 warning.
function warnIncompatibleMethod(method: string, plugin: string) {
  logger.warn(
    colors.cyan(`[plugin:${plugin}] `) +
      colors.yellow(
        `context method ${colors.bold(
          `${method}()`
        )} is not supported in serve mode. This plugin is likely not vite-compatible.`
      )
  );
}
// throw when an unsupported ModuleInfo property is accessed,
// so that incompatible plugins fail in a non-cryptic way.
// 这里很优雅的用到了 Proxy 和 Reflect, 用于拦截 module.info 的 getter
// 配合下面 getModuleInfo 这个函数看
const ModuleInfoProxy: ProxyHandler<ModuleInfo> = {
  get(info: any, key: string) {
    if (key in info) {
      return info[key];
    }
    throw Error(`[vite] The ""${key}"" property of ModuleInfo is not supported.`);
  },
};
// same default value of ""moduleInfo.meta"" as in Rollup
const EMPTY_OBJECT = Object.freeze({});
function getModuleInfo(id: string) {
  const module = moduleGraph?.getModuleById(id);
  if (!module) {
    return null;
  }
  // 如果没有 module.info, 就给 module.info 加上代理, 且
  // module.info 只有 id, meta 两个字段
  // 一旦你访问非 id, meta 字段, 比如 module.info.xxx 就会报错
  if (!module.info) {
    module.info = new Proxy(
      { id, meta: module.meta || EMPTY_OBJECT } as ModuleInfo,
      ModuleInfoProxy
    );
  }
  return module.info;
}
// 更新模块的 meta 信息
function updateModuleInfo(id: string, { meta }: { meta?: object | null }) {
  if (meta) {
    const moduleInfo = getModuleInfo(id);
    if (moduleInfo) {
      moduleInfo.meta = { ...moduleInfo.meta, ...meta };
    }
  }
}
```
### Context
关于 Context 和 TransformContext 我们简单说, 它实现了 rollup 的 PluginContext 接口, 可以把它理解为一个工厂, 是将 vite 的插件转换成 rollup 可用的.
```ts
// we should create a new context for each async hook pipeline so that the
// active plugin in that pipeline can be tracked in a concurrency-safe manner.
// using a class to make creating new contexts more efficient
class Context implements PluginContext {
  meta = minimalContext.meta;
  ssr = false;
  _scan = false;
  _activePlugin: Plugin | null;
  _activeId: string | null = null;
  _activeCode: string | null = null;
  _resolveSkips?: Set<Plugin>;
  _addedImports: Set<string> | null = null;
  constructor(initialPlugin?: Plugin) {
    this._activePlugin = initialPlugin || null;
  }
  // 这里用到了 acorn 这个库, 用来将代码字符串转换为 AST
  // rollup, webpack 都用这个
  parse(code: string, opts: any = {}) {
    return parser.parse(code, {
      sourceType: ""module"",
      ecmaVersion: ""latest"",
      locations: true,
      ...opts,
    });
  }
  // 解析路径
  // src/container/Home.tsx -> /User/xxxx/vite-example/src/container/Home.tsx
  async resolve(
    id: string,
    importer?: string,
    options?: { skipSelf?: boolean }
  ) {
    // 收集需要跳过的插件
    let skip: Set<Plugin> | undefined;
    if (options?.skipSelf && this._activePlugin) {
      skip = new Set(this._resolveSkips);
      skip.add(this._activePlugin);
    }
    // 关于 resolveId 下面会讲到
    // 它就是获取当前模块在文件系统的绝对路径
    // 我们会跳过 skip 包含的插件
    let out = await container.resolveId(id, importer, {
      skip,
      ssr: this.ssr,
      scan: this._scan,
    });
    // 如果没有找到, 或者被跳过, 就返回 null
    // 否则返回路径
    if (typeof out === ""string"") out = { id: out };
    return out as ResolvedId | null;
  }
  // 获取模块信息
  getModuleInfo(id: string) {
    return getModuleInfo(id);
  }
  // 获取所有模块路径
  getModuleIds() {
    return moduleGraph
      ? moduleGraph.idToModuleMap.keys()
      : Array.prototype[Symbol.iterator]();
  }
  addWatchFile(id: string) {
    watchFiles.add(id);
    (this._addedImports || (this._addedImports = new Set())).add(id);
    if (watcher) ensureWatchedFile(watcher, id, root);
  }
  getWatchFiles() {
    return [...watchFiles];
  }
  // 未实现
  emitFile(assetOrFile: EmittedFile) {
    warnIncompatibleMethod(`emitFile`, this._activePlugin!.name);
    return """";
  }
  // 未实现
  setAssetSource() {
    warnIncompatibleMethod(`setAssetSource`, this._activePlugin!.name);
  }
  // 未实现
  getFileName() {
    warnIncompatibleMethod(`getFileName`, this._activePlugin!.name);
    return """";
  }
  warn(
    e: string | RollupError,
    position?: number | { column: number; line: number }
  ) {
    const err = formatError(e, position, this);
    const msg = buildErrorMessage(
      err,
      [colors.yellow(`warning: ${err.message}`)],
      false
    );
    logger.warn(msg, {
      clear: true,
      timestamp: true,
    });
  }
  error(
    e: string | RollupError,
    position?: number | { column: number; line: number }
  ): never {
    // error thrown here is caught by the transform middleware and passed on
    // the the error middleware.
    throw formatError(e, position, this);
  }
}
```
### TransformContext
TransformContext 在 Context 的基础上加上了对 sourcemap 的处理. 具体可以看下面的 transform 部分.
```ts
class TransformContext extends Context {
  filename: string;
  originalCode: string;
  originalSourcemap: SourceMap | null = null;
  sourcemapChain: NonNullable<SourceDescription[""map""]>[] = [];
  combinedMap: SourceMap | null = null;
  constructor(filename: string, code: string, inMap?: SourceMap | string) {
    super();
    this.filename = filename;
    this.originalCode = code;
    if (inMap) {
      this.sourcemapChain.push(inMap);
    }
  }
  _getCombinedSourcemap(createIfNull = false) {
    if (
      debugSourcemapCombineFilter &&
      this.filename.includes(debugSourcemapCombineFilter)
    ) {
      debugSourcemapCombine(""----------"", this.filename);
      debugSourcemapCombine(this.combinedMap);
      debugSourcemapCombine(this.sourcemapChain);
      debugSourcemapCombine(""----------"");
    }
    let combinedMap = this.combinedMap;
    for (let m of this.sourcemapChain) {
      if (typeof m === ""string"") m = JSON.parse(m);
      if (!(""version"" in (m as SourceMap))) {
        // empty, nullified source map
        combinedMap = this.combinedMap = null;
        this.sourcemapChain.length = 0;
        break;
      }
      if (!combinedMap) {
        combinedMap = m as SourceMap;
      } else {
        combinedMap = combineSourcemaps(cleanUrl(this.filename), [
          {
            ...(m as RawSourceMap),
            sourcesContent: combinedMap.sourcesContent,
          },
          combinedMap as RawSourceMap,
        ]) as SourceMap;
      }
    }
    if (!combinedMap) {
      return createIfNull
        ? new MagicString(this.originalCode).generateMap({
            includeContent: true,
            hires: true,
            source: cleanUrl(this.filename),
          })
        : null;
    }
    if (combinedMap !== this.combinedMap) {
      this.combinedMap = combinedMap;
      this.sourcemapChain.length = 0;
    }
    return this.combinedMap;
  }
  getCombinedSourcemap() {
    return this._getCombinedSourcemap(true) as SourceMap;
  }
}
```
### container
```ts
const container: PluginContainer = {
  options: await(async () => {})(),
  // 从依赖图中取得模块信息, 上面介绍了
  getModuleInfo,
  async buildStart() {},
  async resolveId(rawId, importer = join(root, ""index.html""), options) {},
  async load(id, ssr) {},
  async transform(code, id, inMap, ssr) {},
  watchChange(id, event = ""update"") {},
  async close() {},
};
return container;
```
上面我们讲到 rollup 的钩子, 而 vite 用到了如下几个:
- options
- buildStart
- resolveId
- load
- transform
下面我们依次看他们做了些什么.
#### options
options 是一个立即执行函数, 也是构建过程中执行的第一个钩子. 它会遍历执行所有插件的 options 方法, 最终返回合并后的 options.
```ts
const container: PluginContainer = {
  options: await(async () => {
    // 在 vite 配置文件中可以配置 build.rollupOptions
    // https://rollupjs.org/guide/en/#big-list-of-options
    let options = rollupOptions;
    for (const plugin of plugins) {
      if (!plugin.options) continue;
      options = (await plugin.options.call(minimalContext, options)) || options;
    }
    // 扩展 Acorn 的 Parser, 比如:
    // rollupOptions: {
    //  acornInjectPlugins: [ importAssertions ],
    // }
    if (options.acornInjectPlugins) {
      parser = acorn.Parser.extend(
        ...(arraify(options.acornInjectPlugins) as any)
      );
    }
    return {
      acorn,
      acornInjectPlugins: [],
      ...options,
    };
  })(),
};
```
#### buildStart
它的作用是就是开始构建之前获取上面 options 钩子的配置项, 用于其他钩子函数使用. 因为用了 Promise.all, 一个凉了就全部失败.
```ts
const container: PluginContainer = {
  async buildStart() {
    await Promise.all(
      plugins.map((plugin) => {
        if (plugin.buildStart) {
          return plugin.buildStart.call(
            new Context(plugin) as any,
            container.options as NormalizedInputOptions
          );
        }
      })
    );
  },
};
```
#### resolveId
下一章我们会讲到 transformMiddleware 这个中间件, 它用于拦截并处理模块请求, 其中就包含调用 resolveId 钩子函数, 我们在代码中会直接引用 node_modules 中的库, 也会相对引用其他模块的源码, 也会使用 alias 等等. 因此, 这个钩子就是用于解析文件路径, 变成绝对路径.
```ts
/**
 * @param rawId 代码中使用的路径, 比如 import { foo } from '../bar.js', 那 rawId 就是 '../bar.js'
 * @param importer 导入模块的位置, 默认是 index.html 那一级的路径
 * @param options 配置
 * @returns  Promise<PartialResolvedId | null>
 */
const container: PluginContainer = {
  async resolveId(rawId, importer = join(root, ""index.html""), options) {
    const skip = options?.skip; // Set<Plugin> | undefined
    const ssr = options?.ssr;
    const scan = !!options?.scan;
    const ctx = new Context();
    ctx.ssr = !!ssr; // 是否为服务端渲染
    ctx._scan = scan; // 是否需要扫描
    ctx._resolveSkips = skip; // 需要跳过的模块集合
    const resolveStart = isDebug ? performance.now() : 0;
    let id: string | null = null;
    const partial: Partial<PartialResolvedId> = {};
    for (const plugin of plugins) {
      if (!plugin.resolveId) continue; // 没有 resolveId 钩子就跳过
      if (skip?.has(plugin)) continue; // 如果需要跳过, 就跳过
      // 此时这个插件就是当前正在执行 resolveId 钩子函数的
      ctx._activePlugin = plugin;
      const pluginResolveStart = isDebug ? performance.now() : 0;
      // 调用 resolveId 钩子函数
      const result = await plugin.resolveId.call(ctx as any, rawId, importer, {
        ssr,
        scan,
      });
      // 如果没有返回值继续调用剩余插件的 resolveId 钩子函数
      if (!result) continue;
      if (typeof result === ""string"") {
        id = result;
      } else {
        id = result.id;
        Object.assign(partial, result);
      }
      isDebug &&
        debugPluginResolve(
          timeFrom(pluginResolveStart),
          plugin.name,
          prettifyUrl(id, root)
        );
      // resolveId() is hookFirst - first non-null result is returned.
      // 拿到 id 后, 就可以终止 resolveId 钩子函数了
      // 也就是说只要有一个插件的 resolveId 方法返回有效值, 就终止循环
      break;
    }
    if (isDebug && rawId !== id && !rawId.startsWith(FS_PREFIX)) {
      const key = rawId + id;
      // avoid spamming
      if (!seenResolves[key]) {
        seenResolves[key] = true;
        debugResolve(
          `${timeFrom(resolveStart)} ${colors.cyan(rawId)} -> ${colors.dim(id)}`
        );
      }
    }
    // 最终返回一个对象, 对象内有一个属性 id, 值是解析后的绝对路径
    // external 是指引用的外部 url, 比如像 react, react-dom 走了 CDN
    if (id) {
      partial.id = isExternalUrl(id) ? id : normalizePath(id);
      return partial as PartialResolvedId;
    } else {
      return null;
    }
  },
};
```
#### load
在 resolveId 钩子结束后, 我们就拿到了当前文件的绝对路径, 接下来就是调用 load 钩子函数, 可以获取到文件的内容. 在 rollup 中, 如果你执行了 load 函数, 返回 null, 说明你没有对源码进行改变; 否则返回 `SourceDescription` 类型. 因此在下面的代码中, 我们也看到如果 result 是 Object 类型, 那么需要执行 `updateModuleInfo` 函数.
和 resolveId 类似, 只要有一个插件的 load 方法返回了 `SourceDescription` 类型的 result 就终止遍历.
```ts
const container: PluginContainer = {
  async load(id, options) {
    const ssr = options?.ssr;
    const ctx = new Context();
    ctx.ssr = !!ssr;
    for (const plugin of plugins) {
      if (!plugin.load) continue;
      ctx._activePlugin = plugin;
      const result = await plugin.load.call(ctx as any, id, { ssr });
      if (result != null) {
        if (isObject(result)) {
          updateModuleInfo(id, result);
        }
        return result;
      }
    }
    return null;
  },
};
```
#### transform
transform 似乎是我们最常用的钩子, 它用于转换源码, 像 JSON, YAML, 图片等非 JavaScript 文件都需要在这里进行转换. 前段时间写了个插件, 叫做 [rollup-plugin-toml](https://github.com/YanceyOfficial/rollup-plugin-toml), 它可以将 toml 文件转换为 ESM 模块.
```ts
export interface SourceDescription extends Partial<PartialNull<ModuleOptions>> {
  ast?: AcornNode;
  code: string;
  map?: SourceMapInput;
}
const container: PluginContainer = {
  /**
   * @param code 文件源码
   * @param id 文件路径
   * @param options sourcemap 相关
   * @returns {SourceDescription | null}
   */
  async transform(code, id, options) {
    const inMap = options?.inMap;
    const ssr = options?.ssr;
    const ctx = new TransformContext(id, code, inMap as SourceMap);
    ctx.ssr = !!ssr;
    for (const plugin of plugins) {
      if (!plugin.transform) continue;
      ctx._activePlugin = plugin; // 当前正在使用的插件
      ctx._activeId = id; // 当前正在处理的模块路径
      ctx._activeCode = code; // 当前正在处理的源码字符串
      const start = isDebug ? performance.now() : 0;
      let result: TransformResult | string | undefined;
      try {
        // 调用插件的 transform 方法
        result = await plugin.transform.call(ctx as any, code, id, { ssr });
      } catch (e) {
        ctx.error(e);
      }
      if (!result) continue;
      isDebug &&
        debugPluginTransform(
          timeFrom(start),
          plugin.name,
          prettifyUrl(id, root)
        );
      if (isObject(result)) {
        // 说明源码发生了变动
        if (result.code !== undefined) {
          // 复写源码
          code = result.code;
          if (result.map) {
            if (isDebugSourcemapCombineFocused) {
              // @ts-expect-error inject plugin name for debug purpose
              result.map.name = plugin.name;
            }
            ctx.sourcemapChain.push(result.map);
          }
        }
        // 由于结果变了, 需要更新模块信息
        updateModuleInfo(id, result);
      } else {
        // 由于 transform 也可以返回字符串, 那么这个 result 就是 transform 之后的源码.
        code = result;
      }
    }
    // 返回新的 code 和 map 供下个插件使用
    return {
      code,
      map: ctx._getCombinedSourcemap(),
    };
  },
};
```
#### close
不多说, 我们直接摘抄 rollup 的原话: the last one is always `buildEnd`. If there is a build error, `closeBundle` will be called after that. 翻译一下就是在 build 最后会调用 `buildEnd` 钩子, 如果发生了构建错误, 最后还会额外调用 `closeBundle` 钩子.
```ts
const container: PluginContainer = {
  async close() {
    if (closed) return;
    const ctx = new Context();
    await Promise.all(
      plugins.map((p) => p.buildEnd && p.buildEnd.call(ctx as any))
    );
    await Promise.all(
      plugins.map((p) => p.closeBundle && p.closeBundle.call(ctx as any))
    );
    closed = true;
  },
};
```
## @rollup/plugin-alias
最后我们看两个插件, 作为对 `createPluginContainer` 的一个复习. 首先看一下 `@rollup/plugin-alias`.
我们在平时开发中, 为了防止 `../../../xxx.js` 这种路径引用, 一般都会配置 `alias` 配置, 比如:
```ts
module.exports = {
  plugins: [
    alias({
      entries: [
        { find: 'utils', replacement: '../../../utils' },
        { find: 'batman-1.0.0', replacement: './joker-1.5.0' }
        { find:/^i18n\!(.*)/, replacement: '$1.js' }
      ]
    }),
    alias({
      entries: {
        '@': path.resolve(__dirname, 'src')
      }
    });
  ]
};
```
这样的好处是, 当我们引用 `../../../xxx.js` 时, 可以写成 `@/xxx.js`, 代码会非常的干净. 想必大家也能猜出, 这个插件最重要地方的是对 resolveId 这个钩子的处理, 我们来学习下这块.
```ts
function alias(options = {}) {
  // 获取别名列表
  const entries = getEntries(options);
  if (entries.length === 0) {
    return {
      name: ""alias"",
      resolveId: () => null,
    };
  }
  return {
    name: ""alias"",
    async buildStart(inputOptions) {
      await Promise.all(
        [
          ...(Array.isArray(options.entries) ? options.entries : []),
          options,
        ].map(
          ({ customResolver }) =>
            customResolver &&
            typeof customResolver === ""object"" &&
            typeof customResolver.buildStart === ""function"" &&
            customResolver.buildStart.call(this, inputOptions)
        )
      );
    },
    resolveId(importee, importer, resolveOptions) {
      if (!importer) {
        return null;
      }
      // First match is supposed to be the correct one
      // 找到第一个匹配的配置
      const matchedEntry = entries.find((entry) =>
        matches(entry.find, importee)
      );
      if (!matchedEntry) {
        return null;
      }
      // @containers/Home.tsx -> src/containers/Home.tsx
      const updatedId = importee.replace(
        matchedEntry.find,
        matchedEntry.replacement
      );
      // 如果提供了自定义的 resolve 算法, 那就用自定义的
      if (matchedEntry.resolverFunction) {
        return matchedEntry.resolverFunction.call(
          this,
          updatedId,
          importer,
          resolveOptions
        );
      }
      // 否则用默认的 resolve 方法, 这个上面讲 Context 的时候说到了
      return this.resolve(
        updatedId,
        importer,
        // 当然上面有一点没说明的就是 skipSelf: true
        // 这句话的意思是这个 id 已经将要被解析成绝对路径了
        // 如果后面有插件还想解析这个 id, 直接用现成了, 跳过就好
        Object.assign({ skipSelf: true }, resolveOptions)
      ).then((resolved) => resolved || { id: updatedId });
    },
  };
}
```
## vite:esbuild
上面我们讲到了一个使用 resolveId 的实例. 这次我们讲下 vite 内置的 `vite:esbuild`. 我们知道 vite 快的一个根本原因就是用了 esbuild. esbuild 在 vite 开发环境体现在以下三个阶段:
- 依赖预构建: 这也是 vite 冷启为什么快的原因, 我们在第六章会讲到
- ESM 请求源码: 也就是我们一会儿要讲到了, 在前端请求源码时, 会受到 transformMiddleware 的拦截, 我们知道源码是无法被浏览器直接使用的, 所以这里就会通过 rollup 进行构建, 而在开发环境, vite 在 rollup 中使用了 esbuild 插件
- HMR: 和上一条类似, 都是使用 esbuild 加速构建过程
`vite:esbuild` 中最核心的就是 transform 钩子, 它调用了 esbuild 的 transform 函数, 该函数用于转换单个文件, 可以用来压缩 JavaScript, 把 ts/tsx 转换成 JavaScript, 或者把高版本 ECMAScript 转成低版本. 它返回一个 Promise, 当 Promise 被 resolve 时, 返回一个 `TransformResult` 类型的对象; 如果被 reject, 就返回一个 `TransformFailure` 类型的对象.
> This function transforms a single JavaScript file. It can be used to minify JavaScript, convert TypeScript/JSX to JavaScript, or convert newer JavaScript to older JavaScript. It returns a promise that is either resolved with a ""TransformResult"" object or rejected with a ""TransformFailure"" object.
我们简单过一下代码, 了解一下一般我们会在 transform 钩子做什么. 至于 esbuild 的 transform 函数怎么运作的, 超纲了...
```ts
export async function transformWithEsbuild(
  code: string,
  filename: string,
  options?: TransformOptions,
  inMap?: object
): Promise<ESBuildTransformResult> {
  let loader = options?.loader;
  // loader 是 esbuild Transform API 中的一个参数, 它一般就是文件的扩展名, 比如 .js, .css, .tsx 等等
  // 它用于告知 esbuild 用什么 loader 来处理指定格式的文件
  if (!loader) {
    // if the id ends with a valid ext, use it (e.g. vue blocks)
    // otherwise, cleanup the query before checking the ext
    const ext = path
      .extname(/\.\w+$/.test(filename) ? filename : cleanUrl(filename))
      .slice(1);
    if (ext === ""cjs"" || ext === ""mjs"") {
      loader = ""js"";
    } else {
      loader = ext as Loader;
    }
  }
  // tsconfigRaw 也是 esbuild Transform API 中的一个参数, 它以字符串的形式传入 tsconfig.json 的配置
  // https://esbuild.github.io/api/#tsconfig-raw
  // 如果你传入了这个参数, 那么 esbuild 就不会去读取 tsconfig.json 文件了
  let tsconfigRaw = options?.tsconfigRaw;
  // if options provide tsconfigraw in string, it takes highest precedence
  if (typeof tsconfigRaw !== ""string"") {
    // these fields would affect the compilation result
    // https://esbuild.github.io/content-types/#tsconfig-json
    const meaningfulFields: Array<keyof TSCompilerOptions> = [
      ""target"",
      ""jsxFactory"",
      ""jsxFragmentFactory"",
      ""useDefineForClassFields"",
      ""importsNotUsedAsValues"",
      ""preserveValueImports"",
    ];
    // 如果是 ts 或者 tsx, 就找 tsconfig.json 的配置
    // 如果有 meaningfulFields 的这六个, 就把它缓存到 compilerOptionsForFile 对象中
    const compilerOptionsForFile: TSCompilerOptions = {};
    if (loader === ""ts"" || loader === ""tsx"") {
      const loadedTsconfig = await loadTsconfigJsonForFile(filename);
      const loadedCompilerOptions = loadedTsconfig.compilerOptions ?? {};
      for (const field of meaningfulFields) {
        if (field in loadedCompilerOptions) {
          // @ts-ignore TypeScript can't tell they are of the same type
          compilerOptionsForFile[field] = loadedCompilerOptions[field];
        }
      }
    }
    // 最终合并成一个新的 tsconfigRaw
    tsconfigRaw = {
      ...tsconfigRaw,
      compilerOptions: {
        ...compilerOptionsForFile,
        ...tsconfigRaw?.compilerOptions,
      },
    };
  }
  const resolvedOptions = {
    sourcemap: true,
    // ensure source file name contains full query
    sourcefile: filename,
    ...options,
    loader,
    tsconfigRaw,
  } as ESBuildOptions;
  delete resolvedOptions.include;
  delete resolvedOptions.exclude;
  delete resolvedOptions.jsxInject;
  try {
    // 这里就是 esbuild 真正转换文件的核心了, 有兴趣可以去看 esbuild 的源码
    // 对于绝大多数 transfrom 钩子的实现, 我们大多都是读取文件内容, 然后通过三方库来转换, 然后再写入文件
    // 比如我写的 [rollup-plugin-toml](https://github.com/YanceyOfficial/rollup-plugin-toml)
    // 实际用到的转换器是 @iarna/toml 这个库
    const result = await transform(code, resolvedOptions);
    let map: SourceMap;
    if (inMap && resolvedOptions.sourcemap) {
      const nextMap = JSON.parse(result.map);
      nextMap.sourcesContent = [];
      map = combineSourcemaps(filename, [
        nextMap as RawSourceMap,
        inMap as RawSourceMap,
      ]) as SourceMap;
    } else {
      map = resolvedOptions.sourcemap
        ? JSON.parse(result.map)
        : { mappings: """" };
    }
    if (Array.isArray(map.sources)) {
      map.sources = map.sources.map((it) => toUpperCaseDriveLetter(it));
    }
    return {
      ...result,
      map,
    };
  } catch (e: any) {
    debug(`esbuild error with options used: `, resolvedOptions);
    // patch error information
    if (e.errors) {
      e.frame = """";
      e.errors.forEach((m: Message) => {
        e.frame += `\n` + prettifyMessage(m, code);
      });
      e.loc = e.errors[0].location;
    }
    throw e;
  }
}
```
## 总结
这一章我们了解了 vite 的插件机制, vite 的插件本质需要在 rollup 体系下执行, 因此 vite 封装了 createPluginContainer 函数, 通过它, vite 插件才得以在 rollup 的各个 hooks 中被调用.
此外, 我们还通过两个例子, 来了解插件是如何实现钩子函数的. 通过 vite:esbuild 这个例子, 我们知道了 vite 快的原因之一, 就是源码是按需编译的, 且编译使用了 esbuild.
下一章我们将重点学习 vite 的开发 server 是如何搭建的, 以及中间件机制是怎样运行的. 中间件在拦截请求后会调用这一章学到的插件机制, 来进行源码的转化. 敬请期待~","2025-02-02 03:09:36.883466","2025-02-02 03:09:36.883466"
"ad49a690-7438-44f8-8e63-f110c679e789","{travel}",0,0,False,"https://edge.yancey.app/beg/6wijckpj-1731913752983.jpg","New Zealand Memories","A tour in NZ.  🇳🇿","A","2025-02-02 03:09:47.354482","2025-02-02 03:09:47.354482"
"26cad63e-fb39-4a35-8191-20fede0887f6","{JavaScript}",0,0,False,"https://edge.yancey.app/beg/Scope-Closure.jpg","从 JavaScript 编译原理到作用域(链)及闭包","虽然作用域的相关知识是 JavaScript 的基础, 但要彻底理解必须要从原理入手. 从面试角度来讲, 词法/动态作用域、作用域(链)、变量/函数提升、闭包、垃圾回收 实属一类题目, 打通这几个概念并熟练掌握, 面试基本就不用担心这一块了. 这篇文章是对《JavaScript 高级程序设计 (第三版)》第四章, 同样也是 《你不知道的 JavaScript (上卷)》第一部分的学习和总结.","## 编译器和解释器

前两个章节先讲编译器和解释器, 以及 V8 是如何执行一段 JavaScript 代码的.

之所以存在编译器和解释器, 是因为机器不能直接理解我们所写的代码, 所以在执行程序之前, 需要将我们所写的代码**翻译**成机器能读懂的机器语言. **按语言的执行流程, 可以把语言划分为编译型语言和解释型语言.**

编译型语言在程序执行之前, 需要经过编译器的编译过程, 并且编译之后会直接保留机器能读懂的二进制文件, 这样每次运行程序时, 都可以直接运行该二进制文件, 而不需要再次重新编译了. 而由解释型语言编写的程序, 在每次运行时都需要通过解释器对程序进行动态解释和执行.

在编译型语言的编译过程中, 编译器首先会依次对源代码进行词法分析, 语法分析, 生成抽象语法树(AST, Abstract Syntax Tree), 然后是优化代码, 最后再生成处理器能够理解的机器码. 如果编译成功, 将会生成一个可执行的文件. 但如果编译过程发生了语法或者其他的错误, 那么编译器就会抛出异常, 最后的二进制文件也不会生成成功.

在解释型语言的解释过程中, 同样解释器也会对源代码进行词法分析, 语法分析, 并生成抽象语法树(AST), 不过它会再基于抽象语法树生成字节码, 最后再根据字节码来执行程序, 输出结果.

![编译型语言和解释型语言](https://edge.yancey.app/beg/19o46hgr-1650365986390.webp)

## V8 是如何执行一段 JavaScript 代码的

从图中可以清楚地看到, V8 在执行过程中既有解释器 Ignition, 又有编译器 TurboFan.

![V8 执行一段代码流程图](https://edge.yancey.app/beg/6bel8oez-1650370405464.webp)

### 生成 AST 和 执行上下文

高级语言是开发者可以理解的语言, 但是让编译器或者解释器来理解就非常困难了. 对于编译器或者解释器来说, 它们可以理解的就是 AST 了. 所以无论你使用的是解释型语言还是编译型语言, 在编译过程中, 它们都会生成一个 AST. 比如下面这段代码的抽象语法树, 可以用 [javascript-ast](http://resources.jointjs.com/demos/javascript-ast) 这个网站来生成.

```ts
const sayHi = () => {
  return ""Hi"";
};

const MAX_AGE = 18;

sayHi();
```

![抽象语法树的结构](https://edge.yancey.app/beg/teltltt8-1650371188872.jpg)

AST 本质是代码的结构化的表示, 编译器或者解释器后续的工作都需要依赖于 AST, 而不是源代码. 我们常用 Babel 进行 ES6 转 ES5, 它的原理就是先将 ES6 源码转换为 AST, 然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST, 最后利用 ES5 的 AST 生成 JavaScript 源代码. 此外, ESLint 的检测流程也是需要将源码转换为 AST, 然后再利用 AST 来检查代码规范化的问题.

生成 AST 通常有两个步骤:

首先第一步是分词(tokenize), 又称词法分析, 此过程将源代码分解成 `词法单元(token)`, token 指的是语法上不可能再分的, 最小的单个字符或字符串. 如代码 `const firstName = 'Yancey'` 会被分解成 `const`, `firstName`, `=`, `'Yancey'`, 空格是否会被当成词法单元, 取决于空格对这门语言的意义. 这里推荐一个网站 [Parser](http://esprima.org/demo/parse.html#) 可以用来解析 JavaScript 的源代码. 对于 `const firstName = 'Yancey'` 这段代码, 分词结构如下:

```ts
[
  {
    type: ""Keyword"",
    value: ""const"",
  },
  {
    type: ""Identifier"",
    value: ""firstName"",
  },
  {
    type: ""Punctuator"",
    value: ""="",
  },
  {
    type: ""String"",
    value: ""'Yancey'"",
  },
];
```

第二步是解析(Parsing), 又称语法分析. 这个过程将词法单元流转换成一棵抽象语法树. 语法分析会根据 ECMAScript 的标准来解析成 AST, 比如你写了 `const new = 'Yancey'`, 就会报错 **Uncaught SyntaxError: Unexpected token new**. 有了 AST 后, 那接下来 V8 就会生成该段代码的执行上下文.

### 生成字节码

有了 AST 和执行上下文后, 就需要解释器(Ignition) 登场了, 它会根据 AST 生成字节码, 并解释执行字节码. 字节码就是介于 AST 和机器码之间的一种代码. 但是与特定类型的机器码无关, 字节码需要通过解释器将其转换为机器码后才能执行.

其实一开始 V8 并没有字节码, 而是直接将 AST 转换为机器码, 由于执行机器码的效率是非常高效的, 所以这种方式在发布后的一段时间内运行效果是非常好的. 但是随着 Chrome 在手机上的广泛普及, 特别是运行在 512M 内存的手机上, 内存占用问题也暴露出来了, 因为 V8 需要消耗大量的内存来存放转换后的机器码. 为了解决内存占用问题, V8 团队大幅重构了引擎架构, 引入字节码.

从图中可以看出, 机器码所占用的空间远远超过了字节码, 所以使用字节码可以减少系统的内存使用.

![字节码和机器码占用空间对比](https://edge.yancey.app/beg/5yfcuxba-1650373090055.webp)

### 代码执行

通常, 如果有一段第一次执行的字节码, 解释器 Ignition 会逐条解释执行. 到了这里, 相信你已经发现了, 解释器 Ignition 除了负责生成字节码之外, 它还有另外一个作用, 就是解释执行字节码. 在 Ignition 执行字节码的过程中, 如果发现有**热点代码(HotSpot)**, 比如一段代码被重复执行多次. 那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码, 然后当再次执行这段被优化的代码时, 只需要执行编译后的机器码就可以了, 这样就大大提升了代码的执行效率.

V8 的解释器和编译器的取名也很有意思. 解释器 Ignition 是点火器的意思, 编译器 TurboFan 是涡轮增压的意思, 寓意着代码启动时通过点火器慢慢发动, 一旦启动, 涡轮增压介入, 其执行效率随着执行时间越来越高效率, 因为热点代码都被编译器 TurboFan 转换了机器码, 直接执行机器码就省去了字节码“翻译”为机器码的过程.

其实字节码配合解释器和编译器是最近一段时间很火的技术, 比如 Java 和 Python 的虚拟机也都是基于这种技术实现的, 我们把这种技术称为**即时编译(JIT)**. 具体到 V8, 就是指解释器 Ignition 在解释执行字节码的同时, 收集代码信息, 当它发现某一部分代码变热了之后, TurboFan 编译器便闪亮登场, 把热点的字节码转换为机器码, 并把转换后的机器码保存起来, 以备下次使用.

![662413313149f66fe0880113cb6ab98a.webp](https://edge.yancey.app/beg/os9tlvpn-1650432858296.webp)

## 词法作用域和动态作用域

作用域有两种模型, 一种是 **词法作用域(Lexical Scope)**, 另一种是 **动态作用域(Dynamic Scope)**.

词法作用域是定义在词法阶段的作用域, 换句话说就是你写代码时将变量和块作用域写在哪里决定的. JavaScript 可以通过 `eval` 和 `with` 来改变词法作用域, 但这两种会导致引擎无法在编译时对作用域查找进行优化, 因此不要使用它们.

而动态作用域是在运行时定义的, 最典型的就是 this 了.

## 作用域

作用域是指在程序中定义变量的区域, 该位置决定了变量的生命周期. 通俗地理解, 作用域就是变量与函数的可访问范围, 即作用域控制着变量和函数的可见性和生命周期. 在 ES6 之前, ES 的作用域只有两种: 全局作用域和函数作用域.

不管是编译阶段还是运行时, 都离不开 **引擎**, **编译器**, **作用域**.

- 引擎用来负责 JavaScript 程序的编译和执行.

- 编译器负责语法分析, 代码生成等工作.

- 作用域用来收集并维护所有变量访问规则.

以代码 `const firstName = 'Yancey'` 为例, 首先编译器遇到 `const firstName`, 会询问 **作用域** 是否已经有一个同名变量在当前作用域集合, 如果有编译器则忽略该声明, 否则它会在当前作用域的集合中声明一个新的变量并命名为 `firstName`.

接着编译器会为引擎生成运行时所需的代码, 用于处理 `firstName = 'Yancey'` 这个赋值操作. 引擎会先询问作用域, 在当前作用域集合中是否有个变量叫 `firstName`. 如果有, 引擎就会使用这个变量, 否则继续往上查找.

引擎在作用域中查找元素时有两种方式: `LHS` 和 `RHS`. 一般来讲, `LHS` 是赋值阶段的查找, 而 `RHS` 就是纯粹查找某个变量.

看下面这个例子.

```js
function foo(a) {
  var b = a;
  return a + b;
}

var c = foo(2);
```

1. `var c = foo(2);` 引擎会在作用域里找是否有 `foo` 这个函数, 这是一次 RHS 查找, 找到之后将其赋值给变量 `c`, 这是一次 LHS 查找.

2. `function foo(a) {` 这里将实参 `2` 赋值给形参 `a`, 所以这是一次 LHS 查找.

3. `var b = a;` 这里要先找到变量 `a`, 所以这是一次 RHS 查找. 接着将变量 `a` 赋值给 `b`, 这是一次 LHS 查找.

4. `return a + b;` 查找 `a` 和 `b`, 所以是两次 RHS 查找.

### 全局作用域

全局作用域是在 V8 启动过程中就创建了, 且一直保存在内存中不会被销毁的, 直至 V8 退出.

以浏览器环境为例:

- **最外层函数**和**在最外层函数外面**定义的变量拥有全局作用域

- 所有末定义直接赋值的变量自动声明为拥有全局作用域

- 所有 window 对象的属性拥有全局作用域

```js
const a = 1; // 全局变量

// 全局函数
function foo() {
  b = 2; // 未定义却赋初值被认为是全局变量

  const name = ""yancey""; // 局部变量

  // 局部函数
  function bar() {
    console.log(name);
  }
}

window.navigator; // window 对象的属性拥有全局作用域
```

全局作用域的缺点很明显, 就是会污染全局命名空间, 因此很多库的源码都会使用 `(function(){....})()`. 此外, 模块化 (ES6, commonjs 等等) 的广泛使用也为防止污染全局命名空间提供了更好的解决方案.

### 函数作用域

函数作用域指属于这个函数的全部变量都可以在整个函数范围内使用及复用. 函数作用域是在执行该函数时创建的, 当函数执行结束之后, 函数作用域就随之被销毁掉了.

```js
function foo() {
  const name = ""Yancey"";
  function sayName() {
    console.log(`Hello, ${name}`);
  }
  sayName();
}

foo(); // 'Hello, Yancey'

console.log(name); // 外部无法访问到内部变量
sayName(); // 外部无法访问到内部函数
```

值得注意的是, if, switch, while, for 这些条件语句或者循环语句不会创建新的作用域, 虽然它也有一对 `{}` 包裹. 能不能访问的到内部变量取决于声明方式(var 还是 let/const). 这是因为在 ES6 之前, 没有了块级作用域, 再把作用域内部的变量统一提升无疑是最快速, 最简单的设计, 不过这也直接导致了函数中的变量无论是在哪里声明的, 在编译阶段都会被提取到执行上下文的变量环境中, 所以这些变量在整个函数体内部的任何地方都是能被访问的, 这也就是 JavaScript 中的变量提升.

```js
if (true) {
  var name = ""yancey"";
  const age = 18;
}

console.log(name); // 'yancey'

console.log(age); // 报错
```

### 块级作用域

我们知道 let 和 const 的出现改变了 JavaScript 没有块级作用域的情况(具体可以看高程三的第 76 页, 那个时候还没有块级作用域的概念). 关于 let 和 const 不去细说, 这两个再不懂的话... 不过后面会介绍到**临时死区**的概念.

此外, `try/catch` 的 `catch` 分句也会创建一个块级作用域, 看下面一个例子:

```js
try {
  noThisFunction(); // 创造一个异常
} catch (e) {
  console.log(e); // 可以捕获到异常
}

console.log(e); // 报错, 外部无法拿到 e
```

## 作用域链

```ts
function bar() {
  console.log(myName);
}
function foo() {
  let myName = ""A"";
  bar();
}
let myName = ""B"";

foo(); // B
```

在每个执行上下文的变量环境中, 都包含了一个外部引用, 用来指向外部的执行上下文, 我们把这个外部引用称为 outer. 当一段代码使用了一个变量时, JavaScript 引擎首先会在“当前的执行上下文”中查找该变量. 比如上面那段代码在查找 myName 变量时, 如果在当前的变量环境中没有查找到, 那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找.

![带有外部引用的调用栈](https://edge.yancey.app/beg/jgfo7t4j-1650220837330.webp)

从图中可以看出, bar 函数和 foo 函数的 outer 都是指向全局上下文的, 这也就意味着如果在 bar 函数或者 foo 函数中使用了外部变量, 那么 JavaScript 引擎会去全局执行上下文中查找. 我们把这个查找的链条就称为作用域链.

不过还有一个疑问没有解开, foo 函数调用的 bar 函数, 那为什么 bar 函数的外部引用是全局执行上下文, 而不是 foo 函数的执行上下文? 要回答这个问题, 你还需要知道什么是词法作用域. 这是因为在 JavaScript 执行过程中, **其作用域链是由词法作用域决定的**.

词法作用域上面有介绍, 词法作用域就是指作用域是由代码中函数声明的位置来决定的, 所以词法作用域是静态的作用域, 通过它就能够预测代码在执行过程中如何查找标识符. 上面这个例子中, foo 和 bar 的上级作用域都是全局作用域, 所以如果 foo 或者 bar 函数使用了一个它们没有定义的变量, 那么它们会到全局作用域去查找. 也就是说, 词法作用域是代码编译阶段就决定好的, 和函数是怎么调用的没有关系.

## 提升

在 ES6 之前的""蛮荒时代"", 变量提升在面试中经常被问到, 而 let 和 const 的出现解决了变量提升问题. 但函数提升一直是存在的, 这里我们从原理入手来分析一下提升. 以下面这段代码为例:

```ts
showName();
console.log(myname);
var myname = ""极客时间"";
function showName() {
  console.log(""函数showName被执行"");
}
```

之所以有变量提升和函数提升, 这是因为一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译. 变量和函数声明在代码里的位置是不会改变的, 而且是在编译阶段被 JavaScript 引擎放入内存中, 编译完成之后, 才会进入执行阶段.

在编译阶段, 会生成两部分内容: 执行上下文(Execution context)和可执行代码. 执行上下文是 JavaScript 执行一段代码时的运行环境, 比如调用一个函数, 就会进入这个函数的执行上下文, 确定该函数在执行期间用到的诸如 this, 变量, 对象以及函数等. 在执行上下文中存在一个变量环境的对象(Viriable Environment), 该对象中保存了变量提升的内容.

![JavaScript 执行流程细化图](https://edge.yancey.app/beg/nhchchfs-1650013133355.webp)

比如上面代码中的变量 myname 和函数 showName, 都保存在该对象中.

```ts
VariableEnvironment:
  myname -> undefined,
  showName -> function: { console.log(myname) }
```

让我们一步一步来看上面的代码是怎样提升的:

```ts
showName();
console.log(myname);
var myname = ""极客时间"";
function showName() {
  console.log(""函数showName被执行"");
}
```

- 第 1 行和第 2 行, 由于这两行代码不是声明操作, 所以 JavaScript 引擎不会做任何处理;
- 第 3 行, 由于这行是经过 var 声明的, 因此 JavaScript 引擎将在环境对象中创建一个名为 myname 的属性, 并使用 undefined 对其初始化;
- 第 4 行, JavaScript 引擎发现了一个通过 function 定义的函数, 所以它将函数定义存储到堆(HEAP)中, 并在环境对象中创建一个 showName 的属性, 然后将该属性值指向堆中函数的位置.

这样就生成了变量环境对象. 接下来 JavaScript 引擎会把声明以外的代码编译为字节码, 此时, 现在有了执行上下文和可执行代码了, 那么接下来就到了执行阶段了. 执行阶段 JavaScript 引擎便开始在变量环境对象中查找这些变量或函数. 此外, 一段代码如果定义了两个相同名字的函数, 那么最终生效的是最后一个函数. 如果变量和函数同名, 那么在编译阶段, 变量的声明会被忽略.

### 变量提升

我们回忆一下关于编译器的内容, 引擎会在解释 JavaScript 代码之前首先对其进行编译, 编译阶段的一部分工作就是找到所有的声明, 并且使用合适的作用域将它们串联起来. 换句话说, 变量和函数在内的所有声明都会在代码执行前被处理.

因此, 对于代码 `var i = 2;` 而言, JavaScript 实际上会将这句代码看作 `var i;` 和 `i = 2`, 其中第一个是在编译阶段, 第二个赋值操作会原地等待执行阶段. 换句话说, 这个过程将会把变量和函数声明放到其作用域的顶部, 这个过程就叫做提升.

可能你会有疑问, 为什么 let 和 const 不存在变量提升呢?这是因为在编译阶段, 当遇到变量声明时, 编译器要么将它提升至作用域顶部(var 声明), 要么将它放到 **临时死区(temporal dead zone, TDZ)**, 也就是用 let 或 const 声明的变量. **访问 TDZ 中的变量会触发运行时的错误**, 只有执行过变量声明语句后, 变量才会从 TDZ 中移出, 这时才可访问.

下面这个例子你能不能全部答对.

```js
typeof null; // 'object'

typeof []; // 'object'

typeof someStr; // 'undefined'

typeof str; // Uncaught ReferenceError: str is not defined
const str = ""Yancey"";
```

第一个, 因为 `null` 根本上是一个指针, 所以会返回 `'object'`. 深层次一点, 不同的对象在底层都表示为二进制, 在 Javascript 中二进制前三位都为 0 的会被判断为 Object 类型, null 的二进制全为 0, 自然前三位也是 0, 所以执行 typeof 时会返回 `'object'`.

第二个想强调的是, typeof 判断一个引用类型的变量, 拿到的都是 `'object'`, 因此该操作符无法正确辨别具体的类型, 如 Array 还是 RegExp.

第三个, 当 typeof 一个 **未声明** 的变量, 不会报错, 而是返回 'undefined'

第四个, `str` 先是存在于 TDZ, 上面说到访问 TDZ 中的变量会触发运行时的错误, 所以这段代码直接报错.

### 函数提升

函数声明和变量声明都会被提升, 但值得注意的是, 函数首先被提升, 然后才是变量.

```js
test();

function test() {
  foo();
  bar();
  var foo = function () {
    console.log(""this won't run!"");
  };
  function bar() {
    console.log(""this will run!"");
  }
}
```

上面的代码会变成下面的形式: 内部的 `bar` 函数会被提升到顶部, 所以可以被执行到;接下来变量 `foo` 会被提升到顶部, 但变量无法执行, 因此执行 `foo()` 会报错.

```js
function test() {
  var foo;
  function bar() {
    console.log(""this will run!"");
  }
  foo();
  bar();
  foo = function () {
    console.log(""this won't run!"");
  };
}
test();
```

### 提升带来的缺点

**变量容易在不被察觉的情况下被覆盖掉**. 下面这段代码, 在 showName 函数中, 由于 myname 是用 var 声明的, 所以不是块级作用域, 所以 myname 在 showName 函数中会被提升到顶部, 所以两个 log 都会打印出 undefined.

```ts
var myname = ""极客时间"";
function showName() {
  console.log(myname);
  if (0) {
    var myname = ""极客邦"";
  }
  console.log(myname);
}
showName();
```

**本应销毁的变量没有被销毁**. 下面这段代码, 离开了 for 循环之后 i 并没有被销毁.

```ts
function foo() {
  for (var i = 0; i < 7; i++) {}
  console.log(i);
}
foo();
```

### 编译器是怎么即支持 var, 又支持 let, const 的

```ts
function foo() {
  var a = 1;
  let b = 2;
  {
    let b = 3;
    var c = 4;
    let d = 5;
    console.log(a);
    console.log(b);
  }
  console.log(b);
  console.log(c);
  console.log(d);
}
foo();
```

对于 var, 会发生变量提升, 也就是在一个变量赋值前就能访问它. 因此, 自 ECMAScript 5 开始约定, ECMAScript 的执行上下文将有两个环境, 一个称为词法环境(Lexical Environment), 另一个就称为变量环境(Variable Environment), 所有传统风格的 var 声明和函数声明通过变量环境来管理. 所有 let, const 的使用词法环境管理. 而在内核上, 全局上下文的词法环境和变量环境指向是一样的. 也就意味着词法变量和 var 变量共用一个名字表, 因此你声明了 var 变量, 那么就不能声明同名的 let/const 变量.

当进入函数的作用域块时, 作用域块中通过 let 声明的变量, 会被存放在词法环境的一个单独的区域中, 这个区域中的变量并不影响作用域块外面的变量.

在词法环境内部, 维护了一个小型栈结构, 栈底是函数最外层的变量, 进入一个作用域块后, 就会把该作用域块内部的变量压到栈顶; 当作用域执行完成之后, 该作用域的信息就会从栈顶弹出.

当执行到作用域块中的 `console.log(a)` 这行代码时, 就需要在词法环境和变量环境中查找变量 a 的值了, 具体查找方式是: 沿着词法环境的栈顶向下查询, 如果在词法环境中的某个块中查找到了, 就直接返回给 JavaScript 引擎, 如果没有查找到, 那么继续在变量环境中查找.

## 执行上下文

上下文指的是一个外部的, 内部的或由全局 / 模块入口映射成的函数. JavaScript 的执行系统由一个执行栈和一个执行队列构成. 在执行队列中保存的是待执行的任务, 称为 Job. 每一个执行上下文都需要关联到一个对照表. 这个对照表, 就称为**词法环境(Lexical Environment)**.

**模块入口**是所有模块的顶层代码的顺序组合, 它们被封装为一个称为顶层模块执行(TopLevelModule Evaluation Job)的函数中来作为模块加载的第一个执行上下文创建. 一般 **.js 文件**也会创建一个脚本执行(Script Evaluation Job) 的函数, 这也是文件加载中所有全局代码块被称为 script 块的原因. **eval** 也是会开启一个执行上下文, JavaScript 为 eval() 所分配的这个执行上下文, 与调用 eval() 时的函数上下文享有同一个环境(包括词法环境和变量环境等等), 并在退出 eval() 时释放它的引用, 以确保同一个环境中同时只有一个逻辑在执行.

对于普通函数被调用, 它也会形成执行上下文, 但它是**被**调用的, 所以它会创建一个 caller(调用者), 由于栈是先入后出的, 因此总是立即执行这个 callee 函数的上下文. 因此所有其他上下文都在执行栈上, 而生成器的上下文(多数时间是)在栈的外面.

执行上下文包含变量环境, 词法环境, outer, this.

![执行上下文的构成](https://edge.yancey.app/beg/0hkka1zh-1650268445518.webp)

## 调用栈

调用栈就是用来管理函数调用关系的一种数据结构, 在执行上下文创建好后, JavaScript 引擎会将执行上下文压入栈中, 通常把这种用来管理执行上下文的栈称为**执行上下文栈**, 又称**调用栈**. 以下面这段代码为例.

```ts
var a = 2;
function add() {
  var b = 10;
  return a + b;
}
add();
```

在执行到函数 add() 之前, JavaScript 引擎会为上面这段代码创建全局执行上下文, 包含了声明的函数和变量.

![全局执行上下文](https://edge.yancey.app/beg/yrwofq1f-1650203945435.webp)

执行上下文准备好之后, 便开始执行全局代码, 当执行到 add 这儿时, JavaScript 判断这是一个函数调用, 那么将执行以下操作:

- 首先, 从**全局执行上下文**中, 取出 add 函数代码.
- 其次, 对 add 函数的这段代码进行编译, 并创建该函数的**执行上下文**和**可执行代码**.
- 最后, 执行代码, 输出结果.

![函数调用过程](https://edge.yancey.app/beg/gjros498-1650203937037.webp)

再换个复杂的例子:

```ts
var a = 2;
function add(b, c) {
  return b + c;
}
function addAll(b, c) {
  var d = 10;
  result = add(b, c);
  return a + result + d;
}
addAll(3, 6);
```

1. 首先创建全局上下文, 并将其压入栈底. 此时全局上下文的 a, add, adAll 被保存到变量环境对象中.
2. 全局执行上下文压入到调用栈后, JavaScript 引擎便开始执行全局代码了. 首先会执行 `a = 2` 的赋值操作, 执行该语句会将全局上下文变量环境中 a 的值设置为 2.
3. 接着调用 addAll 函数. 当调用该函数时, JavaScript 引擎会编译该函数, 并为其创建一个执行上下文, 最后还将该函数的执行上下文压入栈中.
4. addAll 函数的执行上下文创建好之后, 便进入了函数代码的执行阶段了, 这里先执行的是 d=10 的赋值操作, 执行语句会将 addAll 函数执行上下文中的 d 由 undefined 变成了 10.
5. 当执行到 add 函数调用语句时, 同样会为其创建执行上下文, 并将其压入调用栈, 当 add 函数返回时, 该函数的执行上下文就会从栈顶弹出, 并将 result 的值设置为 add 函数的返回值, 也就是 9
6. 紧接着 addAll 执行最后一个相加操作后并返回, addAll 的执行上下文也会从栈顶部弹出, 此时调用栈中就只剩下全局上下文了, 整个 JavaScript 流程执行结束了

![执行图](https://edge.yancey.app/beg/vuiuq6ua-1650205890104.jpeg)

### 利用调用栈调试指南

通过在 Source 中打断点, 这时可以通过右边“ `call stack` 来查看当前的调用栈的情况, 如下图:

![Source 断点](https://edge.yancey.app/beg/oq4xknmu-1650206989381.webp)

除了通过断点来查看调用栈, 你还可以使用 `console.trace()` 来输出当前的函数调用关系, 如下图:

![console.trace()](https://edge.yancey.app/beg/rep90r1f-1650206979053.webp)

### 栈溢出

现在你知道了调用栈是一种用来管理执行上下文的数据结构, 符合后进先出的规则. 不过还有一点你要注意, 调用栈是有大小的, 当入栈的执行上下文超过一定数目, JavaScript 引擎就会报错, 我们把这种错误叫做栈溢出. 这是因为这个函数是递归的, 并且没有任何终止条件, 所以它会一直创建新的函数执行上下文, 并反复将其压入栈中, 但栈是有容量限制的, 超过最大数量后就会出现栈溢出的错误. 除了对代码做出改进, 目前引擎都实现了尾递归优化, 可以利用这一点来避免爆栈 333333333333333333333333.

![栈溢出](https://edge.yancey.app/beg/tgfm7a8f-1650210260724.jpg)

## 闭包

> 闭包是指那些能够访问独立(自由)变量的函数(变量在本地使用, 但定义在一个封闭的作用域中). 换句话说, 这些函数可以「记忆」它被创建时候的环境. -- MDN
>
> 闭包是有权访问另一个函数作用域的函数. -- 《JavaScript 高级程序设计(第 3 版)》
>
> 函数对象可以通过作用域链相互关联起来, 函数体内部的变量都可以保存在函数作用域内, 这种特性在计算机科学文献中称为闭包. -- 《JavaScript 权威指南(第 6 版)》
>
> 当函数可以记住并访问所在的词法作用域时, 就产生了闭包, 即使函数是在当前词法作用域之外执行. -- 《你不知道的 JavaScript(上卷)》

似乎最后一个解释更容易理解, 所以我们从""记住并访问""来学习闭包.

### 何为""记住""

在 JavaScript 中, 如果函数被调用过了, 并且以后不会被用到, 那么垃圾回收机制(后面会说到)就会销毁由函数创建的作用域. 我们知道, 引用类型的变量只是一个指针, 并不会把真正的值拷贝给变量, 而是把对象所在的**位置**传递给变量. 因此, 当函数被传递到一个还未销毁的作用域的某个变量时, 由于变量存在, 所以函数会存在, 又因为函数的存在依赖于函数所在的词法作用域, 所以函数所在的词法作用域也会存在, 这样一来, 就""记住""了该词法作用域.

看下面这个例子. 在执行 `apple` 函数时, 将 `output` 的引用作为参数传递给了 `fruit` 函数的 `arg`, 因此在 `fruit` 函数执行期间, `arg` 是存在的, 所以 `output` 也是存在的, 而 `output` 依赖的 `apple` 函数产生的局部作用域也是存在. 这也就是 `output` 函数""记住""了 `apple` 函数作用域的原因.

```js
function apple() {
  var count = 0;
  function output() {
    console.log(count);
  }
  fruit(output);
}
function fruit(arg) {
  console.log(""fruit"");
}
apple(); // fruit
```

### ""记住"" 并 ""访问""

但上面的例子并不是完整的""闭包"", 因为只是""记住""了作用域, 但没有去""访问""这个作用域. 我们稍微改造一下上面这个例子, 在 `fruit` 函数中执行 `arg` 函数, 实际就是执行 `output`, 并且还访问了 `apple` 函数中的 `count` 变量.

```js
function apple() {
  var count = 0;
  function output() {
    console.log(count);
  }
  fruit(output);
}

function fruit(arg) {
  arg();
}

apple(); // 0
```

### 循环和闭包

下面是一道经典的面试题. 我们希望代码输出 0 ～ 4, 每秒一次, 每次一个. 但实际上, 这段代码在运行时会以每秒一次的频率输出五次 5.

```js
for (var i = 0; i < 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

因为 setTimeout 是异步执行的, 1000 毫秒后向任务队列里添加一个任务, 只有主线程上的任务全部执行完毕才会执行任务队列里的任务, 所以当主线程 for 循环执行完之后 i 的值为 5, 而用这个时候再去任务队列中执行任务, 因此 i 全部为 5. 又因为在 for 循环中使用 `var` 声明的 `i` 是在全局作用域中, 因此 `timer` 函数中打印出来的 `i` 自然是都是 5.

我们可以通过在迭代内使用 IIFE 来给每个迭代都生成一个新的作用域, 使得延迟函数的回调可以将新的作用域封闭在每个迭代内部, 每个迭代中都会含有一个具有正确值的变量供我们访问.
代码如下所示.

```js
for (var i = 0; i < 5; i++) {
  (function (j) {
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })(i);
}
```

如果你 API 看得仔细的话, 还可以写成下面的形式:

```js
for (var i = 0; i < 5; i++) {
  setTimeout(
    function (j) {
      console.log(j);
    },
    i * 1000,
    i
  );
}
```

当然最好的方式是使用 let 声明 i, 这时候变量 i 就能作用于这个循环块, 每个迭代都会使用上一个迭代结束的值来初始化这个变量.

```js
for (let i = 0; i < 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

### 从词法作用域的角度理解闭包

```ts
function foo() {
  var myName = ""极客时间"";
  let test1 = 1;
  var innerBar = {
    getName: function () {
      console.log(test1);
      return myName;
    },
    setName: function (newName) {
      myName = newName;
    },
  };
  return innerBar;
}
var bar = foo();
bar.setName(""极客邦"");
bar.getName(); // 1 极客邦
```

根据词法作用域的规则, 内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量, 所以当 innerBar 对象返回给全局变量 bar 时, 虽然 foo 函数已经执行结束, 但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 myName 和 test1.

foo 函数执行完成之后, 其执行上下文从栈顶弹出了, 但是由于返回的 setName 和 getName 方法中使用了 foo 函数内部的变量 myName 和 test1, 所以这两个变量依然保存在内存中. 这像极了 setName 和 getName 方法背的一个**专属背包**, 无论在哪里调用了 setName 和 getName 方法, 它们都会背着这个 foo 函数的专属背包.

之所以是**专属背包**, 是因为除了 setName 和 getName 函数之外, 其他任何地方都是无法访问该背包的, 我们就可以把这个背包称为 foo 函数的**闭包**.

在 JavaScript 中, 根据词法作用域的规则, 内部函数总是可以访问其外部函数中声明的变量, 当通过调用一个外部函数返回一个内部函数后, 即使该外部函数已经执行结束了, 但是内部函数引用外部函数的变量依然保存在内存中, 我们就把这些变量的集合称为闭包. 比如外部函数是 foo, 那么这些变量的集合就称为 foo 函数的闭包.

那这些闭包是如何使用的呢? 当执行到 `bar.setName` 方法中的 `myName = ""极客邦""` 这句代码时, JavaScript 引擎会沿着 **当前执行上下文 -> foo 函数闭包 -> 全局执行上下文** 的顺序来查找 myName 变量. 同样的流程, 当调用 bar.getName 的时候, 所访问的变量 myName 也是位于 foo 函数闭包中的.

![闭包](https://edge.yancey.app/beg/lgr3ye21-1650222691372.webp)

你可以通过打断点来了解闭包. 从图中可以看出来, 当调用 bar.getName 的时候, 右边 Scope 项就体现出了作用域链的情况: Local 就是当前的 getName 函数的作用域, Closure(foo) 是指 foo 函数的闭包, 最下面的 Global 就是指全局作用域, 从 **Local -> Closure(foo) -> Global** 就是一个完整的作用域链.

### 闭包回收

如果引用闭包的函数是一个全局变量, 那么闭包会一直存在直到页面关闭; 但如果这个闭包以后不再使用的话, 就会造成内存泄漏. 如果引用闭包的函数是个局部变量, 等函数销毁后, 在下次 JavaScript 引擎执行垃圾回收时, 判断闭包这块内容如果已经不再被使用了, 那么 JavaScript 引擎的垃圾回收器就会回收这块内存.

所以在使用闭包的时候, 如果该闭包会一直使用, 那么它可以作为全局变量而存在; 但如果使用频率不高, 而且占用内存又比较大的话, 那就尽量让它成为一个局部变量.

### JavaScript 的内存与闭包

```ts
function foo() {
  var myName = ""极客时间"";
  let test1 = 1;
  const test2 = 2;
  var innerBar = {
    setName: function (newName) {
      myName = newName;
    },
    getName: function () {
      console.log(test1);
      return myName;
    },
  };
  return innerBar;
}
var bar = foo();
bar.setName(""极客邦"");
bar.getName();
console.log(bar.getName());
```

还是以这段代码为例. 当 foo 函数的执行上下文销毁时, 由于 foo 函数产生了闭包, 所以变量 myName 和 test1 并没有被销毁, 而是保存在内存中. 这应该怎么解释呢?

1. 当 JavaScript 引擎执行到 foo 函数时, 首先会编译, 并创建一个空执行上下文.
2. 在编译过程中, 遇到内部函数 setName, JavaScript 引擎还要对内部函数做一次快速的词法扫描, 发现该内部函数引用了 foo 函数中的 myName 变量, 由于是内部函数引用了外部函数的变量, 所以 JavaScript 引擎判断这是一个闭包, 于是在堆空间创建换一个 `closure(foo)` 的对象(这是一个内部对象, JavaScript 是无法访问的), 用来保存 myName 变量.
3. 接着继续扫描到 getName 方法时, 发现该函数内部还引用变量 test1, 于是 JavaScript 引擎又将 test1 添加到 `closure(foo)` 对象中. 这时候堆中的 `closure(foo)` 对象中就包含了 myName 和 test1 两个变量了.
4. 由于 test2 并没有被内部函数引用, 所以 test2 依然保存在调用栈中.

![闭包的产生过程](https://edge.yancey.app/beg/kqsj6rkj-1650287019406.webp)

从上图你可以清晰地看出, 当执行到 foo 函数时, 闭包就产生了; 当 foo 函数执行结束之后, 返回的 getName 和 setName 方法都引用 `closure(foo)` 对象, 所以即使 foo 函数退出了, `closure(foo)` 依然被其内部的 getName 和 setName 方法引用. 所以在下次调用 `bar.setName` 或者 `bar.getName` 时, 创建的执行上下文中就包含了 `closure(foo)`.

总的来说, 产生闭包的核心有两步: 第一步是需要预扫描内部函数; 第二步是把内部函数引用的外部变量保存到堆中.

## 垃圾回收

上面提到, 函数被调用过了, 并且以后不会被用到, 那么垃圾回收机制就会销毁由函数创建的作用域. JavaScript 有两种垃圾回收机制, 即 **标记清除** 和 **引用计数**, 对于现代浏览器, 绝大多数都会采用 **标记清除**.

标记清除的主要原理是, 垃圾收集器在运行的时候会给存储在内存中的所有变量加上标记, 然后它会去掉环境中变量以及被环境中的变量引用的变量的标记. 而在此之后再被加上标记的变量将被视为准备删除的变量, 原因是环境中的变量已经无法访问到这些变量了. 最后, 垃圾收集器完成内存清除工作, 销毁那些带标记的值并且回收它们所占用的内存空间.

引用计数是跟踪记录每个值被引用的次数. 当声明了一个变量并将一个引用类型值赋给该变量时, 这个值得引用次数就是 1;相反, 如果包含对这个值引用的变量又取得了另外一个值, 则这个值得引用次数减 1; 下次运行垃圾回收器时就可以释放那些引用次数为 0 的值所占用的内存. 缺点: **循环引用**会导致引用次数永远不为 0.

本文会详细讲标记清除, 在此之前, 我们先看一看垃圾是如何产生的, 以及调用栈中的数据和堆中的数据是如何回收的.

### 垃圾是如何产生的

```ts
window.test = new Object();
window.test.a = new Uint16Array(100);
```

以上面代码为例, 首先先为 window 对象添加一个 test 属性, 并在堆中创建了一个空对象, 并将该对象的地址指向了 window.test 属性. 随后又创建一个大小为 100 的数组, 并将属性地址指向了 test.a 的属性值, 此时的内存布局图如下所示:

![内存布局](https://edge.yancey.app/beg/w12566ou-1653750219252.webp)

我们可以看到, 栈中保存了指向 window 对象的指针, 通过栈中 window 的地址, 我们可以到达 window 对象, 通过 window 对象可以到达 test 对象, 通过 test 对象还可以到达 a 对象.

如果此时, 我将另外一个对象赋给了 a 属性, 代码如下所示:

```ts
window.test.a = new Object();
```

此时的内存布局图如下所示: 我们可以看到, a 属性之前是指向堆中数组对象的, 现在已经指向了另外一个空对象, 那么此时堆中的数组对象就成为了垃圾数据, 因为我们无法从一个根对象遍历到这个 Array 对象. 不过, 你不用担心这个数组对象会一直占用内存空间, 因为 V8 虚拟机中的垃圾回收器会帮你自动清理.

![内存布局](https://edge.yancey.app/beg/5bi4j3kn-1653750212035.webp)

### 调用栈中的数据是如何回收的

```ts
function foo() {
  var a = 1;
  var b = { name: ""极客邦"" };
  function showName() {
    var c = 2;
    var d = { name: ""极客时间"" };
  }
  showName();
}

foo();
```

我们知道, 如果执行到 showName 函数时, 那么 JavaScript 引擎会创建 showName 函数的执行上下文, 并将 showName 函数的执行上下文压入到调用栈中来执行, 与此同时, 还有一个记录当前执行状态的指针 **ESP**, 指向调用栈中 showName 函数的执行上下文, 表示当前正在执行 showName 函数.

接着, 当 showName 函数执行完成之后, 函数执行流程就进入了 foo 函数, 那这时就需要销毁 showName 函数的执行上下文了. **ESP** 这时候就帮上忙了, JavaScript 会将 **ESP** 下移到 foo 函数的执行上下文, 这个下移操作就是销毁 showName 函数执行上下文的过程.

之所以下移操作能奏效, 是因为当 showName 函数执行结束之后, ESP 向下移动到 foo 函数的执行上下文中, 上面 showName 的执行上下文虽然保存在栈内存中, 但是已经是无效内存了. 比如当 foo 函数再次调用另外一个函数时, 这块内容会被直接覆盖掉, 用来存放另外一个函数的执行上下文.

因此, **当一个函数执行结束之后, JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文**.

![ESP](https://edge.yancey.app/beg/r7o00vv8-1650353078333.jpg)

### 堆中的数据是如何回收的

上面的代码中, 当 foo 也执行完了, ESP 就会下移到全局上下文, 当在全局上下文调用其他函数后, showName 函数和 foo 函数的执行上下文就处于无效状态了, 不过保存在堆中的两个对象 b 和 d 依然占用着空间. 要回收堆中的垃圾数据, 就需要用到 JavaScript 中的垃圾回收器了.

![foo 函数执行结束后的内存状态](https://edge.yancey.app/beg/i33mlywv-1650354379275.webp)

### 代际假说和分代收集

在正式介绍 V8 是如何实现回收之前, 先说一下代际假说(The Generational Hypothesis)的内容, 这是垃圾回收领域中一个重要的术语, 后续垃圾回收的策略都是建立在该假说的基础之上的.

代际假说有以下两个特点:

- 第一个是大部分对象在内存中存在的时间很短, 简单来说, 就是很多对象一经分配内存, 很快就变得不可访问;
- 第二个是不死的对象, 会活得更久.

在 V8 中会把堆分为**新生代**和**老生代**两个区域, 新生代中存放的是生存时间短的对象, 老生代中存放的生存时间久的对象. 新生区通常只支持 1 - 8M 的容量, 而老生区支持的容量就大很多了. 对于这两块区域, V8 分别使用两个不同的垃圾回收器. **副垃圾回收器**负责新生代的垃圾回收; **主垃圾回收器**负责老生代的垃圾回收.

### 垃圾回收器的工作流程

第一步通过 GC Root 标记空间中活动对象和非活动对象. 目前 V8 采用的可访问性(reachability) 算法来判断堆中的对象是否是活动对象. 具体地讲, 这个算法是将一些 GC Root 作为初始存活的对象的集合, 从 GC Roots 对象出发, 遍历 GC Root 中的所有对象:

- 通过 GC Root 遍历到的对象, 也就是还在使用的对象, 我们就认为该对象是可访问的(reachable), 那么必须保证这些对象应该在内存中保留, 我们也称可访问的对象为活动对象;
- 通过 GC Roots 没有遍历到的对象, 其实就是在所有的标记完成之后, 统一清理内存中所有被标记为可回收的对象, 则是不可访问的(unreachable), 那么这些不可访问的对象就可能被回收, 我们称不可访问的对象为非活动对象.

在浏览器环境中, GC Root 有很多, 通常包括了以下几种 (但是不止于这几种):

- 全局的 window 对象(位于每个 iframe 中);
- 文档 DOM 树, 由可以通过遍历文档到达的所有原生 DOM 节点组成;
- 存放栈上变量.

第二步是回收非活动对象所占据的内存. 其实就是在所有的标记完成之后, 统一清理内存中所有被标记为可回收的对象.

第三步是做内存整理. 一般来说, 频繁回收对象后, 内存中就会存在大量不连续空间, 我们把这些不连续的内存空间称为**内存碎片**. 当内存中出现了大量的内存碎片之后, 如果需要分配较大连续内存的时候, 就有可能出现内存不足的情况. 所以最后一步需要整理这些内存碎片, 但这步其实是可选的, 因为有的垃圾回收器不会产生内存碎片, 比如接下来我们要介绍的副垃圾回收器.

### 副垃圾回收器

副垃圾回收器主要负责新生区的垃圾回收. 而通常情况下, 大多数小的对象都会被分配到新生区, 所以说这个区域虽然不大, 但是垃圾回收还是比较频繁的. 新生代中用 Scavenge 算法来处理. 它将把新生代空间对半划分为两个区域, 一半是**对象区域**, 一半是**空闲区域**, 如下图所示:

![新生代区](https://edge.yancey.app/beg/w0ykx6yu-1650357462884.webp)

新加入的对象都会存放到对象区域, 当对象区域快被写满时, 就需要执行一次垃圾清理操作.

在垃圾回收过程中, 首先要对对象区域中的垃圾做标记; 标记完成之后, 就进入垃圾清理阶段, 副垃圾回收器会把这些存活的对象复制到空闲区域中, 同时它还会把这些对象有序地排列起来, 所以这个复制过程, 也就相当于完成了内存整理操作, 复制后空闲区域就没有内存碎片了.

完成复制后, 对象区域与空闲区域进行角色翻转, 也就是原来的对象区域变成空闲区域, 原来的空闲区域变成了对象区域. 这样就完成了垃圾对象的回收操作, **同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去.**

由于新生代中采用的 Scavenge 算法, 所以每次执行清理操作时, 都需要将存活的对象从对象区域复制到空闲区域. 但复制操作需要时间成本, 如果新生区空间设置得太大了, 那么每次清理的时间就会过久, **所以为了执行效率, 一般新生区的空间会被设置得比较小.**

也正是因为新生区的空间不大, 所以很容易被存活的对象装满整个区域. 为了解决这个问题, JavaScript 引擎采用了**对象晋升策略**, 也就是经过两次垃圾回收依然还存活的对象, 会被移动到老生区中.

### 主垃圾回收器

主垃圾回收器主要负责老生区中的垃圾回收. 除了新生区中晋升的对象, 一些大的对象会直接被分配到老生区. 因此老生区中的对象有两个特点, **一个是对象占用空间大, 另一个是对象存活时间长**.

由于老生区的对象比较大, 若要在老生区中使用 Scavenge 算法进行垃圾回收, 复制这些大的对象将会花费比较多的时间, 从而导致回收执行效率不高, 同时还会浪费一半的空间. 因而, 主垃圾回收器是采用**标记 - 清除(Mark-Sweep)**的算法进行垃圾回收的.

首先是标记过程阶段. 标记阶段就是从一组根元素开始, 递归遍历这组根元素, 在这个遍历过程中, 能到达的元素称为**活动对象**, 没有到达的元素就可以判断为**垃圾数据**.

![标记过程](https://edge.yancey.app/beg/bnpcxgwo-1650358091604.webp)

比如看着面这张图, 当 showName 函数执行结束之后, ESP 向下移动, 指向了 foo 函数的执行上下文, 这时候如果遍历调用栈, 是不会找到引用 1003 地址的变量, 也就意味着 1003 这块数据为垃圾数据, 被标记为红色. 由于 1050 这块数据被变量 b 引用了, 所以这块数据会被标记为活动对象.

接下来就是垃圾的清除过程, 大致就是下图中红色区域被去掉.

![标记清除](https://edge.yancey.app/beg/2j1wuo84-1650358285275.webp)

由于标记 - 清除算法对一块内存多次执行标记 - 清除算法后, 会产生大量不连续的内存碎片. 而碎片过多会导致大对象无法分配到足够的连续内存, 于是又产生了另外一种算法, 即**标记 - 整理(Mark-Compact)**, 这个标记过程仍然与标记 - 清除算法里的是一样的, 但后续步骤不是直接对可回收对象进行清理, 而是让所有存活的对象都向一端移动, 然后直接清理掉端边界以外的内存.

![标记整理](https://edge.yancey.app/beg/yvn2djx2-1650358293921.webp)

### 全停顿

由于 JavaScript 是运行在主线程之上的, 一旦执行垃圾回收算法, 都需要将正在执行的 JavaScript 脚本暂停下来, 待垃圾回收完毕后再恢复脚本执行. 我们把这种行为叫做**全停顿(Stop-The-World)**. 以下面的图片为例, 有 200ms 交给了垃圾回收, 这也意味着有 200ms 导致主线程停滞导致卡顿.

![全停顿](https://edge.yancey.app/beg/qamdrdni-1650359478882.webp)

在 V8 新生代的垃圾回收中, 因其空间较小, 且存活对象较少, 所以全停顿的影响不大. 但老生代的垃圾回收就会很耗时, 如果全停顿的话, 应用的性能和响应能力都会直线下降. 为此, V8 向现有的垃圾回收器添加并行, 并发和增量等垃圾回收技术:

- 第一, **将一个完整的垃圾回收的任务拆分成多个小的任务**, 这样就消灭了单个长的垃圾回收任务;
- 第二, **将标记对象, 移动对象等任务转移到后台线程进行**, 这会大大减少主线程暂停的时间, 改善页面卡顿的问题, 让动画, 滚动和用户交互更加流畅.

### 并行回收

由于全停顿执行一次完整的垃圾回收过程比较耗时, 那么解决效率问题, 第一个思路就是主线程在执行垃圾回收的任务时, 引入多个辅助线程来并行处理, 同时执行同样的回收工作, 这样就会加速垃圾回收的执行速度.

采用并行回收时, 垃圾回收所消耗的时间, 等于总体辅助线程所消耗的时间(辅助线程数量乘以单个线程所消耗的时间), 再加上一些同步开销的时间. 这种方式比较简单, 因为在执行垃圾标记的过程中, 主线程并不会同时执行 JavaScript 代码, 因此 JavaScript 代码也不会改变回收的过程.

**V8 的副垃圾回收器所采用的就是并行策略**, 它在执行垃圾回收的过程中, 启动了多个线程来负责新生代中的垃圾清理操作, 这些线程同时将对象空间中的数据移动到空闲区域. 由于数据的地址发生了改变, 所以还需要同步更新引用这些对象的指针.

![并行回收](https://edge.yancey.app/beg/lpp4avgy-1653761663732.webp)

### 增量回收

虽然并行策略能增加垃圾回收的效率, 能够很好地优化副垃圾回收器, 但是这仍然是一种**全停顿**的垃圾回收方式, 在主线程执行回收工作的时候才会开启辅助线程, 这依然还会存在效率问题, 因此只适合副垃圾回收器这种轻量的垃圾回收器.

而对于老生代存放的都是一些大的对象, 如 window, DOM 这种, 完整执行老生代的垃圾回收, 时间依然会很久. 这些大的对象都是主垃圾回收器的, 如果通过并行回收仍然会很慢.

因此, 为了降低老生代的垃圾回收而造成的卡顿, V8 将标记过程分为一个个的子标记过程, 每次执行的只是整个垃圾回收过程中的一小部分工作, 同时让垃圾回收标记和 JavaScript 应用逻辑(主线程)交替进行, 直到标记阶段完成, 我们把这个算法称为**增量标记(Incremental Marking)算法**. 使用增量标记算法, 可以把一个完整的垃圾回收任务拆分为很多小的任务, 这些小的任务执行时间比较短, 可以穿插在其他的 JavaScript 任务中间执行, 这样当执行一些动画效果时, 就不会让用户因为垃圾回收任务而感受到页面的卡顿了.

![增量标记](https://edge.yancey.app/beg/aylatppg-1650359714173.webp)

增量标记的算法, 比全停顿的算法要稍微复杂, 这主要是因为增量回收是并发的（concurrent）, 要实现增量执行, 需要满足两点要求:

- 垃圾回收可以被随时暂停和重启, 暂停时需要保存当时的扫描结果, 等下一波垃圾回收来了之后, 才能继续启动.
- 在暂停期间, 被标记好的垃圾数据如果被 JavaScript 代码修改了, 那么垃圾回收器需要能够正确地处理.

我们先来看看第一点, V8 是如何实现垃圾回收器的暂停和恢复执行的.

在没有采用增量算法之前, V8 使用黑色和白色来标记数据. 在执行一次完整的垃圾回收之前, 垃圾回收器会将所有的数据设置为白色, 用来表示这些数据还没有被标记, 然后垃圾回收器在会从 GC Roots 出发, 将所有能访问到的数据标记为黑色. 遍历结束之后, 被标记为黑色的数据就是活动数据, 那些白色数据就是垃圾数据.

![数据标记](https://edge.yancey.app/beg/9f9m5u7n-1653762225750.webp)

但由于执行一段 GC 后, 又会回到主线程运行时执行一段 JavaScript 代码, 这些代码就把黑白标记搞乱了. 为了解决这个问题, V8 采用了三色标记法, 除了黑色和白色, 还额外引入了灰色:

- 黑色表示这个节点被 GC Root 引用到了, 而且该节点的子节点都已经标记完成了;
- 灰色表示这个节点被 GC Root 引用到了, 但子节点还没被垃圾回收器标记处理, 也表明目前正在处理这个节点;
- 白色表示这个节点没有被访问到, 如果在本轮遍历结束时还是白色, 那么这块数据就会被收回.

引入灰色标记之后, 垃圾回收器就可以依据当前内存中有没有灰色节点, 来判断整个标记是否完成, 如果没有灰色节点了, 就可以进行清理工作了. 如果还有灰色标记, 当下次恢复垃圾回收器时, 便从灰色的节点开始继续执行. 我们看下面一个例子:

```ts
window.a = Object();
window.a.b = Object();
window.a.b.c = Object();
```

执行到这段代码时, 垃圾回收器标记的结果如下图所示:

![初次标记](https://edge.yancey.app/beg/76yxq6vm-1653763604705.webp)

然后又执行了另外一个代码, 这段代码如下所示:

```ts
window.a.b = Object();
```

执行完之后, 垃圾回收器又恢复执行了增量标记过程, 由于 b 重新指向了 d 对象, 所以 b 和 c 对象的连接就断开了. 这时候代码的应用如下图所示:

![再次标记](https://edge.yancey.app/beg/0wkcakle-1653763613071.webp)

这就说明一个问题, 当垃圾回收器将某个节点标记成了黑色, 然后这个黑色的节点被续上了一个白色节点, 那么垃圾回收器不会再次将这个白色节点标记为黑色节点了, 因为它已经走过这个路径了.

但是这个新的白色节点的确被引用了, 所以我们还是需要想办法将其标记为黑色. 为了解决这个问题, 增量垃圾回收器添加了一个约束条件: **不能让黑色节点指向白色节点**.

通常我们使用**写屏障(Write-barrier)**机制实现这个约束条件, 也就是说, 当发生了黑色的节点引用了白色的节点, 写屏障机制会强制将被引用的白色节点变成灰色的, 这样就保证了黑色节点不能指向白色节点的约束条件. 这个方法也被称为**强三色不变性**, 它保证了垃圾回收器能够正确地回收数据, 因为在标记结束时的所有白色对象, 对于垃圾回收器来说, 都是不可到达的, 可以安全释放.

所以在 V8 中, 每次执行如 `window.a.b = value` 的写操作之后, V8 会插入写屏障代码, 强制将 value 这块内存标记为灰色.

### 并发回收

虽然通过三色标记法和写屏障机制可以很好地实现增量垃圾回收, 但是由于这些操作都是在主线程上执行的, 如果主线程繁忙的时候, 增量垃圾回收操作依然会增加主线程处理任务的吞吐量 (throughput). 此外, 并行回收可以将一些任务分配给辅助线程, 但是并行回收依然会阻塞主线程. 因此, 我们有了并发回收, 所谓并发回收, 是指主线程在执行 JavaScript 的过程中, 辅助线程能够在后台完成执行垃圾回收的操作.

并发回收的优势非常明显, 主线程不会被挂起, JavaScript 可以自由地执行 , 在执行的同时, 辅助线程可以执行垃圾回收操作.

但是并发回收却是这三种技术中最难的一种, 这主要由以下两个原因导致的:

- 第一, 当主线程执行 JavaScript 时, 堆中的内容随时都有可能发生变化, 从而使得辅助线程之前做的工作完全无效;
- 第二, 主线程和辅助线程极有可能在同一时间去更改同一个对象, 这就需要额外实现读写锁的一些功能了.

不过, 这三种技术在实际使用中, 并不是单独的存在, 通常会将其融合在一起使用, V8 的主垃圾回收器就融合了这三种机制, 来实现垃圾回收:

- 首先主垃圾回收器主要使用并发标记, 我们可以看到, 在主线程执行 JavaScript, 辅助线程就开始执行标记操作了, 所以说标记是在辅助线程中完成的.
- 标记完成之后, 再执行并行清理操作. 主线程在执行清理操作时, 多个辅助线程也在执行清理操作.
- 另外, 主垃圾回收器还采用了增量标记的方式, 清理的任务会穿插在各种 JavaScript 任务之间执行.

![综合](https://edge.yancey.app/beg/rg52zimp-1653769610158.webp)

## 几种内存问题

- 内存泄漏 (Memory leak), 它会导致页面的性能越来越差;
- 内存膨胀 (Memory bloat), 它会导致页面的性能会一直很差;
- 频繁垃圾回收, 它会导致页面出现延迟或者经常暂停.

### Nodejs 事件循环机制

Node 是 V8 的宿主, 它会给 V8 提供事件循环和消息队列. 在 Node 中, 事件循环是由 libuv 提供的, libuv 工作在主线程中, 它会从消息队列中取出事件, 并在主线程上执行事件. 同样, 对于一些主线程上不适合处理的事件, 比如消耗时间过久的网络资源下载, 文件读写, 设备访问等, Node 会提供很多线程来处理这些事件, 我们把这些线程称为线程池. 以 file 模块为例, 通常, 在 Node 中, 我们认为读写文件是一个非常耗时的工作, 因此主线程会将回调函数和读文件的操作一道发送给文件读写线程, 并让实际的读写操作运行在读写线程中.

![Node 的体系架构](https://edge.yancey.app/beg/zsc0u9db-1653780799522.webp)

比如当在 Node 的主线程上执行 readFile 的时候, 主线程会将 readFile 的文件名称和回调函数, 提交给文件读写线程来处理.

文件读写线程完成了文件读取之后, 会将结果和回调函数封装成新的事件, 并将其添加进消息队列中. 比如文件线程将读取的文件内容存放在内存中, 并将 data 指针指向了该内存, 然后文件读写线程会将 data 和回调函数封装成新的事件, 并将其丢进消息队列中.

等到 libuv 从消息队列中读取该事件后, 主线程就可以着手来处理该事件了. 在主线程处理该事件的过程中, 主线程调用事件中的回调函数, 并将 data 结果数据作为参数.

![读取文件原理](https://edge.yancey.app/beg/l0ffmhmm-1653781021532.jpeg)

不过, 总有些人觉得异步读写文件操作过于复杂了, 如果读取的文件体积不大或者项目瓶颈不在文件读写, 那么依然使用异步调用和回调函数的模式就显得有点过度复杂了. 因此 Node 还提供了一套同步读写的 API. 第一段代码中的 readFileSync 就是同步实现的, 同步代码非常简单, 当 libuv 读取到 readFileSync 的任务后, 就直接在主线程上执行读写操作, 等待读写结束, 直接返回读写的结果, 这也是同步回调的一种应用. 当然在读写过程中, 消息队列中的其他任务是无法被执行的.

### 内存泄漏 (Memory leak)

本质上, 内存泄漏可以定义为当进程不再需要某些内存的时候, 这些不再被需要的内存依然没有被进程回收. 在 JavaScript 中, 造成内存泄漏的主要原因是不再需要没有作用的内存数据依然被其他对象引用着. 下面举几个例子:

**不要声明没有使用 var, let, const 的变量**, 看下面这段代码, temp_array 没有使用 var, let, const 声明, 在**非严格模式**下, 会默认将 temp_array 变成 `this.temp_array`, 在浏览器默认情况下, this 是指向 window 对象的, 而 window 对象是常驻内存的, 所以即便 foo 函数退出了, 但是 temp_array 依然被 window 对象引用了, 所以 temp_array 依然也会和 window 对象一样, 会常驻内存. 因为 temp_array 已经是不再被使用的对象了, 但是依然被 window 对象引用了, 这就造成了 temp_array 的泄漏. 为了解决这个问题, 我们可以在 JavaScript 文件头部加上 `""use strict""`, 使用严格模式避免意外的全局变量, 此时上例中的 this 指向 undefined.

```ts
function foo() {
  temp_array = new Array(200000);
}
```

**小心闭包**, 闭包会引用父级函数中定义的变量, 如果引用了不被需要的变量, 那么也会造成内存泄漏. 下面这段代码中, 由于闭包函数使用了 `temp_object.x`, 因此 temp_object 对象会常驻内存, 而 temp_object 有个很重的属性 array, 它也被常驻内存了, 而我们仅仅需要 `temp_object.x` 而已.

```ts
function foo() {
  var temp_object = new Object();
  temp_object.x = 1;
  temp_object.y = 2;
  temp_object.array = new Array(200000);

  return function () {
    console.log(temp_object.x);
  };
}
```

为防止这个问题, 你可以把 x 单独拎出来.

```ts
function foo() {
  const temp_object = new Object();
  temp_object.x = 1;
  temp_object.y = 2;
  temp_object.array = new Array(200000);

  const { x } = temp_object;
  return function () {
    console.log(x);
  };
}
```

**JavaScript 引用了 DOM 节点而造成的内存泄漏的问题**, 我们知道只有同时满足 DOM 树和 JavaScript 代码都不引用某个 DOM 节点, 该节点才会被作为垃圾进行回收. 如果某个节点已从 DOM 树移除, 但 JavaScript 仍然引用它, 我们称此节点为 **detached**, detached 是 DOM 内存泄漏的常见原因. 比如下面这段代码, ul 关联到 DOM 树上, 即便 ul 从 DOM 上被移除后, 它们并不会立即销毁, 这主要是由于 JavaScript 代码中保留了这些元素的引用, 导致这些 DOM 元素依然会待在内存中.

```ts
let detachedTree;
function create() {
  const $ul = document.createElement(""ul"");

  for (let i = 0; i < 100; i++) {
    const $li = document.createElement(""li"");
    $ul.appendChild($li);
  }

  detachedTree = $ul;
}

create();
```

### 内存膨胀 (Memory bloat)

内存膨胀和内存泄漏有一些差异, 内存膨胀主要表现在程序员对内存管理的不科学, 比如只需要 50M 内存就可以搞定的, 有些程序员却花费了 500M 内存. 额外使用过多的内存有可能是没有充分地利用好缓存, 也有可能加载了一些不必要的资源. 通常表现为内存在某一段时间内快速增长, 然后达到一个平稳的峰值继续运行. 从下图我们可以看到, 内存膨胀是快速增长, 然后达到一个平衡的位置, 而内存泄漏是内存一直在缓慢增长.

![内存膨胀](https://edge.yancey.app/beg/uwl4frdv-1653782059696.webp)

### 频繁垃圾回收

上面我们讲到垃圾回收, 由于全停顿会在主线程运行导致 JavaScript 运行暂停, 如果 GC 很耗时的话, 会引起卡顿. 对应到代码上, 如果频繁使用大的临时变量, 导致了新生代空间很快被装满, 从而频繁触发垃圾回收. 频繁的垃圾回收操作会让你感觉到页面卡顿. 为了解决频繁的垃圾回收的问题, 你可以考虑将这些临时变量设置为全局变量.

## 总结

Q: 什么是作用域?

A: 作用域是根据名称查找变量的一套规则.

Q: 什么是作用域链?

A: 当一个块或函数嵌套在另一个块或另一个函数中时, 就发生了作用域嵌套. 因此, 在当前作用域下找不到某个变量时, 会往外层嵌套的作用域继续查找, 直到找到该变量或抵达全局作用域, 如果在全局作用域中还没找到就会报错. 这种逐级向上查找的模式就是作用域链.

Q: 什么是闭包?

A: 当函数可以记住并访问所在的词法作用域时, 就产生了闭包, 即使函数是在当前词法作用域之外执行.

## 最后

导致这篇文章写这么长的根本原因就是 ~~面试~~ 该死的 `var` 关键字! 它就是一个设计错误! 不要去用它!

![卑微](https://edge.yancey.app/beg/me8Sqe9R.jpg)

以一道笔试题收尾: 写一个函数, 第一次调用返回 0, 之后每次调用返回比之前大 1. 这道题不难, 主要是在考察闭包和立即执行函数. 我写的答案如下, 如果你有更好的方案请在评论区分享.

```js
const add = (() => {
  let num = 0;
  return () => num++;
})();
```

## 参考

《JavaScript 高级程序设计 (第三版)》 —— Nicholas C. Zakas

《深入理解 ES6》 —— Nicholas C. Zakas

《你不知道的 JavaScript (上卷)》—— Kyle Simpson

[javascript 的词法作用域](https://js8.in/2011/08/15/javascript%E7%9A%84%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/)

[《JavaScript 闯关记》之作用域和闭包](https://juejin.im/post/58500a02128fe10069319d83)

[深入理解 JavaScript 作用域和作用域链](https://juejin.im/post/5c8290455188257e5d0ec64)

[JavaScript 编译原理, 编译器, 引擎及作用域](https://www.jianshu.com/p/5ebf2ad6def2)

[作用域闭包, 你真的懂了吗?](https://i-solar.github.io/2016/11/05/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82%E4%BA%86%E5%90%97%EF%BC%9F-JavaScript/)

---

欢迎关注我的公众号: 进击的前端

![Yancey_FE](https://edge.yancey.app/beg/qrcode_for_gh_541158abcb21_344.jpg)
","2025-02-02 03:08:22.324081","2025-02-02 03:08:22.324081"
"cf835392-25e1-4e34-9b03-e257ccf3f2f4","{JavaScript}",0,0,False,"https://edge.yancey.app/beg/cover.png","从感性角度学习原型和原型链","最近在拜读 winter 大神的《重学前端》系列，果然是大佬的手笔，追本溯源，娓娓道来。感觉不仅是在重学前端，更是在学习一套方法论。这篇文章是对原型/原型链的一个总结，从生活实际入手，攻克 JavaScript 所谓最难理解的一部分。","## 什么是面向对象?

对象这一概念在人类的幼儿期形成，这远远早于我们编程逻辑中常用的值、过程等概念。在幼年期，我们总是先认识到某一个苹果能吃（这里的某一个苹果就是一个对象），继而认识到所有的苹果都可以吃（这里的所有苹果，就是一个类），再到后来我们才能意识到三个苹果和三个梨之间的联系，进而产生数字“3”（值）的概念。

所以说，面向对象编程强调的是数据和操作数据的行为本质上是互相关联的，因此好的设计就是把数据以及和它相关的行为封装起来。

举例来说，用来表示一个单词或者短语的一串字符通常被称为字符串。字符就是数据。但是你关心的往往不是数据是什么，而是可以对数据做什么，所以可以应用在这种数据上的行为(计算长度、添加数据、搜索，等等)都被设计成 String 类的方法。

### JavaScript 的对象特征

- 对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。

- 对象有状态：对象具有状态，同一对象可能处于不同状态之下。

- 对象具有行为：即对象的状态，可能因为它的行为产生变迁。

第一点很好理解，对象存放在堆内存中，具有唯一标识的内存地址，所以具有唯一的标识。而对于“对象有状态和行为”，`this` 似乎最能阐述这一点，不同方式调用函数让 this 在运行时有不同的指向，从而产生不同的行为。

## 构造函数

构造函数本身就是一个函数，与普通函数没有任何区别。但为了做些区分，使用 new 生成实例的函数我们把它称为构造函数（形式上我们一般将构造函数的名称首字母大写），而直接调用的就是普通函数。

与传统的面向对象语言不同，JavaScript 没有**类**的概念，即便是 ES6 增加了 `class` 关键字，也无非是原型的语法糖。当年 JavaScript 为了模仿 Java，也加入了 new 操作符，但它后面直接跟的是 `构造函数` 而非 `class`。

```js
function Dog(name, age) {
  this.name = name;
  this.age = age;
  this.bark = function () {
    return ""wangwang~"";
  };
}

const husky = new Dog(""Lolita"", 2);
const alaska = new Dog(""Roland"", 3);
```

![属性和方法都放在构造函数里](https://edge.yancey.app/beg/Jietu20190408-182950%402x.jpg)

虽然上面的代码有了面向对象的味道，但它却有一个缺陷。我们根据 Dog 创建了两个实例，导致 bark 方法被创建了两次，这无疑造成了浪费。所以有没有一种办法将 bark 方法单独放到一个地方，让所有的实例都能访问到呢？没错，就是接下来要说到的原型。

## 原型

下面是一张神图，原型/原型链之精髓融汇于此。很多面试管要求你手画原型链，它是个很好的参照。

![图解原型链](https://edge.yancey.app/beg/161c172f0c940ffe.png)

### 生活中的原型

何为“原型”? 从感性的角度来讲，原型是顺应人类自然思维的产物。有个成语叫做“照猫画虎”，这里的猫就是虎的原型，另一个俗语“比着葫芦画瓢”亦是如此。可见，“原型”可以是一个具体的、现实存在的事物。

而我们再看“类”。以房屋和图纸为例，这里图纸就是“类”。图纸的意义在于“指导”工人创造出真实的房子（实例）。因此“类”更倾向于是一种具有指导意义的理论和思想。

所以，JavaScript 才是真正应该被称为“面向对象”的语言，因为它是少有的可以不通过类，直接创建对象的语言。

### 技术上的原型

C++、Java、C# 这些语言都是基于经典的类继承的设计模式，这种模式最大的特点就是提供了非常复杂的规则，并提供了非常多的关键字，诸如 class、friend、protected、private、interface 等，通过组合使用这些关键字，就可以实现继承。而 JavaScript 仅仅在对象中引入了一个原型的属性，就实现了语言的继承机制，基于原型的继承省去了很多基于类继承时的繁文缛节，简洁而优美。

JavaScript 的每个对象都包含了一个隐藏属性 `__proto__` ，我们就把该隐藏属性 `__proto__` 称之为该对象的原型 (prototype)，`__proto__` 指向了内存中的另外一个对象，我们就把 `__proto__` 指向的对象称为该对象的原型对象，那么该对象就可以直接访问其原型对象的方法或者属性。下面这张图, 我们看到使用 C.name 和 C.color 时，给人的感觉属性 name 和 color 都是对象 C 本身的属性，但实际上这些属性都是位于原型对象上，我们把这个查找属性的路径称为**原型链**，它像一个链条一样，将几个原型链接了起来.

![原型](https://edge.yancey.app/beg/xpyiw9l3-1652558442902.webp)

在 JavaScript 中的继承非常简洁，就是每个对象都有一个原型属性，该属性指向了原型对象，查找属性的时候，JavaScript 虚拟机会沿着原型一层一层向上查找，直至找到正确的属性。

在 JavaScript 中，每个函数都有一个 `prototype` 属性（这个说法并不严谨，像 Symbol 和 Math 就没有），该属性指向一个对象，称为`原型对象`，当使用构造函数创建实例时，`prototype` 属性指向的原型对象就成为实例的原型对象。

原型对象默认有一个 `constructor` 属性，它指向该原型对象对应的构造函数。由于实例对象可以继承原型对象的属性，所以实例对象也可以直接调用`constructor` 属性，同样指向原型对象对应的构造函数。

![构造函数和原型对象的关系](https://edge.yancey.app/beg/68747470733a2f2f7773312e73696e61696d672e636e2f6c617267652f303036744e6337396c79316730326a3731396164626a333076613034696a72772e6a7067.jpeg)

```js
function Foo() {}

const foo = new Foo();

// 原型对象的 constructor 属性指向构造函数
Foo.prototype.constructor === Foo; // true

// 实例的 constructor 属性同样指向构造函数
foo.constructor === Foo; // true
```

每个实例都有一个隐藏的属性 `[[prototype]]`，指向它的原型对象，我们可以使用下面两种方式的任意一种来获取实例的原型对象。

```ts
instance.__proto__;

Object.getPrototypeOf(instance);
```

注意：在 ES5 之前，为了能访问到 `[[Prototype]]`，浏览器厂商创造了 `__proto__` 属性。但在 ES5 之后有了标准方法 `Object.getPrototypeOf` 和 `Object.setPrototypeOf`。尽管为了浏览器的兼容性，已经将 `__proto__` 属性添加到 ES6 规范中，但它已被不推荐使用。因为修改 `__proto__` 会破坏 v8 通过隐藏类优化好的结构对象，进而引发隐藏类对该数据对象重新优化.

![实例、原型对象和构造函数之间的关系](https://edge.yancey.app/beg/68747470733a2f2f7773342e73696e61696d672e636e2f6c617267652f303036744e6337396c7931673032716b7264636d6b6a3330726b3064676a736f2e6a7067.jpeg)

至此，原型就介绍完了，实际并没那么复杂。通过上面这张图片，我们很容易得到下面这个公式。

```js
Object.getPrototypeOf(实例) === 构造函数.prototype;
```

所以说，**原型对象类似于一座“桥梁”，连通实例和构造函数**，因此我们可以把公共的属性或方法放在原型对象里，这样就能解决构造函数实例化产生多个重复方法的问题了。我们修改一下构造函数那个例子，将 bark 方法放到 Dog 构造函数的原型中，这样无论 new 多少个实例都只会创建一份 bark 方法。

```js
function Dog(name, age) {
  this.name = name;
  this.age = age;
}

Dog.prototype.bark = function () {
  return ""wangwang~"";
};

const husky = new Dog(""Lolita"", 2);
const alaska = new Dog(""Roland"", 3);

husky.bark(); // 'wangwang~'
alaska.bark(); // 'wangwang~'
```

![方法放在原型里](https://edge.yancey.app/beg/Jietu20190408-162254%402x.jpg)

## 原型链

每个对象都拥有一个原型对象，通过 \_\_proto\_\_ 指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，逐级向上，最终指向 null（null 没有原型）。这种关系被称为原型链 \(prototype chain\)，通过原型链，一个对象会拥有定义在其他对象中的属性和方法。

```js
function Parent(name) {
  this.name = name;
}

const p = new Parent();

p.__proto__ === Parent.prototype; // true
p.__proto__.__proto__ === Object.prototype; // true
p.__proto__.__proto__.__proto__ === null; // true
```

![原型链](https://edge.yancey.app/beg/68747470733a2f2f7773342e73696e61696d672e636e2f6c617267652f303036744e6337396c7931673034773761787071616a33316265303436676d372e6a7067.jpeg)

## 稍微说一下 new

```ts
function DogFactory(type, color) {
  this.type = type;
  this.color = color;
}

var dog = new DogFactory(""Dog"", ""Black"");
```

对于上面这个代码, new 实际上做了三件事:

```ts
var dog = {};
dog.__proto__ = DogFactory.prototype;
DogFactory.call(dog, ""Dog"", ""Black"");
```

- 首先，创建了一个空白对象 dog；
- 然后，将 DogFactory 的 prototype 属性设置为 dog 的原型对象，这就是给 dog 对象设置原型对象的关键一步；
- 最后，再使用 dog 来调用 DogFactory，这时候 DogFactory 函数中的 this 就指向了对象 dog，然后在 DogFactory 函数中，利用 this 对对象 dog 执行属性填充操作，最终就创建了对象 dog。

![new](https://edge.yancey.app/beg/hji62b14-1652562445606.webp)

## 一些关于原型/原型链的方法

这里简单列举一些关于原型/原型链常用的内置方法，最近在写一个 [《JavaScript API 全解析》](https://js.yanceyleo.com) 系列，更详细的用法可以直接去里面查看，点击下面各方法的标题也可以直接跳转。

### Object.create()

用于创建一个新的对象，它使用现有对象作为新对象的 `__proto__`。第一个参数为原型对象，第二个参数可选，可以传入属性描述符对象或 null，其他类型直接报错。

没错，这就是“照猫画虎”！

```js
const cat = { type: ""猫科"" };

const tiger = Object.create(cat);

tiger.tooth = ""大牙"";
```

![“照猫画虎”](https://edge.yancey.app/beg/Jietu20190409-140353%402x.jpg)

### Object.getOwnPropertyNames()

该方法返回一个由指定对象的所有自身属性的属性名组成的数组。

- 包括不可枚举属性

- 但不包括 Symbol 值作为名称的属性

- 不会获取到原型链上的属性

- 当不存在普通字符串作为名称的属性时返回一个空数组

```js
// 它只会获取自身属性，而不去关心原型链上的属性
Object.getOwnPropertyNames(tiger); // ['tooth']
```

### Object.getPrototypeOf() 和 Object.setPrototypeOf()

这两个用于获取和设置一个对象的原型，它主要用来代替 `__proto__`。

### hasOwnProperty

用来判断一个对象**本身**是否含有该属性，返回一个 Boolean 值。

- **原型链上的属性** 一律返回 false

- `Symbol` 类型的属性也可以被检测

```js
tiger.hasOwnProperty(""tooth""); // true
tiger.hasOwnProperty(""type""); // false
```

### isPrototypeOf

该方法用于检测一个对象是否存在于另一个对象的原型链上，返回一个 Boolean 值。

```js
cat.isPrototypeOf(tiger); // true
```

## 最后

下一篇会着重介绍继承和 ES6 新增的 class，敬请期待。

欢迎关注我的微信公众号：进击的前端

![进击的前端](https://edge.yancey.app/beg/qrcode_for_gh_541158abcb21_344.jpg)

## 参考

《JavaScript 高级程序设计 (第三版)》 —— Nicholas C. Zakas

《深入理解 ES6》 —— Nicholas C. Zakas

《你不知道的 JavaScript (上卷)》—— Kyle Simpson

[三分钟看完 JavaScript 原型与原型链](https://juejin.im/post/5a94c0de5188257a8929d837)

[\[进阶 5-1 期\] 重新认识构造函数、原型和原型链](https://github.com/yygmind/blog/issues/32)

[\[进阶 5-2 期\] 图解原型链及其继承](https://juejin.im/post/5ca9cebb6fb9a05e505c5f81)

[详解 JS 原型链与继承](http://louiszhai.github.io/2015/12/15/prototypeChain/)
","2025-02-02 03:08:25.607707","2025-02-02 03:08:25.607707"
"e566832a-5d64-40bc-b573-e34595865d8a","{JavaScript}",0,0,False,"https://edge.yancey.app/beg/1_rt8J89LahYwwOuLOgA_TvA.jpeg","JavaScript 七大继承全解析","继承作为基本功和面试必考点，必须要熟练掌握才行。小公司可能仅仅让你手写继承（一般写 `寄生组合式继承` 即可），大厂就得要求你全面分析各个继承的优缺点了。这篇文章深入浅出，让你全面了解 JavaScript 继承及其优缺点，以在寒冬中立于不败之地。","## 原型链继承

上一篇文章[《从感性角度谈原型 / 原型链》](https://juejin.im/post/5cac4e0af265da03973a8c84)介绍了什么是原型和原型链。我们简单回忆一下构造函数、原型、原型链之间的关系：每个构造函数有一个 `prototype` 属性，它指向原型对象，而原型对象都有一个指向构造函数的指针 `constructor`，实例对象都包含指向原型对象的内部指针 `[[prototype]]`。如果我们让原型对象等于另一个构造函数的实例，那么此原型对象就会包含一个指向另一个原型的指针。这样一层一层，逐级向上，就形成了原型链。

根据上面的介绍，我们可以写出 `原型链继承`。

```js
function Vehicle(powerSource) {
  this.powerSource = powerSource;
  this.components = ['座椅', '轮子'];
}

Vehicle.prototype.run = function() {
  console.log('running~');
};

function Car(wheelNumber) {
  this.wheelNumber = wheelNumber;
}

Car.prototype.playMusic = function() {
  console.log('sing~');
};

// 将父构造函数的实例赋值给子构造函数的原型
Car.prototype = new Vehicle();

const car1 = new Car(4);
```

上面这个例子中，首先定义一个叫做 `交通工具` 的构造函数，它有两个属性分别是是 `驱动方式` 和 `组成部分`，还有一个原型方法是 `跑`；接下来定义叫做 `汽车` 的构造函数，它有 `轮胎数量` 属性和 `播放音乐` 方法。我们将 `Vehicle` 的实例赋值给 `Car` 的原型，并创建一个名叫 `car1` 的实例。

![原型链继承](https://edge.yancey.app/beg/16a0b5309e5adfff.jpg)

但是该方式有几个缺点：

- 多个实例对引用类型的操作会被篡改

- 子类型的原型上的 constructor 属性被重写了

- 给子类型原型添加属性和方法必须在替换原型之后

- 创建子类型实例时无法向父类型的构造函数传参

### 缺点 1

从上图可以看出，父类的实例属性被添加到了实例的原型中，当原型的属性为引用类型时，就会造成数据篡改。

我们新增一个实例叫做 `car2`，并给 `car2.components` 追加一个新元素。打印 `car1`，发现 `car1.components` 也发生了变化。这就是所谓多个实例对引用类型的操作会被篡改。

```js
const car2 = new Car(8);

car2.components.push('灯具');

car2.components; // ['座椅', '轮子', '灯具']
car1.components; // ['座椅', '轮子', '灯具']
```

### 缺点 2

该方式导致 `Car.prototype.constructor` 被重写，它指向的是 `Vehicle` 而非 `Car`。因此你需要手动将 `Car.prototype.constructor` 指回 `Car`。

```js
Car.prototype = new Vehicle();
Car.prototype.constructor === Vehicle; // true

// 重写 Car.prototype 中的 constructor 属性，指向自己的构造函数 Car
Car.prototype.constructor = Car;
```

### 缺点 3

因为 `Car.prototype = new Vehicle();` 重写了 Car 的原型对象，所以导致 `playMusic` 方法被覆盖掉了，因此给子类添加原型方法必须在替换原型之后。

```js
function Car(wheelNumber) {
  this.wheelNumber = wheelNumber;
}

Car.prototype = new Vehicle();

// 给子类添加原型方法必须在替换原型之后
Car.prototype.playMusic = function() {
  console.log('sing~');
};
```

### 缺点 4

显然，创建 `car` 实例时无法向父类的构造函数传参，也就是无法初始化 `powerSource` 属性。

```js
const car = new Car(4);

// 只能创建实例之后再修改父类的属性
car.powerSource = '汽油';
```

## 借用构造函数继承

该方法又叫 `伪造对象` 或 `经典继承`。它的实质是 `在创建子类实例时调用父类的构造函数`。

```js
function Vehicle(powerSource) {
  this.powerSource = powerSource;
  this.components = ['座椅', '轮子'];
}

Vehicle.prototype.run = function() {
  console.log('running~');
};

function Car(wheelNumber) {
  this.wheelNumber = wheelNumber;

  // 继承父类属性并且可以传参
  Vehicle.call(this, '汽油');
}

Car.prototype.playMusic = function() {
  console.log('sing~');
};

const car = new Car(4);
```

![借用构造函数继承](https://edge.yancey.app/beg/16a0b5309e5518f1.jpg)

使用经典继承的好处是可以给父类传参，并且该方法不会重写子类的原型，故也不会损坏子类的原型方法。此外，由于每个实例都会将父类中的属性复制一份，所以也不会发生多个实例篡改引用类型的问题（因为父类的实例属性不在原型中了）。

然而缺点也是显而易见的，我们丝毫找不到 `run` 方法的影子，这是因为该方式只能继承父类的实例属性和方法，不能继承原型上的属性和方法。

回忆上一篇文章讲到的构造函数，为了将公有方法放到所有实例都能访问到的地方，我们一般将它们放到构造函数的原型中。而如果让 `借用构造函数继承` 运作下去，显然需要将 `公有方法` 写在构造函数里而非其原型，这在创建多个实例时势必造成浪费。

## 组合继承

组合继承吸收上面两种方式的优点，它使用原型链实现对原型方法的继承，并借用构造函数来实现对实例属性的继承。

```js
function Vehicle(powerSource) {
  this.powerSource = powerSource;
  this.components = ['座椅', '轮子'];
}

Vehicle.prototype.run = function() {
  console.log('running~');
};

function Car(wheelNumber) {
  this.wheelNumber = wheelNumber;
  Vehicle.call(this, '汽油'); // 第二次调用父类
}

Car.prototype = new Vehicle(); // 第一次调用父类

// 修正构造函数的指向
Car.prototype.constructor = Car;

Car.prototype.playMusic = function() {
  console.log('sing~');
};

const car = new Car(4);
```

![组合继承](https://edge.yancey.app/beg/16a0b5309e5518f1.jpg)

虽然该方式能够成功继承到父类的属性和方法，但它却调用了两次父类。第一次调用父类的构造函数时，`Car.prototype` 会得到 `powerSource` 和 `components` 两个属性；当调用 `Car` 构造函数生成实例时，又会调用一次 `Vehicle` 构造函数，此时会在这个实例上创建 `powerSource` 和 `components`。根据原型链的规则，实例上的这两个属性会屏蔽原型链上的两个同名属性。

## 原型式继承

该方式通过借助原型，基于已有对象创建新的对象。

首先创建一个名为 `object` 的函数，然后在里面中创建一个空的函数 `F`，并将该函数的 `prototype` 指向传入的对象，最后返回该函数的实例。本质来讲，`object()` 对传入的对象做了一次 `浅拷贝`。

```js
function object(proto) {
  function F() {}
  F.prototype = proto;
  return new F();
}

const cat = {
  name: 'Lolita',
  friends: ['Yancey', 'Sayaka', 'Mitsuha'],
  say() {
    console.log(this.name);
  },
};

const cat1 = object(cat);
```

![原型式继承](https://edge.yancey.app/beg/16a0b5309f15d2ca.jpg)

虽然这种方式很简洁，但仍然有一些问题。因为 `原型式继承` 相当于 `浅拷贝`，所以会导致 `引用类型` 被多个实例篡改。下面这个例子中，我们给 `cat1.friends` 追加一个元素，却导致 `cat.friends` 被篡改了。

```js
cat1.friends.push('Hachi');

cat.friends; // ['Yancey', 'Sayaka', 'Mitsuha', 'Hachi']
```

如果你读过 `Object.create()` 的 polyfill，应该不会对上面的代码感到陌生。该方法规范了原型式继承，它接收两个参数：第一个参数传入用作新对象原型的对象，第二个参数传入属性描述符对象或 null。关于此 API 的详细文档可以点击 [Object.create() | JavaScript API 全解析](https://js.yanceyleo.com/ECMAScript/Object/Object.create.html)

```js
const cat = {
  name: 'Lolita',
  friends: ['Yancey', 'Sayaka', 'Mitsuha'],
  say() {
    console.log(this.name);
  },
};

const cat1 = Object.create(cat, {
  name: {
    value: 'Kitty',
    writable: false,
    enumerable: true,
    configurable: false,
  },
  friends: {
    get() {
      return ['alone'];
    },
  },
});
```

## 寄生式继承

该方式创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象。

```js
const cat = {
  name: 'Lolita',
  friends: ['Yancey', 'Sayaka', 'Mitsuha'],
  say() {
    console.log(this.name);
  },
};

function createAnother(original) {
  const clone = Object.create(original); // 获取源对象的副本

  clone.gender = 'female';

  clone.fly = function() {
    // 增强这个对象
    console.log('I can fly.');
  };

  return clone; // 返回这个对象
}

const cat1 = createAnother(cat);
```

![寄生式继承](https://edge.yancey.app/beg/16a0b530a0259877.jpg)

和 `原型式继承` 一样，该方式会导致 `引用类型` 被多个实例篡改，此外，`fly` 方法存在于 `实例` 而非 `原型` 中，因此 `函数复用` 无从谈起。

## 寄生组合式继承

上面我们谈到了 `组合继承`，它的缺点是会调用两次父类，因此父类的实例属性会在子类的实例和其原型上各自创建一份，这会导致实例属性屏蔽原型链上的同名属性。

好在我们有 `寄生组合式继承`，它本质上是通过 `寄生式继承` 来继承父类的原型，然后再将结果指定给子类的原型。这可以说是在 ES6 之前最好的继承方式了，面试写它没跑了。

```js
function inheritPrototype(child, parent) {
  const prototype = Object.create(parent.prototype); // 创建父类原型的副本
  prototype.constructor = child; // 将副本的构造函数指向子类
  child.prototype = prototype; // 将该副本赋值给子类的原型
}
```

然后我们尝试写一个例子。

```js
function Vehicle(powerSource) {
  this.powerSource = powerSource;
  this.components = ['座椅', '轮子'];
}

Vehicle.prototype.run = function() {
  console.log('running~');
};

function Car(wheelNumber) {
  this.wheelNumber = wheelNumber;
  Vehicle.call(this, '汽油');
}

inheritPrototype(Car, Vehicle);

Car.prototype.playMusic = function() {
  console.log('sing~');
};
```

![寄生组合式继承](https://edge.yancey.app/beg/16a0b530a03639bb.jpg)

看上面这张图就知道为什么这是最好的方法了。它只调用了一次父类，因此避免了在子类的原型上创建多余的属性，并且原型链结构还能保持不变。

硬要说缺点的话，给子类型原型添加属性和方法仍要放在 `inheritPrototype` 函数之后。

## ES6 继承

功利主义来讲，在 ES6 新增 class 语法之后，上述几种方法已沦为面试专用。当然 class 仅仅是一个语法糖，它的核心思想仍然是 `寄生组合式继承`，下面我们看一看怎样用 ES6 的语法实现一个继承。

```js
class Vehicle {
  constructor(powerSource) {
    // 用 Object.assign() 会更加简洁
    Object.assign(
      this,
      { powerSource, components: ['座椅', '轮子'] },

      // 当然你完全可以用传统的方式
      // this.powerSource = powerSource;
      // this.components = ['座椅', '轮子'];
    );
  }

  run() {
    console.log('running~');
  }
}

class Car extends Vehicle {
  constructor(powerSource, wheelNumber) {
    // 只有 super 方法才能调用父类实例
    super(powerSource, wheelNumber);
    this.wheelNumber = wheelNumber;
  }

  playMusic() {
    console.log('sing~');
  }
}

const car = new Car('核动力', 3);
```

![“类”继承](https://edge.yancey.app/beg/16a0b530d175dfb2.jpg)

下面代码是继承的 polyfill，思路和 `寄生组合式继承` 一致。

```js
function _inherits(subType, superType) {
  // 创建对象，创建父类原型的一个副本

  subType.prototype = Object.create(superType && superType.prototype, {
    // 增强对象，弥补因重写原型而失去的默认的constructor 属性
    constructor: {
      value: subType,
      enumerable: false,
      writable: true,
      configurable: true,
    },
  });
  if (superType) {
    // 指定对象，将新创建的对象赋值给子类的原型
    Object.setPrototypeOf
      ? Object.setPrototypeOf(subType, superType)
      : (subType.__proto__ = superType);
  }
}
```

## ES5 和 ES6 继承的比较

ES5 是用构造函数创建类，因此会发生 `函数提升`；而 class 类似于 let 和 const，因此不能够先创建实例，再声明类，否则直接报错。

```js
// Uncaught ReferenceError: Rectangle is not defined
let p = new Rectangle();

class Rectangle {}
```

ES5 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到 this 上，即 `Parent.call(this)`.

ES6 的继承有所不同，实质上是先创建父类的实例对象 this，然后再用子类的构造函数修改 this。因为子类没有自己的 this 对象，所以必须先调用父类的 super()方法，否则新建实例报错。

## 最后

欢迎关注我的微信公众号：进击的前端

![进击的前端](https://edge.yancey.app/beg/16a011118f355822.jpg)

## 参考

《JavaScript 高级程序设计 (第三版)》 —— Nicholas C. Zakas

[[进阶 5-2 期] 图解原型链及其继承](https://juejin.im/post/5ca9cebb6fb9a05e505c5f81)

[JavaScript 常用八种继承方案](https://github.com/yygmind/blog/issues/7)
","2025-02-02 03:08:27.013951","2025-02-02 03:08:27.013951"
"e8d3798a-38df-44e1-8863-bff8d6743078","{WebAPI}",0,0,False,"https://edge.yancey.app/beg/68747470733a2f2f79616e6365792d6173736574732e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f494d475f32303137313132375f3136313533302d31303234783537362e6a7067.jpeg","剖析 requestAnimationFrame","得益于 CSS3 的发展，大部分动效不再依赖传统的定时器编写。然而 CSS3 无法处理一些需要数学计算的效果，如三次方缓动、指数衰减的正弦曲线缓动等等。requestAnimationFrame 作为一个新兴的 API（其实也不新了），既比定时器动效温柔，又比 CSS 动效广泛，下面其聊一聊其正确打开姿势。","## 定时器动画存在的问题

「JavaScript 高级程序（第三版）」这么说：IE9 将定时器精度提高到 4ms, Chrome 也是 4ms, FF 和 Safari 是 10ms，但此精度对动画并不够明确。而且浏览器显示后台标签页和不活动标签页的计时器。

第二点还是深有体会，比如写了一个倒计时的组件，运行之后最小化浏览器，过一会儿再打开，发现时间还定格在一个过去的时间，然后会快速的滚到实际的时间。

## requestAnimationFrame 原理

大多数电脑显示器刷新频率是 60HZ，也就是说每秒重绘次，因此，最平滑动画的最佳循环间隔是 1000ms/60≈17ms

所以有疑问了，那把`setTimeOut()`或者`setInterval()`间隔时间设为 17ms 不就得了？

肯定不行，如果这两个方法之前有其他正在执行的任务，那这两段代码也无法立即执行。

## requestAnimationFrame 语法

书上还保留着`mozRequestAnimationFrame`和`msRequestAnimationFrame`，但用 WebStorm 语法提示发现这两个已经没有了，所以下面就不对这两个进行兼容了。

直接看 W3C 的一个例子，这个例子是将元素向右滑动移动 200px：

```
var start = null;
var element = document.getElementById('SomeElementYouWantToAnimate');
element.style.position = 'absolute';

function step(timestamp) {
  if (!start) start = timestamp;
  var progress = timestamp - start;
  element.style.left = Math.min(progress / 10, 200) + 'px';
  if (progress < 2000) {
    window.requestAnimationFrame(step);
  }
}

window.requestAnimationFrame(step);


```

window.requestAnimationFrame(callback),里面需要传一个函数，并且每次调用它会给这个函数传一个`DOMHighResTimeStamp`，指示 requestAnimationFrame() 开始触发回调函数的当前时间。

而每次传入的这个`DOMHighResTimeStamp`的增量, 大约就是 17ms，为了佐证，我专门将`timestamp`追加到数组，然后放在`Chart.js`做了简单的数据可视化，如图下：

![DOMHighResTimeStamp变化曲线](//edge.yancey.app/beg/b4ca9cf3-35db-4f27-9143-73b54cca26ee.jpg)

分析这张图，因为程序启动或多或少受到一些干扰，因此横坐标并不是从 0 开始的；

但是从程序开始到程序结束的`截距`可以大致看出是`2000ms`;

然后函数接近于一条线性函数，`斜率`可以计算一下大约为`17`;

## requestAnimationFrame 在缓动效果的用法

上面说到，CSS3 还无法处理一些缓动效果，而定时器效果又不好，因此 requestAnimationFrame 是个不错的选择，直接看例子：

```
    let t = 0, b = 0, c = 100, d = 100;

    const easeOut = (t, b, c, d) => {
        if ((t /= d) < (1 / 2.75)) {
            return c * (7.5625 * t * t) + b;
        } else if (t < (2 / 2.75)) {
            return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;
        } else if (t < (2.5 / 2.75)) {
            return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;
        } else {
            return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
        }
    };

    const step = () => {
        const _width = easeOut(t, b, c, d);
        t++;
        document.querySelector('#SomeElementYouWantToAnimate').style.width = (100 + _width) + 'px';
        if (t <= d) {
            window.requestAnimationFrame(step);
        } else {
            window.cancelAnimationFrame(step);
        }
    };

    step();


```

代码和效果全都放在了上面，其中`easeOut`是一个缓动函数，直接从张鑫旭大大那边抄来了，戳 => [GitHub Repo](https://github.com/zhangxinxu/Tween)

## requestAnimationFrame 的一些问题

W3C 原文这么说：

Also note that multiple calls to requestAnimationFrame with the same callback (before callbacks are invoked and the list is cleared) will result in multiple entries being in the list with that same callback, and thus will result in that callback being invoked more than once for the animation frame.

也就是 requestAnimationFrame 不管理回调，因此有可能出现在同一帧多次调用的问题。

下面我同样去调用文章第一个函数，但这次在函数运行过程中我会`切换选项卡`，然后再看一下渲染出来的图表：

![当我在程序运行中切换选项卡](//edge.yancey.app/beg/77bab955-9126-4260-89e9-a89b45970fbe.jpg)

由图可见，横坐标不再是 120 份，渲染出来的也不是近似一条直线。因此，在 requestAnimationFrame 运行过程中如果触发到`resize`、`visibilitychange`、`scroll`、`touch`这种高频事件，requestAnimationFrame 可能就会造成紊乱。

## 解决方法

看到这类方法，有经验的同学肯定一下子就能想到`防抖`和`节流`，但不见得有什么卵用，<mark>因为`防抖`和`节流`是基于时间管理队列的，而 requestAnimationFrame 的触发时间是不固定的，在高刷新频率的显示屏上时间会小于 16.67ms，页面如果被推入后台，时间可能大于 16.67ms。</mark>

但是每次调用 requestAnimationFrame 时，它自身知道自己的调用时间，所以可以加个 flag 来判断：

```
let ticking = false; //raf触发锁

    function onScroll() {
        if (!ticking) {
            requestAnimationFrame(step);
            ticking = true;
        }
    }

    window.addEventListener('resize', onScroll, false);


```

然后在`step`把`ticking`置为`false`。

最后把整个 demo 贴在这里，包括 chart.js 渲染：

```
<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <title>requestAnimationFrame</title>
    <style>
        #SomeElementYouWantToAnimate {
            width: 100px;
            height: 100px;
            background: #7fffd4;
        }
    </style>
</head>
<body>
<div style=""height: 10000px;""></div>
<div id=""SomeElementYouWantToAnimate""></div>
<canvas id=""myChart"" width=""400"" height=""400""></canvas>
<script src=""./Chart.min.js""></script>
<script>
    // record data
    const arr = [];
    const indexList = [];

    let ticking = false; //raf触发锁

    function onScroll() {
        if (!ticking) {
            requestAnimationFrame(step);
            ticking = true;
        }
    }

    window.addEventListener('resize', onScroll, false);

    let start = null;
    function step(timestamp) {

        ticking = false;

        arr.push(timestamp);

        if (!start) start = timestamp;
        const progress = timestamp - start;
        document.querySelector('#SomeElementYouWantToAnimate').style.width = (100 + Math.min(progress / 10, 200)) + 'px';
        if (progress <= 2000) {
            window.requestAnimationFrame(step);
        } else {
            window.cancelAnimationFrame(step);
            for (let i = 0; i < arr.length; i++) {
                indexList.push(i)
            }
            new Chart(document.getElementById(""myChart""), {
                ""type"": ""line"",
                ""data"": {
                    ""labels"": indexList,
                    ""datasets"": [{
                        ""label"": ""Chart for requestAnimationFrame API"",
                        ""data"": arr,
                        ""fill"": false,
                        ""borderColor"": ""rgba(75, 192, 192)"",
                        ""lineTension"": 0.1
                    }]
                },
            });
        }
    }

    window.requestAnimationFrame(step);
</script>
</body>
</html>


```

## 参考文章

[张鑫旭 - CSS3 动画那么强，requestAnimationFrame 还有毛线用？](https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/)

[requestAnimationFrame 方法你真的用对了吗？](https://segmentfault.com/a/1190000010229232)

以上、よろしく。
","2025-02-02 03:08:28.652484","2025-02-02 03:08:28.652484"
"7379b001-d94a-4430-8752-f68501cf6a8f","{JavaScript}",0,0,False,"https://edge.yancey.app/beg/1__nZVv7Q11vrGnqCJW37jKA.png","防抖和节流","防抖和节流是 JavaScript 开发中性能优化的重要方案, 下面通过代码教你掌握他们.","## 防抖

> 当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。

```js
function debounce(fun, delay) {
  let timer = null;
  return function(args) {
    let that = this;
    let _args = args;
    clearTimeout(timer);
    timer = setTimeout(function() {
      fun.call(that, _args);
    }, delay);
  };
}
```

### 立即防抖和非立即防抖

非立即执行防抖是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。

![非立即执行](https://edge.yancey.app/beg/1655a8fd99421ad2.jpg)

立即执行防抖是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。

![立即执行](https://edge.yancey.app/beg/1655a9049d597f7e.jpg)

下面是一个综合版的例子。

```js
function debounce(func, wait, immediate) {
  var timeout;

  return function() {
    var context = this;
    var args = arguments;

    if (timeout) clearTimeout(timeout);
    if (immediate) {
      var callNow = !timeout;
      timeout = setTimeout(function() {
        timeout = null;
      }, wait);
      if (callNow) func.apply(context, args);
    } else {
      timeout = setTimeout(function() {
        func.apply(context, args);
      }, wait);
    }
  };
}
```

### 使用场景

- search 搜索联想，用户在不断输入值时，用防抖来节约请求资源

- window 触发 resize 的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次

## 节流

> 当持续触发事件时，保证一定时间段内只调用一次事件处理函数。

```js
function throttle(fn, delay) {
  let canRun = true;
  return function() {
    if (!canRun) {
      return;
    }
    canRun = false;
    setTimeout(() => {
      fn.call(this, arguments);
      canRun = true;
    }, delay);
  };
}
```

节流分为时间戳版和定时器版，下面是一个综合版。

```js
function throttle(func, delay) {
  var timer = null;
  var startTime = Date.now();
  return function() {
    var curTime = Date.now();
    var remaining = delay - (curTime - startTime);
    var context = this;
    var args = arguments;
    clearTimeout(timer);
    if (remaining <= 0) {
      func.apply(context, args);
      startTime = Date.now();
    } else {
      timer = setTimeout(func, remaining);
    }
  };
}
```

### 使用场景

- 鼠标不断点击触发，mousedown(单位时间内只触发一次)

- 监听滚动事件，比如是否滑到底部自动加载更多，用 throttle 来判断

![防抖和节流](https://edge.yancey.app/beg/168848565d65c88b.jpg)

## 参考

[7 分钟理解 JS 的节流、防抖及使用场景](https://juejin.im/post/5b8de829f265da43623c4261)

[JS 的防抖与节流](https://mp.weixin.qq.com/s/Vkshf-nEDwo2ODUJhxgzVA)
","2025-02-02 03:08:30.054051","2025-02-02 03:08:30.054051"
"c14f3dc1-8ec8-4384-aeb9-3cf0127874b5","{JavaScript,回到顶部,WebAPI}",0,0,False,"https://edge.yancey.app/beg/backtotop.jpg","回到顶部的几种玩法","前不久优化 FE 的时候用 withRouter 封装了一个 ScrollRestoration 组件，里面用到了 window.scrollTo(0, 0)。而 FE 回到顶部的小猫用的是 requestAnimationFrame，然后去网上搜索一下发现还有其他一些冷门的方法，遂结合 caniuse 和例子总结一番。","## scrollTop

在 Chrome 中， 通过 `document.documentElement.scrollTop` 来获取滚动条距离顶端的位置；而在 FF 和 Safari 中，则是通过 `document.body.scrollTop` .

在 Chrome 中，`document.body.scrollTop` 恒为 0， 在 FF 和 Safari 中，`document.documentElement.scrollTop`恒为 0.

因此做兼容的话，可以通过两者相加来获取滚动条距离顶端的位置。

这两个属性可以被设置，所以业界常用的回到顶部的做法如下。

```
document.body.scrollTop = document.documentElement.scrollTop = 0


```

最后扩充一个属性 `window.pageYOffset`, 这个属性同样是获取滚动条距离顶端的位置，在 Chrome 和 FF 都可以使用，**⚠️ 但是这个属性不能够设置位置，并且在 Safari 上不能用**

## scrollTo()

用过 React 的同学应该对这个方法不陌生。因为用到了 hashHistory，它是建立在 history 之上的，当路由发生变化时会记住原路由的状态，跳转新页面后默认停留在原页面的位置。
所以我们经常用这个简单方法让页面回到顶部(当然关于 withRouter 是另外一个话题了，详情戳 [scroll-restoration](https://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom/docs/guides/scroll-restoration.md))

window.scrollTo() 接收两种参数形式。

第一种是 `window.scrollTo(x-coord, y-coord )`， 其中 `x-coord` 是文档中的横轴坐标， `y-coord` 是文档中的纵轴坐标，所以一般通过 `window.scrollTo(0, 0)` 的方式回到顶部。

window.scrollTo(options)

第二种是 `window.scrollTo(options)`, 接受一个参数对象，其中 top 相当于 y-coord，left 相当于 x-coord，而 behavior 里有个属性值是 ‘smooth’ ，可以平滑的滚动到顶部，很赞。

```
window.scrollTo({
    left: 0,
    top: 0,
    behavior: 'smooth' / 'instant' / 'auto'
})


```

在挖一下，还有一个方法是 `window.scroll()`， 它和 `window.scrollTo()` 的用法一模一样。

## scrollBy()

这个方法和 `scrollTo()` 的传参形式一样，都是传递 `x-coord, y-coord` 或者 `option`，不同的是， `scrollTo()` 传递的参数是一个对于文档的一个绝对的量，而 `scrollBy()` 传递的是一个相对于自身当前位置的一个量。

因此，可以用下面的方式回到顶部。

```
const top = document.body.scrollTop || document.documentElement.scrollTop
scrollBy(0,-top);

```

当然，FF 还有两个方法叫做 `window.scrollByLines(lines)` 和 `window.scrollByPages()`, 两种方法在 Chrome 和 Safari 无效，当作了解即可。

## 其他

当然还看到别人在说在文档头部放一个隐藏的锚点，或者用 `element.scrollIntoView()` 之类的方式，这些就有些反人类了，这里不打算介绍。

## 番外篇：平滑滚动

这里主要谈一谈 `requestAnimationFrame`，我在 FE 回到顶部的小猫用到了这个 API，一开始是这样写的，但这样有个问题是写死了每次递归只往上走 160px，但如果页面很长的话，这个速度就会很慢。

```
   public scrollToTop1 = () => {
    let time: number = 0;
    document.documentElement.scrollTop -= 160;
    if (document.documentElement.scrollTop <= 0) {
      window.cancelAnimationFrame(time);
    } else {
      time = window.requestAnimationFrame(this.scrollToTop);
    }
  };

```

改进版：

```
  public scrollToTop = () => {
    let timer: number = 0;
    cancelAnimationFrame(timer);
    const startTime = +new Date();
    const b = document.body.scrollTop || document.documentElement.scrollTop;
    const d = 500;
    const c = b;
    timer = requestAnimationFrame(function func() {
      const t = d - Math.max(0, startTime - +new Date() + d);
      document.documentElement.scrollTop = document.body.scrollTop =
        (t * -c) / d + b;
      timer = requestAnimationFrame(func);
      if (t === d) {
        cancelAnimationFrame(timer);
      }
    });
  };

```
","2025-02-02 03:08:30.858568","2025-02-02 03:08:30.858568"
"b6cf5d7a-4e8c-4d95-bf44-41e3c58197a2","{JavaScript,Promise}",0,0,False,"https://edge.yancey.app/beg/1_BGiiqgFwaDq5eNHII17Lvw.png","深入理解并手写遵循 Promise/A+ 规范的 Promise","相比于回调函数，Promise 解决了 “回调地狱” 和 “信任问题” 等痛点，并且大大提高了代码的可读性。在现代前端开发中，Promise 几乎成了处理异步的首选（虽然还有更方便的 async/await，逃）。这篇文章从 Promise 的思想和运行机制入手，深入理解每个 API，最后手写一个遵循 Promise/A+ 规范的 Promise 来。","## 异步方式

JavaScript 异步方式共有有下面六种.

- 事件监听

- 回调函数

- 发布/订阅

- Promise

- 生成器

- async/await

## 回调函数

面试中被问到 `回调函数` 有什么缺点, 相信你一定不假思索地回答 `回调地狱`. 的确如此, 当我们需要发送多个异步请求, 并且每个请求之间需要相互依赖时, 就会产生回调地狱.

前段时间写了一个天气微信小程序 [Natsuha](https://github.com/YanceyOfficial/Natsuha-Weather), 它获取天气的逻辑大致如下(当然真实场景复杂的多).

- 首先要获取用户的经纬度 (接口 A)

- 根据经纬度反查城市 (接口 B)

- 根据城市拿到相应的天气信息 (接口 C)

按照回调的方式去处理这个逻辑, 大致会写成下面的样子：

```js
ajax(A, () => {
  // 获取经纬度
  ajax(B, () => {
    // 根据经纬度反查城市
    ajax(C, () => {
      // 根据城市获取天气信息
    });
  });
});
```

看起来很丑陋不是吗? 相信大家对回调函数的缺点大致都了解, 这里就不展开, 只做个总结.

- 代码逻辑书写顺序与执行顺序不一致, 不利于阅读与维护.

- 异步操作的顺序变更时, 需要大规模的代码重构.

- 回调函数基本都是匿名函数, bug 追踪困难.

- 回调函数是被第三方库代码(如上例中的 ajax)而非自己的业务代码所调用的, 造成了控制反转(IoC).

简单谈一谈 `控制反转`, 《你不知道的 JavaScript (中卷)》把回调函数的最大缺点归结为 `信任问题`. 例子中 ajax 是一个三方的函数(你完全可以把它想象成 jQuery 的 $.ajax()), 我们把自己的业务逻辑, 也就是将回调函数 `交给了` ajax 去处理. 但 ajax 对我们来说仅仅是一个黑盒, 如果 ajax 本身有缺陷的话, 我们的回调函数就处于危险之中, 这也就是所谓的“信任问题”.

不过 Promise 的出现解决了这些缺点, 它能够把控制反转再反转回来. 这样的话, 我们可以不把自己程序的传给第三方, 而是让第三方给我们提供了解其任务何时结束的能力, 进而由我们自己的代码来决定下一步做什么.

## 何为 Promise

《你不知道的 JavaScript (中卷)》举了一个例子：

我在快餐店点了一个汉堡, 并支付了 1.07 美金. 这意味着我对某个值(汉堡)发出了请求.

接着收银员给我一张 `取餐单据`, 它保证了我最终会得到汉堡, 因此 `取餐单据` 就是一个 `承诺`.

在等待取餐的过程中, 我可以做点其他的事情, 比如刷刷推特, 看看 [996.icu](https://github.com/996icu/996.ICU) 今天又涨了多少 star. 之所以我可做点儿其他的事情, 是因为 `取餐单据` 代表了我 `未来的` 汉堡. 它在某种意义上已经成了汉堡的 `占位符`. 从本质上来讲, 这个 `占位符` 使得这个值不再依赖时间, 这是一个 `未来值`.

终于, 我听到服务员在喊 `250号前来取餐`, 我就可以拿着 `取餐单据` 换我的汉堡了.

但是可能还有另一种结果, 在我去取餐时, 服务员充满抱歉的告诉我汉堡已经售罄了, 除了愤怒, 我们还可以看到 `未来值` 可能成功, 也可能失败.

## Promise 基础知识

### Promise 的生命周期

每个 Promise 都会经历一个短暂的生命周期：先是处于 `进行中 (pending)`, 此时操作尚未完成, 因此它也是 `未处理 (unsettled)` 的；一旦异步操作执行结束, Promise 变成 `已处理 (settled)` 状态, 此时它会进入到以下两个状态中的其中一个：

- Fulfilled：Promise 异步操作成功完成

- Rejected：由于程序错误或其他原因, 异步操作未能成功完成

### Promise 构造函数

Promise 本身是一个构造函数, 它接收一个叫做 `executor` 的函数, 该函数会被传递两个名为 `resolve()` 和 `reject()` 的函数作为参数. `resolve()` 函数在执行器成功时被调用, 而 `reject()` 在执行器操作失败后被调用. 看下面这个例子.

```js
const fs = require(""fs"");

const promise = (path) =>
  // 执行器接收 resolve() 和 reject() 作为参数
  new Promise((resolve, reject) => {
    fs.readFile(__dirname + ""/"" + path, ""utf-8"", (err, data) => {
      if (err) {
        // 失败时调用 reject()
        reject(err);
        return;
      }
      // 成功时时调用 resolve()
      resolve(data);
    });
  });
```

### Promise 的 then 方法

then() 方法接收两个函数作为参数, 第一个作为 `完成` 时的回调, 第二个作为 `拒绝` 时的回调. 两个参数均为可选, 因此你可以只监听 `完成`, 或者只监听 `拒绝`. 其中当第一个参数为 `null`, 第二个参数为回调函数时, 它意味着监听 `拒绝`. 在实际应用中, `完成` 和 `拒绝` 都应当被监听.

```js
const promise = new Promise((resolve, reject) => {
  resolve(""success"");
});

// 监听完成和拒绝
promise.then(
  (res) => {
    // 完成
    console.log(res);
  },
  (e) => {
    // 拒绝
    console.log(e);
  }
);

// 只监听完成
promise.then((res) => {
  console.log(res);
});

// 第一个参数为 null 时意味着拒绝
promise.then(null, (res) => {
  // 完成
  console.log(res);
});
```

Promise 还有两个方法分别是 `catch()` 和 `finally()`, 前者用于监听 `拒绝`, 后者无论成功失败都会被执行到. 链式调用显然可读性更高, 所以我们推荐下面这种写法.

```js
promise
  .then((res) => {
    console.log(res);
  })
  .catch((e) => {
    console.log(e);
  })
  .finally(() => {
    console.log(""无论成功失败都会执行这句"");
  });
```

## Promise 链式调用

每次调用 then() 或 catch() 方法时都会 `创建并返回一个新的 Promise`, 只有当前一个 Promise 完成或被拒绝后, 下一个才会被解决.

看下面这个例子, p.then() 完成后返回第二个 Promise, 接着又调用了它的 then() 方法, 也就是说只有当第一个 Promise 被解决之后才会调用第二个 then() 方法的 `then()` .

```js
let p = new Promise((resolve, reject) => {
  resolve(42);
});

p.then((value) => {
  console.log(value); // 42
}).then(() => {
  console.log(""可以执行到""); // '可以执行到'
});
```

将上述示例拆开, 看起来是这样的. 调用 p1.then() 的结果被存储到 p2 中, p2.then() 被调用来添加最终的 `then()` .

```js
let p1 = new Promise((resolve, reject) => {
  resolve(42);
});

let p2 = p1.then((value) => {
  console.log(value);
});

p2.then(() => {
  console.log(""可以执行到"");
});
```

我们通过一个实例来看一下链式调用. 下面是获取城市天气的场景：我们首先需要调用 `getCity` 接口来获取 `城市id`, 接着调用 `getWeatherById/城市id` 来获取城市的天气信息. 首先用 Promise 封装一个原生 Ajax. (敲黑板, 面试可能要求手写)

```js
const getJSON = function (url) {
  const promise = new Promise(function (resolve, reject) {
    const handler = function () {
      if (this.readyState !== 4) {
        return;
      }
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
    const client = new XMLHttpRequest();
    client.open(""GET"", url);
    client.onreadystatechange = handler;
    client.responseType = ""json"";
    client.setRequestHeader(""Accept"", ""application/json"");
    client.send();
  });

  return promise;
};

const baseUrl = ""https://5cb322936ce9ce00145bf070.mockapi.io/api/v1"";
```

通过链式调用来请求数据, 最后别忘了捕获错误.

```js
getJSON(`${baseUrl}/getCity`)
  .then((value) => getJSON(`${baseUrl}/getWeatherById/${value.cityId}`))
  .then((value) => console.log(value))
  .catch((e) => {
    console.log(e);
  });
```

### 捕获错误

当 then() 方法或者 catch() 方法抛出错误时, 链式调用的下一个 Promise 中的 catch() 方法可以通过 `catch()` 接收这个错误. 侧面来讲, 异常不一定只发生在 Promise 中, 还有可能发生在 `then()` 或者 `catch()` 中.

```js
let p1 = new Promise((resolve, reject) => {
  resolve(42);
});

p1.then((value) => {
  throw new Error("" `then()` 错误"");
}).catch((e) => {
  console.log(e.message); // ' `then()` 错误'
});
```

不仅 `then()` 可以抛出异常, `catch()` 也可以抛出的异常, 且可以被下一个 `catch()` 捕获. 因此, 无论如何都应该在 Promise 链的末尾留一个 `catch()` , 以保证能够正确处理所有可能发生的错误. 看下面这个例子.

```js
let p1 = new Promise((resolve, reject) => {
  throw new Error(""执行器错误"");
});

p1.catch((e) => {
  console.log(e.message); // '执行器错误'
  throw new Error("" `catch()` 错误"");
}).catch((e) => {
  console.log(e.message); // ' `catch()` 错误'
});
```

### Promise 链的返回值

Promise 链的一个重要特性是能从一个 Promise 传递数据给下一个 Promise, 通过完成处理函数的返回值, 来将数据沿着一个链传递下去. 我们看下面这个例子.

```js
function task() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(""task"");
    }, 1000);
  });
}

task()
  .then((res) => {
    console.log(res);
    return ""taskB"";
  })
  .then((res) => {
    console.log(res);
    return ""taskC"";
  })
  .then((res) => {
    console.log(res);
    throw new Error();
  })
  .catch((e) => {
    console.log(e);
    return ""taskD"";
  })
  .then((res) => {
    console.log(res);
  });
```

![Jietu20190415-172853.jpg](https://edge.yancey.app/beg/Jietu20190415-172853.jpg)

运行结果如上图所示. 我们知道, 每次调用 then() 或者 catch() 都会返回一个新的 Promise 实例, 通过指定处理函数的返回值, 可以沿着一个链继续传递数据.

因此第一个 then() 将 'taskB' 作为下一个 then() 的参数传递下去, 同样第二个 then() 将 'taskC' 作为第三个 then() 的参数传递下去.

而第三个 then() 里面抛出一个异常, 上面说到处理函数中的抛出异常一定会被后面的拒绝处理函数捕获, 所以 catch() 里能够打印出上一个 then() 的错误.

别忘了 catch() 返回 'taskD' 也可以被最后一个 then() 捕获.

## 其他构造方法

### Promise.resolve() 和 Promise.reject()

Promise.resolve() 和 Promise.reject() 类似于快捷方式, 用来创建一个 `已完成` 或 `已被拒绝` 的 promise. 此外, Promise.resolve() 还能接受非 Promise 的 `thenable` 的作为参数, 也就是所谓 `拥有 then 方法的对象`.

```js
// p1 和 p2 等价
const p1 = new Promise((resolve, reject) => {
  reject(""Oops"");
});

const p2 = Promise.reject(""Oops"");

// p3 和 p4 等价
const p3 = new Promise((resolve, reject) => {
  resolve(""Oops"");
});

const p4 = Promise.resolve(""Oops"");
```

而对于 Promise.resolve(), 它还能接收一个非 Promise 的 `thenable` 作为参数. 它可以创建一个已完成的 Promise, 也可以创建一个以拒绝的 Promise.

```js
let thenable1 = {
  then(resolve, reject) {
    resolve(1);
  },
};

let p1 = Promise.resolve(thenable1);

p1.then((value) => console.log(value)); // 1

let thenable2 = {
  then(resolve, reject) {
    reject(1);
  },
};

let p2 = Promise.resolve(thenable2);

p2.catch((reason) => console.log(reason)); // 1
```

### Promise.all()

该方法接收单个迭代对象(最常见的就是数组)作为参数, 并返回一个 Promise. 这个可迭代对象的元素都是 Promise, 只有在它们都完成后, 所返回的 Promise 才会被完成.

- 当所有的 Promise 均为完成态, 将会返回一个包含所有结果的数组.

- 只要有一个被拒绝, 就不会返回数组, 只会返回最先被拒绝的那个 Promise 的原因

```js
let p1 = new Promise((resolve, reject) => {
  resolve(42);
});
let p2 = new Promise((resolve, reject) => {
  reject(43);
});
let p3 = new Promise((resolve, reject) => {
  reject(44);
});

let p4 = new Promise((resolve, reject) => {
  resolve(45);
});

// 全部完成, 返回数组
let p5 = Promise.all([p1, p4]);
p5.then((value) => console.log(value)); // [42, 45]

// 只要有一个出错, 就不会返回数组, 且只会返回最先被拒绝的那个 Promise 的原因
let p6 = Promise.all([p1, p2, p3, p4]);
p6.catch((value) => console.log(value)); // 43
```

### Promise.race()

该方法同样接收单个迭代对象(最常见的就是数组)作为参数, 不同的是, 该方法只要检测到任意一个被解决, 该方法就会做出响应. 因此一个有趣的例子是把 `请求接口` 和一个 `setTimeout` 进行竞逐, 如果 `setTimeout` 先做出响应, 就证明这个接口请求超时.

```js
const p = Promise.race([
  fetch(""/some-api""),
  new Promise((resolve, reject) => {
    setTimeout(() => reject(new Error(""请求超时"")), 3000);
  }),
]);

p.then((value) => {
  console.log(value);
}).catch((reason) => {
  console.log(reason);
});
```

## Promise 的局限性

看起来 Promise 很美好, 解决了回调函数的种种问题, 但它也有自己的局限性.

- 一旦创建一个 Promise 并为其注册完成/拒绝处理函数, Promise 将无法被取消.

- 当处于 pending 状态时, 你无法得知当前进展到哪一块

- 因为 Promise 只能被决议一次(完成或拒绝), 如果某些事件不断发生, stream 模式会更合适.

- 如果不设置回调函数, Promise 内部抛出的错误, 不会反应到外部.

## 手撕代码

手撕代码的之前可以参照一下后面的 Promise A+ 规范翻译, 最好还是自己去官网翻译一遍, 这样写起来才会得心应手. 下面的代码几乎每句都加了注释, 并且链接到每一条规范.

```js
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'

class Promise {
  constructor(executor) {
    // state 的初始状态为等待态
    this.state = PENDING

    // 成功的值 (1.3)
    this.value = undefined

    // 失败的原因 (1.5)
    this.reason = undefined

    // 因为 then 在相同的 promise 可以被调用多次，所以需要将所有的 onFulfilled 存到数组 (2.2.6)
    this.onResolvedCallbacks = []

    // 因为 then 在相同的 promise 可以被调用多次，所以需要将所有的 onRejected 存到数组 (2.2.6)
    this.onRejectedCallbacks = []

    const resolve = (value) => {
      // 只有当前是 pending，才可能转换为 fulfilled
      // 并且不能再转换成其他任何状态，且必须拥有一个不可变的值
      if (this.state === PENDING) {
        this.state = FULFILLED
        this.value = value
        // onFulfilled 回调按原始调用顺序依次执行 (2.2.6.1)
        this.onResolvedCallbacks.forEach((fn) => fn())
      }
    }

    const reject = (reason) => {
      // 只有当前是 pending，才可能转换为 rejected
      // 并且不能再转换成其他任何状态，且必须拥有一个不可变的原因
      if (this.state === PENDING) {
        this.state = REJECTED
        this.reason = reason
        // onRejectec 回调按原始调用顺序依次执行 (2.2.6.1)
        this.onRejectedCallbacks.forEach((fn) => fn()) // (2.2.6.2)
      }
    }

    // 若 executor 报错，直接执行 reject()
    try {
      executor(resolve, reject)
    } catch (err) {
      reject(err)
    }
  }

  then(onFulfilled, onRejected) {
    // onFulfilled 和 onRejected 都是可选参数 (2.2.1)

    // 如果 onFulfilled 不是函数，则必须将它忽略 (2.2.1.1)
    onFulfilled =
      typeof onFulfilled === 'function' ? onFulfilled : (value) => value

    // 如果 onRejected 不是函数，则必须将它忽略 (2.2.1.2)
    onRejected =
      typeof onRejected === 'function'
        ? onRejected
        : (err) => {
            throw err
          }

    // 为了做到链式调用，规定每个 then 方法必须返回一个 promise，称为 promise2
    const promise2 = new Promise((resolve, reject) => {
      // 在 promise 完成后方可调用 onFulfilled (2.2.2)
      if (this.state === FULFILLED) {
        // onFulfilled/onRejected 必须被异步调用，因此我们用延时函数模拟 (2.2.4)
        setTimeout(() => {
          try {
            // value 作为完成函数的第一个参数 (2.2.2.1)
            // onFulfilled 函数被记做 x (2.2.7.1)
            const x = onFulfilled(this.value)
            resolvePromise(promise2, x, resolve, reject)
          } catch (e) {
            // 如果 onFulfilled/onRejected 抛出异常，则 promise2 必须拒绝执行，并返回拒因 e (2.2.7.2)
            reject(e)
          }
        }, 0)
      }

      // 在 promise 被拒绝后方可调用 onRejected (2.2.3)
      if (this.state === REJECTED) {
        // onFulfilled/onRejected 必须被异步调用，因此我们用延时函数模拟 (2.2.4)
        setTimeout(() => {
          try {
            // reason 作为拒绝函数的第一个参数 (2.2.3.1)
            // onRejected 函数被记做 x (2.2.7.1)
            const x = onRejected(this.reason)
            resolvePromise(promise2, x, resolve, reject)
          } catch (e) {
            // 如果 onFulfilled/onRejected 抛出异常，则 promise2 必须拒绝执行，并返回拒因 e (2.2.7.2)
            reject(e)
          }
        }, 0)
      }

      if (this.state === PENDING) {
        this.onResolvedCallbacks.push(() => {
          // onFulfilled/onRejected 必须被异步调用，因此我们用延时函数模拟 (2.2.4)
          setTimeout(() => {
            try {
              const x = onFulfilled(this.value)
              resolvePromise(promise2, x, resolve, reject)
            } catch (e) {
              // 如果 onFulfilled/onRejected 抛出异常，则 promise2 必须拒绝执行，并返回拒因 e (2.2.7.2)
              reject(e)
            }
          }, 0)
        })
        this.onRejectedCallbacks.push(() => {
          // onFulfilled/onRejected 必须被异步调用，因此我们用延时函数模拟 (2.2.4)
          setTimeout(() => {
            try {
              const x = onRejected(this.reason)
              resolvePromise(promise2, x, resolve, reject)
            } catch (e) {
              // 如果 onFulfilled/onRejected 抛出异常，则 promise2 必须拒绝执行，并返回拒因 e (2.2.7.2)
              reject(e)
            }
          }, 0)
        })
      }
    })

    // 返回 promise2 (2.2.7)
    return promise2
  }

  // catch 实际是 then 的语法糖
  catch(fn) {
    return this.then(null, fn)
  }

  finally(fn) {
    return this.then(
      (value) => Promise.resolve(fn()).then(() => value),
      (reason) =>
        Promise.resolve(fn()).then(() => {
          throw reason
        }),
    )
  }
}

const resolvePromise = (promise2, x, resolve, reject) => {
  // 如果 promise 和 x 指向同一个对象，将以 TypeError 作为拒因拒绝执行 promise (2.3.1)
  if (x === promise2) {
    return reject(new TypeError('Chaining cycle detected for promise'))
  }

  // onFulfilled 和 onRejected 只能被调用一次，因此这里加一个 flag 作为判断 (2.2.2.3 & 2.2.3.3)
  let isCalled = false

  // 如果 x 是一个对象或者是一个函数 (2.3.3)
  if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
    try {
      // (2.3.3.1)
      const then = x.then

      // 如果 then 是函数，就以 x 作为 this 调用它 (2.3.3.2 & 2.3.3.3)
      if (typeof then === 'function') {
        // 后面接收两个回调，第一个是成功的回调，第二个是失败的回调 (2.3.3.3)
        then.call(
          x,
          (y) => {
            if (isCalled) return
            isCalled = true
            // 如果 resolvePromise 以 y 为参数被调用，执行 [[Resolve]](promise, y) (2.3.3.3.1)
            resolvePromise(promise2, y, resolve, reject)
          },
          (r) => {
            if (isCalled) return
            isCalled = true
            // 如果 rejectPromise 以 r 为原因被调用，则以拒因 r 拒绝 promise (2.3.3.3.2)
            reject(r)
          },
        )
      } else {
        // 如果 then 不是个函数，则以 x 为参数执行 promise (2.3.3.4)
        resolve(x)
      }
    } catch (e) {
      if (isCalled) return
      isCalled = true
      // 如果取 x.then 报错，则以 e 为拒因拒绝 `promise` (2.3.3.2)
      reject(e)
    }
  }
  // 如果 then 不是个函数或者对象，则以 x 为参数执行 promise (2.3.4)
  else {
    resolve(x)
  }
}

// Promise.resolve
Promise.resolve = function (promises) {
  if (promises instanceof Promise) {
    return promises
  }
  return new Promise((resolve, reject) => {
    if (promises && promises.then && typeof promises.then === 'function') {
      setTimeout(() => {
        promises.then(resolve, reject)
      })
    } else {
      resolve(promises)
    }
  })
}

// Promise.reject
Promise.reject = (reason) => new Promise((resolve, reject) => reject(reason))

// Promise.all
Promise.all = (promises) => {
  return new Promise((resolve, reject) => {
    let resolvedCounter = 0
    let n = promises.length
    let resolvedValues = []

    promises.forEach((promise, i) => {
      Promise.resolve(promise).then(
        (value) => {
          resolvedCounter++
          resolvedValues[i] = value
          if (resolvedCounter === n) {
            return resolve(resolvedValues)
          }
        },
        (reason) => {
          return reject(reason)
        },
      )
    })
  })
}

// Promise.race
Promise.race = (promises) => {
  return new Promise((resolve, reject) => {
    promises.forEach((promise) => {
      Promise.resolve(promises[i]).then(
        (data) => {
          resolve(data)
          return
        },
        (err) => {
          reject(err)
          return
        },
      )
    })
  })
}

// Promise.any
Promise.any = (promises) => {
  return new Promise((resolve, reject) => {
    let hasOneResolved = false
    let remaining = promises.length
    const errors = []

    promises.forEach((promise, i) => {
      promise.then(
        (data) => {
          if (hasOneResolved) return
          hasOneResolved = true
          resolve(data)
        },
        (err) => {
          if (hasOneResolved) return
          remaining--
          errors[i] = err
          remaining || reject(errors)
        },
      )
    })
  })
}

// Promise.allSettled
Promise.allSettled = function (promises) {
  return new Promise(function (resolve) {
    const res = []
    const count = 0
    const n = promises.length
    promises.forEach((promise, i) => {
      Promise.resolve(promise)
        .then((value) => {
          res[i] = {
            status: FULFILLED,
            value,
          }
          count++
          if (count === n) {
            resolve(res)
          }
        })
        .catch((reason) => {
          res[i] = {
            status: REJECTED,
            reason: reason,
          }
          count++
          if (count === n) {
            resolve(res)
          }
        })
    })
    resolve(res)
  })
}
```

最后全局安装 `yarn global add promises-aplus-tests`, 插入下面这段代码, 然后使用 `promises-aplus-tests 该文件的文件名` 来验证你手写的 Promise 是否符合 Promises A+ 规范.

```js
Promise.defer = Promise.deferred = function () {
  let dfd = {};
  dfd.promise = new Promise((resolve, reject) => {
    dfd.resolve = resolve;
    dfd.reject = reject;
  });
  return dfd;
};
module.exports = Promise;
```

##

附录：[全文翻译] Promises/A+ 规范

**一个开放、可靠且通用的 JavaScript Promise 标准. 由开发者制定, 供开发者参考. **

_promise_ 代表着一个异步操作的最终结果, 与之交互的主要方式是它的 `then` 方法, 该方法注册了两个回调函数, 用于接收 promise 最终的值或者失败的原因.

该规范详细描述了 `then` 方法的行为, 所有遵循 Promises/A+ 规范实现的 promise 均可以本标准作为参照基础来实施. 因此, 这份规范是很稳定的. 虽然 Promises/A+ 组织偶尔会修订这份规范, 但大多是为了处理一些特殊的边界情况. 这些改动都是微小且向下兼容的. 如果我们要进行大规模不兼容的更新, 我们一定会在事先进行谨慎地考虑、详尽的探讨和严格的测试.

最后, 核心的 Promises/A+ 规范不会提供如何创建、解决和拒绝 promise, 而是专注于提供一个通用的 `then` 方法. 上述对于 promises 的操作方法将来在其他规范中可能会提及.

## 1\. 术语

1.1. 'promise' 是一个拥有 `then` 方法的对象或者函数, 且其行为符合此规范.

1.2. 'thenable' 是一个用来定义 `then` 方法的对象或者函数.

1.3. 'value' 是任何一个合法的 JavaScript 值 (包括 `undefined`, thenable 或者 promise)

1.4. 'exception' 是一个使用 throw 语句抛出的值

1.5. 'reason' 表明了一个 promise 为什么会被拒绝

## 2\. 要求

### 2.1. Promise 状态

promise 必须是三个状态之一：等待态(Pending)、执行态(Fulfilled)和拒绝态(Rejected).

- 2.1.1. 当前状态为 pending 时, 一个 promise：

  * 2.1.1.1 可以转换成 fulfilled 或者 rejected 状态


- 2.1.2. 当前状态为 fulfilled 时, 一个 promise：

  - 2.1.2.1 不能再转换成其他任何状态

  - 2.1.2.2 必须拥有一个不可变的值

- 2.1.3. 当前状态为 rejected 时, 一个 promise：

  - 2.1.3.1 不能再转换成其他任何状态

  - 2.1.3.2 必须拥有一个不可变的原因

这里的不可变指的是恒等(即可用 === 判断相等), 而不是意味着更深层次的不可变. (即当 value 或者 reason 为引用类型时, 只要求引用地址相等即可, 但属性值可以被修改)

### 2.2. `then` 方法

promise 必须提供一个 `then` 方法以访问它当前或最终的值或被拒绝的原因.

一个 promise 的 `then` 方法接收两个参数：

```js
promise.then(onFulfilled, onRejected);
```

- 2.2.1 `onFulfilled` 和 `onRejected` 都是可选参数.

  - 2.2.1.1 如果 `onFulfilled` 不是个函数, 它将被忽略

  - 2.2.1.2 如果 `onRejected` 不是个函数, 它将被忽略

- 2.2.2 如果 `onFulfilled` 是一个函数：

  - 2.2.2.1 它必须在 `promise` 完成式后被调用, 并且以 `promise` 的值作为它的第一个参数.

  - 2.2.2.2 在 `promise` 未完成前不可调用

  - 2.2.2.3 此函数仅可调用一次

- 2.2.3 如果 `onRejected` 是一个函数：

  - 2.2.3.1 它必须在 `promise` 被拒绝后被调用, 并且以 `promise` 的原因作为它的第一个参数.

  - 2.2.3.2 在 `promise` 未被拒绝前不可调用

  - 2.2.3.3 此函数仅可调用一次

- 2.2.4 `onFulfilled` 和 `onRejected` 只有在 [执行上下文](https://es5.github.io/#x10.3) 堆栈仅包含平台代码时才可被调用. [^3.1]

- 2.2.5 `onFulfilled` 和 `onRejected` 必须被作为函数调用 (即没有 this 值). [^3.2]

- 2.2.6 `then` 在相同的 promise 可以被调用多次

  - 2.2.6.1 当 `promise` 是完成态, 所有相应的 `onFulfilled` 回调必须按其原始调用的顺序执行.

  - 2.2.6.2 当 `promise` 是拒绝态, 所有相应的 `onRejected` 回调必须按其原始调用的顺序执行.

- 2.2.7 每个 `then` 方法必须返回一个 promise [^3.3].

```js
promise2 = promise1.then(onFulfilled, onRejected);
```

- 2.2.7.1 如果 `onFulfilled` 或者 `onRejected` 返回一个值 `x` , 则运行下面的 Promise 解决过程：`[[Resolve]](promise2, x)`

  - 2.2.7.2 如果 `onFulfilled` 或者 `onRejected` 抛出一个异常 `e` , 则 `promise2` 必须拒绝执行, 并返回拒因 `e`

  - 2.2.7.3 如果 `onFulfilled` 不是函数且 `promise1` 成功执行, `promise2` 必须成功执行并返回相同的值

  - 2.2.7.4 如果 `onRejected` 不是函数且 `promise1` 拒绝执行, `promise2` 必须拒绝执行并返回相同的拒因

### 2.3. Promise 解决过程

**Promise 解决过程**是一个抽象的操作, 它接收一个 promise 和一个值, 我们可以表示为 `[[Resolve]](promise, x)`, 如果 `x` 是一个 thenable 的对象, 解决程序将试图接受 `x` 的状态, 否则用 `x` 的值来执行 `promise`.

这种对 thenales 的处理使得 promise 的实现更加有普适性, 只要它暴露出一个兼容 Promises/A+ 规范的 `then` 方法. 它还允许让遵循 Promise/A+ 规范的实现和不太规范但可用的实现良好共存.

为了运行 `[[Resolve]](promise, x)`, 要执行下面的步骤：

- 2.3.1 如果 `promise` 和 `x` 指向同一个对象, 将以 `TypeError` 作为拒因拒绝执行 `promise`.

- 2.3.2 如果 `x` 是一个 promise, 那么将 promise 将接受它的状态 [^3.4]：

  - 2.3.2.1 如果 `x` 是等待态, `promise` 必须保留等待状态直到 `x` 被完成或者被拒绝.

  - 2.3.2.2 如果 `x` 是完成态, 用相同的值执行 `promise`

  - 2.3.2.3 如果 `x` 是拒态, 用相同的原因拒绝 `promise`

- 2.3.3 如果 `x` 是一个对象或者是一个函数,

  - 2.3.3.1 把 `x.then` 赋值给 `then`. [^3.5]

  - 2.3.3.2 如果取 `x.then` 的值时抛出错误 `e`, 则以 `e` 为拒因拒绝 `promise`

  - 2.3.3.3 如果 `then` 是函数, 将 `x` 作为函数的作用域 `this` 来调用它. 传递两个回调函数作为参数, 第一个参数叫做 `resolvePromise`, 第二个参数叫做 `rejectPromise`:

    - 2.3.3.3.1 如果 `resolvePromise` 以 `y` 为参数被调用, 执行 `[[Resolve]](promise, y)`

    - 2.3.3.3.2 如果 `rejectPromise` 以 `r` 为原因被调用, 则以拒因 `r` 拒绝 promise

    - 2.3.3.3.3 如果 `resolvePromise` 和 `rejectPromise` 都被调用, 或者被同一参数调用了多次, 则优先采用首次调用并忽略剩下的调用.

    - 2.3.3.3.4 如果调用 `then` 抛出一个异常 `e`

      - 2.3.3.3.4.1 如果 `resolvePromise` 和 `rejectPromise` 都被调用, 则忽略掉它

      - 2.3.3.3.4.2 否则, 以 `e` 为拒因拒绝这个 `promise`

  - 2.3.3.4 如果 `then` 不是个函数, 则以 `x` 为参数执行 `promise`

- 2.3.4 如果 `then` 不是个函数或者对象, 则以 `x` 为参数执行 `promise`

如果一个 promise 被一个循环的 thenable 链中的对象解决, 而 `[[Resolve]](promise, thenable)` 的递归性质又使得其被再次调用, 根据上述的算法将会陷入无限递归之中. 算法虽不强制要求, 但也鼓励施者检测这样的递归是否存在, 若检测到存在则以一个可识别的 TypeError 为拒因来拒绝 promise [^3.6].

## 3\. 注释

[^3.1]: 这里的“平台代码”意味着引擎, 环境和 promise 实施代码, 在实践中要确保 `onFulfilled` 和 `onRejected` 异步执行, 且应该在 `then` 方法被调用的那一轮事件循环之后的新执行栈中执行. 这个事件队列可以采用“宏任务（macro-task）”机制, 类似于 `setTimeOut` 或者 `setImmediate`, 也可以使用“微任务（micro-task）”机制来实现, 类似于 `MutationObserver` 或 `process.nextTick`. 因为 promise 实现被认为是平台代码, 所以它本身可能包含一个任务调度队列或跳板, 在其中调用处理程序.

[^3.2]: 在严格模式下 `this` 为 `undefined`, 而在非严格模式中, `this` 为全局对象.

[^3.3]: 代码实现在满足所有要求的情况下可以允许 `promise2 === promise1` . 每个实现都要文档说明其是否允许以及在何种条件下允许 `promise2 === promise1` .

[^3.4]: 总体来说, 如果 `x` 符合当前实现, 我们才认为它是真正的 promise . 这一规则允许那些特例实现接受符合已知要求的 Promises 状态.

[^3.5]: 这步我们先是存储了一个指向 `x.then` 的引用, 然后测试并调用该引用, 以避免多次访问 `x.then` 属性. 这种预防措施确保了该属性的一致性, 因为其值可能在检索调用时被改变.

[^3.6]: 实现不应该对 thenable 链的深度设限, 并假定超出本限制的递归就是无限循环. 只有真正的循环递归才应能导致 `TypeError` 异常；如果一条无限长的链上 thenable 均不相同, 那么递归下去永远是正确的行为.
","2025-02-02 03:08:34.497345","2025-02-02 03:08:34.497345"
"7c5cfa3e-d6ae-4578-81c0-f94494ade35a","{JavaScript}",0,0,False,"https://edge.yancey.app/beg/PpDlUWz9b0.jpg","你可能不知道的 Object.defineProperty()","最近在写一个 《JavaScript API 全解析》系列（刚写完 String，现正在写 Object，https://js.yanceyleo.com），想把 MDN 推荐使用的 API 全部撸一遍，也算是给自己准备一份资料。因为 Object.defineProperty() 涉及到的知识点比较复杂，所以单独拎出来放到这里，欢迎大家拍砖。","## 语法

```ts
defineProperty(o: any, p: PropertyKey, attributes: PropertyDescriptor & ThisType<any>): any;
```

## 描述

用于在一个对象上定义新的属性或修改现有属性, 并返回该对象.

### 参数

- `o` 目标对象

- `p` 需要定义的属性或方法名 (可修改既有的, 也可添加新属性或方法)

- `attributes` 属性描述符, 具体属性如下:

```javascript
interface PropertyDescriptor {
  configurable?: boolean;
  enumerable?: boolean;
  value?: any;
  writable?: boolean;
  get?(): any;
  set?(v: any): void;
}
```

## 属性描述符

ECMAScript 中有两种属性: `数据属性` 和 `访问器属性`.

**数据属性**包括: **[[Configurable]]**, **[[Enumerable]]**, **[[Writable]]**, **[[Value]]**

**访问器属性**包括: **[[Configurable]]**, **[[Enumerable]]**, **[[Get]]**, **[[Set]]**

### 属性描述符可同时具有的键值

|            | configurable | enumerable | value | writable | get | set |
| ---------- | ------------ | ---------- | ----- | -------- | --- | --- |
| 数据属性   | Yes          | Yes        | Yes   | Yes      | No  | No  |
| 访问器属性 | Yes          | Yes        | No    | No       | Yes | Yes |

简言之, 定义了 **value** 或 **writable** ,
一定不能有 **get** 或 **set**, 反之亦然, 否则报错.

### Configurable

如果某个属性的 configurable 为`false`, 那么:

1. 将不能删除此属性, 即 `delete obj.xxx` 无效, 在严格模式下直接报错.

```javascript
// 非严格模式下删除一个""不可配置""的属性会返回false
const obj = {};

Object.defineProperty(obj, 'name', {
  value: 'yancey',
  configurable: false,
});

delete obj.name; // false

// obj.name并没有被删除
obj.name; // yancey
```

```javascript
// 严格模式下删除一个""不可配置""的属性直接报错
(function() {
  'use strict';
  var o = {};
  Object.defineProperty(o, 'b', {
    value: 2,
    configurable: false,
  });
  delete o.b; // Uncaught TypeError: Cannot delete property 'b' of #<Object>
  return o.b;
})();
```

2. 当 enumerable 或 writable 是`false`时, 再次将它们变成`true`则报错; 但当它们是`true`时, 却可以把它们变成`false` (
   注意必须是在`不可配置`的前提下, 如果属性`可配置`, enumerable 和 writable 可任意切换 true 和 false)

```javascript
const obj = {};

Object.defineProperty(obj, 'name', {
  value: 'yancey',
  configurable: false,
  writable: false,
});

// 当""writable""和""configurable""均为false时, 尝试将""writable""变为true会报错
// Uncaught TypeError: Cannot redefine property: name
Object.defineProperty(obj, 'name', { writable: true });
```

```javascript
const obj = {};

Object.defineProperty(obj, 'name', {
  value: 'yancey',
  configurable: false,
  writable: true,
});

// 但""writable""可成功从true切换到false
Object.defineProperty(obj, 'name', { writable: false });
```

3. 无论如何再次修改`get`和`set`都会报错, 因为两者的属性值是一个函数，在 JS 中不可能存在一个相同的函数。复杂数据类型在`栈`中存储**数据名**和一个**堆的地址**, 在`堆`中存储**属性**及**值**. 访问时先从栈获取地址, 再到堆中拿出相应的值.

```javascript
const obj = {};

Object.defineProperty(obj, 'name', {
  value: 'yancey',
  configurable: false,
});

// Uncaught TypeError: Cannot redefine property: name
Object.defineProperty(obj, 'name', { get: function() {} });

// Uncaught TypeError: Cannot redefine property: name
Object.defineProperty(obj, 'name', { set: function() {} });
```

4. 只要`writable` 是 true, 可以`任意重新定义` value, 但当`writable`是 false 时, 需要看具体数据类型. 第一个例子中, 虽然 configurable 是 **false**, 但只要 writable 是 **true**, 便可以重新定义 value; 第二个例子中, value 是 `基本数据类型`, 所以再次定义 value 时只要覆盖原值即可; 第三个例子 value 是复杂数据类型, 同样因为 **堆栈** 问题而不能重新赋值.

```javascript
const obj = {};

Object.defineProperty(obj, 'name', {
  value: [],
  configurable: false,
  writable: true,
});

// 任意重定义value不报错
Object.defineProperty(obj, 'name', { value: 123 }); // {name: 123}

// 任意重定义value不报错
Object.defineProperty(obj, 'name', { value: {}); // {name: {}}
```

```javascript
const obj = {};

Object.defineProperty(obj, 'name', {
  value: 123,
  configurable: false,
  writable: false,
});

// 当value是基本数据类型, 用原值覆盖不会报错
Object.defineProperty(obj, 'name', { value: 123 }); // {name: 123}

// 用其他值代替必然报错
Object.defineProperty(obj, 'name', { value: {}); // Uncaught TypeError: Cannot redefine property: name
```

```javascript
const obj = {};

Object.defineProperty(obj, 'name', {
  value: [],
  configurable: false,
  writable: false,
});

// 当value是复杂数据类型, 修改value必定报错, 同样是堆栈的原因
Object.defineProperty(obj, 'name', { value: [] }); // {name: 123}
```

### Writable

如果某个属性的`writable`设为`false`, 那么该属性将不能被`赋值运算符`改变. 但属性值假如是数组时, 将不受 `push`, `splice`等方法的影响.

```javascript
const obj = {};

Object.defineProperty(obj, 'hobby', {
  value: ['girl', 'music', 'sleep'],
  writable: false,
  configurable: true,
  enumerable: true,
});

// ""writable: false""并不对push、shift等方法起作用
obj.hobby.push('drink');
obj.hobby; // ['girl', 'music', 'sleep', 'drink']

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// 当 hobby 被""赋值""给一个空数组时, 此属性的属性值不会被改变
obj.hobby = [];
obj.hobby; // ['girl', 'music', 'sleep', 'drink']

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// 而当使用""严格模式""时, 给一个""不可写""属性赋值将直接报错
(function() {
  'use strict';
  var o = {};
  Object.defineProperty(o, 'b', {
    value: 2,
    writable: false
  });
  o.b = 3; // throws TypeError: ""b"" is read-only
  return o.b; // 2
}());
```

### Enumerable

定义了对象的属性是否可以在 for...in 循环和 Object.keys() 中被枚举

```javascript
const obj = {
  name: 'yancey',
  age: 18,
  say() {
    return 'say something...';
  },
};

Object.defineProperty(obj, 'hobby', {
  value: ['girl', 'music', 'sleep'],
  enumerable: true,
});

Object.defineProperty(obj, 'income', {
  value: '100,00,000',
  enumerable: false,
});

// 以下迭代器均不能输出""不可枚举属性"", 即 income 的相关信息
for (const i in obj) {
  console.log(obj[i]);
}
Object.keys(obj);
Object.values(obj);
Object.entries(obj);
```

### Getter & Setter

Getter 为读取属性时调用的函数. Setter 为设置属性是调用的函数, Setter 会有一个参数, 即设置的那个值.

下面的代码创建一个 obj 对象, 定义了两个属性 name 和 \_time, 注意 \_time 的下划线是一个常用记号, 用于表示`只能通过对象方法访问的属性`.
而访问器属性 time 则包含一个 getter 函数和一个 setter 函数. getter 函数返回`被修饰`的 \_time 的值, setter 则根据`被设置的值`修改 name.
因此当`obj.time = 2`, name 会变成`我为长者+2s`. 这是使用访问器属性的常见方式, 即设置一个属性的值会导致其他属性发生变化.

```javascript
const obj = {
  name: '长者',
  _time: 1,
};

Object.defineProperty(obj, 'time', {
  configurable: true,
  get() {
    return `default: ${this._time}s`;
  },
  set(newValue) {
    if (Number(newValue)) {
      this._time = newValue;
      this.name = `我为${this.name}+${newValue}s`;
    }
  },
});

obj.time; // 'default: 1s'
obj.time = 2; // 2
obj.name; // '我为长者+2s'
```

再看另一个例子, 通过 Object.defineProperty 劫持 `obj.input`, 将输入的值 **set** 到 id 为 `name` 的标签里. 这里便有了种 Vue.js 的味道, 推荐一篇文章 [剖析 Vue 实现原理 - 如何实现双向绑定 mvvm](https://github.com/DMQ/mvvm).

```html
<p>Hello, <span id='name'></span></p>
<input type='text' id='input'>

const obj = {
  input: '',
};

const inputDOM = document.getElementById('input');
const nameDOM = document.getElementById('name');

inputDOM.addEventListener('input', function (e) {
  obj.input = e.target.value;
})

Object.defineProperty(obj, 'input', {
  set: function (newValue) {
    nameDOM.innerHTML = newValue.trim().toUpperCase();
  }
})
```

最后看一个关于继承的例子, 我们创建了一个 **Person** 构造函数, 它包括两个参数: **firstName** 和 **lastName**, 此构造函数暴露出四个属性: **firstName**, **lastName**, **fullName**, **species**, 我们想让前三个属性动态变化, 最后一个属性是一个常量而不允许变化.

下面这段代码显然没有达到想要的效果: 在尝试修改 **firstName** 或 **lastName** 时, **fullName** 并没有实时被更新; **species**属性能随意被改变.

```javascript
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
  this.fullName = this.firstName + ' ' + this.lastName;
  this.species = 'human';
}

const person = new Person('Yancey', 'Leo');

// 虽然 firstName 和 lastName 被修改了, 但 fullName 仍然是 ""Yancey Leo""
person.firstName = 'Sayaka';
person.lastName = 'Yamamoto';

// 我们定义了一个关于“人”的构造函数, 所以并不希望 species 被修改成 fish
person.species = 'fish';

// 当我们修改了 fullName, 也同样希望 firstName 和 lastName 被更新
person.fullName = 'Kasumi Arimura';
```

所以我们使用 Object.defineProperty() 重写这个例子. 需要注意的是: **被劫持的属性应放在原型里**. 通过下面这种方式, 即使创建多个实例, 也不会冲突,
所以可以放心使用.

```javascript
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

Object.defineProperty(Person.prototype, 'species', {
  value: 'human',
  writable: false,
});

Object.defineProperty(Person.prototype, 'fullName', {
  get() {
    return this.firstName + ' ' + this.lastName;
  },
  set(newValue) {
    const newValueArr = newValue.trim().split(' ');
    if (newValueArr.length === 2) {
      this.firstName = newValueArr[0];
      this.lastName = newValueArr[1];
    }
  },
});

const person = new Person('Yancey', 'Leo');

person.firstName = 'Sakaya';
person.lastName = 'Yamamoto';
person.fullName; // 'Sayaka Yamamoto'

person.fullName = 'Kasumi Arimura';
person.firstName; // 'Kasumi'
person.lastName; // 'Arimura'

person.species = 'fish';
person.species; // 'human'
```

## 扩展

除了 Object.defineProperty() 中的 Getter 和 Setter, 还有两种类似的方式.

### \_\_defineGetter\_\_ 和 \_\_defineSetter\_\_()

\_\_defineGetter\_\_ 方法可以为一个`已经存在`的对象设置 (新建或修改) 访问器属性, \_\_defineSetter\_\_ 方法可以将一个函数绑定在当前对象的指定属性上, 当那个属性被赋值时, 你所绑定的函数就会被调用.

```javascript
var o = {};
o.__defineGetter__('gimmeFive', function() {
  return 5;
});
o.gimmeFive; // 5
```

:::danger
该特性是非标准的, 请尽量不要在生产环境中使用它!

该特性已经从 Web 标准中删除, 虽然一些浏览器目前仍然支持它, 但也许会在未来的某个时间停止支持, 请尽量不要使用该特性.
:::

### 对象字面量中的 get 语法

对象字面量中的 get 语法只能在`新建一个对象`时使用.

```javascript
var o = {
  get gimmeFive() {
    return 5;
  },
};
o.gimmeFive; // 5
```

## 参考

[Vue 核心之数据劫持](https://juejin.im/entry/589ff26486b599006b3dea9b)

[不会 Object.defineProperty 你就 out 了](https://imweb.io/topic/56d40adc0848801a4ba198ce)

[vue.js 关于 Object.defineProperty 的利用原理](https://www.jianshu.com/p/07ba2b0c8fca)

[面试官: 实现双向绑定 Proxy 比 defineproperty 优劣如何?](https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf)

[JAVASCRIPT ES5: MEET THE OBJECT.DEFINEPROPERTY() METHOD](https://x-team.com/blog/es5-object-defineproperty-method/)

<style scope>
  img {
    margin: 0 auto;
    display: block;
  }
</style>
","2025-02-02 03:08:37.018692","2025-02-02 03:08:37.018692"
"eda127b1-ccc3-40d8-ad52-31502cb206da","{JavaScript}",0,0,False,"https://edge.yancey.app/beg/0_X7Z0k20cwHHi8UOI.png","最后一次弄懂 Event Loop","Event Loop 是 JavaScript 异步编程的核心思想，也是前端进阶必须跨越的一关。同时，它又是面试的必考点，特别是在 Promise 出现之后，各种各样的面试题层出不穷，花样百出。这篇文章从现实生活中的例子入手，让你彻底理解 Event Loop 的原理和机制，并能游刃有余的解决此类面试题。","## 宇宙条那道烂大街的笔试题镇楼

```js
async function async1() {
  console.log(""async1 start"");
  await async2();
  console.log(""async1 end"");
}
async function async2() {
  console.log(""async2"");
}
console.log(""script start"");
setTimeout(function () {
  console.log(""setTimeout"");
}, 0);
async1();
new Promise(function (resolve) {
  console.log(""promise1"");
  resolve();
}).then(function () {
  console.log(""promise2"");
});
console.log(""script end"");
```

## 为什么 JavaScript 是单线程的?

我们都知道 JavaScript 是一门 `单线程` 语言, 也就是说同一时间只能做一件事. 这是因为 JavaScript 生来作为浏览器脚本语言, 主要用来处理与用户的交互, 网络以及操作 DOM. 这就决定了它只能是单线程的, 否则会带来很复杂的同步问题.

假设 JavaScript 有两个线程, 一个线程在某个 DOM 节点上添加内容, 另一个线程删除了这个节点, 这时浏览器应该以哪个线程为准?

既然 Javascript 是单线程的, 它就像是只有一个窗口的银行, 客户不得不排队一个一个的等待办理. 同理 JavaScript 的任务也要一个接一个的执行, 如果某个任务(比如加载高清图片)是个耗时任务, 那浏览器岂不得一直卡着? 为了防止主线程的阻塞, JavaScript 有了 `同步` 和 `异步` 的概念.

## 同步和异步

### 同步

如果在一个函数返回的时候, 调用者就能够得到预期结果, 那么这个函数就是同步的. 也就是说同步方法调用一旦开始, 调用者必须等到该函数调用返回后, 才能继续后续的行为. 下面这段段代码首先会弹出 alert 框, 如果你不点击 `确定` 按钮, 所有的页面交互都被锁死, 并且后续的 `console` 语句不会被打印出来.

```js
alert(""Yancey"");
console.log(""is"");
console.log(""the"");
console.log(""best"");
```

### 异步

如果在函数返回的时候, 调用者还不能够得到预期结果, 而是需要在将来通过一定的手段得到, 那么这个函数就是异步的. 比如说发一个网络请求, 我们告诉主程序等到接收到数据后再通知我, 然后我们就可以去做其他的事情了. 当异步完成后, 会通知到我们, 但是此时可能程序正在做其他的事情, 所以即使异步完成了也需要在一旁等待, 等到程序空闲下来才有时间去看哪些异步已经完成了, 再去执行.

这也就是定时器并不能精确在指定时间后输出回调函数结果的原因.

```js
setTimeout(() => {
  console.log(""yancey"");
}, 1000);

for (let i = 0; i < 100000000; i += 1) {
  // todo
}
```

## 回调函数

当某个函数被作为参数, 传递给另外一个函数, 或者传递给宿主环境, 然后该函数在函数内部或者在宿主环境中被调用, 我们称之为回调函数. 回调函数有同步和异步两种, 同步回调和异步回调的最大区别在于**同步回调函数是在执行函数内部被执行的, 而异步回调函数是在执行函数外部被执行的**.

比如 forEach 里的回调函数, 是在 forEach 函数内部执行, 所以是个同步回调. 再比如 setTimeout 里的回调函数, V8 执行 setTimeout 时, 会立即返回, 等待 x 毫秒之后, 该回调函数才会被 V8 调用, 该回调函数并不是在 setTimeout 函数内部被执行的, 所以这是一个异步回调.

浏览器有个 UI 线程(在浏览器中就是主线程), 它是用来运行窗口的线程, 如触发绘制页面的事件, 鼠标点击, 拖拽, 放大缩小的事件, 资源下载, 文件读写的事件都会交由 UI 线程处理. 但是很多时候, UI 线程并不能立即响应和处理这些事件, 比如频繁的拖拽事件. 为此我们为 UI 线程提供一个消息队列, 将这些待执行的事件添加到消息队列中, 然后 UI 线程会不断循环地从消息队列中取出事件, 执行事件. 我们把 UI 线程每次从消息队列中取出事件, 执行事件的过程称为一个任务.

![UI 线程架构](https://edge.yancey.app/beg/qenp8ktp-1653308091219.webp)

以 setTimeout 为例, 比如在页面主线程中正在执行 A 任务, 在执行 A 任务的过程中调用 `setTimeout(foo, 3000)`, 在执行 setTimeout 函数的过程中, 宿主就会将 foo 函数封装成一个事件, 并添加到消息队列中, 然后 setTimeout 函数执行结束. 主线程会不间断地从消息队列中取出新的任务, 执行新的任务, 等到时机合适, 便取出 setTimeout 设置的 foo 函数的回调的任务, 然后就可以直接执行 foo 函数的调用了.

## 执行栈和任务队列

- 栈 (stack): 栈是遵循后进先出 (LIFO) 原则的有序集合, 新添加或待删除的元素都保存在同一端, 称为栈顶, 另一端叫做栈底. 在栈里, 新元素都靠近栈顶, 旧元素都接近栈底. 栈在编程语言的编译器和内存中存储基本数据类型和对象的指针, 方法调用等.

- 队列 (queue): 队列是遵循先进先出 (FIFO) 原则的有序集合, 队列在尾部添加新元素, 并在顶部移除元素, 最新添加的元素必须排在队列的末尾. 在计算机科学中, 最常见的例子就是打印队列.

- 堆 (heap): 堆是基于树抽象数据类型的一种特殊的数据结构.

![栈/队列](https://edge.yancey.app/beg/16a3e8964d42e54e.png)

如上图所示, JavaScript 中的内存分为 `堆内存` 和 `栈内存`,

JavaScript 中引用类型值的大小是不固定的, 因此它们会被存储到 `堆内存` 中, 由系统自动分配存储空间. JavaScript 不允许直接访问堆内存中的位置, 因此我们不能直接操作对象的堆内存空间, 而是操作 `对象的引用`.

而 JavaScript 中的基础数据类型都有固定的大小, 因此它们被存储到 `栈内存` 中. 我们可以直接操作保存在栈内存空间的值, 因此基础数据类型都是 `按值访问`. 此外, 栈内存还会存储 `对象的引用 (指针)` 以及 `函数执行时的运行空间`.

下面比较一下两种存储方式的不同.

| 栈内存                 | 堆内存                       |
| ---------------------- | ---------------------------- |
| 存储基础数据类型       | 存储引用数据类型             |
| 按值访问               | 按引用访问                   |
| 存储的值大小固定       | 存储的值大小不定, 可动态调整 |
| 由系统自动分配内存空间 | 由程序员通过代码进行分配     |
| 主要用来执行程序       | 主要用来存放对象             |
| 空间小, 运行效率高     | 空间大, 但是运行效率相对较低 |
| 先进后出, 后进先出     | 无序存储, 可根据引用直接获取 |

### 执行栈

当我们调用一个方法的时候, JavaScript 会生成一个与这个方法对应的执行环境, 又叫执行上下文(context). 这个执行环境中保存着该方法的私有作用域, 上层作用域(作用域链), 方法的参数, 以及这个作用域中定义的变量和 this 的指向, 而当一系列方法被依次调用的时候. 由于 JavaScript 是单线程的, 这些方法就会按顺序被排列在一个单独的地方, 这个地方就是所谓执行栈.

### 任务队列

事件队列是一个存储着 `异步任务` 的队列, 其中的任务严格按照时间先后顺序执行, 排在队头的任务将会率先执行, 而排在队尾的任务会最后执行. 事件队列每次仅执行一个任务, 在该任务执行完毕之后, 再执行下一个任务. 执行栈则是一个类似于函数调用栈的运行容器, 当执行栈为空时, JS 引擎便检查事件队列, 如果事件队列不为空的话, 事件队列便将第一个任务压入执行栈中运行.

![任务队列](https://edge.yancey.app/beg/g1tyu1pj-1650445583033.webp)

## 页面使用单线程的缺点

我们知道页面线程所有执行的任务都来自于消息队列. 消息队列是先进先出的属性, 也就是说放入队列中的任务, 需要等待前面的任务被执行完, 才会被执行. 假设有一个耗时的任务, 它是同步的, 就会导致执行效率的下降. 如果它是异步的, 它将被添加到消息队列的尾部, 那么又会影响到实时性, 因为在添加到消息队列的过程中, 可能前面就有很多任务在排队了.

为了权衡效率和实时性, 微任务就应用而生了. 通常我们把消息队列中的任务称为宏任务, 每个宏任务中都包含了一个微任务队列. 在执行宏任务的过程中, 如果有一些微任务, 那么就会将该变化添加到微任务列表中, 这样就不会影响到宏任务的继续执行, 因此也就解决了执行效率的问题. 等宏任务中的主要功能都直接完成之后, 这时候, 渲染引擎并不着急去执行下一个宏任务, 而是执行当前宏任务中的微任务, 因为这些微任务的事件都保存在这些微任务队列中, 这样也就解决了实时性问题.

第二个是如何解决单个任务执行时长过久的问题. 因为所有的任务都是在单线程中执行的, 所以每次只能执行一个任务, 而其他任务就都处于等待状态. 如果其中一个任务执行时间过久, 那么下一个任务就要等待很长时间. 针对这种情况, JavaScript 可以通过回调功能来规避这种问题, 也就是让要执行的 JavaScript 任务滞后执行.

## 单线程处理任务的方法论

- 如果有一些确定好的任务, 可以使用一个单线程来按照顺序处理这些任务, 这是第一版线程模型.
- 要在线程执行过程中接收并处理新的任务, 就需要引入循环语句和事件系统, 这是第二版线程模型.
- 如果要接收其他线程发送过来的任务, 就需要引入消息队列, 这是第三版线程模型.
- 如果其他进程想要发送任务给页面主线程, 那么先通过 IPC 把任务发送给渲染进程的 IO 线程, IO 线程再把任务发送给页面主线程.
- 消息队列机制并不是太灵活, 为了适应效率和实时性, 引入了微任务.

## 事件循环

我们注意到, 在异步代码完成后仍有可能要在一旁等待, 因为此时程序可能在做其他的事情, 等到程序空闲下来才有时间去看哪些异步已经完成了. 所以 JavaScript 有一套机制去处理同步和异步操作, 那就是事件循环 (Event Loop).

下面就是事件循环的示意图.

![事件循环示意图](https://edge.yancey.app/beg/16a3e8964d1e54ce.png)

用文字描述的话, 大致是这样的:

异步任务的返回结果会被放到一个任务队列中, 根据异步事件的类型, 这个事件实际上会被放到对应的宏任务和微任务队列中去.

在当前执行栈为空时, 主线程会查看微任务队列是否有事件存在

- 存在, 依次执行队列中的事件对应的回调, 直到微任务队列为空, 然后去宏任务队列中取出最前面的事件, 把当前的回调加到当前指向栈.
- 如果不存在, 那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈;
  当前执行栈执行完毕后时会立刻处理所有微任务队列中的事件, 然后再去宏任务队列中取出一个事件. 同一次事件循环中, 微任务永远在宏任务之前执行.

在事件循环中, 每进行一次循环操作称为 tick, 每一次 tick 的任务处理模型是比较复杂的, 但关键步骤如下:

- 执行一个宏任务(栈中没有就从事件队列中获取)
- 执行过程中如果遇到微任务, 就将它添加到微任务的任务队列中
- 宏任务执行完毕后, 立即执行当前微任务队列中的所有微任务(依次执行)
- 当前宏任务执行完毕, 开始检查渲染, 然后 GUI 线程接管渲染
- 渲染完毕后, JS 线程继续接管, 开始下一个宏任务(从事件队列中获取)

简单总结一下执行的顺序:

执行宏任务, 然后执行该宏任务产生的微任务, 若微任务在执行过程中产生了新的微任务, 则继续执行微任务, 微任务执行完毕后, 再回到宏任务中进行下一轮循环.

![事件循环流程图](https://edge.yancey.app/beg/7hev6i1qvz-1625658327597)

看一个例子:

```ts
console.log(""start"");

setTimeout(function () {
  console.log(""setTimeout"");
}, 0);

Promise.resolve()
  .then(function () {
    console.log(""promise1"");
  })
  .then(function () {
    console.log(""promise2"");
  });

console.log(""end"");
```

![1653721873-5adb68e2247cf.gif](https://edge.yancey.app/beg/1653721873-5adb68e2247cf.gif)

## 宏任务和微任务

异步任务分为 `宏任务(macrotask)` 与 `微任务 (microtask)`. 宏任务会进入一个队列, 而微任务会进入到另一个不同的队列, 且微任务要优于宏任务执行.

[微任务, 宏任务与 Event-Loop](https://juejin.im/post/5b73d7a6518825610072b42b#heading-5) 这篇文章用了很有趣的例子来解释宏任务和微任务, 下面 copy 一下.

还是以去银行办业务为例, 当 5 号窗口柜员处理完当前客户后, 开始叫号来接待下一位客户, 我们将每个客户比作 `宏任务`, `接待下一位客户` 的过程也就是让下一个 `宏任务` 进入到执行栈.

所以该窗口所有的客户都被放入了一个 `任务队列` 中. 任务队列中的都是 `已经完成的异步操作的`, 而不是注册一个异步任务就会被放在这个任务队列中(它会被放到 Task Table 中). 就像在银行中排号, 如果叫到你的时候你不在, 那么你当前的号牌就作废了, 柜员会选择直接跳过进行下一个客户的业务处理, 等你回来以后还需要重新取号.

在执行宏任务时, 是可以穿插一些微任务进去. 比如你大爷在办完业务之后, 顺便问了下柜员: “最近 P2P 暴雷很严重啊, 有没有其他稳妥的投资方式”. 柜员暗爽: “又有傻子上钩了”, 然后叽里咕噜说了一堆.

我们分析一下这个过程, 虽然大爷已经办完正常的业务, 但又咨询了一下理财信息, 这时候柜员肯定不能说: “您再上后边取个号去, 重新排队”. 所以只要是柜员能够处理的, 都会在响应下一个宏任务之前来做, 我们可以把这些任务理解成是 `微任务`.

大爷听罢, 扬起 45 度微笑, 说: “我就问问. ”

柜员 OS: “艹...”

这个例子就说明了: ~~你大爷永远是你大爷~~ `在当前微任务没有执行完成时, 是不会执行下一个宏任务的!`

### 宏任务

为了协调这些任务有条不紊地在主线程上执行, 页面进程引入了消息队列和事件循环机制, 渲染进程内部会维护多个消息队列, 比如延迟执行队列和普通的消息队列. 然后主线程采用一个 for 循环, 不断地从这些任务队列中取出任务并执行任务. 我们把这些消息队列中的任务称为宏任务.

宏任务可以满足我们大部分的日常需求, 不过如果有对时间精度要求较高的需求, 宏任务就难以胜任了. 这是因为页面的渲染事件, 各种 IO 的完成事件, 执行 JavaScript 脚本的事件, 用户交互的事件等都随时有可能被添加到消息队列中, 而且添加事件是由系统操作的, JavaScript 代码不能准确掌控任务要添加到队列中的位置, 控制不了任务在消息队列中的位置, 所以很难控制开始执行任务的时间.

```ts
function timerCallback2() {
  console.log(2);
}

function timerCallback() {
  console.log(1);
  setTimeout(timerCallback2, 0);
}

setTimeout(timerCallback, 0);
```

比如上面这段代码, 你调用 setTimeout 来设置回调任务的间隙, 但消息队列中就有可能被插入很多系统级的任务. 如果中间被插入的任务执行时间过久的话, 那么就会影响到后面任务的执行了. 所以说宏任务的时间粒度比较大, 执行的时间间隔是不能精确控制的, 对一些高实时性的需求就不太符合了.

![Performance 记录](https://edge.yancey.app/beg/rl44re8h-1650540528919.webp)

### 微任务

因为宏任务需要先被放到消息队列中, 如果某些宏任务的执行时间过久, 那么就会影响到消息队列后面的宏任务的执行, 而且这个影响是不可控的, 因为你无法知道前面的宏任务需要多久才能执行完成. 于是我们引入了微任务.

微任务是一个需要异步执行的函数, 执行时机是在主函数执行结束之后, 当前宏任务结束之前. 当 JavaScript 执行一段脚本的时候, V8 会为其创建一个全局执行上下文, 在创建全局执行上下文的同时, V8 引擎也会在内部创建一个微任务队列. 每个宏任务都关联了一个微任务队列.

在现代浏览器里面, 产生微任务有两种方式. 一个是 MutationObserver, 另一个是 Promise.then, Promise.resolve, Promise.reject 这些. 通过 DOM 节点变化产生的微任务或者使用 Promise 产生的微任务都会被 JavaScript 引擎按照顺序保存到微任务队列中.

通常情况下, 在当前宏任务中的 JavaScript 快执行完成时, 也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候, JavaScript 引擎会检查全局执行上下文中的微任务队列, 然后按照顺序执行队列中的微任务. WHATWG 把执行微任务的时间点称为检查点.

如果在执行微任务的过程中, 产生了新的微任务, 同样会将该微任务添加到微任务队列中, V8 引擎一直循环执行微任务队列中的任务, 直到队列为空才算执行结束. 也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行, 而是在当前的宏任务中继续执行.

![微任务添加](https://edge.yancey.app/beg/hez6dg4s-1650540943549.webp)

![微任务执行](https://edge.yancey.app/beg/pb8nvxor-1650540920071.webp)

所以我们得出几个结论:

- 微任务和宏任务是绑定的, 每个宏任务在执行时, 会创建自己的微任务队列.
- 微任务的执行时长会影响到当前宏任务的时长. 比如一个宏任务在执行过程中, 产生了 100 个微任务, 执行每个微任务的时间是 10 毫秒, 那么执行这 100 个微任务的时间就是 1000 毫秒, 也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒.
- 在一个宏任务中, 分别创建一个用于回调的宏任务和微任务, 无论什么情况下, 微任务都早于宏任务执行.

### 常见的宏任务和微任务

宏任务: script(整体代码), setTimeout, setInterval, I/O, 事件, postMessage, MessageChannel, setImmediate (Node.js)

微任务: Promise.then, MutaionObserver, process.nextTick (Node.js)

### 来做几道题

看看下面这道题你能不能做出来.

```js
setTimeout(() => {
  console.log(""A"");
}, 0);
var obj = {
  func: function () {
    setTimeout(function () {
      console.log(""B"");
    }, 0);
    return new Promise(function (resolve) {
      console.log(""C"");
      resolve();
    });
  },
};
obj.func().then(function () {
  console.log(""D"");
});
console.log(""E"");
```

- 第一个 `setTimeout` 放到宏任务队列, 此时宏任务队列为 ['A']

- 接着执行 obj 的 func 方法, 将 `setTimeout` 放到宏任务队列, 此时宏任务队列为 ['A', 'B']

- 函数返回一个 Promise, 因为这是一个同步操作, 所以先打印出 `'C'`

- 接着将 `then` 放到微任务队列, 此时微任务队列为 ['D']

- 接着执行同步任务 `console.log('E');`, 打印出 `'E'`

- 因为微任务优先执行, 所以先输出 `'D'`

- 最后依次输出 `'A'` 和 `'B'`

再来看一道阮一峰老师出的题目, 其实也不难.

```js
let p = new Promise((resolve) => {
  resolve(1);
  Promise.resolve().then(() => console.log(2));
  console.log(4);
}).then((t) => console.log(t));
console.log(3);
```

- 首先将 `Promise.resolve()` 的 then() 方法放到微任务队列, 此时微任务队列为 ['2']

- 然后打印出同步任务 `4`

- 接着将 `p` 的 then() 方法放到微任务队列, 此时微任务队列为 ['2', '1']

- 打印出同步任务 `3`

- 最后依次打印微任务 `2` 和 `1`

## 当 Event Loop 遇到 async/await

我们知道, async/await 仅仅是生成器的语法糖, 所以不要怕, 只要把它转换成 Promise 的形式即可. 下面这段代码是 async/await 函数的经典形式.

```js
async function foo() {
  // await 前面的代码
  await bar();
  // await 后面的代码
}

async function bar() {
  // do something...
}

foo();
```

其中 `await 前面的代码` 是同步的, 调用此函数时会直接执行; 而 `await bar();` 这句可以被转换成 `Promise.resolve(bar())`; `await 后面的代码` 则会被放到 Promise 的 then() 方法里. 因此上面的代码可以被转换成如下形式, 这样是不是就很清晰了?

```js
function foo() {
  // await 前面的代码
  Promise.resolve(bar()).then(() => {
    // await 后面的代码
  });
}

function bar() {
  // do something...
}

foo();
```

回到开篇宇宙条那道烂大街的题目, 我们""重构""一下代码, 再做解析, 是不是很轻松了?

```js
function async1() {
  console.log(""async1 start""); // 2

  Promise.resolve(async2()).then(() => {
    console.log(""async1 end""); // 6
  });
}

function async2() {
  console.log(""async2""); // 3
}

console.log(""script start""); // 1

setTimeout(function () {
  console.log(""settimeout""); // 8
}, 0);

async1();

new Promise(function (resolve) {
  console.log(""promise1""); // 4
  resolve();
}).then(function () {
  console.log(""promise2""); // 7
});
console.log(""script end""); // 5
```

- 首先打印出 `script start`

- 接着将 `settimeout` 添加到宏任务队列, 此时宏任务队列为 `['settimeout']`

- 然后执行函数 `async1`, 先打印出 `async1 start`, 又因为 `Promise.resolve(async2())` 是同步任务, 所以打印出 `async2`, 接着将 `async1 end` 添加到微任务队列, , 此时微任务队列为 ['async1 end']

- 接着打印出 `promise1`, 将 `promise2` 添加到微任务队列, , 此时微任务队列为 `['async1 end', promise2]`

- 打印出 `script end`

- 因为微任务优先级高于宏任务, 所以先依次打印出 `async1 end` 和 `promise2`

- 最后打印出宏任务 `settimeout`

> 关于这道题的争议: 文章发表了大概有两天的时间, 陆陆续续收到了小伙伴的评论. 大多都是 `async1 end` 和 `promise2` 的顺序问题. 我在 `Chrome 73.0.3683.103 for MAC` 和 `Node.js v8.15.1` 测试是 `async1 end` 先于 `promise2`, 在 `FireFox 66.0.3 for MAC` 测试是 `async1 end` 后于 `promise2`.

## Node.js 的事件循环

浏览器中有事件循环, node 中也有, 事件循环是 node 处理非阻塞 I/O 操作的机制, node 中事件循环的实现是依靠的 libuv 引擎. 由于 node 11 之后, 事件循环的一些原理发生了变化, 这里就以新的标准去讲.

```ts
   ┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
```

### Node.js 中的宏任务和微任务

macro-task 大概包括:

- setTimeout

- setInterval

- setImmediate

- script(整体代码)

- I/O 操作等.

micro-task 大概包括:

- process.nextTick(与普通微任务有区别, 在微任务队列执行之前执行)

- new Promise().then(回调)等.

图中的每个框被称为事件循环机制的一个阶段, 每个阶段都有一个 FIFO 队列来执行回调. 虽然每个阶段都是特殊的, 但通常情况下, 当事件循环进入给定的阶段时, 它将执行特定于该阶段的任何操作, 然后执行该阶段队列中的回调, 直到队列用尽或最大回调数已执行. 当该队列已用尽或达到回调限制, 事件循环将移动到下一阶段.

因此, 从上面这个简化图中, 我们可以分析出 node 的事件循环的阶段顺序为:

输入数据阶段(incoming data)->轮询阶段(poll)->检查阶段(check)->关闭事件回调阶段(close callback)->定时器检测阶段(timers)->I/O 事件回调阶段(I/O callbacks)->闲置阶段(idle, prepare)->轮询阶段...

- 定时器检测阶段(timers): 本阶段执行 timer 的回调, 即 setTimeout, setInterval 里面的回调函数.

- I/O 事件回调阶段(I/O callbacks): 执行延迟到下一个循环迭代的 I/O 回调, 即上一轮循环中未被执行的一些 I/O 回调.

- 闲置阶段(idle, prepare): 仅系统内部使用.

- 轮询阶段(poll): 检索新的 I/O 事件;执行与 I/O 相关的回调(几乎所有情况下, 除了关闭的回调函数, 那些由计时器和 setImmediate() 调度的之外), 其余情况 node 将在适当的时候在此阻塞.

- 检查阶段(check): setImmediate() 回调函数在这里执行

- 关闭事件回调阶段(close callback): 一些关闭的回调函数, 如: socket.on('close', ...).

## 浅谈 Web Workers

需要强调的是, Worker 是浏览器(即宿主环境)的功能, 实际上和 JavaScript 语言本身几乎没有什么关系. 也就是说, JavaScript 当前并没有任何支持多线程执行的功能.

所以, JavaScript 是一门单线程的语言! JavaScript 是一门单线程的语言! JavaScript 是一门单线程的语言!

浏览器可以提供多个 `JavaScript 引擎实例`, 各自运行在自己的线程上, 这样你可以在每个线程上运行不同的程序. 程序中每一个这样的的独立的多线程部分被称为一个 Worker. 这种类型的并行化被称为 `任务并行`, 因为其重点在于把程序划分为多个块来并发运行. 下面是 Worker 的运作流图.

![web worker](https://edge.yancey.app/beg/16a3e8964d3a7ae8.png)

### Web Worker 实例

下面用一个阶乘的例子浅谈 Worker 的用法.

![计算阶乘的实例](https://edge.yancey.app/beg/16a3e8964d2d4242.jpg)

首先新建一个 `index.html` , 直接上代码:

```html
<body>
  <fieldset>
    <legend>计算阶乘</legend>
    <input id=""input"" type=""number"" placeholder=""请输入一个正整数"" />
    <button id=""btn"">计算</button>
    <p>计算结果: <span id=""result""></span></p>
  </fieldset>
  <legend></legend>

  <script>
    const input = document.getElementById(""input"");
    const btn = document.getElementById(""btn"");
    const result = document.getElementById(""result"");

    btn.addEventListener(""click"", () => {
      const worker = new Worker(""./worker.js"");

      // 向 Worker 发送消息
      worker.postMessage(input.value);

      // 接收来自 Worker 的消息
      worker.addEventListener(""message"", (e) => {
        result.innerHTML = e.data;

        // 使用完 Worker 后记得关闭
        worker.terminate();
      });
    });
  </script>
</body>
```

在同目录下新建一个 `work.js`, 内容如下:

```js
function memorize(f) {
  const cache = {};
  return function () {
    const key = Array.prototype.join.call(arguments, "","");
    if (key in cache) {
      return cache[key];
    } else {
      return (cache[key] = f.apply(this, arguments));
    }
  };
}

const factorial = memorize((n) => {
  return n <= 1 ? 1 : n * factorial(n - 1);
});

// 监听主线程发过来的消息
self.addEventListener(
  ""message"",
  function (e) {
    // 响应主线程
    self.postMessage(factorial(e.data));
  },
  false
);
```

## 谈一谈 setTimeout

上面我们说道宏任务会放在消息队列中, 但除此之外, 还有另外一个消息队列, 这个队列中维护了需要延迟执行的任务列表, 包括了定时器和 [Chromium 内部一些需要延迟执行的任务](https://source.chromium.org/chromium/chromium/src/+/main:base/task/sequence_manager/task_queue_impl.h;l=391;bpv=0;bpt=1). 所以当通过 JavaScript 创建一个定时器时, 渲染进程会将该定时器的回调任务添加到延迟队列中, 延迟队列的签名如下:

```c++
DelayedIncomingQueue delayed_incoming_queue;
```

当通过 JavaScript 调用 setTimeout 设置回调函数的时候, 渲染进程将会创建一个回调任务, 包含了回调函数 callBack, 当前发起时间, 延迟执行时间,

```c++
struct DelayTask {
  int64 id;
  CallBackFunction cbf;
  int start_time;
  int delay_time;
};
DelayTask timerTask;
timerTask.cbf = callBack;
timerTask.start_time = getCurrentTime(); //获取当前时间
timerTask.delay_time = 200;//设置延迟执行时间
```

创建好回调任务之后, 再将该任务添加到延迟执行队列中, 代码如下所示:

```c++
delayed_incoming_queue.push(timerTask);
```

我们添加了一个 ProcessDelayTask 函数, 该函数是专门用来处理延迟执行任务的, 它会在 delayed_incoming_queue 中取出已经到期的定时器任务依次执行.

这里我们要重点关注它的执行时机, 在上段代码中, 处理完消息队列中的一个任务之后, 就开始执行 ProcessDelayTask 函数. ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务, 然后依次执行这些到期的任务. 等到期的任务执行完成之后, 再继续下一个循环过程. 通过这样的方式, 一个完整的定时器就实现了.

```c++
void ProcessTimerTask() {
  // 从 delayed_incoming_queue 中取出已经到期的定时器任务
  // 依次执行这些任务
}

TaskQueue task_queue;
void ProcessTask();
bool keep_running = true;
void MainTherad() {
  for(;;){
    //执行消息队列中的任务
    Task task = task_queue.takeTask();
    ProcessTask(task);

    //执行延迟队列中的任务
    ProcessDelayTask()

    if(!keep_running) //如果设置了退出标志, 那么直接退出线程循环
        break;
  }
}
```

`clearTimeout(timer_id)` 的原理也很简单, 就是在 delayed_incoming_queue 把 timer_id 删掉即可.

### 从 V8 看 setTimeout

```ts
function foo() {
  setTimeout(foo, 0);
}
foo();
```

以上面这段代码为例, 我们再从主线程、调用栈、消息队列的角度来聊一聊 setTimeout:

- 首先, 主线程会从消息队列中取出需要执行的宏任务, 假设当前取出的任务就是要执行的这段代码, 这时候主线程便会进入代码的执行状态
- 接下来 V8 就要执行 foo 函数了, 同样执行 foo 函数时, 会创建 foo 函数的执行上下文, 并将其压入栈中
- 当 V8 执行执行 foo 函数中的 setTimeout 时, setTimeout 会将 foo 函数封装成一个新的宏任务, 并将其添加到消息队列中
- 等 foo 函数执行结束, V8 就会结束当前的宏任务, 调用栈也会被清空
- 当一个宏任务执行结束之后, 忙碌的主线程依然不会闲下来, 它会一直重复这个取宏任务、执行宏任务的过程. 刚才通过 setTimeout 封装的回调宏任务, 也会在某一时刻被主线取出并执行, 这个执行过程, 就是 foo 函数的调用过程

![setTimeout](https://edge.yancey.app/beg/t492fq9h-1653392963471.jpeg)

```ts
function bar() {
  bar();
}

bar();
```

我们再看上面这段代码, 他肯定会栈溢出, 但 setTimeout 那段就不会, 因为 foo 函数并不是在当前的父函数内部被执行的, 而是封装成了宏任务, 并丢进了消息队列中, 然后等待主线程从消息队列中取出该任务, 再执行该回调函数 foo, 这样就解决了栈溢出的问题.

### 使用 setTimeout 的一些注意事项

**如果当前任务执行时间过久, 会影响定时器任务的执行**. 这个很好理解, 要执行消息队列中的下个任务, 需要等待当前的任务执行完成, 所以当前任务很重的话, 势必会影响到下个任务的执行.

**如果 setTimeout 存在嵌套调用, 那么系统会设置最短时间间隔为 4 毫秒**, 下图中的竖线就是定时器的函数回调过程, 从图中可以看出, 前面五次调用的时间间隔比较小, 嵌套调用超过五次以上, 后面每次的调用最小时间间隔是 4 毫秒. 之所以出现这样的情况, 是因为在 Chrome 中, 定时器被嵌套调用 5 次以上, 系统会判断该函数方法被阻塞了, 如果定时器的调用时间间隔小于 4 毫秒, 那么浏览器会将每次调用的时间间隔设置为 4 毫秒.

![最短时间间隔为 4 毫秒](https://edge.yancey.app/beg/6j7l3o5c-1650464022544.webp)

```c++
static const int kMaxTimerNestingLevel = 5;

// Chromium uses a minimum timer interval of 4ms. We'd like to go
// lower; however, there are poorly coded websites out there which do
// create CPU-spinning loops.  Using 4ms prevents the CPU from
// spinning too busily and provides a balance between CPU spinning and
// the smallest possible interval timer.
static constexpr base::TimeDelta kMinimumInterval = base::TimeDelta::FromMilliseconds(4);


base::TimeDelta interval_milliseconds =
      std::max(base::TimeDelta::FromMilliseconds(1), interval);

  if (interval_milliseconds < kMinimumInterval &&
      nesting_level_ >= kMaxTimerNestingLevel)
    interval_milliseconds = kMinimumInterval;

  if (single_shot)
    StartOneShot(interval_milliseconds, FROM_HERE);
  else
    StartRepeating(interval_milliseconds, FROM_HERE);
```

**激活的页面, setTimeout 执行最小间隔是 1000 毫秒**, 如果标签不是当前的激活标签, 那么定时器最小的时间间隔是 1000 毫秒, 目的是为了优化后台页面的加载损耗以及降低耗电量.

**延时执行时间有最大值**, 除了要了解定时器的回调函数时间比实际设定值要延后之外, 还有一点需要注意下, 那就是 Chrome, Safari, Firefox 都是以 32 个 bit 来存储延时值的, 32bit 最大只能存放的数字是 2147483647 毫秒, 这就意味着, 如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出, 那么相当于延时值被设置为 0 了, 这导致定时器会被立即执行.

**小心 setTimeout 设置的回调函数中的 this**, 如下代码中 showName 的 this 指向的是 window, 为了解决这个问题, 你可以 bind 一下.

```ts
var name = 1;
var MyObj = {
  name: 2,
  showName: function () {
    console.log(this.name);
  },
};
setTimeout(MyObj.showName, 1000);
```

## 谈一谈 XMLHttpRequest

首先谈一谈同步回调和异步回调. 将一个函数作为参数传递给另外一个函数, 那作为参数的这个函数就是回调函数, 回调函数可以是同步或者异步的. 回调函数 callback 是在主函数返回之前执行的, 我们把这个回调过程称为同步回调. 回调函数 callback 并没有在主函数内部被调用, 我们把这种回调函数在主函数外部执行的过程称为异步回调.

```ts
// 同步回调
let callback = function () {
  console.log(""i am do homework"");
};
function doWork(cb) {
  console.log(""start do work"");
  cb();
  console.log(""end do work"");
}
doWork(callback);
```

```ts
// 异步回调
let callback = function () {
  console.log(""i am do homework"");
};
function doWork(cb) {
  console.log(""start do work"");
  setTimeout(cb, 1000);
  console.log(""end do work"");
}
doWork(callback);
```

我们知道消息队列和主线程循环机制保证了页面有条不紊地运行. 这里还需要补充一点, 那就是当循环系统在执行一个任务的时候, 都要为这个任务维护一个系统调用栈. 这个系统调用栈类似于 JavaScript 的调用栈, 只不过系统调用栈是 Chromium 的开发语言 C++ 来维护的.

![消息循环系统调用栈记录](https://edge.yancey.app/beg/3ftb0md5-1650528631114.webp)

这幅图记录了一个 Parse HTML 的任务执行过程, 其中黄色的条目表示执行 JavaScript 的过程, 其他颜色的条目表示浏览器内部系统的执行过程.

通过该图你可以看出来, Parse HTML 任务在执行过程中会遇到一系列的子过程, 比如在解析页面的过程中遇到了 JavaScript 脚本, 那么就暂停解析过程去执行该脚本, 等执行完成之后, 再恢复解析过程. 然后又遇到了样式表, 这时候又开始解析样式表... 直到整个任务执行完成.

需要说明的是, 整个 Parse HTML 是一个完整的任务, 在执行过程中的脚本解析, 样式表解析都是该任务的子过程, 其下拉的长条就是执行过程中调用栈的信息.

每个任务在执行过程中都有自己的调用栈, 那么同步回调就是在当前主函数的上下文中执行回调函数, 这个没有太多可讲的. 下面我们主要来看看异步回调过程, 异步回调是指回调函数在主函数之外执行, 一般有两种方式:

- 第一种是把异步函数做成一个任务, 添加到信息队列尾部;
- 第二种是把异步函数添加到微任务队列中, 这样就可以在当前任务的末尾处执行微任务了.

### XMLHttpRequest 运作机制

![XMLHttpRequest 运作机制](https://edge.yancey.app/beg/93zmowbx-1650530029418.webp)

这里仅仅说下 xhr.send 发生的事情. 对照上面那张请求流程图, 可以看到: 渲染进程会将请求发送给网络进程, 然后网络进程负责资源的下载, 等网络进程接收到数据之后, 就会利用 IPC 来通知渲染进程; 渲染进程接收到消息之后, 会将 xhr 的回调函数封装成任务并添加到消息队列中, 等主线程循环系统执行到该任务的时候, 就会根据相关的状态来调用对应的回调函数.

### MutationObserver

MutationObserver API 可以用来监视 DOM 的变化, 包括属性的变化, 节点的增减, 内容的变化等.

它将响应函数改成异步调用, 可以不用在每次 DOM 变化都触发异步调用, 而是等多次 DOM 变化后, 一次触发异步调用, 并且还会使用一个数据结构来记录这期间所有的 DOM 变化. 这样即使频繁地操纵 DOM, 也不会对性能造成太大的影响.

和上面说到的一样, MutationObserver 通过微任务解决了实时性的问题.

## 以三道题收尾

下面的三道题来自 [@小美娜娜](https://juejin.im/user/5aa23691518825556d0db27e) 的文章 [Eventloop 不可怕, 可怕的是遇上 Promise](https://juejin.im/post/5c9a43175188252d876e5903). 抄一下不会打我吧, 嗯.

### 第一道题

```js
const p1 = new Promise((resolve, reject) => {
  console.log(""promise1"");
  resolve();
})
  .then(() => {
    console.log(""then11"");
    new Promise((resolve, reject) => {
      console.log(""promise2"");
      resolve();
    })
      .then(() => {
        console.log(""then21"");
      })
      .then(() => {
        console.log(""then23"");
      });
  })
  .then(() => {
    console.log(""then12"");
  });

const p2 = new Promise((resolve, reject) => {
  console.log(""promise3"");
  resolve();
}).then(() => {
  console.log(""then31"");
});
```

- 首先打印出 `promise1`

- 接着将 `then11`, `promise2` 添加到微任务队列, 此时微任务队列为 `['then11', 'promise2']`

- 打印出 `promise3`, 将 `then31` 添加到微任务队列, 此时微任务队列为 `['then11', 'promise2', 'then31']`

- 依次打印出 `then11`, `promise2`, `then31`, 此时微任务队列为空

- 将 `then21` 和 `then12` 添加到微任务队列, 此时微任务队列为 `['then21', 'then12']`

- 依次打印出 `then21`, `then12`, 此时微任务队列为空

- 将 `then23` 添加到微任务队列, 此时微任务队列为 `['then23']`

- 打印出 `then23`

### 第二道题

这道题实际在考察 Promise 的用法, 当在 then() 方法中返回一个 Promise, p1 的第二个完成处理函数就会挂在返回的这个 Promise 的 then() 方法下, 因此输出顺序如下.

```js
const p1 = new Promise((resolve, reject) => {
  console.log(""promise1""); // 1
  resolve();
})
  .then(() => {
    console.log(""then11""); // 2
    return new Promise((resolve, reject) => {
      console.log(""promise2""); // 3
      resolve();
    })
      .then(() => {
        console.log(""then21""); // 4
      })
      .then(() => {
        console.log(""then23""); // 5
      });
  })
  .then(() => {
    console.log(""then12""); //6
  });
```

### 第三道题

依次为 ['sync1', 'promise', 'sync2', 'pro_then', 'setTimeout1', 'setTimeoutPromise', 'last_setTimeout', 'pro_timeout'], 注意 last_setTimeout 和 pro_timeout 的位置.

```ts
console.log(""sync1"");

setTimeout(function () {
  console.log(""setTimeout1"");
}, 0);

var promise = new Promise(function (resolve, reject) {
  setTimeout(function () {
    console.log(""setTimeoutPromise"");
  }, 0);
  console.log(""promise"");
  resolve();
});

promise.then(() => {
  console.log(""pro_then"");
  setTimeout(() => {
    console.log(""pro_timeout"");
  }, 0);
});

setTimeout(function () {
  console.log(""last_setTimeout"");
}, 0);
console.log(""sync2"");
```

## 最后

欢迎关注我的微信公众号: 进击的前端

![进击的前端](https://edge.yancey.app/beg/16a3e8964d43486c.jpg)

## 参考

《你不知道的 JavaScript (中卷)》—— Kyle Simpson

[这一次, 彻底弄懂 JavaScript 执行机制](https://juejin.im/post/59e85eebf265da430d571f89)

[从一道题浅说 JavaScript 的事件循环](https://github.com/dwqs/blog/issues/61)

[微任务, 宏任务与 Event-Loop](https://juejin.im/post/5b73d7a6518825610072b42b)

[前端基础进阶: 详细图解 JavaScript 内存空间](https://juejin.im/entry/589c29a9b123db16a3c18adf)

[详解 JavaScript 中的 Event Loop(事件循环)机制](https://zhuanlan.zhihu.com/p/33058983)

[Eventloop 不可怕, 可怕的是遇上 Promise](https://juejin.im/post/5c9a43175188252d876e5903)

[图解搞懂 JavaScript 引擎 Event Loop](https://juejin.im/post/5a6309f76fb9a01cab2858b1)

[JavaScript 线程机制与事件机制](https://juejin.im/post/5bb05494e51d450e7428da59)
","2025-02-02 03:08:39.060329","2025-02-02 03:08:39.060329"
"39e3c2ee-1858-432c-a7f1-80fd98d80c65","{大事记}",0,0,False,"https://edge.yancey.app/beg/02542344136f8c6cefd9138785bf6f40.jpg","Yancey Blog 大事记","从 Blog 初代上线, 到现在已然是第三代了. Blog 项目陪伴了我大学最后的时光和职业生涯的前两年, 这篇文章记录了 Blog 项目一代一代的发展历程...","## 诞生

Blog 第一个版本是在 18 年 2 月份上线的. 至于当时为什么要做个博客网站, 一是为了应付毕设, 二是给自己大学生涯做个交代. 当时会写点儿 Python, 后端就选了 Django 和 MySQL; 那个年代 BootStrap 和 jQuery 还活着, 前端就选了这俩.

项目大约从年初动工, 开发的那段时光早已模糊不清了, 只记得当时图书馆只剩下我一个人, 暖气也停了, 用的是一台白色的 VAIO, 偶尔中午去喂喂猫...... 毕业后的两年似乎被什么追逐着, 有时连回忆都是奢侈的. 大约折腾了一个来月, 项目也终于上线了, 后来的答辩也很顺利, 那篇论文《基于 Bootstrap + Django 响应式博客网站的设计与实现》还获得了优秀毕设, 有趣.

后来毕业了, 搬家和职场转换交织在一起, 论文的备份也弄丢了, 那时还没有使用 GitHub 的习惯, 项目最终也丢了, 下面这两张图, 还是翻推特找到的.

![封面图](https://edge.yancey.app/beg/DtA6rMEU4AAtFBG.jpeg)

![blog summary 页](https://edge.yancey.app/beg/DtA6tTiU8AAKhY2.jpeg)

```ts
I could not look back, you'd gone away from me

I felt my heartaches, I was afraid of following you

When I was looking the shadows on the wall

I started running into the night to find the truth in me
```

## 前后端分离

第一版上线后不久就找了家公司实习, 期间偶尔看到了 [樱花庄的白猫 | ねこ・しろ・ましろ](http://2heng.xin/) 这个网站做得很 cool, 就萌生了想要模(chao)仿(xi)的念头.

后来毕业工作了, 在公司有幸独立完成了一个比较有规模的后台系统(Vue.js) —— 一个刚毕业的菜鸟有幸去做这种项目, 还是很感谢当时 leader 的信任. 待这个项目结束后有一小段空闲期, 我意识到新版的 Blog 也该到了“折腾”的时候了.

项目分为三部分: [前台](https://github.com/Yancey-Blog/BLOG_FE)用的是 React + mobx, [后台管理系统](https://github.com/Yancey-Blog/BLOG_CMS)是 React + mobx + Antd, [后端](https://github.com/Yancey-Blog/BLOG_BE)是 express + MongoDB 写 RESTful 接口. 我业余做些 MIDI 音乐, 所以单独开辟了一个音乐板块.

项目于 18 年 10 月 14 日正式上线, 之后前台又做了几次迭代优化:

- 2018-12-30 code splitting, 代码优化

- 2019-01-13 使用 TypeScript 重构

- 2019-04-03 升级到了 CRA3, 给所有的动态加载增加了 Skeleton

直到 GraphQL 项目上线, 这一期收获了 6000 多 pv.

### FE

![首页](https://edge.yancey.app/beg/68747470733a2f2f79616e6365792d6173736574732e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6965747532303139303531332d31323038353425343032782e6a7067.jpeg)

![blog summary 页](https://edge.yancey.app/beg/68747470733a2f2f79616e6365792d6173736574732e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6965747532303138313031372d3138313433384032782e6a70673f782d6f73732d70726f636573733d696d6167652f7175616c6974792c515f3630.jpeg)

![blog archive 页](https://edge.yancey.app/beg/68747470733a2f2f79616e6365792d6173736574732e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6965747532303138313031372d3138333533304032782e6a70673f782d6f73732d70726f636573733d696d6167652f7175616c6974792c515f3630.jpeg)

![music 页](https://edge.yancey.app/beg/68747470733a2f2f79616e6365792d6173736574732e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6965747532303138313031372d3138343133304032782e6a70673f782d6f73732d70726f636573733d696d6167652f7175616c6974792c515f3130.jpeg)

### CMS

![登录](https://edge.yancey.app/beg/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31302f32302f313636393231323536633938353438303f773d36343026683d34303026663d67696626733d31393039333537.gif)

![blog list 页](https://edge.yancey.app/beg/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31302f31382f313636383564393136303961313630343f773d3338343026683d3234303026663d6a70656726733d313933333436.jpeg)

![blog detail 页](https://edge.yancey.app/beg/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31302f31382f313636383564393136363033343731633f773d3338343026683d3234303026663d6a70656726733d323237383238.jpeg)

## GraphQL 时代

后来各种原因换了公司, 前后端分离版本也平稳运行了一年多了. 看到 Twiiter, FaceBook, 甚至 GitHub 都使用了 GraphQL, 我意识到 GraphQL 的时代终将到来. 新的东西在公司内部总是难以推广, 尤其在小公司而且当你不是 leader 的时候. 加之前后端分离版本的 Blog 积累了一些技术/业务债务, 遂决定将 Blog 进行一次升级. 项目大约是从 19 年 9 月零零散散开始动工, 到 20 年 5 月 2 日正式上线运行. 项目仍然分为三部分.

### 前台

[前台](https://github.com/Yancey-Blog/blog-fe-v2)用的是 Next.js + Apollo client + GraphQL + styled-component. 这次使用了服务端渲染, 我心心念念的推特大图分享终于回来了; 尝试了 css-in-js, 使用 styled-component 轻松实现了 light/dark 主题的切换 (虽然原生 css 的 var 也是不错的选择). 整体样式没有太多的变化, 但生产环境明显比上个版本顺滑多了.

![暗黑色 blog summary 页](https://edge.yancey.app/beg/Jietu20200505-042858.jpg)

![暗黑色 blog detail 页](https://edge.yancey.app/beg/Jietu20200505-042926.jpg)

最后跑个分吧, 除了 a11y 其他都还不错!

![lighthouse](https://edge.yancey.app/beg/Jietu20200514-122909.jpg)

### 后台管理系统

[后台管理系统](https://github.com/Yancey-Blog/blog-cms-v2) 用了 React + Apollo client + GraphQL + Material UI.

![Material 风格的 Dashbord](https://edge.yancey.app/beg/Jietu20200505-043334.jpg)

为灵活控制展示顺序, 通过权重的方式为一些模块增加了上移/下移/置顶的功能.

![支持上移/下移/置顶](https://edge.yancey.app/beg/Jietu20200505-043729.jpg)

增加了 blog statistics 的功能, 相当于对每篇文章创建/修改/发布 or 草稿等操作做了埋点.

![blog statistics](https://edge.yancey.app/beg/Jietu20200505-044146.jpg)

增加了 Agenda 模块, 可以做些简单的日程管理.

![Agenda 模块](https://edge.yancey.app/beg/Jietu20200505-044045.jpg)

Profile 模块: 可修改 name (不是 UserName), 地区, 组织, 网站, Bio, 头像, 修改后会和左边 Drawer 实时同步.

![修改基本信息](https://edge.yancey.app/beg/Jietu20200505-044712.jpg)

Account 模块: 支持修改用户名/密码/删除账号

![Account](https://edge.yancey.app/beg/Jietu20200505-044725.jpg)

Security 模块做的较多, 支持修改密码, 二步验证, 绑定手机号, 还可以申请 Recovery Codes 等.

![修改密码](https://edge.yancey.app/beg/Jietu20200505-045200.jpg)

![二步验证 - 选择手机系统](https://edge.yancey.app/beg/Jietu20200505-045213.jpg)

![二步验证 - 扫码](https://edge.yancey.app/beg/Jietu20200505-045226.jpg)

![二步验证 - 手动录入](https://edge.yancey.app/beg/Jietu20200505-045520.jpg)

![二步验证 - code 验证](https://edge.yancey.app/beg/Jietu20200505-045231.jpg)

![绑定手机号](https://edge.yancey.app/beg/Jietu20200505-045242.jpg)

![Recovery Codes](https://edge.yancey.app/beg/Jietu20200505-045251.jpg)

### 后端

[后端](https://github.com/Yancey-Blog/blog-be-next)用了 Nestjs + MongoDB + Apollo server + GraphQL, Nestjs 使用了 AOP 的思想, 虽然代码量繁琐了, 但可维护性指数型提高! 并且 Nestjs 的文档一级棒, 绝对值得学习一下. (我成功安利了我们部门后端团队将他们的项目全面迁移到 Nestjs, 但 GraphQL 似乎是没戏了)

### 运维

项目运行在一台 Debian 系统的 vps 上, 服务器在米国, 有时比较慢; fe 和 be 使用 pm2 守护进程, 其中 be 开启了集群模式; 三个项目都用 Travis CI 做了 CI 和 CD, master 只要一 push, 代码更新分分钟的事儿, 妈妈再也不用担心我手动上线了; 用 Caddy 做反向代理(没用 nginx 主要是懒得手动申请 https 证书).

## Monorepo & Keycloack 时代

21 年 11 月开始使用 rushjs, 将所有项目收敛到 monorepo, 即 [beg-monorepo](https://github.com/Yancey-Blog/beg-monorepo). 并且 CI/CD 从 travis 迁移到 GitHub Actions, 并且打通了 Slark 机器人.

此外, 放弃了手写 auth & role 管理, 采用 Keycloack 做全局的 SSO.

![image.png](https://edge.yancey.app/beg/urc1gb5f-1698218271650.png)



## 未来

未来可能做的? 比如后端用 rust 重写, 前端样式换成 tailwindcss? 一切都将一去杳然, 任何人都无法将其捕获, 我们便是这样活着.



","2025-02-02 03:08:41.369864","2025-02-02 03:08:41.369864"
"1f9cc791-bbdf-4cc8-a932-f41bb7b0282f","{Vite}",0,0,False,"https://edge.yancey.app/beg/i63v2qle-1698217561350.jpg","Vite 源码解析(4) - 开发服务篇","我们在解析完配置, 创建了插件容器之后, 要想运行一个开发环境, 并且持续的给客户端发送热更新 module, 开发服务是必不可少的, 本篇我们来讲一讲 vite 的开发 server 环境, 中间件机制, 以及如何监听文件的改动, 并通过 ws 发送给客户端的. 值得注意的是, 早期 vite 用的 koa 一把梭, 到了后面开始自己卷了个开发服务, 整体大同小异, 下面我们来逐一分析下.","## resolveHttpsConfig
```ts
// https 配置, 主要是证书
const httpsOptions = await resolveHttpsConfig(
  config.server.https,
  config.cacheDir
);
let { middlewareMode } = serverConfig;
if (middlewareMode === true) {
  middlewareMode = ""ssr"";
}
```
首先 vite 的开发环境是支持 https 的, 虽然绝大多数我们是用 localhost 的, 不过有些场景, 比如你依赖的三方服务, 必须使用 https, 否则没法调试, 那你就得支持 https 了.
该函数接收两个参数, 第一个 `ServerOptions` 是 node 标准库 https 的配置, 签名如下; 第二个是缓存文件的目录.
```ts
type ServerOptions = tls.SecureContextOptions &
  tls.TlsOptions &
  http.ServerOptions;
```
整个函数简单来讲就是你在配置里传了证书没, 没传就去缓存文件里找, 最后返回配置.
```ts
export async function resolveHttpsConfig(
  https: boolean | HttpsServerOptions | undefined,
  cacheDir: string
): Promise<HttpsServerOptions | undefined> {
  if (!https) return undefined;
  const httpsOption = isObject(https) ? { ...https } : {};
  const { ca, cert, key, pfx } = httpsOption;
  Object.assign(httpsOption, {
    ca: readFileIfExists(ca),
    cert: readFileIfExists(cert),
    key: readFileIfExists(key),
    pfx: readFileIfExists(pfx),
  });
  if (!httpsOption.key || !httpsOption.cert) {
    httpsOption.cert = httpsOption.key = await getCertificate(cacheDir);
  }
  return httpsOption;
}
```
`getCertificate` 就是用来获取缓存路径中的证书的, 如果没有, 就会调用 [`createCertificate`](https://github.com/jfromaniello/selfsigned/blob/da38146f8d02183c35f49f91659a744a243e8707/index.js) 生成一个新的自签名证书, 这个不多说了, 毕竟不咋会, 匿了匿了. 总之 vite 就是一条龙服务, 你有就用你的, 顺带帮你验证下证书过没过期, 如果你没提供证书, 还帮你搞个自签名, 老铁们给尤雨溪双击 666.
```ts
async function getCertificate(cacheDir: string) {
  const cachePath = path.join(cacheDir, ""_cert.pem"");
  try {
    const [stat, content] = await Promise.all([
      fsp.stat(cachePath),
      fsp.readFile(cachePath, ""utf8""),
    ]);
    if (Date.now() - stat.ctime.valueOf() > 30 * 24 * 60 * 60 * 1000) {
      throw new Error(""cache is outdated."");
    }
    return content;
  } catch {
    const content = (await import(""./certificate"")).createCertificate();
    fsp
      .mkdir(cacheDir, { recursive: true })
      .then(() => fsp.writeFile(cachePath, content))
      .catch(() => {});
    return content;
  }
}
```
## resolveHttpServer
```ts
// 一个三方库,用于把中间件和 server 关联起来, 最基本的支持 req, res, next, use, handle 等等
const middlewares = connect() as Connect.Server;
const httpServer = middlewareMode
  ? null
  : await resolveHttpServer(serverConfig, middlewares, httpsOptions);
```
下面是创建 http server, 如果是 http, 就直接用 `node:http` 的 `createServer`; 否则就是 https, 那么优先用 `node:http2`, 因为我们知道 http2 强制使用 https 的; 当然如果是代理, 就得用 `node:https`. 看了一下 [issue](https://github.com/vitejs/vite/issues/484) 是这样解释的:
> http-proxy (The underlying module which vite uses for proxy) does not support http2. You cannot use https with proxy as vite is now using Http2.
```ts
export async function resolveHttpServer(
  { proxy }: CommonServerOptions,
  app: Connect.Server,
  httpsOptions?: HttpsServerOptions
): Promise<HttpServer> {
  if (!httpsOptions) {
    const { createServer } = await import(""http"");
    return createServer(app);
  }
  // #484 fallback to http1 when proxy is needed.
  if (proxy) {
    const { createServer } = await import(""https"");
    return createServer(httpsOptions, app);
  } else {
    const { createSecureServer } = await import(""http2"");
    return createSecureServer(
      {
        // Manually increase the session memory to prevent 502 ENHANCE_YOUR_CALM
        // errors on large numbers of requests
        maxSessionMemory: 1000,
        ...httpsOptions,
        allowHTTP1: true,
      },
      // @ts-expect-error TODO: is this correct?
      app
    ) as unknown as HttpServer;
  }
}
```
## createWebSocketServer
```ts
const ws = createWebSocketServer(httpServer, config, httpsOptions);
```
当我们改动源码时, chokidar 会监听到文件变化, 然后交给 rollup 去做编译, 当编译完成后就要通知到前端进行热更新, 那么我们就需要一个 websocket 的服务, vite 使用了 [ws](https://github.com/websockets/ws) 这个库, 而 `createWebSocketServer` 基本就是 ws 的封装.
当然要补充一个小知识, 就是 ws 的开启需要用 http 做为引导, http 返回 101 状态码后方可升级成 ws.
```ts
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
```
整个函数因为不复杂, 我们直接在源码上写注释.
```ts
export function createWebSocketServer(
  server: Server | null,
  config: ResolvedConfig,
  httpsOptions?: HttpsServerOptions
): WebSocketServer {
  let wss: WebSocketServerRaw;
  let httpsServer: Server | undefined = undefined;
  const hmr = isObject(config.server.hmr) && config.server.hmr;
  // 用户可以自行提供一个 server, 不过一般不会这么玩
  const hmrServer = hmr && hmr.server;
  const hmrPort = hmr && hmr.port;
  // TODO: the main server port may not have been chosen yet as it may use the next available
  const portsAreCompatible = !hmrPort || hmrPort === config.server.port;
  const wsServer = hmrServer || (portsAreCompatible && server);
  // 监听器, key 是事件名, value 是 WebSocketCustomListener 格式的集合
  const customListeners = new Map<string, Set<WebSocketCustomListener<any>>>();
  const clientsMap = new WeakMap<WebSocketRaw, WebSocketClient>();
  if (wsServer) {
    wss = new WebSocketServerRaw({ noServer: true });
    // 如果用户自行提供了 http server, 那么监听到 101 状态码, 就升级成 ws
    wsServer.on(""upgrade"", (req, socket, head) => {
      // 如果 sec-websocket-protocol 为 vite-hmr, 也就是 vite 的热更新协议, 那么就接受
      // 这块代码写的很严谨, 为了防止恰好命中了其他 http 过来的 101
      if (req.headers[""sec-websocket-protocol""] === HMR_HEADER) {
        // 升级完协议后就正式连接到 ws 了
        wss.handleUpgrade(req, socket as Socket, head, (ws) => {
          wss.emit(""connection"", ws, req);
        });
      }
    });
  } else {
    const websocketServerOptions: ServerOptions = {};
    const port = hmrPort || 24678;
    const host = (hmr && hmr.host) || undefined;
    if (httpsOptions) {
      // if we're serving the middlewares over https, the ws library doesn't support automatically creating an https server, so we need to do it ourselves
      // create an inline https server and mount the websocket server to it
      // 因为 ws 没提供 https 的 server, 需要自己起一个
      httpsServer = createHttpsServer(httpsOptions, (req, res) => {
        // 426 Upgrade Required 表示服务器拒绝处理客户端使用当前协议发送的请求, 但是可以接受其使用升级后的协议发送的请求
        // 不过 STATUS_CODES[statusCode] 这个操作没搞懂, 肯定不是 undefiend 啊? 我给提 pr 那哥们留了个 comment, 先留个 TODO:
        const statusCode = 426;
        const body = STATUS_CODES[statusCode];
        if (!body)
          throw new Error(
            `No body text found for the ${statusCode} status code`
          );
        res.writeHead(statusCode, {
          ""Content-Length"": body.length,
          ""Content-Type"": ""text/plain"",
        });
        res.end(body);
      });
      httpsServer.listen(port, host);
      websocketServerOptions.server = httpsServer;
    } else {
      // we don't need to serve over https, just let ws handle its own server
      websocketServerOptions.port = port;
      if (host) {
        websocketServerOptions.host = host;
      }
    }
    // vite dev server in middleware mode
    // 最终我们跑起了一个 WebSocket 的服务, 默认端口是 24678
    wss = new WebSocketServerRaw(websocketServerOptions);
  }
  // 接下来就是对 ws 的封装了
  wss.on(""connection"", (socket) => {
    // message 事件是 ws 接收到数据后触发的事件
    socket.on(""message"", (raw) => {
      // 如果没有事件监听器, 收到消息也处理不了, 直接 return
      if (!customListeners.size) return;
      // 拿到解析后的数据, 校验合法性
      // parsed 就是当源码改了, chokidar 通过 rollup 改完之后, 发送给 ws 的数据
      let parsed: any;
      try {
        parsed = JSON.parse(String(raw));
      } catch {}
      if (!parsed || parsed.type !== ""custom"" || !parsed.event) return;
      // 根据 event 名去事件监听器集合中查找相应的监听器集合
      const listeners = customListeners.get(parsed.event);
      // 如果监听器集合没有, 直接 return
      if (!listeners?.size) return;
      // getSocketClient 这个函数下面有解释, 就是给 client 封装一层, 保证发送数据的一致性
      const client = getSocketClient(socket);
      // 遍历监听器集合, 逐一执行
      listeners.forEach((listener) => listener(parsed.data, client));
    });
    socket.send(JSON.stringify({ type: ""connected"" }));
    // 如果编译出错了啥的, 也把错误暴露给前端
    if (bufferedError) {
      socket.send(JSON.stringify(bufferedError));
      bufferedError = null;
    }
  });
  // 监听失败事件
  wss.on(""error"", (e: Error & { code: string }) => {
    if (e.code === ""EADDRINUSE"") {
      config.logger.error(
        colors.red(`WebSocket server error: Port is already in use`),
        { error: e }
      );
    } else {
      config.logger.error(
        colors.red(`WebSocket server error:\n${e.stack || e.message}`),
        { error: e }
      );
    }
  });
  // Provide a wrapper to the ws client so we can send messages in JSON format
  // To be consistent with server.ws.send
  // 对 ws 客户端进行封装, 保证发送一致性的 json 格式的数据
  // 也就是说, 对于每个新进来的 ws 实例, 都对它的 send 方法(发送给客户端的 payload)进行了封装, 使其发送的数据格式一致
  function getSocketClient(socket: WebSocketRaw) {
    if (!clientsMap.has(socket)) {
      clientsMap.set(socket, {
        send: (...args) => {
          let payload: HMRPayload;
          if (typeof args[0] === ""string"") {
            payload = {
              type: ""custom"",
              event: args[0],
              data: args[1],
            };
          } else {
            payload = args[0];
          }
          socket.send(JSON.stringify(payload));
        },
        socket,
      });
    }
    return clientsMap.get(socket)!;
  }
  // On page reloads, if a file fails to compile and returns 500, the server
  // sends the error payload before the client connection is established.
  // If we have no open clients, buffer the error and send it to the next
  // connected client.
  let bufferedError: ErrorPayload | null = null;
  // 下面大家就太熟悉了, 一个典型 EventEmitter
  // 尤雨溪确实好这口, vue 源码里我记得也有个类似的东西, 我们就不多说了
  return {
    on: ((event: string, fn: () => void) => {
      if (wsServerEvents.includes(event)) wss.on(event, fn);
      else {
        if (!customListeners.has(event)) {
          customListeners.set(event, new Set());
        }
        customListeners.get(event)!.add(fn);
      }
    }) as WebSocketServer[""on""],
    off: ((event: string, fn: () => void) => {
      if (wsServerEvents.includes(event)) {
        wss.off(event, fn);
      } else {
        customListeners.get(event)?.delete(fn);
      }
    }) as WebSocketServer[""off""],
    get clients() {
      return new Set(Array.from(wss.clients).map(getSocketClient));
    },
    send(...args: any[]) {
      let payload: HMRPayload;
      if (typeof args[0] === ""string"") {
        payload = {
          type: ""custom"",
          event: args[0],
          data: args[1],
        };
      } else {
        payload = args[0];
      }
      if (payload.type === ""error"" && !wss.clients.size) {
        bufferedError = payload;
        return;
      }
      const stringified = JSON.stringify(payload);
      wss.clients.forEach((client) => {
        // readyState 1 means the connection is open
        if (client.readyState === 1) {
          client.send(stringified);
        }
      });
    },
    close() {
      return new Promise((resolve, reject) => {
        wss.clients.forEach((client) => {
          client.terminate();
        });
        wss.close((err) => {
          if (err) {
            reject(err);
          } else {
            if (httpsServer) {
              httpsServer.close((err) => {
                if (err) {
                  reject(err);
                } else {
                  resolve();
                }
              });
            } else {
              resolve();
            }
          }
        });
      });
    },
  };
}
```
## chokidar
在 server 搭建好后, 就需要使用 chokidar 监听文件变化, 来触发 hmr.
```ts
const { ignored = [], ...watchOptions } = serverConfig.watch || {};
// chokidar 实例
const watcher = chokidar.watch(path.resolve(root), {
  ignored: [
    ""**/node_modules/**"",
    ""**/.git/**"",
    ...(Array.isArray(ignored) ? ignored : [ignored]),
  ],
  ignoreInitial: true,
  ignorePermissionErrors: true,
  disableGlobbing: true,
  ...watchOptions,
}) as FSWatcher;
// 监听文件变化
watcher.on(""change"", async (file) => {
  file = normalizePath(file);
  // 如果是 package.json 的变化, 需要更新 packageCache 的数据
  if (file.endsWith(""/package.json"")) {
    return invalidatePackageData(packageCache, file);
  }
  // invalidate module graph cache on file change
  // 当有源码文件变化, 重塑模块依赖图
  moduleGraph.onFileChange(file);
  if (serverConfig.hmr !== false) {
    try {
      // 并进行 hmr, 这个我们下一章主讲
      await handleHMRUpdate(file, server);
    } catch (err) {
      ws.send({
        type: ""error"",
        err: prepareError(err),
      });
    }
  }
});
```
## server 实例
至此我们就跑起来一个服务, 下面是它最终的实例, 这里面的大部分方法都跟 hmr 有关, 我们只是简单贴一下, 下一章重点来讲 hmr. 至于 ssr, 由于官方还不稳定, 等稳定了后面再填坑.
```ts
const server: ViteDevServer = {
  config, // 配置
  middlewares, // 中间件
  httpServer, // http 服务
  watcher, // chokidar
  pluginContainer: container, // 插件容器
  ws, // ws 模块
  moduleGraph, // 模块依赖图
  ssrTransform(code: string, inMap: SourceMap | null, url: string) {
    return ssrTransform(code, inMap, url, {
      json: { stringify: server.config.json?.stringify },
    });
  },
  transformRequest(url, options) {
    // 当有 bundle 发生变化时, 转换成请求
    return transformRequest(url, server, options);
  },
  transformIndexHtml: null!, // to be immediately set
  async ssrLoadModule(url, opts?: { fixStacktrace?: boolean }) {
    await updateCjsSsrExternals(server);
    return ssrLoadModule(
      url,
      server,
      undefined,
      undefined,
      opts?.fixStacktrace
    );
  },
  ssrFixStacktrace(e) {
    if (e.stack) {
      const stacktrace = ssrRewriteStacktrace(e.stack, moduleGraph);
      rebindErrorStacktrace(e, stacktrace);
    }
  },
  ssrRewriteStacktrace(stack: string) {
    return ssrRewriteStacktrace(stack, moduleGraph);
  },
  listen(port?: number, isRestart?: boolean) {
    return startServer(server, port, isRestart);
  },
  async close() {
    if (!middlewareMode) {
      process.off(""SIGTERM"", exitProcess);
      if (process.env.CI !== ""true"") {
        process.stdin.off(""end"", exitProcess);
      }
    }
    await Promise.all([
      watcher.close(),
      ws.close(),
      container.close(),
      closeHttpServer(),
    ]);
  },
  printUrls() {
    if (httpServer) {
      printCommonServerUrls(httpServer, config.server, config);
    } else {
      throw new Error(""cannot print server URLs in middleware mode."");
    }
  },
  async restart(forceOptimize?: boolean) {
    if (!server._restartPromise) {
      server._forceOptimizeOnRestart = !!forceOptimize;
      server._restartPromise = restartServer(server).finally(() => {
        server._restartPromise = null;
        server._forceOptimizeOnRestart = false;
      });
    }
    return server._restartPromise;
  },
  _ssrExternals: null,
  _restartPromise: null,
  _importGlobMap: new Map(),
  _forceOptimizeOnRestart: false,
  _pendingRequests: new Map(),
};
```
## configureServer
由于 vite 的插件系统提供了 `configureServer` 钩子, configureServer 钩子将在内部中间件被安装前调用, 所以自定义的中间件将会默认会比内部中间件早运行. 如果你想注入一个在内部中间件之后运行的中间件, 你可以从 configureServer 返回一个函数, 将会在内部中间件安装后被调用.
```ts
// apply server configuration hooks from plugins
const postHooks: ((() => void) | void)[] = [];
for (const plugin of config.plugins) {
  if (plugin.configureServer) {
    postHooks.push(await plugin.configureServer(server));
  }
}
```
## middleware 总览
解析来 vite 将执行一票内置中间件, 我们先看个概览, 下面逐一学习.
```ts
// Internal middlewares ------------------------------------------------------
// request timer
// 在 debug 模式统计一次请求耗费的时间
if (process.env.DEBUG) {
  middlewares.use(timeMiddleware(root));
}
// cors (enabled by default)
// 处理跨域
const { cors } = serverConfig;
if (cors !== false) {
  middlewares.use(corsMiddleware(typeof cors === ""boolean"" ? {} : cors));
}
// proxy
// 处理代理
const { proxy } = serverConfig;
if (proxy) {
  middlewares.use(proxyMiddleware(httpServer, proxy, config));
}
// base
// base 是开发或生产环境服务的公共基础路径, 默认是  '/', 如果用户设置了其他路径, 需要藉此进行调整
if (config.base !== ""/"") {
  middlewares.use(baseMiddleware(server));
}
// open in editor support
// 这个库是 vite 直接从 react-dev-utils 里拿的, 用于前端框架在报错的时候, 会在浏览器出个弹窗, 展示错误堆栈(行数, 列数, 路径)
// 你点击错误, 这个中间件帮助你打开编辑器, 并定位到那一行
// (其实挺鸡肋的)
middlewares.use(""/__open-in-editor"", launchEditorMiddleware());
// serve static files under /public
// this applies before the transform middleware so that these files are served
// as-is without transforms.
// 保护 public 文件夹下的文件不被编译到
if (config.publicDir) {
  middlewares.use(
    servePublicMiddleware(config.publicDir, config.server.headers)
  );
}
// main transform middleware
// 转换(src 下的)源码 / 资源
middlewares.use(transformMiddleware(server));
// serve static files
middlewares.use(serveRawFsMiddleware(server));
middlewares.use(serveStaticMiddleware(root, server));
const isMiddlewareMode = middlewareMode && middlewareMode !== ""html"";
// spa fallback
if (config.spa && !isMiddlewareMode) {
  middlewares.use(spaFallbackMiddleware(root));
}
// run post config hooks
// This is applied before the html middleware so that user middleware can
// serve custom content instead of index.html.
// 执行后置自定义 server 钩子
postHooks.forEach((fn) => fn && fn());
if (config.spa && !isMiddlewareMode) {
  // transform index.html
  middlewares.use(indexHtmlMiddleware(server));
}
if (!isMiddlewareMode) {
  // handle 404s
  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
  // 简单地把状态码设置为 404
  middlewares.use(function vite404Middleware(_, res) {
    res.statusCode = 404;
    res.end();
  });
}
// error handler
// 返回一个状态码为 500 的错误 html 页面
middlewares.use(errorMiddleware(server, !!middlewareMode));
```
关于前几个中间件, `timeMiddleware`, `corsMiddleware`, `proxyMiddleware`, `baseMiddleware`, `launchEditorMiddleware`, 以及 `vite404Middleware`, `errorMiddleware` 就不多说, 很常见也很通用, 直接看注释即可.
我们主要来分析下面两组:
- 跟 index.html 有关的: `transformMiddleware`,`spaFallbackMiddleware`, `indexHtmlMiddleware`
- 跟静态文件有关的: `servePublicMiddleware`, `serveRawFsMiddleware`, `serveStaticMiddleware`
## 跟 index.html 相关的中间件
### spaFallbackMiddleware
这个中间件的重点是 [connect-history-api-fallback](https://github.com/bripkens/connect-history-api-fallback) 这个库. 我们知道对于单页应用, 路由实际都是假的, 因此你刷新一下页面, 就到 404 了, 而这个库的目的就是在刷新后, 重写路由到 index.html 上, 这样就不会导致资源丢失了.
```ts
import fs from ""fs"";
import path from ""path"";
import history from ""connect-history-api-fallback"";
import type { Connect } from ""types/connect"";
import { createDebugger } from ""../../utils"";
export function spaFallbackMiddleware(
  root: string
): Connect.NextHandleFunction {
  const historySpaFallbackMiddleware = history({
    logger: createDebugger(""vite:spa-fallback""),
    // support /dir/ without explicit index.html
    rewrites: [
      {
        from: /\/$/,
        to({ parsedUrl }: any) {
          const rewritten =
            decodeURIComponent(parsedUrl.pathname) + ""index.html"";
          if (fs.existsSync(path.join(root, rewritten))) {
            return rewritten;
          } else {
            return `/index.html`;
          }
        },
      },
    ],
  });
  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
  return function viteSpaFallbackMiddleware(req, res, next) {
    return historySpaFallbackMiddleware(req, res, next);
  };
}
```
顺便提一嘴, 在最终线上, 你也要在 nginx 配置好路由重写, 否则也会 404.
```shell
try_files {path} /index.html
```
### indexHtmlMiddleware
在讲这个中间件之前, 我们先看看在 public 文件夹下初始化的 index.html 文件是这样婶的:
```html
<!DOCTYPE html>
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <link rel=""icon"" type=""image/svg+xml"" href=""/src/favicon.svg"" />
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"" />
    <title>Vite App</title>
  </head>
  <body>
    <div id=""root""></div>
    <script type=""module"" src=""/src/main.tsx""></script>
  </body>
</html>
```
但是我们在浏览器审查元素, 它变成了如下的样子:
```html
<!DOCTYPE html>
<html lang=""en"">
  <head>
    <script type=""module"" src=""/@vite/client""></script>
    <script type=""module"">
      import RefreshRuntime from ""/@react-refresh"";
      RefreshRuntime.injectIntoGlobalHook(window);
      window.$RefreshReg$ = () => {};
      window.$RefreshSig$ = () => (type) => type;
      window.__vite_plugin_react_preamble_installed__ = true;
    </script>
    <meta charset=""UTF-8"" />
    <link rel=""icon"" type=""image/svg+xml"" href=""/src/favicon.svg"" />
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"" />
    <title>Vite App</title>
  </head>
  <body>
    <div id=""root""></div>
    <script type=""module"" src=""/src/main.tsx""></script>
  </body>
</html>
```
之所以增加了两个 script 标签, 就是由 `indexHtmlMiddleware` 做到的, 它通过拦截 index.html, 然后根据传入的 hooks(plugin), 将 index.html 进行一番改造, 比如注入 `vite/client`, `react-fast-refresh` 等等.
上面我们在讲 spaFallbackMiddleware 时知道, 所有前端路由都被处理成 `/index.html`. 因此这个中间件首先找到 index.html 的绝对路径, 然后读取它. 再通过 `transformIndexHtml` 将其转换后, 通过 `send` 发送给前端.
```ts
export function indexHtmlMiddleware(
  server: ViteDevServer
): Connect.NextHandleFunction {
  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
  return async function viteIndexHtmlMiddleware(req, res, next) {
    if (res.writableEnded) {
      return next();
    }
    const url = req.url && cleanUrl(req.url);
    // spa-fallback always redirects to /index.html
    // 所有前端路由都被处理成 `/index.html`
    // 此外, 这里很严谨地判断了 sec-fetch-dest, 这是一个由浏览器发起的请求头, 这个请求头明确告知客户端需要什么类型的文件
    // 由于是 sec(security) 开头, 客户端是无法篡改的, 详情可以看 https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Mode
    if (url?.endsWith("".html"") && req.headers[""sec-fetch-dest""] !== ""script"") {
      const filename = getHtmlFilename(url, server);
      if (fs.existsSync(filename)) {
        try {
          // 获取 index.html 的内容
          let html = fs.readFileSync(filename, ""utf-8"");
          // 转换 html
          html = await server.transformIndexHtml(url, html, req.originalUrl);
          return send(req, res, html, ""html"", {
            headers: server.config.server.headers,
          });
        } catch (e) {
          return next(e);
        }
      }
    }
    next();
  };
}
```
回想 `createServer` 函数, 有一段这样的代码:
```ts
server.transformIndexHtml = createDevHtmlTransformFn(server);
```
可见, 重点就是 `createDevHtmlTransformFn` 个函数了, 它首先用 `resolveHtmlTransforms` 函数, 根据 enforce 拿到前置和后置 hooks. 然后通过 `applyHtmlTransforms` 方法处理 index.html 的代码. 下面我们细说这两个函数.
```ts
export function createDevHtmlTransformFn(
  server: ViteDevServer
): (url: string, html: string, originalUrl: string) => Promise<string> {
  const [preHooks, postHooks] = resolveHtmlTransforms(server.config.plugins);
  return (url: string, html: string, originalUrl: string): Promise<string> => {
    return applyHtmlTransforms(html, [...preHooks, devHtmlHook, ...postHooks], {
      path: url,
      filename: getHtmlFilename(url, server), // 绝对路径
      server,
      originalUrl,
    });
  };
}
```
下面列出了 `plugin.transformIndexHtml` 的函数签名. 可见它要么是个函数, 要么是个对象: 如果是函数的话就放在 postHooks 中; 如果是个对象, 会根据 `enforce` 属性决定它应该放在 preHooks 还是 postHooks 中.
```ts
export type IndexHtmlTransform =
  | IndexHtmlTransformHook
  | {
      enforce?: ""pre"" | ""post"";
      transform: IndexHtmlTransformHook;
    };
```
```ts
export function resolveHtmlTransforms(
  plugins: readonly Plugin[]
): [IndexHtmlTransformHook[], IndexHtmlTransformHook[]] {
  const preHooks: IndexHtmlTransformHook[] = [];
  const postHooks: IndexHtmlTransformHook[] = [];
  for (const plugin of plugins) {
    const hook = plugin.transformIndexHtml;
    if (hook) {
      if (typeof hook === ""function"") {
        postHooks.push(hook);
      } else if (hook.enforce === ""pre"") {
        preHooks.push(hook.transform);
      } else {
        postHooks.push(hook.transform);
      }
    }
  }
  return [preHooks, postHooks];
}
```
比如是个 react 项目, 它会引入 `@vitejs/plugin-react-refresh` 这个 plugin, 然后经过一系列操作, 在 index.html 注入以下代码, 因为这个 plugin 有个 `preambleCode` 字符串, 这个字符串正是 `@react-refresh` 的代码.
```html
<head>
  ...
  <script type=""module"" src=""/@vite/client""></script>
  <script type=""module"">
    import RefreshRuntime from ""/@react-refresh"";
    RefreshRuntime.injectIntoGlobalHook(window);
    window.$RefreshReg$ = () => {};
    window.$RefreshSig$ = () => (type) => type;
    window.__vite_plugin_react_preamble_installed__ = true;
  </script>
  ...
</head>
```
接下来我们看一下 `applyHtmlTransforms`, 它根据上面已经排序好的 hooks 依次执行, 它返回的是 `IndexHtmlTransformResult`. 我们先看一下相关 hook 的签名.
```ts
export type IndexHtmlTransformHook = (
  html: string,
  ctx: IndexHtmlTransformContext
) => IndexHtmlTransformResult | void | Promise<IndexHtmlTransformResult | void>;
export type IndexHtmlTransformResult =
  | string
  | HtmlTagDescriptor[]
  | {
      html: string;
      tags: HtmlTagDescriptor[];
    };
export interface HtmlTagDescriptor {
  tag: string;
  attrs?: Record<string, string | boolean | undefined>;
  children?: string | HtmlTagDescriptor[];
  /**
   * default: 'head-prepend'
   */
  injectTo?: ""head"" | ""body"" | ""head-prepend"" | ""body-prepend"";
}
```
`IndexHtmlTransformResult` 有可能是字符串, 数组或者对象:
- 如果是字符串, 那么直接赋值给最终 html 字符串
- 如果是数组, 那就先赋值给 tags 变量, 等待处理
- 如果是对象, 那就把 html 属性赋值给 html 变量, tags 属性赋值给 tags 变量, 等待处理
接下来就要对 tags 进行遍历, 根据 tag 的不同的类型, 也就是 `""head"" | ""body"" | ""head-prepend"" | ""body-prepend""`, 先放到不同的数组中, 然后通过 `injectToHead` 和 `injectToBody` 这两个函数, 将新增的标签及其内容添加到 html 中.
```ts
export async function applyHtmlTransforms(
  html: string,
  hooks: IndexHtmlTransformHook[],
  ctx: IndexHtmlTransformContext
): Promise<string> {
  for (const hook of hooks) {
    const res = await hook(html, ctx);
    if (!res) {
      continue;
    }
    if (typeof res === ""string"") {
      html = res;
    } else {
      let tags: HtmlTagDescriptor[];
      if (Array.isArray(res)) {
        tags = res;
      } else {
        html = res.html || html;
        tags = res.tags;
      }
      const headTags: HtmlTagDescriptor[] = [];
      const headPrependTags: HtmlTagDescriptor[] = [];
      const bodyTags: HtmlTagDescriptor[] = [];
      const bodyPrependTags: HtmlTagDescriptor[] = [];
      for (const tag of tags) {
        if (tag.injectTo === ""body"") {
          bodyTags.push(tag);
        } else if (tag.injectTo === ""body-prepend"") {
          bodyPrependTags.push(tag);
        } else if (tag.injectTo === ""head"") {
          headTags.push(tag);
        } else {
          headPrependTags.push(tag);
        }
      }
      html = injectToHead(html, headPrependTags, true);
      html = injectToHead(html, headTags);
      html = injectToBody(html, bodyPrependTags, true);
      html = injectToBody(html, bodyTags);
    }
  }
  return html;
}
```
关于 `injectToHead` 和 `injectToBody` 我们就不多讲了, 大抵就是把下面这个对象, 变成 `<script src=""/@vite/client"" type='module'></script>`, 然后插入到指定位置.
```ts
const o = {
  tag: ""script"",
  attrs: {
    type: ""module"",
    src: ""/@vite/client"",
  },
  injectTo: ""head-prepend"",
};
```
### transformMiddleware
`transformMiddleware` 比较复杂, 大体来讲就是当浏览器成功加载了 index.html 之后, 肯定涉及一些源码的拉取; 此外, 用户交互也可能会涉及(比如切换了懒加载路由, 新页面肯定要下载对应的资源).
vite 会通过原生 ESM 的方式请求源码文件, 但由于源码肯定不能被浏览器直接使用的(比如 tsx), 那这个中间件的目的就是拦截这些请求, 将这个被请求文件通过 esbuild 编译成浏览器支持的文件; 并会为该文件创建模块对象, 设置模块之间的依赖关系等等.
此外, 它还充分利用 http 的缓存机制, 来保证未过期文件的重复利用, 以提高速度. 关于 http 缓存可以看我的文章 [\[HTTP 系列\] 第 3 篇 —— HTTP 缓存那些事](https://www.yanceyleo.com/post/89731d8e-5510-4094-8962-462b127ed5d0).
```ts
export function transformMiddleware(
  server: ViteDevServer
): Connect.NextHandleFunction {
  const {
    config: { root, logger },
    moduleGraph,
  } = server;
  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
  return async function viteTransformMiddleware(req, res, next) {
    // 拉取数据肯定是 GET 请求, 如果不是直接放掉
    // 此外, 如果资源是 ['/', '/favicon.ico'], 也不要通过这里处理, 因为 '/' 就是 index.html, 它已经被上面 indexHtmlMiddleware 处理了
    // favicon.ico 不用多说, 给浏览器用的, 没必要处理
    if (req.method !== ""GET"" || knownIgnoreList.has(req.url!)) {
      return next();
    }
    let url: string;
    try {
      // 我们知道 vite 为了比较资源的新鲜度, 会给资源的 url 附上一个时间戳 query
      // removeTimestampQuery 这个函数就是把 &t=xxxxxxxxxxxxx 干掉
      // 此外, 我们知道 rollup 的插件机制有虚拟模块的概念, 按照约定如果你用了虚拟模块, 为了防止它被其他插件处理, 需要加上 \0
      // 而一个合法 url 是不能存在 \0 的, 因此 vite 把它转成了 __x00__
      // 所以在 decodeURI 的时候需要把它还原成 \0
      // 一个现实的例子是 /@id/__x00__react/jsx-dev-runtime'
      url = decodeURI(removeTimestampQuery(req.url!)).replace(
        NULL_BYTE_PLACEHOLDER,
        ""\0""
      );
    } catch (e) {
      return next(e);
    }
    // 干掉 url 的 query 和 hash
    const withoutQuery = cleanUrl(url);
    try {
      const isSourceMap = withoutQuery.endsWith("".map"");
      // since we generate source map references, handle those requests here
      // 首先要分析 sourcemap
      if (isSourceMap) {
        if (getDepsOptimizer(server.config)?.isOptimizedDepUrl(url)) {
          // If the browser is requesting a source map for an optimized dep, it
          // means that the dependency has already been pre-bundled and loaded
          const mapFile = url.startsWith(FS_PREFIX)
            ? fsPathFromId(url)
            : normalizePath(
                ensureVolumeInPath(path.resolve(root, url.slice(1)))
              );
          try {
            const map = await fs.readFile(mapFile, ""utf-8"");
            return send(req, res, map, ""json"", {
              headers: server.config.server.headers,
            });
          } catch (e) {
            // Outdated source map request for optimized deps, this isn't an error
            // but part of the normal flow when re-optimizing after missing deps
            // Send back an empty source map so the browser doesn't issue warnings
            const dummySourceMap = {
              version: 3,
              file: mapFile.replace(/\.map$/, """"),
              sources: [],
              sourcesContent: [],
              names: [],
              mappings: "";;;;;;;;;"",
            };
            return send(req, res, JSON.stringify(dummySourceMap), ""json"", {
              cacheControl: ""no-cache"",
              headers: server.config.server.headers,
            });
          }
        } else {
          const originalUrl = url.replace(/\.map($|\?)/, ""$1"");
          const map = (await moduleGraph.getModuleByUrl(originalUrl, false))
            ?.transformResult?.map;
          if (map) {
            return send(req, res, JSON.stringify(map), ""json"", {
              headers: server.config.server.headers,
            });
          } else {
            return next();
          }
        }
      }
      // check if public dir is inside root dir
      // 检查 /public 是否在 / 之内
      // 老实巴交写代码的话, 实在没想到有什么反面例子...
      const publicDir = normalizePath(server.config.publicDir);
      const rootDir = normalizePath(server.config.root);
      if (publicDir.startsWith(rootDir)) {
        const publicPath = `${publicDir.slice(rootDir.length)}/`;
        // warn explicit public paths
        if (url.startsWith(publicPath)) {
          let warning: string;
          if (isImportRequest(url)) {
            const rawUrl = removeImportQuery(url);
            warning =
              ""Assets in public cannot be imported from JavaScript.\n"" +
              `Instead of ${colors.cyan(
                rawUrl
              )}, put the file in the src directory, and use ${colors.cyan(
                rawUrl.replace(publicPath, ""/src/"")
              )} instead.`;
          } else {
            warning =
              `files in the public directory are served at the root path.\n` +
              `Instead of ${colors.cyan(url)}, use ${colors.cyan(
                url.replace(publicPath, ""/"")
              )}.`;
          }
          logger.warn(colors.yellow(warning));
        }
      }
      // 接下来最重要的, 就是拦截客户端请求了哪些类型的资源
      if (
        isJSRequest(url) || // 判断是否请求 js 文件, /\.((j|t)sx?|mjs|vue|marko|svelte|astro)($|\?)/
        isImportRequest(url) || // url 上挂有 import 参数的, vite 会对热更新时请求的文件等挂上 import 参数, /(\?|&)import=?(?:&|$)/
        isCSSRequest(url) || // 判断是否请求 css 文件, `\\.(css|less|sass|scss|styl|stylus|pcss|postcss)($|\\?)`
        isHTMLProxy(url) // url 上挂有 html-proxy 参数的,  /(\?|&)html-proxy\b/
      ) {
        // strip ?import, 干掉 import 参数
        url = removeImportQuery(url);
        // Strip valid id prefix. This is prepended to resolved Ids that are
        // not valid browser import specifiers by the importAnalysis plugin.
        // 如果 url 以 /@id/ 开头，则去掉 /@id/, 上面说了, 这个前缀跟 rollup 插件规范有关
        url = unwrapId(url);
        // for CSS, we need to differentiate between normal CSS requests and
        // imports
        if (
          isCSSRequest(url) &&
          !isDirectRequest(url) &&
          req.headers.accept?.includes(""text/css"")
        ) {
          url = injectQuery(url, ""direct"");
        }
        // check if we can return 304 early
        // 找出有没有与 if-none-match 匹配的 etag, 如果有直接返回协商缓存
        const ifNoneMatch = req.headers[""if-none-match""];
        if (
          ifNoneMatch &&
          (await moduleGraph.getModuleByUrl(url, false))?.transformResult
            ?.etag === ifNoneMatch
        ) {
          isDebug && debugCache(`[304] ${prettifyUrl(url, root)}`);
          res.statusCode = 304;
          return res.end();
        }
        // resolve, load and transform using the plugin container
        // 对于没有命中协商缓存的, 那就需要进行一波代码编译了
        // 这个我们下面详细说
        const result = await transformRequest(url, server, {
          html: req.headers.accept?.includes(""text/html""),
        });
        if (result) {
          const type = isDirectCSSRequest(url) ? ""css"" : ""js"";
          // 我们知道 vite 会给 node_moudles 的三方依赖进行预构建
          // 前端在请求三方依赖资源时, 会加上 t={browserHash},
          // 或者资源有 depsCacheDirPrefix 前缀, 就认为是依赖
          const isDep =
            DEP_VERSION_RE.test(url) ||
            getDepsOptimizer(server.config)?.isOptimizedDepUrl(url);
          return send(req, res, result.code, type, {
            etag: result.etag,
            // allow browser to cache npm deps!
            // 如果是依赖的话直接强缓存写死, 下次再请求到这个三方依赖, 直接强缓存返回!
            cacheControl: isDep ? ""max-age=31536000,immutable"" : ""no-cache"",
            headers: server.config.server.headers,
            map: result.map,
          });
        }
      }
    } catch (e) {
      if (e?.code === ERR_OPTIMIZE_DEPS_PROCESSING_ERROR) {
        // Skip if response has already been sent
        if (!res.writableEnded) {
          res.statusCode = 504; // status code request timeout
          res.end();
        }
        // This timeout is unexpected
        logger.error(e.message);
        return;
      }
      if (e?.code === ERR_OUTDATED_OPTIMIZED_DEP) {
        // Skip if response has already been sent
        if (!res.writableEnded) {
          res.statusCode = 504; // status code request timeout
          res.end();
        }
        // We don't need to log an error in this case, the request
        // is outdated because new dependencies were discovered and
        // the new pre-bundle dependendencies have changed.
        // A full-page reload has been issued, and these old requests
        // can't be properly fullfilled. This isn't an unexpected
        // error but a normal part of the missing deps discovery flow
        return;
      }
      return next(e);
    }
    next();
  };
}
```
#### transformRequest
```ts
export function transformRequest(
  url: string,
  server: ViteDevServer,
  options: TransformOptions = {}
): Promise<TransformResult | null> {
  const cacheKey = (options.ssr ? ""ssr:"" : options.html ? ""html:"" : """") + url;
  // This module may get invalidated while we are processing it. For example
  // when a full page reload is needed after the re-processing of pre-bundled
  // dependencies when a missing dep is discovered. We save the current time
  // to compare it to the last invalidation performed to know if we should
  // cache the result of the transformation or we should discard it as stale.
  //
  // A module can be invalidated due to:
  // 1. A full reload because of pre-bundling newly discovered deps
  // 2. A full reload after a config change
  // 3. The file that generated the module changed
  // 4. Invalidation for a virtual module
  //
  // For 1 and 2, a new request for this module will be issued after
  // the invalidation as part of the browser reloading the page. For 3 and 4
  // there may not be a new request right away because of HMR handling.
  // In all cases, the next time this module is requested, it should be
  // re-processed.
  //
  // We save the timestamp when we start processing and compare it with the
  // last time this module is invalidated
  const timestamp = Date.now();
  const pending = server._pendingRequests.get(cacheKey);
  if (pending) {
    return server.moduleGraph
      .getModuleByUrl(removeTimestampQuery(url), options.ssr)
      .then((module) => {
        if (!module || pending.timestamp > module.lastInvalidationTimestamp) {
          // The pending request is still valid, we can safely reuse its result
          return pending.request;
        } else {
          // Request 1 for module A     (pending.timestamp)
          // Invalidate module A        (module.lastInvalidationTimestamp)
          // Request 2 for module A     (timestamp)
          // First request has been invalidated, abort it to clear the cache,
          // then perform a new doTransform.
          pending.abort();
          return transformRequest(url, server, options);
        }
      });
  }
  const request = doTransform(url, server, options, timestamp);
  // Avoid clearing the cache of future requests if aborted
  let cleared = false;
  const clearCache = () => {
    if (!cleared) {
      server._pendingRequests.delete(cacheKey);
      cleared = true;
    }
  };
  // Cache the request and clear it once processing is done
  server._pendingRequests.set(cacheKey, {
    request,
    timestamp,
    abort: clearCache,
  });
  request.then(clearCache, clearCache);
  return request;
}
```
## 跟静态文件相关的中间件","2025-02-02 03:09:39.315244","2025-02-02 03:09:39.315244"
"57a922cd-7a64-493c-aee8-beb124f8ae78","{Vite}",0,0,False,"https://edge.yancey.app/beg/odwipf56-1698219189232.jpg","Vite 源码解析(5) - importAnalysis 插件","todo","todo","2025-02-02 03:09:42.095051","2025-02-02 03:09:42.095051"
"ade71570-8fb0-41b8-972b-aebed7d8386a","{""About Me""}",0,0,False,"https://edge.yancey.app/beg/44299297_s.jpg","关于我","All about me.","## 个人简介

初めまして！我是 Yancey, 人在北京, 毕业两年的前端工程师. 平时喜欢 ~~唱跳rap篮球~~ 折腾技术, 这个 Blog 项目就是产出之一, 偶尔运营下微信公众号 **进击的前端**, 写过一个天气微信小程序 **Natsuha Weather**, 运营着 [JavaScript API 全解析](https://js.yanceyleo.com/), 希望以此契机打打基础. 平时后端运维也喜欢玩一玩, 业余做点儿 MIDI 音乐, 摇滚古典发烧友...

## 关于 Blog

关于博客的历史和展望可移步 [Yancey Blog 大事记](https://www.yanceyleo.com/post/9aef0fc9-eb16-4ccc-bf18-388f885f2cd6), 建议和批评都可以在下面评论(Disqus 需要你懂的), 当然更希望你能够在 [GitHub](https://github.com/Yancey-Blog) 中提 pr 和 issues, 共同学习, 共同进步~

## 联系方式

Email: yanceyofficial(at)gmail.com

Twitter: [@YanceyOfficial](https://twitter.com/YanceyOfficial)","2025-02-02 03:08:42.562303","2025-02-02 03:08:42.562303"
"72a7292b-ef20-433f-9a2b-029b1606f4c5","{HTTP}",0,0,False,"https://edge.yancey.app/beg/cgm30he0-1649091196932.jpg","[HTTP 系列] 第 3 篇 —— HTTP 缓存那些事","这里是《写给前端工程师的 HTTP 系列》，记得有位大佬曾经说过：“大厂前端面试对 HTTP 的要求比 CSS 还要高”，由此可见 HTTP 的重要程度不可小视。文章写作计划如下，视情况可能有一定的删减，本篇是该系列的第 3 篇 —— 《深入理解 HTTP 的缓存机制》。","- [\[HTTP 系列\] 第 1 篇 —— 从 TCP/UDP 到 DNS 解析](https://www.yanceyleo.com/post/3a9d3d47-9977-4579-a756-4bf5af4a3fd4)
- [\[HTTP 系列\] 第 2 篇 —— HTTP 协议那些事](https://www.yanceyleo.com/post/efd566e9-4ee3-4ee2-8448-628414659480)
- [\[HTTP 系列\] 第 3 篇 —— HTTP 缓存那些事](https://www.yanceyleo.com/post/89731d8e-5510-4094-8962-462b127ed5d0)
- [\[HTTP 系列\] 第 4 篇 —— HTTPS](https://www.yanceyleo.com/post/f976717f-9e40-4849-a73f-86c63c0c45e1)
- [\[HTTP 系列\] 第 5 篇 —— 网络安全](https://www.yanceyleo.com/post/953ccf20-7f3b-4d3f-816e-b6e98b26a4da)
- [\[HTTP 系列\] 第 6 篇 —— 从输入 URL 回车到页面呈现](https://www.yanceyleo.com/post/05daeef2-2caf-4ebe-89f0-2ad9cae286c4)

## 从一张图片的响应头说起

![一个响应头的例子](https://edge.yancey.app/beg/Jietu20190507-164837%402x.jpg)

下面是一张图片的响应头, 我们复习一下各个字段:

- Accept-Ranges: 该字段告知客户端, 服务器是否能处理范围请求, 当可以处理时其值为 `bytes`, 否则为 `none`.

- Connection: 该字段决定当前的事务完成后, 是否会关闭网络连接. 如果该值是 `keep-alive`, 网络连接就是持久的, 不会关闭, 使得对同一个服务器的请求可以继续在该连接上完成. 此外它还可以控制不再转发给代理的首部字段.

- Content-Length: 该字段表明实体主体的大小, 单位是字节.

- Content-MD5: 该字段用于检查报文主体在传输过程中是否保持完整性, 以及确认传输到达. 服务端对报文主体执行 MD5 算法, 获取一个 128 位的二进制数, 再通过 base64 编码后将结果写入 Content-MD5 字段值. 因为 HTTP 首部无法记录二进制值, 因此需要通过 Base64 进行处理. 客户端在接收到响应后再对报文主体执行一次相同的 MD5 算法. 将计算值于该字段值比较, 即可判断出报文主体的准确性.

- Content-Type: 报文主体的格式.

- Date: 表示创建报文的日期和时间.

- ETag: 该值是将资源以字符串的形式作唯一标识, 服务器给每份资源分配对应的 ETag 值. 当资源更新时, ETag 值也会更新. ETag 有 `强 ETag` 和 `弱 ETag` 之分, 前者一般用于静态文件, 后者的字段值起始会有 `W` 标志.

- Last-Modified: 该字段为服务器认定的资源做出修改的日期及时间, 它的精度比 ETag 要低, 也就是如果响应头中同时包含 ETag 和 Last-Modified 时, 会以 ETag 为准.

## 什么是 HTTP 缓存

当客户端向服务端请求资源时, 会先访问浏览器缓存, 如果浏览器有""要请求资源""的副本, 就可以直接从浏览器缓存中提取, 而不是从原始服务器中提取这个资源.

HTTP 缓存都是在第二次请求开始的. 第一次请求资源时, 服务器返回资源, 并在响应头中回传资源的缓存参数; 后续请求中, 浏览器判断这些请求参数, 命中强缓存就直接 200 from cache, 否则就把请求参数加到请求头中回传给服务器, 看是否命中协商缓存, 命中则返回 304, 并使用浏览器缓存, 否则服务器会返回新的资源.

根据是否需要向服务器重新发起请求来分类, 可分为**强制缓存**和**协商缓存**; 根据是否可以被单个或者多个用户使用来分类, 可分为**私有缓存**和**共享缓存**. 这篇文章我们主要来聊**强制缓存**和**协商缓存**.

![强缓存和协商缓存](https://edge.yancey.app/beg/4845448-ab0e961921da5694.png)

## 强缓存

通过上面这张图, 我们知道强缓存由响应头中的 `Pragma`, `Cache-Control` 和 `Expires` 控制, 因为 `Pragma` 已经在 HTTP1.1 被废弃了, 这里不做讨论.

对于 `Cache-Control` 和 `Expires`, 如果两者都存在, 且 `Cache-Control` 设置了 max-age 或者 s-max-age, 那么 `Expires` 头会被忽略. **也就是说 `Cache-Control` 的优先级要比 `Expires` 高**, 这是因为后者用的是**服务器时间**, 这就导致客户端跟服务端的时间不一致而发生错误; 此外, 在缓存未失效前, `Expires` 无法获取到修改后的资源.

两个字段本质上都是告知客户端对比本地时间和服务器返回的生存时间来检测缓存是否可用, 如果缓存没有超过它的生存时间, 响应的副本会一直被保存. 当超过指定的时间后, 缓存服务器在请求发送过来时, 转向源服务器请求资源.

下面简单复习一下 Cache-Control 的各个指令, 要注意不止服务器可以发 Cache-Control 头, 浏览器也可以发 Cache-Control 也就是说请求 - 应答的双方都可以用这个字段进行缓存控制, 互相协商缓存的使用策略. 下面是请求头中的 Cache-Control:

| 指令             | 指令值 | 说明                                                                                                                                             |
| ---------------- | ------ | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| max-age=[秒]     | 必填   | 设置缓存存储的最大周期, 超过这个时间缓存被认为过期, 该指令优先级高于 `Expires`, 并且它传递的是一个相对时间, 而 `Expires` 传递的是一个未来的时间. |
| max-stale(=[秒]) | 选填   | 在这个已过期的时间段之内, 客户端愿意接收一个已经过期的资源                                                                                       |
| min-fresh=[秒]   | 必填   | 表示客户端希望在指定的时间内获取最新的响应.                                                                                                      |
| no-cache         | 选填   | 表示客户端不会接收缓存过的响应, 在使用之前必须要去服务器验证是否过期, 是否有最新的版本.                                                          |
| no-store         | 无     | 不缓存请求或响应中的任何内容(注意这个才是告知浏览器不缓存资源).                                                                                  |
| no-transform     | 无     | 代理服务器不得对资源进行转换或转变, 比如 Content-Encoding, Content-Range, Content-Type 等字段信息.                                               |
| only-if-cached   | 无     | 客户端只接受已缓存的响应, 并且不要向原始服务器检查是否有更新的拷贝, 若没有命中缓存, 则返回 504 状态码(Gateway Timeout).                          |

下面是响应头中的 Cache-Control:

| 指令             | 指令值 | 说明                                                                                                                                                                               |
| ---------------- | ------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| max-age=[秒]     | 必填   | 设置缓存存储的最大周期, 超过这个时间缓存被认为过期, 该指令优先级高于 `Expires`, 并且它传递的是一个相对时间, 而 `Expires` 传递的是一个未来的时间.                                   |
| s-maxage=[秒]    | 必填   | 覆盖 max-age 或者 Expires 头, 但是仅适用于共享缓存(比如各个代理), 私有缓存会忽略它.                                                                                                |
| no-cache         | 选填   | 表示客户端不会接收缓存过的响应, 在使用之前必须要去服务器验证是否过期, 是否有最新的版本.                                                                                            |
| no-store         | 无     | 不缓存请求或响应中的任何内容(注意这个才是告知浏览器不缓存资源).                                                                                                                    |
| no-transform     | 无     | 代理服务器不得对资源进行转换或转变, 比如 Content-Encoding, Content-Range, Content-Type 等字段信息.                                                                                 |
| must-revalidate  | 无     | 如果缓存不过期就可以继续使用,但过期了如果还想用就必须去服务器验证                                                                                                                  |
| public           | 无     | 表明响应可以被任何对象(包括: 发送请求的客户端, 代理服务器, 等等)缓存, 即使是通常不可缓存的内容.(例如: 1.该响应没有 max-age 指令或 Expires 消息头；2. 该响应对应的请求方法是 POST.) |
| private          | 无     | 表明响应只能被单个用户缓存, 不能作为共享缓存(即代理服务器不能缓存它). 私有缓存可以缓存响应内容, 比如: 对应用户的本地浏览器.                                                        |
| proxy-revalidate | 无     | 与 must-revalidate 作用相同, 但它仅适用于共享缓存(例如代理), 并被私有缓存忽略.                                                                                                     |

下面是非标准的:

下面是响应头中的 Cache-Control:

| 指令                        | 指令值 | 说明                                                                                                                    |
| --------------------------- | ------ | ----------------------------------------------------------------------------------------------------------------------- |
| immutable                   | 无     | 一个实验性的属性, 表示响应正文不会随时间而改变. 资源(如果未过期)在服务器上不发生改变, 因此客户端不应发送重新验证请求头. |
| stale-while-revalidate=[秒] | 无     | 表明客户端愿意接受陈旧的响应, 同时在后台异步检查新的响应. 秒值指示客户愿意接受陈旧响应的时间长度.                       |
| stale-if-error=[秒]         | 无     | 表示如果新的检查失败, 则客户愿意接受陈旧的响应. 秒数值表示客户在初始到期后愿意接受陈旧响应的时间.                       |

![Cache-Control](https://edge.yancey.app/beg/n3z7k43l-1647525647997.webp)

## 协商缓存

浏览器用 **Cache-Control** 做缓存控制只能是刷新数据, 不能很好地利用缓存数据, 又因为缓存会失效, 使用前还必须要去服务器验证是否是最新版. 当然浏览器可以用两个连续的请求组成**验证动作**: 先是一个 HEAD, 获取资源的修改时间等元信息, 然后与缓存数据比较, 如果没有改动就使用缓存, 节省网络流量, 否则就再发一个 GET 请求, 获取最新的版本. 但这样的两个请求网络成本太高了, 所以 HTTP 协议就定义了一系列 **If** 开头的**条件请求**字段, 专门用来检查验证资源是否过期, 把两个请求才能完成的工作合并在一个请求里做. 而且, 验证的责任也交给服务器, 浏览器只需**坐享其成**.

当第一次请求时服务器返回的响应头中符合如下三个条件之一, 浏览器第二次请求时就会与服务器进行协商, 即与服务端对比判断资源是否进行了修改更新.

- 没有 Cache-Control 和 Expires

- Cache-Control 和 Expires 已经过期

- Cache-Control 的属性值为 no-cache 时(即不走强缓存)

如果服务器端的资源没有修改, 就返回 304, 那么浏览器可以使用缓存中的数据, 否则直接返回 200 和新的资源. 跟协商缓存相关的头部属性有 `ETag/If-Not-Match` 和 `Last-Modified/If-Modified-Since`, 他们是成对出现的. 其中 `ETag` 和 `Last-Modified` 是请求头中的字段, 而 `If-Not-Match` 和 `If-Modified-Since` 是响应头中的字段, 下图是对两者的比较.

![ETag/If-Not-Match 和 Last-Modified/If-Modified-Since 对比](https://edge.yancey.app/beg/4845448-a22cef109d00aa79-2.jpeg)

协商缓存的流程是这样的: 当浏览器第一次向服务器发送请求时, 会在响应头中返回协商缓存的头属性: ETag 和 Last-Modified, 其中 ETag 返回的是一个 hash 值, Last-Modified 返回的是 GMT 格式的最后修改时间; 在后续的请求中, 会在请求头上带上 If-Not-Match 和 If-Modified-Since, 服务器在接收到这两个参数后会做比较, 如果返回的是 304 状态码, 则说明请求的资源没有修改, 浏览器可以直接在缓存中取数据, 否则, 服务器会直接返回数据.

![协商缓存请求头](https://edge.yancey.app/beg/4845448-c2d84719d423f269.jpeg)

![协商缓存响应头](https://edge.yancey.app/beg/4845448-45287e60a17830db.png)

为什么有了 Last-Modified 还需要 ETag 呢? ETag/If-Not-Match 是在 HTTP/1.1 出现的, 主要是修正 Last-Modified 一些不准确的问题:

- Last-Modified 标注的最后修改只能精确到秒级, 如果某些文件在 1 秒钟以内, 被修改多次的话, 它将不能准确标注文件的修改时间

- 如果某些文件被修改了, 但是内容并没有任何变化, 而 Last-Modified 却改变了, 导致文件没法使用缓存

- 有可能存在服务器没有准确获取文件修改时间, 或者与代理服务器时间不一致等情形

### 多说一点 Etag

Etag 是**实体标签**(Entity Tag) 的缩写, 是资源的一个唯一标识, 主要是用来解决修改时间无法准确区分文件变化的问题. ETag 还有强弱之分. 强 ETag 要求资源在字节级别必须完全相符, 弱 ETag 在值前有个 `W/` 标记, 只要求资源在语义上没有变化, 但内部可能会有部分发生了改变(例如 HTML 里的标签顺序调整, 或者多了几个空格).

## HTML 文件如何使用缓存

HTML 禁用缓存:

```html
<meta http-equiv=""cache-control"" content=""no-cache"" />
```

HTML 设置缓存:

```html
<meta http-equiv=""Cache-Control"" content=""max-age=7200"" />
```

## 用户行为对浏览器缓存的影响

所谓用户行为对浏览器缓存的影响, 指的就是用户在浏览器如何操作时, 会触发怎样的缓存策略. 主要有 3 种:

- 打开网页, 地址栏输入地址: 查找 disk cache 中是否有匹配. 如有则使用;如没有则发送网络请求.

- 普通刷新(Command + R): 因为 TAB 并没有关闭, 因此 memory cache 是可用的, 会被优先使用(如果匹配的话). 其次才是 disk cache. 其实是发了一个 **Cache-Control: no-cache**, 含义和 **max-age=0** 基本一样, 就看后台的服务器怎么理解, 通常两者的效果是相同的.

- 强制刷新(Command + Shift + R): 浏览器不使用缓存, 因此发送的请求头部均带有 Cache-control: no-cache(为了兼容, 还带了 Pragma: no-cache), 服务器直接返回 200 和最新内容.

## 私有缓存和共享缓存

私有缓存(浏览器级缓存): 私有缓存只能用于单独用户. 你可能已经见过浏览器设置中的**缓存**选项. 浏览器缓存拥有用户通过 HTTP 下载的所有文档. 这些缓存为浏览过的文档提供向后/向前导航, 保存网页, 查看源码等功能, 可以避免再次向服务器发起多余的请求. 它同样可以提供缓存内容的离线浏览, 并且只能用于单独的用户.

```html
Cache-Control: Private
```

共享缓存(代理级缓存): 共享缓存可以被多个用户使用. 例如, ISP 或你所在的公司可能会架设一个 web 代理来作为本地网络基础的一部分提供给用户. 这样热门的资源就会被重复使用, 减少网络拥堵与延迟. 共享缓存可以被多个用户使用.

```html
Cache-Control: Public
```

## HTTP 的缓存代理

上面谈到的强缓存也好, 协商缓存也好, 都是基于客户端(浏览器)的缓存, 它能够减少响应时间, 节约带宽, 提升客户端的用户体验.

但 HTTP 传输链路上, 不只是客户端有缓存, 服务器上的缓存也是非常有价值的, 可以让请求不必走完整个后续处理流程, **就近**获得响应结果.

特别是对于那些**读多写少**的数据, 例如突发热点新闻, 爆款商品的详情页, 一秒钟内可能有成千上万次的请求. 即使仅仅缓存数秒钟, 也能够把巨大的访问流量挡在外面, 让 RPS(request per second)降低好几个数量级, 减轻应用服务器的并发压力, 对性能的改善是非常显著的.

HTTP 的服务器缓存功能主要由**代理服务器**来实现(即缓存代理), 注意它不同于源服务器的缓存(比如使用 Memcache, Redis, Varnish).

![缓存代理](https://edge.yancey.app/beg/p4bne3z0-1647716347123.webp)

代理服务收到源服务器发来的响应数据后需要做两件事. 第一个当然是把报文转发给客户端, 而第二个就是把报文存入自己的 Cache 里. 下一次再有相同的请求, 代理服务器就可以直接发送 304 或者缓存数据, 不必再从源服务器那里获取. 这样就降低了客户端的等待时间, 同时节约了源服务器的网络带宽.

### 源服务器的缓存控制

客户端和代理是不一样的, 客户端的缓存只是用户自己使用, 而代理的缓存可能会为非常多的客户端提供服务. 所以, 需要对它的缓存再多一些限制条件.

为了区分客户端上的缓存和代理上的缓存, 需要使用 Cache-Control 上的两个字段 **private** 和 **public**. **private** 表示缓存只能在客户端保存, 是用户**私有**的, 不能放在代理上与别人共享. 而**public** 的意思就是缓存完全开放, 谁都可以存, 谁都可以用. 比如你自己的 userId 肯定是不能被代理共享的, 否则别人可能通过你的 userId 就能拿到你私有的代理缓存.

缓存失效后的重新验证也要区分开, **must-revalidate** 是只要过期就必须回源服务器验证, 而新的 **proxy-revalidate** 只要求代理的缓存过期后必须验证, 客户端不必回源, 只验证到代理这个环节就行了.

缓存的生存时间可以使用新的 **s-maxage**(s 是 share 的意思), 只限定在代理上能够存多久, 而客户端仍然使用 **max-age**.

此外, 代理的 Cache-Control 还有一个特殊的缓存控制, 就是**no-transform**, 表示代理服务器不得对资源进行转换或转变, 比如 Content-Encoding, Content-Range, Content-Type 等字段信息. 因为我们知道代理服务器可以对报文做一些修改, 该字段勒令代理服务器不要对资源进行转换或转变. 举个例子, 你缓存了个 png 的文件, 如果代理服务器不小心把它转成了 application/json 那就惨了.

当然, 源服务器在设置完 **Cache-Control** 后必须要为报文加上 **Last-modified** 或 **ETag** 字段. 否则, 客户端和代理后面就无法使用条件请求来验证缓存是否有效, 也就不会有 304 缓存重定向.

[源服务器的缓存控制](https://edge.yancey.app/beg/xflbup8m-1647717521707.webp)

### 客户端的缓存控制

客户端在 HTTP 缓存体系里要面对的是代理和源服务器, 也必须区别对待. 除了 max-age、no-store、no-cache 这三个属性, 还多了两个新属性 **max-stale** 和 **min-fresh**.

**max-stale** 的意思是如果代理上的缓存过期了也可以接受, 但不能过期超过 x 秒. **min-fresh** 的意思是缓存必须有效, 而且必须在 x 秒后依然有效. 换句话说, **max-stale** 相当于给 **max-age** 增加时间, **min-fresh** 相当于减少时间.

举个例子, **max-age** 是 10 天, **max-stale** 是 2 天, 那么 12 天內代理缓存都是有效的. 如果 **min-fresh** 是 1 天, 这意味着只有 9 天内缓存是有效的.

有的时候客户端还会发出一个特别的 **only-if-cached** 属性, 表示只接受代理缓存的数据, 不接受源服务器的响应. 如果代理上没有缓存或者缓存过期, 就应该给客户端返回一个 504(Gateway Timeout).

![客户端的缓存控制](https://edge.yancey.app/beg/ugrjj4de-1647763569133.webp)

## 缓存清理

- 过期的数据应该及时淘汰, 避免占用空间;
- 源站的资源有更新, 需要删除旧版本, 主动换成最新版(即刷新);
- 有时候会缓存了一些本不该存储的信息, 例如网络谣言或者危险链接, 必须尽快把它们删除.

清理缓存的方法有很多, 比较常用的一种做法是使用自定义请求方法 **PURGE**, 发给代理服务器, 要求删除 URI 对应的缓存数据.

## 扩展: 多说一嘴重定向

重定向的一个原因就是**资源不可用**, 比如域名变了, 服务器变了等等, 为了避免出现 404, 需要跳转至另一个 URI. 另一个原因就是**避免重复**, 有的网站都会申请多个名称类似的域名, 然后把它们再重定向到主站上. 比如访问 z.cn 会被重定向到 www.amazon.cn/ref=z_cn?tag=zcn0e-23.

如果域名, 服务器, 网站架构发生了大幅度的改变, 比如启用了新域名, 服务器切换到了新机房, 网站目录层次重构, 这些都算是**永久性**的改变. 原来的 URI 已经不能用了, 必须用 301 **永久重定向**到新的 URI 上. 如果原来的 URI 在将来的某个时间点还会恢复正常, 常见的应用场景就是系统维护, 把网站重定向到一个通知页面, 告诉用户过一会儿再来访问. 另一种用法就是 **服务降级** , 比如在双十一促销的时候, 把订单查询, 领积分等不重要的功能入口暂时关闭, 保证核心服务能够正常运行.

当然, 重定向也有缺点, 第一个就是**性能损耗**. 很明显 重定向的机制决定了一个跳转会有两次请求 - 应答. 比正常的访问多了一次. 站内重定向还好说, 可以长连接复用, 站外重定向就要开两个连接, 如果网络连接质量差, 那成本可就高多了, 会严重影响用户的体验. 此外, 一个风险就是**循环跳转(又叫重定向死锁)**, 假设某个重定向在 A=>B=>C=>A 中无限转圈圈, 后果可想而知. 因此 HTTP 协议特别规定, 浏览器必须具有检测**循环跳转**的能力, 在发现这种情况时应当停止发送请求并给出错误提示.

![循环跳转](https://edge.yancey.app/beg/51bwhcuf-1647251501932.webp)

HTML 的 meta 有个刷新, 但也可以用到重定向, 下面的例子是 5 秒后跳转到 `http://example.com/` 这个页面.

```html
<head>
  <meta http-equiv=""Refresh"" content=""0; URL=http://example.com/"" />
</head>
```

JavaScript 也有重定向, 即 `window.location = ""http://example.com/"";`;

它们的优先级如下:

1. HTTP 协议的重定向机制永远最先触发, 即便是在没有传送任何页面, 也就没有页面被客户端读取的情况下.
2. HTML 的重定向机制会在 HTTP 协议重定向机制未设置的情况下触发.
3. JavaScript 的重定向机制总是作为最后诉诸的手段, 并且只有在客户端开启了 JavaScript 的情况下才起作用.

### 外部重定向和内部重定向

- 外部重定向: 服务器会把重定向的地址给浏览器, 然后浏览器再次的发起请求, 地址栏的地址变化了.
- 内部重定向: 服务器会直接把重定向的资源返给浏览器, 不需要再次在浏览器发起请求, 地址栏的地址不变.

## 其他

较早版本的 Chrome(66 之前)可以使用 **chrome://cache** 检查本地缓存, 但因为存在安全隐患, 现在已经不能用了.

**no-cache** 属性可以理解为 **max-age=0,must-revalidate**.

除了 **Cache- Control** 服务器也可以用, **Expires** 字段来标记资源的有效期, 它的形式和 Cookie 的差不多, 同样属于 **过时**的属性, 优先级低于 **Cache_Control**. 还有一个历史遗留字段 **Pragma: no-cache**, 它相当于 **Cache- Control: no-cache**, 除非为了兼容 HTTP/1.0, 否则不建议使用.

如果响应报文里提供了 **Last-modified** 但没有 **Cache-Control** 或 **Expires** 浏览器会使用**启发**(Heuristic)算法计算一个缓存时间, 在 RFC 里的建议是: **(Date - Last-Modified) \* 10%**.

每个 Web 服务器对 ETag 的计算方法都不一样只要保证数据变化后值不一样就好, 但复杂的计算会增加服务器的负担. Nginx 的算法是**修改时间 + 长度**, 实际上和 Last-modified 基本等价.

有的缓存代理在命中缓存时, 会在响应头中加入一个 Age 字段, 表示报文的时候生存时间, 即已经在缓存里存了多久, 通常这个值会小于 Cache-Control 里的 max-age, 如果大于就认为数据是陈旧的.

判断缓存是否命中类似于查询 hash 表, 使用的 可以通常就是 URI, 在 Nginx 里可以用 proxy_cache_key 来自定义.

Nginx 对 Vary 的处理实际是做了 MD5, 把 Vary 头摘要后写入缓存, 请求时不仅比较 URI, 还要比较摘要.

![age 字段](https://edge.yancey.app/beg/2j1lhnyb-1647765693311.jpg)

## 总结

最后用一张图总结缓存机制:

![缓存机制](https://edge.yancey.app/beg/6.jpg)

## 参考

《图解 HTTP》 -- 上野 宣

[HTTP 协议知识点总结](https://ddduanlian.github.io/2018/06/22/http_note/)

[【前端词典】从输入 URL 到展现涉及哪些缓存环节(非常详细)](https://juejin.im/post/5c6e77da6fb9a049db73bb07)

[HTTP Keep-Alive 是什么? 如何工作?](http://www.nowamagic.net/academy/detail/23350305)

[一文读懂 http 缓存(超详细)](https://www.jianshu.com/p/227cee9c8d15)

[深入理解浏览器的缓存机制](https://www.jianshu.com/p/54cc04190252)
","2025-02-02 03:08:43.569809","2025-02-02 03:08:43.569809"
"e75360e4-de3c-427d-bc2c-3fc796cb212c","{JavaScript,""JavaScript 模块""}",0,0,False,"https://edge.yancey.app/beg/1_6Nvt8ulmOMKJobZ2MCzMJQ.png","简析 AMD / CMD / UMD / CommonJS / ES Module","现代的前端项目一般都在采用 ES Module, 不过对于配置文件大多都在使用 CommonJS, 这边文章简析 AMD / CMD / CommonJS / ES Module 的发展史与异同.","## CommonJS 和 ES Module 的区别

CommonJS 模块输出的是一个**值的拷贝**, ES6 模块输出的是**值的引用**

下面的例子, mod.incCounter() 不会影响 mod.counter, 对于基本数据类型, CommonJS 模块无论加载多少次, 都只会在第一次加载时运行一次, 以后再加载, 返回的都是第一次运行结果的缓存, 除非手动清除系统缓存.

```ts
// lib.js
var counter = 3
function incCounter() {
  counter++
}
module.exports = {
  counter: counter,
  incCounter: incCounter,
}

// main.js
var mod = require('./lib')
console.log(mod.counter) // 3
mod.incCounter()
console.log(mod.counter) // 3
```

如果是个对象, 修改里面的值, 会影响原对象.

```ts
// lib.js
var obj = { name: 'Yancey', age: 18 }
function incCounter() {
  obj.name = 'Leo'
}
module.exports = {
  obj: obj,
  incCounter: incCounter,
}

// main.js
var mod = require('./lib')
console.log(mod.obj) // { name: 'Yancey', age: 18 }
mod.incCounter()
console.log(mod.obj) // { name: 'Leo', age: 18 }
```

如果把对象改成其他类型, 原变量不受响应.

```ts
// lib.js
var obj = { name: 'Yancey', age: 18 }
function incCounter() {
  obj = '沙雕'
}
module.exports = {
  obj: obj,
  incCounter: incCounter,
}

// main.js
var mod = require('./lib')
console.log(mod.obj) // { name: 'Yancey', age: 18 }
mod.incCounter()
console.log(mod.obj) // { name: 'Yancey', age: 18 }
```

JS 引擎对脚本静态分析的时候, 遇到模块加载命令 import 就会生成一个只读引用. 等到脚本真正执行的时候, 再根据这个只读引用到被加载的模块中取值. 因此, ES6 模块是动态引用, 并且不会缓存值, 模块里的变量绑定其所在的模块.

```ts
// lib.js
export let counter = 3
export function incCounter() {
  counter++
}

// main.js
import { counter, incCounter } from './lib'
console.log(counter) // 3
incCounter()
console.log(counter) // 4
```

ES6 输入的模块变量只是一个""符号连接"", 所以这个变量是只读的, 对它重新赋值会报错

```ts
// lib.js
export let obj = {}

// main.js
import { obj } from './lib'
obj.prop = 123 // 可以
obj = {} // 报错
```

CommonJS 是**运行时加载**, 这种特性不能使用 Tree-shaking; ES6 Module 是**编译时输出接口**, 可使用 Tree-shaking

```ts
const { stat, readFile } = require('fs')

// 等价于
const _fs = require('fs')
const stat = _fs.stat
const readFile = _fs.readFile
```

## AMD

使用 `require.js`

```ts
// 定义没有依赖的模块
define(function () {
  return 模块
})

// 定义有依赖的模块
define(['module1', 'module2'], function (m1, m2) {
  return 模块
})

//引入使用模块
require(['module1', 'module2'], function (m1, m2) {
  // 使用m1/m2
})
```

## CMD

使用 `sea.js`

```ts
// 定义没有依赖的模块
define(function (require, exports, module) {
  exports.xxx = value
  module.exports = value
})

// 定义有依赖的模块
define(function (require, exports, module) {
  // 引入依赖模块(同步)
  var module2 = require('./module2')
  // 引入依赖模块(异步)
  require.async('./module3', function (m3) {})
  // 暴露模块
  exports.xxx = value
})

// 引入使用模块
define(function (require) {
  var m1 = require('./module1')
  var m4 = require('./module4')
  m1.show()
  m4.show()
})
```

## CMD 和 AMD 的异同

- 相同点: 都是异步加载

- 不同点: AMD 依赖前置, 提前执行, js 可以方便知道依赖模块是谁, 立即加载; 而 CMD 就近依赖, 需要使用把模块变为字符串解析一遍才知道依赖了那些模块

## UMD

所谓UMD (Universal Module Definition), 就是一种 JavaScript 通用模块定义规范, 让你的模块能在 JavaScript 所有运行环境中发挥作用.
","2025-02-02 03:08:45.563091","2025-02-02 03:08:45.563091"
"bfadc0b1-71f9-4d28-8d45-a618a05051ec","{JavaScript}",0,0,False,"https://edge.yancey.app/beg/20210118152248307.png","聊一聊 ES6 的 Proxy 与 Reflect","ES5 和 ES6 致力为开发者提供 JavaScript 已有却不可调用的功能. 例如 ES5 出现的 Object.defineProperty() 使操作对象是否可枚举, 是否可写等等成为可能. 而 Proxy 和 Reflect 比 Object.defineProperty() 更加先进和高效, 知名的 Vue 3.x 将使用代理重写, 拿奖到手软的 immer 也是通过 Proxy 实现...","## Object.defineProperty() 的局限性

谈到 Proxy 就不得不提起它的大前辈 Object.defineProperty(), 我们都知道早期的 Vue 无法监听数组如 `push`, `splice` 等操作, 这是因为 Vue 内核使用了 [Object.defineProperty()](../Object/defineProperty), 它虽然能劫持数组并为其设置 getter 和 setter, 但调用 `push`, `splice` 等操作时却无法触发 setter, 虽然尤小右同学[重写了这些方法](https://github.com/vuejs/vue/blob/dev/src/core/observer/array.js), 但总有如鲠在喉的感觉.

而万众瞩目的 Vue 3.x 将使用 Proxy 重写内核, 最近拿奖拿到手软 [immer.js](https://immerjs.github.io/immer/docs/introduction) 同样是用 Proxy 编写. 当然无论是 Object.defineProperty() 还是 Proxy, 它们都是为了使“元编程”变为可能. 在深入 Proxy 之前, 首先聊一聊 Object.defineProperty() 的局限性.

![proxyVSdefineProperty.jpeg](https://edge.yancey.app/beg/proxyVSdefineProperty.jpeg)

### 拦截方式较少

相比较 Proxy 的 13 种陷阱, Object.defineProperty() 只能对如下属性操作符进行修改.

```ts
interface PropertyDescriptor {
  configurable?: boolean
  enumerable?: boolean
  value?: any
  writable?: boolean
  get?(): any
  set?(v: any): void
}
```

### 无法一次性监听对象的所有属性

Object.defineProperty() 只能通过遍历(或递归)的方式处理对象中的每个属性, 而 Proxy 直接代理整个对象.

```ts
const obj = {
  name: 'Yancey',
  age: 18,
}

Object.keys(obj).forEach((key) => {
  Object.defineProperty(obj, key, {
    enumerable: false,
  })
})
```

### 无法监听新增属性

上面的代码仅仅是对 `name` 和 `age` 做了不可枚举的处理, 如果新增一个属性, 它仍然是可以枚举的, 如果你写过 Vue, 相信你对 `Vue.set()` 一定不陌生.

```ts
obj.hobby = 'eat'
console.log(obj.propertyIsEnumerable('hobby')) // true
```

### 无法监听 push, splice 等数组方法

上面已经谈到了原因, 这里不再赘述, Vue 通过重写这些原型方法来达到可监听的目的:

```ts
import { def } from '../util/index'

const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto)

const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse',
]

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator(...args) {
    const result = original.apply(this, args)
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted)
    // notify change
    ob.dep.notify()
    return result
  })
})
```

### 兼容性

除了万恶的 IE 和早期浏览器, Proxy 都可以在项目中完美使用, 而 Object.defineProperty() 出自 ES5, 几乎现存浏览器都可以使用. 很多库也给出了兼容方案, 即高级浏览器使用 Proxy, 低级浏览器回退为 Object.defineProperty().

## 什么是代理和反射

`Proxy` 就是在访问或操作目标对象之前架设一个拦截对象, 使得 `Proxy` 对象可自定义基本操作的某些行为（如属性查找、赋值、枚举、函数调用等, `Proxy` 接受两个参数, 第一个是**目标对象**, 第二个是**陷阱函数**.

`Reflect` 提供拦截 JavaScript 操作的原生方法, 每个代理陷阱函数都有一个对应的反射方法, 每个方法都与对应的陷阱函数同名, 并且接收的参数也与之一致.

:::caution
与大多数全局对象不同, Reflect 不是一个构造函数, 因此不能将其与一个 new 运算符一起使用(类似的还有 Math).
:::

| 代理陷阱                | 被重写的行为                                                                                 | 默认行为                          |
| ----------------------- | -------------------------------------------------------------------------------------------- | --------------------------------- |
| get                     | 读取一个属性值                                                                               | Reflect.get()                     |
| set                     | 写入一个属性                                                                                 | Reflect.set()                     |
| has                     | in 操作符                                                                                    | Reflect.has()                     |
| deleteProperty          | delete 操作符                                                                                | Reflect.deleteProperty()          |
| getPropertyOf           | Object.getPropertyOf()                                                                       | Reflect.getPropertyOf()           |
| setPropertyOf           | Object.setPropertyOf()                                                                       | Reflect.setPropertyOf()           |
| isExtensible            | Object.isExtensible()                                                                        | Reflect.isExtensible()            |
| preventExtensions       | Object.preventExtensions()                                                                   | Reflect.preventExtensions()       |
| getOwnPropertyDesciptor | Object.getOwnPropertyDesciptor()                                                             | Reflect.getOwnPropertyDesciptor() |
| defineProperty          | Object.defineProperty()                                                                      | Reflect.defineProperty()          |
| ownKeys                 | Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()、Object.assign() | Reflect.ownKeys()                 |
| apply                   | 调用一个函数                                                                                 | Reflect.apply()                   |
| construct               | 用 new 调用一个函数                                                                          | Reflect.construct()               |

## 小试牛刀

下面的例子中, 给 target 对象创建一个代理对象 proxy, 当 proxy.name 被赋值时, target.name 也同时被创建; 同样地, 当修改 target 时, proxy 也会反映出相应的变化.

:::tip
需要注意的是, 代理对象 proxy 自身并不存储 name, 它只是简单的将值转发给 target 对象.
:::

```ts
const target = {}

const proxy = new Proxy(target, {})

proxy.name = 'proxy'
console.log(proxy.name) // proxy
console.log(target.name) // proxy

target.name = 'target'
console.log(proxy.name) // target
console.log(target.name) // target
```

## 使用 set 陷阱函数验证属性值

Proxy 更强大的地方在于它的第二个参数, 也就是**陷阱函数**. 接下来通过一个 set 陷阱验证属性值的例子来学习: 假设有一个对象, 该对象已经存在的属性的属性值可以是任意类型, 但新增的属性的属性值必须是 Number 类型, 否则将抛出错误. 直接上代码:

```ts
const validationSchema = {
  name: {
    validate(value) {
      return value.length > 6
    },
    message: '用户名长度不能小于6',
  },
  password: {
    validate(value) {
      return value.length > 10
    },
    message: '密码长度不能小于10',
  },
  moblie: {
    validate(value) {
      return /^1\d{10}$/.test(value)
    },
    message: '手机号格式错误',
  },
}

function validator(obj, validationSchema) {
  return new Proxy(obj, {
    set(trapTarget, key, value) {
      const validator = validationSchema[key]
      if (!validator) {
        trapTarget[key] = value
      } else if (validator.validate(value)) {
        trapTarget[key] = value
      } else {
        console.log(validator.message || '')
      }
    },
  })
}

const form = validator(form, validationSchema)
form.name = '666' // 报错
form.password = '113123123123123'
```

上面的例子中, 需要在**写入**对象时做一些拦截, 因此需要代理对象的 `set`, set 陷阱接收四个参数, 分别是:

- trapTarget: 将接收属性的对象, 即目标对象

- key: 需要写入的属性 (key 为 String 或 Symbol 类型)

- value: 需要写入的属性的属性值

- receiver: 操作发生的对象, 一般为代理对象

:::tip
这个例子似乎有了表单校验的雏形. 此外, 还可以使用 get 陷阱函数进行对象外形验证, 使用 has 陷阱函数隐藏属性, 使用 deleteProperty 陷阱函数避免属性被删除.
:::

## 原型代理

ES6 新增了两个对象方法, 分别是 [Object.getPrototypeOf()](../Object/getPrototypeOf) 和 [Object.setPrototypeOf()](../Object/setPrototypeOf), 以代替大多数浏览器厂商自行约定的属性 `__proto__`

我们知道, 一个对象的原型, 要么是一个对象, 要么到达原型链的终点, 也就是 null, 其他任何类型都会返回运行时的错误; setPrototypeOf 必须在操作没有成功的情况下返回 false, 这样会让 Object.setPrototypeOf() 抛出错误, 否则认为成功.

对于 getPrototypeOf, 它的陷阱函数接受一个参数:

- trapTarget: 需要设置原型的对象(即代理的目标对象)

对于 setPrototypeOf, 它的陷阱函数接受两个参数:

- trapTarget: 需要设置原型的对象(即代理的目标对象)

- proto: 需用被用作原型的对象

下面的例子通过返回 null 隐藏了代理对象的原型, 并且使得该原型不可被修改.

```ts
let target = {}
let proxy = new Proxy(target, {
  getPrototypeOf(trapTarget) {
    return null
  },
  setPrototypeOf(trapTarget, proto) {
    return false
  },
})

let targetProto = Object.getPrototypeOf(target)
let proxyProto = Object.getPrototypeOf(proxy)

console.log(targetProto === Object.prototype) // true
console.log(proxyProto === Object.prototype) // false
console.log(proxyProto) // null

Object.setPrototypeOf(target, {}) // 成功
Object.setPrototypeOf(proxy, {}) // 抛出异常
```

与这两个陷阱对应的是 `Reflect.getPrototypeOf()` 和 `Reflect.setPrototypeOf()`, 这两个更加个底层, 操作的是 `[[GetPrototypeOf]]` 与 `[[SetPrototypeOf]]`, 而 `getPrototypeOf` 和 `setPrototypeOf` 显然是更高级的封装.

## 对象可扩展性的陷阱函数

ES5 通过 [Object.preventExtensions()](../Object/preventExtensions) 与 [Object.isExtensible()](../Object/isExtensible) 来判断对象是否可扩展. 这里简单复习下: 前者用于禁止给对象及其原型**添加新属性**, 但不会影响已有属性的**修改**和**删除**; 后者则是判断一个对象是否可扩展.

下面的例子本身没有什么意义, 代理仍然返回了 isExtensible 与 preventExtensions 陷阱函数的默认行为. 同原型代理一样, 代理方法仍然要比高层的方法更加的底层, 它对传参的检查更加的严格.

```ts
let target = {}
let proxy = new Proxy(target, {
  isExtensible(trapTarget) {
    return Reflect.isExtensible(trapTarget)
  },
  preventExtensions(trapTarget) {
    return Reflect.preventExtensions(trapTarget)
  },
})

console.log(Object.isExtensible(target)) // true
console.log(Object.isExtensible(proxy)) // true

Object.preventExtensions(proxy)

console.log(Object.isExtensible(target)) // false
console.log(Object.isExtensible(proxy)) // false
```

## 属性描述符的陷阱函数

属性描述符的陷阱函数实际上是对 [Object.defineProperty()](../Object/defineProperty) 和 [Object.getOwnPropertyDescriptor()](../Object/getOwnPropertyDescriptor) 的代理, 它可以用来自定义创建属性描述符和查询属性描述符. 下面的例子中, 如果一个对象的 key 是 Symbol 类型, 那么不能为它设置属性描述符.

```ts
let proxy = new Proxy(
  {},
  {
    defineProperty(trapTarget, key, descriptor) {
      if (typeof key === 'symbol') {
        return false
      }
      return Reflect.defineProperty(trapTarget, key, descriptor)
    },
  },
)
Object.defineProperty(proxy, 'name', { value: 'proxy' })

console.log(proxy.name) // 'name'

let nameSymbol = Symbol('name')
// 抛出错误
Object.defineProperty(proxy, nameSymbol, {
  value: 'proxy',
})
```

## ownKeys 陷阱函数

ownKeys 陷阱拦截了内部方法 `[[OwnPropertyKeys]]`, 它允许你返回一个数组用于重写该行为, 被重写的行为可以是 [Object.key()](../Object/keys)、[Object.getOwnPropertyNames()](../Object/getOwnPropertyNames)、[Object.getOwnPropertySymbols()](../Object/getOwnPropertySymbols)、[Object.assign()](../Object/assign). 在 JS 编码习惯中, 一般约定将以**下划线打头**的属性视为私有属性, 下面的例子通过代理过滤掉所有的 “私有属性”:

```ts
const proxy = new Proxy(
  {},
  {
    ownKeys(trapTarget) {
      return Reflect.ownKeys(trapTarget).filter((key) => {
        return typeof key !== 'string' || key[0] !== '_'
      })
    },
  },
)

proxy.name = 'public property'
proxy._name = 'private property'
proxy.age = 18
proxy[Symbol('symbolName')] = 'symbol property'

Object.defineProperty(proxy, 'age', {
  enumerable: false, // age 不可枚举
})

// 原生 Object.getOwnPropertyNames() 返回一个包括不可枚举属性, 不包括 Symbol 值作为名称的属性, 不会获取到原型链上的属性的数组.
// 通过代理后, 在原生的基础上过滤掉了私有属性 _name
console.log(Object.getOwnPropertyNames(proxy)) // [ 'name', 'age' ]

// 原生 Object.keys() 返回一个不包括不可枚举属性, 不包括 Symbol 值作为名称的属性, 不会获取到原型链上的属性的数组.
// 通过代理后, 在原生的基础上过滤掉了私有属性 _name
console.log(Object.keys(proxy)) // [ 'name' ]

// 原生 Object.getOwnPropertySymbols() 返回一个包括不可枚举 Symbol 的属性, 不包括普通字符串作为名称的属性, 不会获取到原型链上的 Symbol 属性的数组.
// 当然该方法不能直观的看出是否过滤了 _name, 但本质上该私有属性 _name 已经被过滤了!
console.log(Object.getOwnPropertySymbols(proxy)) // [ Symbol(symbolName) ]
```

:::tip
目前公认的定义私有属性的方式是以下划线打头, 此外也有使用 # 作为私有属性标识符的提案, 当然使用 WeakMap 定义私有变量也是一个可行的方案, 不过都不如 TypeScript 香啊.
:::

## 使用 apply 与 construct 陷阱函数的函数代理

在所有的代理陷阱中, 只有 `apply` 和 `construct` 的代理目标必须是一个函数, 我们知道函数有两个内部方法 `[[Call]]` 和 `[[Construct]]`, 前者会在函数被直接调用时执行, 后者会在使用 new 的时候执行.

当不使用 new 调用一个函数时, apply 陷阱函数会接受以下三个参数:

- trapTarget: 被执行的函数(即代理的目标对象)

- thisArg: 调用过程中函数内部的 this 值

- argumentsList: 被传递给函数的参数数组

当使用 new 创建构造函数的一个实例时, construct 陷阱函数会接受以下两个参数:

- trapTarget: 被执行的函数(即代理的目标对象)

- argumentsList: 被传递给函数的参数数组

Reflect.construct() 方法同样会接收到这两个参数, 还会收到可选的第三参数 newTarget, 如果提供了此参数, 则它就指定了函数内部的 `new.target` 值.

### 验证函数参数的有效性

考虑以下函数, 我们需要限制传递的参数都是数字类型, 因此在代理中做一层拦截, 一旦发现非数字类型的参数就抛出错误; 此外, 该函数也不能被用做构造函数, 因此一旦触发 construct 陷阱亦直接抛出错误.zz

```ts
const sum = (...arr) => arr.reduce((acc, val) => acc + val, 0)

const proxy = new Proxy(sum, {
  apply(trapTarget, thisArg, argumentsList) {
    const isNotAllNumber = argumentsList.some((val) => typeof val !== 'number')

    if (isNotAllNumber) {
      throw new TypeError('必须是数字类型的数组!')
    }

    return Reflect.apply(trapTarget, thisArg, argumentsList)
  },

  construct(trapTarget, argumentsList, newTarget) {
    throw new TypeError('该函数不能用做构造函数!')
  },
})

console.log(sum(1, 2, 3, 4)) // 10
console.log(proxy(1, 2, 'a', 4)) // 抛出错误
console.log(new proxy(1, 2, 'a', 4)) // 抛出错误
```

## 可被撤销的代理

上面所有的例子, 一旦创建了代理, 就不能再从目标对象上被解绑. 如果我们想在某些时候删除掉代理对象, 就可以使用**可被撤销的代理**.

```ts
let target = {
  name: 'target',
}

// 创建一个可被撤销的代理
let { proxy, revoke } = Proxy.revocable(target, {
  // your trap
})

console.log(proxy.name) // 'target'

revoke() // 代理被撤销
console.log(proxy.name) // 抛出错误
```

## 参考

[ES6 Proxy 可以做哪些有意思的事情？](https://mp.weixin.qq.com/s/Z3_AfTy84h-ojhljnQJqIg)
","2025-02-02 03:08:46.621115","2025-02-02 03:08:46.621115"
"575834ac-389f-405e-8ee7-9a9d0ad8a151","{WebP}",0,0,False,"https://edge.yancey.app/beg/fu971t7kv1x51.png","手摸手教你 360 度无死角 WebP 能力检测","WebP 作为当今性价比最高的图片格式之一, 广泛应用于 Web 应用, 无论是电商网站还是图片流网站, 都能看到它的身影. 但它仍不被某些浏览器所支持, 这篇文章通过三种方案, 帮你全方位扫清 WebP 能力检测.","## 什么是 WebP

WebP 是 Google 开发一种同时采用有损和无损压缩的图像格式,于 2010 年 9 月 30 日首次发布, 可用于网页上大量摄影, 半透明和图形图像. WebP 有损压缩的程度是可调的, 因此用户可以在文件大小和图像质量之间自由权衡. WebP 通常平均比 JPEG 和 JPEG 2000 多压缩 30%, 而且不会损失图像质量. 关于 WebP 格式的压缩实验, 可参考 [WebP 相对于 PNG、JPG 有什么优势？ - Hahn 的回答 - 知乎](https://www.zhihu.com/question/27201061/answer/35637827) 的回答, 这篇文章不做赘述.

WebP 除了有损和无损形式, 它还支持 Alpha 通道(图像可能具有透明度), 也支持 Animation(即动图, 可类比 GIF). 目前 Youtube 在支持 WebP 格式的浏览器中, 将**视频预览**的图像格式全部转换为 WebP; 而不支持 WebP 的浏览器如 Safari, Youtube 干脆就取消了**视频预览**的特性.

![Youtube 预览使用 WebP 格式](https://edge.yancey.app/beg/Jietu20200721-135252.jpg)

WebP 已诞生 10 年之久, 并且对于图片性能的提升肉眼可见, 但部分浏览器仍不支持. 下面是 [caniuse](https://caniuse.com/#search=WebP) 给出的数据, 可见 ~~IE~~ 和苹果系的浏览器仍不支持, 这里可能是一些技术原因, 但更多是商业因素. 因此这篇文章教你 360° 无死角 WebP 的能力检测.

![Can I use WebP?](https://edge.yancey.app/beg/Jietu20200720-202312.jpg)

## 方案一

方案一通过 JavaScript 脚本进行检测, 这里用到了 [Modernizr](https://modernizr.com/), 该库提供了大量浏览器能力检测的脚本. 我已经把 WebP 能力检测的脚本放到了 gist, 你可访问 [WebP 能力检测.js](https://gist.github.com/YanceyOfficial/5951b17d7a64906248ecb7a8074791c1) 下载.

在浏览器中执行这段脚本, 最新版的 Chrome 浏览器给 html 标签增加了 `webp`, `webp-alpha`, `webp-aniamtion`, `webp-lossless` 的类; 而 Safari 浏览器增加了 `no-webp` 的类, 因此我们在 css 中, 只要写出形如下的代码就可以了.

![支持 WebP](https://edge.yancey.app/beg/Jietu20200721-112534.jpg)

![不支持 WebP](https://edge.yancey.app/beg/Jietu20200721-112156.jpg)

```css
.no-webp .cover {
  background-image: url('image.jpg');
}

.webp .cover {
  background-image: url('image.webp');
}
```

当然如果用到 img 标签上, 你还可以这么写.

```jsx
const [supportWebP, setSupportWebP] = useState(
  document.documentElement.classList.contains('webp'),
)

return <img src={supportWebP ? 'image.webp' : 'image.jpg'} alt=""img"" />
```

Modernizr 给出的脚本做了较多的兼容, minify 后也有 1.2kb 的大小, 下面这段代码比较精简, 根据实际情况可以考虑使用. 它返回一个 Boolean 类型, 你可以把结果存到 Store 或者 LocalStorage 中, 也可以跟 Modernizr 一样, 给 html 的 class 增加一个 webp 标识. 这段代码收集到了我的工具集 [yancey-js-util](https://www.npmjs.com/package/yancey-js-util), 有兴趣也可使用 `yarn add yancey-js-util` 安装使用.

```ts
export const checkWebp = () => {
  return (
    document
      .createElement('canvas')
      .toDataURL('image/webp')
      .indexOf('data:image/webp') === 0
  )
}
```

## 方案二

第二种方式是使用 HTML5 新增的 **picture** 标签. 与 **audio**, **video** 标签类似, 它们都可以包含 **source** 标签, 用于让浏览器自行选择最优的格式来呈现. 这种方案无需 js 代码, 性能会更好一些, 但它的缺点显而易见, 即无法应用于 css 的 background-image.

```tsx
<picture>
  <source srcset=""img/image.webp"" type=""image/webp"" />
  <source srcset=""img/image.jpg"" type=""image/jpeg"" />
  <img src=""img/image.jpg"" alt=""img"" />
</picture>
```

## 方案三

方案一可以应用于 **backgroud-image** 和 **img** 标签两种场景, 似乎是一种万全之策, 但它毕竟依托于 JavaScript. 如果用户阻止浏览器使用 JS 脚本, 或者说在 SSR 服务端渲染阶段(因为这些检测脚本涉及到了 DOM 操作, 而服务端是无法操作 DOM 的), 方案一就不 ok 了.

第一种情况比较极端, 我们可以一开始就给 html 标记上 `no-js` 的 class, 当 DOM 加载完成后执行如下脚本, 如果 no-js 被移除了, 那证明 JS 没有被阻止; 否则降级处理, 代码如下所示.

```tsx
<style>
  .no-js .elementWithBackgroundImage {
    background-image: url('image.jpg');
  }
</style>

<script>
  document.documentElement.classList.remove('no-js')
</script>
```

对于 SSR 场景下, 方案二可保证所有的 img 标签都能展示最优结果, 但对于 background-image 就无能为力了. 这种情况下, 我们依然可以借助后端之力. 在 HTTP 请求头中的 accept 字段中, 我们发现了 `image/webp` 的字样, 后端接收到这个请求, 只要判断存在 `image/webp`, 就证明该浏览器支持 WebP 格式, 后端将**你的浏览器支持 WebP** 再告诉给前端, 那这个问题就迎刃而解了.

![HTTP 请求头中记录浏览器是否支持 WebP](https://edge.yancey.app/beg/Jietu20200721-153247.jpg)

下面这段代码是[我的博客](https://yanceyleo.com)中的真实案例, 项目使用了 [Next.js](https://nextjs.org) 做服务端渲染, 通过 `getServerSideProps` 方法将 `isSupportWebp` 返回给前端, 进而前端判断是否有能力展示 WebP 格式的图片.

```tsx
import React, { FC } from 'react'
import { GetServerSidePropsContext } from 'next'
import Layout from 'src/containers/Layout/Layout'
import HomeContainer from 'src/containers/Home/Home'

interface Props {
  isSupportWebp: boolean
}

// 前端以 props 的形式获取该浏览器是否支持 WebP
const Index: FC<Props> = ({ isSupportWebp }) => {
  return (
    <Layout>
      <HomeContainer isSupportWebp={isSupportWebp} />
    </Layout>
  )
}

// 后端判断该浏览器是否支持 WebP
export const getServerSideProps = async (ctx: GetServerSidePropsContext) => {
  return {
    props: {
      isSupportWebp: ctx.req.headers.accept?.includes('image/webp'),
    },
  }
}

export default Index
```

## 小结

Emmmm, 没啥可小结的, 还是希望各位浏览器大大们早日统一吧.

## 参考

- [Using WebP Images](https://css-tricks.com/using-webp-images/)

- [WebP 相对于 PNG、JPG 有什么优势？](https://www.zhihu.com/question/27201061)

- [探究 WebP 一些事儿](https://aotu.io/notes/2016/06/23/explore-something-of-webp/index.html)
","2025-02-02 03:08:49.720889","2025-02-02 03:08:49.720889"
"e5cf2569-3b59-424b-983c-4d0994c4d33f","{JavaScript,""Server-Sent Events"",""Web APIs""}",0,0,False,"https://edge.yancey.app/beg/sse-diagram.png","浅谈 Server-Sent Events","前几天看到 Twitter 点赞区域蹦哒的很可爱, 于是乎想研究研究怎么实现的. 一开始下意识以为是 WebSocket, 但是在控制台死活没找到相关的信息, 去 stackoverflow 问了下原来是 Server-Sent Events, 本文对此做个介绍.","![万能的推特](https://edge.yancey.app/beg/Screen%20Shot%202021-03-21%20at%2010.45.19%20PM.png)

## 什么是 Server-Sent Events

Server-Sent Events 是一种服务器推送技术, 使客户端可以通过 **HTTP 连接**从服务器自动接收更新. 每个通知以**文本流(文本应该为 utf-8)**的形式发送, 并以一对**换行符**结尾. 与 WebSocket 相比:

1. 它不是全双工的, 只能服务器向浏览器发送, 因为流信息本质上就是下载, 一旦连接后不能再次发送请求(否则就变成了一次新的连接)
2. WebSocket 使用的 ws 协议, 而 SSE 使用的仍然是 HTTP 协议.

## SSE 的特点

这里直接抄袭阮一峰聚聚的:

- SSE 使用 HTTP 协议, 现有的服务器软件都支持. WebSocket 是一个独立协议.
- SSE 属于轻量级, 使用简单；WebSocket 协议相对复杂.
- SSE 默认支持断线重连, WebSocket 需要自己实现.
- SSE 一般只用来传送文本, 二进制数据需要编码后传送, WebSocket 默认支持传送二进制数据.
- SSE 支持自定义发送的消息类型.

## 来个例子

无码言屌, 下面我们通过一个例子来演示怎么使用 SSE. 首先看客户端的代码, 通过 new 一个 EventSource 来创建 SSE 实例, 第一个参数为后端接口, 第二个 option 参数只有一个 `withCredentials`, 如果为 true, 在跨域的情况下, 可被允许发送 cookie.

```ts
const evtSource = new EventSource(""http://localhost:3002/sse"", {
  withCredentials: true,
});
```

EventSource 可以监听三种事件, 分别是 `onopen`, `onmessage`, `onerror`, 第一个和第三个不用多说, 分别是**建立连接成功**和**建立连接失败**(CORS 或者请求超时等等). 而 `onmessage` 最重要, 它用来监听每次推送的信息流.

因为 SSE 接收的只能是 utf-8 的纯文本, 因此最通用的做法是后端传递一个 **JSON 字符串**. 下面的代码中, 每次接收到新的推送, 就会打印出 like_count, 直到 like_count > 10, 客户端会主动要求服务端停止推送.

```ts
interface Data {
  payload: { like_count: number };
}

evtSource.addEventListener(""message"", (e: MessageEvent) => {
  const {
    payload: { like_count },
  }: Data = JSON.parse(e.data);

  console.log(like_count);

  if (like_count > 10) {
    evtSource.close();
  }
});
```

上面基本就是客户端要做的事情了, 很简单, 下面看下服务端的. 因为 nestjs 封装了对 SSE 的支持, 这里就用这个框架搞下.

事件流仅仅是一个简单的文本数据流, 文本应该使用 UTF-8 格式的编码. 每条消息后面都由一个空行作为分隔符. 每条消息是由多个字段组成的, 每个字段由**字段名, 一个冒号, 以及字段值组成**.

规范中支持四个字段, 分别是:

- event: 该字段为 onmessage 的子集, 也就是说你可以通过 `evtSource.addEventListener(""customEvt"", () => {}` 来细粒度监听指定 event 的推送.

- data: 也就是传递的实体, 如果该条消息包含多个 data 字段, 则客户端会用换行符把它们连接成一个字符串来作为字段值.

- id 可以给每次推送增加一个 id 标识, 比如是 tweetId, 这样就可以把实体中的 likeCount 跟 tweetId 一一映射.

- retry: 指定浏览器重新发起连接的时间间隔, 它是一个整数值, 指定了重新连接的时间(单位为毫秒), 如果不是正整数将被忽略

此外, 以冒号开头的行为注释行, 会被忽略, 注释行可以用来防止连接超时, 服务器可以定期发送一条消息注释行, 以保持连接不断.

```ts
: just a comment\n\n

id: 12345\n
event: addLikeCount\n
retry: 10000\n
data: {\n
data: ""likeCount"": 1,\n
data: }\n\n
```

下面直接看后端代码实现, 由于 nestjs 实现 SSE 必须用 rxjs, 所以得有点儿相关基础. 代码中每两秒吐出一次数据, 由于 nestjs 会将 data 转化为 SSE 想要的结构, data 直接写成对象即可.

```ts
import { Injectable } from ""@nestjs/common"";
import { interval } from ""rxjs"";
import { map } from ""rxjs/operators"";
import { randomSeries } from ""yancey-js-util"";

@Injectable()
export class SSEService {
  public sse() {
    let count = 1;
    return interval(2000).pipe(
      map((_) => ({
        id: randomSeries(6),
        type: ""addLikeCount"",
        data: { payload: { tweetId: randomSeries(6), likeCount: count++ } },
        retry: 10000,
      }))
    );
  }
}
```

如果没什么意外, 前端就可以看到 stream 了.

![相应体](https://edge.yancey.app/beg/Screen%20Shot%202021-03-21%20at%2011.36.29%20PM.png)

分析下响应头, 很重要的两个标志是禁止了缓存, 并且 `Content-Type: text/event-stream`.

![响应头](https://edge.yancey.app/beg/Screen%20Shot%202021-03-21%20at%2011.37.55%20PM.png)

## GraphQL 是否支持?

![GraphQL 是否支持?](https://edge.yancey.app/beg/Screen%20Shot%202021-03-21%20at%2011.49.43%20PM.png)

Emmmm, 似乎不支持, 不过 GraphQL 本身已经有了强大的 Subscriptions 系统, 也没必要支持这些玩意儿了(毕竟去年 GraphQL 支持个上传还不利索, 逃).

## Can I use SSE?

Emmmm, 除了某浏览器, 都可以用.

![can i use?](https://edge.yancey.app/beg/Screen%20Shot%202021-03-21%20at%2010.40.10%20PM.png)

## 其他

突然想到, 我在后端配置了 rateLimit. 那么前端如此频繁的获取数据, 会触发 rateLimit 吗? 答案是不会的, 因为 SSE 始终只是一条 HTTP 请求, 而 rateLimit 限制的只是重复请求.

```ts
app.use(
  rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 100,
  })
);
```

## 奉上全部代码

```ts
// 前端部分

// SSE.tsx
import { FC, useState, useEffect } from ""react"";

interface CustomEvent extends Event {
  data: string;
}

interface Data {
  payload: {
    likeCount: number;
  };
}

const SSE: FC = () => {
  const [like, setLike] = useState(0);

  const initialSSE = () => {
    const evtSource = new EventSource(""http://localhost:3002/sse"", {
      withCredentials: true,
    });

    evtSource.addEventListener(""open"", () => {
      console.log(""已开启"");
    });

    // 这里使用的便是自定义事件
    evtSource.addEventListener(""addLikeCount"", ((e: CustomEvent) => {
      const {
        payload: { likeCount },
      }: Data = JSON.parse(e.data);

      setLike(likeCount);

      if (likeCount > 10) {
        evtSource.close();
      }
    }) as EventListener);

    evtSource.addEventListener(""message"", (e: MessageEvent) => {});

    evtSource.addEventListener(""error"", (err: Event) => {
      console.log(err);
    });
  };

  useEffect(() => {
    initialSSE();
  }, []);

  return <div>{like}</div>;
};

export default SSE;

// 后端部分

// sse.module.ts
import { Module } from ""@nestjs/common"";
import { SSEController } from ""./sse.controller"";
import { SSEService } from ""./sse.service"";

@Module({
  controllers: [SSEController],
  providers: [SSEService],
})
export class SSEModule {}

// sse.controller.ts
import { Controller, MessageEvent, Sse } from ""@nestjs/common"";
import { Observable } from ""rxjs"";
import { SSEService } from ""./sse.service"";

@Controller()
export class SSEController {
  constructor(private readonly sseService: SSEService) {
    this.sseService = sseService;
  }

  @Sse(""sse"")
  public sse(): Observable<MessageEvent> {
    return this.sseService.sse();
  }
}

// sse.service.ts
import { Injectable } from ""@nestjs/common"";
import { interval } from ""rxjs"";
import { map } from ""rxjs/operators"";
import { randomSeries } from ""yancey-js-util"";

@Injectable()
export class SSEService {
  public sse() {
    let count = 1;
    return interval(2000).pipe(
      map((_) => ({
        id: randomSeries(6),
        type: ""addLikeCount"",
        data: { payload: { tweetId: randomSeries(6), likeCount: count++ } },
        retry: 10000,
      }))
    );
  }
}
```

## 参考

- [Using server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#event_stream_format)
- [Server-Sent Events 教程](https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html)
","2025-02-02 03:08:50.704026","2025-02-02 03:08:50.704026"
"c3783afc-11c3-47b6-8669-8005b6b593e8","{JavaScript}",0,0,False,"https://edge.yancey.app/beg/dark-star%20(1).jpeg","从 React 源码谈 v8 引擎对数组的内部处理","前段时间在看 Lane(以前叫做 expirationTime) 相关的代码时, 被 v8 引擎的这个注释给吸引到了. 打开研究了一番, 发现创建数组的形式不同, v8 内部的处理也不同, 因此适当的方式会对性能大有裨益, 本文做一个记录.","## 前言

这篇文章翻译自 [Elements kinds in V8](https://v8.dev/blog/elements-kinds#avoid-creating-holes), 可配合 Mathias Bynens 的一篇演讲视频 [_V8 internals for JavaScript developers_](https://www.youtube.com/watch?v=m9cTaYI95Zc) 一同观看.

```embeded
<iframe width=""100%"" height=""315"" src=""https://www.youtube.com/embed/m9cTaYI95Zc"" title=""YouTube video player"" frameborder=""0"" allow=""accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"" allowfullscreen> </iframe>
```

## 从 React 的源码说起

```ts
export function createLaneMap<T>(initial: T): LaneMap<T> {
  // Intentionally pushing one by one.
  // https://v8.dev/blog/elements-kinds#avoid-creating-holes
  const laneMap = [];
  for (let i = 0; i < TotalLanes; i++) {
    laneMap.push(initial);
  }
  return laneMap;
}
```

先简单介绍一下 `createLaneMap` 这个方法, 它是用来初始化 FiberRoot 对象中的 `eventTimes`, `expirationTimes`, `entanglements` 属性, 其中 `TotalLanes` 是常量 31, 这是因为 Lane 是由 32 位二进制来表示的, 去除二进制的前导 `0b`, 正好是长度是 31, 如 `0b0000000000000000000000000000000`.

## 正文

JavaScript 中对象的属性可以是任意类型, 这意味着它们可以是 numeric, 可以是 Symbol, 甚至你用 undefined, null, Date 等等作为 key 都无所谓. 而对于 key 是 numeric 的情形, JavaScript 引擎是做了一些优化的, 其中最典型的就是数组索引了.

在 V8 中, 具有整数名称的属性(最常见的形式是由 Array 构造函数生成的对象, 也就是 `new Array()`)会得到特别处理. 尽管在许多情况下这些数字索引属性的行为与其他属性一样, 但是 V8 出于优化目的选择将它们与非数字属性分开存储. 在内部, V8 甚至给这些属性一个特殊的名称: **元素**. 对象具有映射到**值**的**属性**, 而数组具有映射到**元素**的**索引**.

虽然这些内部代码从未直接暴露给 JavaScript 开发人员, 但它们解释了为什么某些代码模式比其他代码模式更快.

## Common element kinds

在 JavaScript 代码的运行时, V8 会对数组中的每个 element kinds 保持跟踪. 这些跟踪信息允许 V8 来对数组中的指定类型做一些优化. 举个栗子, 在你调用 reduce, map 或者 forEach 的时候, V8 可以根据数组包含的 element kinds 优化这些操作. 对于 JavaScript 来说, 它不会区分一个数字是 integers, floats, 亦或 doubles, 但在 V8 内部会有一个精确的区分.

考察下面代码: 数组一开始为 `[1, 2, 3]`, 它的 element kinds(elements kind)在 v8 引擎内部被定义成 `PACKED_SMI_ELEMENTS`; 我们追加一个浮点型数字, element kinds 变成了 `PACKED_DOUBLE_ELEMENTS`, 而当我们再追加进一个字符串类型的元素时, element kinds 变成了 `PACKED_ELEMENTS`.

```ts
const arr = [1, 2, 3]; // PACKED_SMI_ELEMENTS

arr.push(4.56); // PACKED_DOUBLE_ELEMENTS

arr.push(""x""); // PACKED_ELEMENTS
```

即便我们此时并不知道以上三种 elements kinds 的区别, 但也能隐隐感受到, v8 肯定会对纯 Int 类型元素的数组做些什么优化. 下面来具体认识一下这三种标记:

- SMI 是 **Sm**all **i**ntegers 的缩写
- 如果有双精度元素, 数组会被标记成 `PACKED_DOUBLE_ELEMENTS`
- 对于有普通类型元素的, 数组会被标记成 `PACKED_ELEMENTS`

需要注意的是, element kinds 的转换是**不可逆**的, 并且方向只能从特殊到一般, 这就意味着从 `PACKED_SMI_ELEMENTS` 可以到 `PACKED_DOUBLE_ELEMENTS`, 但反之不行, 即便你后面再把 `4.56` 移除掉, 这个数组仍然会是 `PACKED_DOUBLE_ELEMENTS`.

稍作总结, 我们可以看到 v8 为数组做了这些事:

- v8 会给每个数组指定 element kinds
- element kinds 不是一成不变的, 随着我们对数组操作, 它会在运行时发生变化
- element kinds 的转换是**不可逆**的, 并且方向只能从特殊到一般

## PACKED vs. HOLEY kinds

上面几种标记都是针对的**密集**数组. 什么是**密集**数组呢? 比如 `[1, 2, 4.56, 'x']`, 它的 length 是 4, 并且这四个位置**在初始化的时候**都有元素.

与此相反便是**稀疏**数组了, 比如下面这个例子: 原本数组为 `PACKED_ELEMENTS`, 但我们在 `arr[8]` 的位置设置了一个元素, 众所周知数组内存分配空间是按照长度来的, 这就导致 `arr[5] ~ arr[7]` 什么都没有, 对于这种数组, 它的 elements kind 被标记成了 `HOLEY_ELEMENTS`.

```ts
// HOLEY_ELEMENTS
const arr = [1, 2, 4.56, ""x""];
arr[8] = ""hahaha"";
```

v8 之所以做出这样的区别, 是因为操作一个 packed array 会比 holey array 得到更多的优化. 对于 packed array, 大多数操作可以高效的执行, 而操作 holey array, 需要额外付出昂贵的代价来检查原型链(这里后面会说到).

## elements kind 转化关系

到此为止, 基本的 elements kind 的转化关系我们就介绍完了. 当然 v8 目前一共提供了 [21 种不同的 elements kind](https://cs.chromium.org/chromium/src/v8/src/elements-kind.h?l=14&rcl=ec37390b2ba2b4051f46f153a8cc179ed4656f5d), 都在 `ElementsKind` 这个枚举类型中, 每种类型都有它不同的优化方案.

通过这张图, 我们看到转化关系是不可逆的, 且只能从特殊类型到普遍类型. 更特定的元素类型支持更细粒度的优化, 元素类型在越靠右下，对该数组的操作可能就越慢. 为了获得最佳性能, 避免不必要地转换到那些普遍类型, 坚持使用最适合情况的特定类型.

![elements kind 转化关系](https://edge.yancey.app/beg/0t8gs8apw3-1621848252686.jpg)

## Performance tips

在大多数情况下我们无需 care 这种细微的类型转换. 但是, 你可以做以下几件事来获得最大的性能.

### Avoid reading beyond the length of the array

这个很好理解, 比如一个数组 arr 的长度是 5, 但你却访问了 `arr[42]`, 因为该数组没有一个叫做 42 的属性, 因此 JavaScript 引擎必须得到原型链上查找, 直到原型链的顶端 null 为止. 一旦负载遇到这种情况, V8 就会记住""此负载需要处理特殊情况"", 并且它再也不会像读取越界之前那样快.

下面这个例子, 在读取完数组中的所有元素后, 仍再读取一个越界的元素, 才跳出循环. 可能看到这段代码你会嗤之以鼻, 因为我们几乎 100% 不会这么写, 但 jQuery 里面极少代码就用到了这种模式.

```ts
for (let i = 0, item; (item = items[i]) != null; i++) {
  doSomething(item);
}
```

取而代之, 我们用最朴素的 for 循环就够了.

```ts
const n = items.length;
for (let index = 0; index < n; index += 1) {
  const item = items[index];
  doSomething(item);
}
```

下面是原作者真实测量过的例子, 该方法传入 10000 个元素的数组, `i <= array.length` 要比 `i < array.length` 慢 6 倍(然而我测了好几遍下面的代码居然还快不少, 手动狗头).

```ts
function Maximum(array) {
  let max = 0;
  for (let i = 0; i <= array.length; i++) {
    // BAD COMPARISON!
    if (array[i] > max) max = array[i];
  }
  return max;
}
```

最后, 如果你的集合是可迭代的, 比如 NodeList, Map, Set, 使用 for...of 也是不错的选择. 而对于数组, 可以使用 forEach 等内建原型方法. 如今, 无论是 for...of 还是 forEach, 它们的性能跟传统的 for 循环已经不相上下了.

稍微扩展一下, Airbnb 的规则 [no-restricted-syntax](https://eslint.org/docs/rules/no-restricted-syntax) 屏蔽了 for...of, 理由如下. 不过我觉得 for...of 还是可以正常用, for...in 注意增加个 `hasOwnProperty` 限制就行.

> iterators/generators require regenerator-runtime, which is too heavyweight for this guide to allow them. Separately, loops should be avoided in favor of array iterations.

### Avoid elements kind transitions

上面就讲到了尽量不要进行 elements kind 的转换, 因为一旦转换了就是不可逆的. 这里有一些小知识, 尽管大家几乎 100% 不会做, 还是贴一下. 如 NaN, Infinity, -0 都会导致纯 Int 类型的数组变成 `PACKED_DOUBLE_ELEMENTS`.

```ts
const arr = [1, 2, 3, +0]; // PACKED_SMI_ELEMENTS

arr.push(NaN, Infinity, -0); // PACKED_DOUBLE_ELEMENTS
```

### Prefer arrays over array-like objects

一些在 JavaScript 中的对象 —— 尤其在 DOM 中, 有很多的类数组对象, 有时你自己也会创建类数组对象(嗯, 只在面试中见过).

```ts
const arrayLike = {};
arrayLike[0] = ""a"";
arrayLike[1] = ""b"";
arrayLike[2] = ""c"";
arrayLike.length = 3;
```

上面的代码虽然有 index, 也有 length, 但它毕竟缺少真正数组的原型方法, 即便如此, 你也可以通过 call 或者 apply 数组的语法来使用它.

```ts
Array.prototype.forEach.call(arrayLike, (value, index) => {
  console.log(`${index}: ${value}`);
});
// This logs '0: a', then '1: b', and finally '2: c'.
```

这段代码使用起来没啥问题, 但它仍然比真正的数组去调用 forEach 要慢, 因此如果有必要(比如要对该类数组进行大量的操作), 你可以先将该类数组对象转换为真正的数组, 再去做后续的操作, 也许这种牺牲空间换时间的方法是值得的.

```ts
const actualArray = Array.prototype.slice.call(arrayLike, 0); // 先转换为真正的数组

actualArray.forEach((value, index) => {
  console.log(`${index}: ${value}`);
});
// This logs '0: a', then '1: b', and finally '2: c'.
```

另一个经典的的类数组是 argument, 和上面的例子一样, 同样可以通过 call 或者 apply 来使用数组的原型方法. 但随着 ES6 的普及, 我们更应该使用**剩余参数**, 因为剩余参数是真正的数组.

```ts
const logArgs = (...args) => {
  args.forEach((value, index) => {
    console.log(`${index}: ${value}`);
  });
};
logArgs(""a"", ""b"", ""c"");
```

### Avoid polymorphism

如果你的一个方法会处理不同元素类型的数组, 它可能会导致多态操作, 这样会比操作单一元素类型的代码要慢. 举个例子来讲, 你自己写了个数组迭代器, 这个迭代器可以传入一个纯数字类型的数组, 也可以是其他乱七八糟类型的数组, 这样就是多态操作. 当然需要注意的是, 数组内建的原型方法在引擎内部已经做了优化, 不在我们的考虑范围.

下面这个例子中, each 方法先传入了 `PACKED_ELEMENTS` 类型的数组, 于是 V8 使用内联缓存(inline cache, 简称 IC) 来记住这个特定的类型. 此时 V8 会""乐观的""假定 `array.length` 和 `array[index]` 在 each 内部访问函数是**单调的**(即只有一种类型的元素). 因此如果后续传入该方法的数组仍是 `PACKED_ELEMENTS`, V8 可以复用这些先前生成的代码.

但在后面分别传入了 `PACKED_DOUBLE_ELEMENTS`, `PACKED_SMI_ELEMENTS` 类型的数组, 就会导致 `array.length` 和 `array[index]` 在 each 内部访问函数被标记为**多态的**. V8 在每次调用 each 时需要额外的检查一次 `PACKED_ELEMENTS`, 并添加一个新的 `PACKED_DOUBLE_ELEMENTS`, 这就会造成潜在的性能问题.

```ts
const each = (array, callback) => {
  for (let index = 0; index < array.length; ++index) {
    const item = array[index];
    callback(item);
  }
};
const doSomething = (item) => console.log(item);

each([""a"", ""b"", ""c""], doSomething); // PACKED_ELEMENTS

each([1.1, 2.2, 3.3], doSomething); // PACKED_DOUBLE_ELEMENTS

each([1, 2, 3], doSomething); // PACKED_SMI_ELEMENTS
```

### Avoid creating holes

这条就对应着开头 React 源码的考量了, 直接看代码. 方式一你创建了数组长度为 3 的空数组, 那这个数组是**稀疏**的, 此时这个数组会被标记成 `HOLEY_SMI_ELEMENTS`, 即便最后我们填满了数组, 他也不会是 `packed` 的, 仍然被标记成是 `holey` 的. 方式二是最优雅的, 它被标记成了 `PACKED_ELEMENTS`. 当然如果你不知道到底有多少元素, 那么就使用方式三, 即将元素 push 到一个空数组将是最好的选择.

```ts
// 方式 1 (不推荐)
const arr = new Array(3);
arr[0] = 0;
arr[1] = 1;
arr[2] = 2;

// 方式 2
const arr = [""a"", ""b"", ""c""];

// 方式 3
const arr = [];
arr.push(0);
arr.push(1);
arr.push(2);
```

## 最后

综上来讲, 这就是一篇爽文, 旨在涨涨见识. 基本百分之九十以上, 后端返回给我们的数组就已经是 `PACKED_ELEMENTS` 的类型了, 所以真正在乎这种内核级别优化的, 也就是如 React 这种牛逼的框架了. 当然还有一种情况, 我们似乎可以优化一番, 想想你刷动态规划的时候, 是不是初始化背包的时候就用了 `new Array(n).fill(false)` 这种代码呢? (手动狗头.
","2025-02-02 03:08:52.390204","2025-02-02 03:08:52.390204"
"5ed96595-4069-43d0-a3fa-9e70021d41fb","{""React 源码解析系列""}",0,0,False,"https://edge.yancey.app/beg/_1_img_885_590.jpeg","深入""时间管理大师"" —— React Scheduler","众所周知 React 的愿景就是快速响应用户, 让用户觉得够快, 不能阻塞用户的交互. 而 Scheduler 作为 React 的调度中枢, 通过划分优先级, 时间切片, 可中断、可恢复任务等策略来保证高优任务先被执行, 以提高性能. 可谓""时间管理大师"", 罗志祥本祥了.","## 什么是 Scheduler

[Scheduler](https://github.com/facebook/react/tree/master/packages/scheduler) 是内置于 React 项目下的一个包, **你只需要将任务以及任务的优先级交给它, 它就可以帮你进行任务的协调调度**. 目前 Scheduler 只被用于 React, 但团队的愿景是希望它能够更通用化.

## Scheduler 用来做什么

Scheduler 从宏观和微观对任务进行管控. 宏观上, 也就是对于多个任务, Scheduler 根据优先级来安排执行顺序; 而对于单个任务(微观上), 需要""有节制""的执行. 什么是""有节制""呢? 我们知道 JavaScript 是单线程的, 如果一个同步任务占用时间很长, 就会导致掉帧和卡顿. 因此需要把一个耗时的任务及时中断掉, 去执行更重要的任务(比如用户交互), 后续再执行该耗时任务, 如此往复. Scheduler 就是用这样的模式, 将任务细粒度切分, 来避免一直占用有限的资源执行耗时较长的任务, 实现更快的响应.

## 原理综述

为了实现**多个任务的管理** 和 **单个任务的控制**, Scheduler 引入了两个概念: **任务优先级**, **时间片**. 任务优先级让任务按照自身的紧急程度排序, 这样可以让优先级最高的任务最先被执行到. 时间片规定的是单个任务在这一帧内最大的执行时间(`yieldInterval = 5ms`), 任务一旦执行时间超过时间片, 则会被打断, 转而去执行更高优的任务, 这样可以保证页面不会因为任务执行时间过长而产生掉帧或者影响用户交互.

### 多个任务的管理

在 Scheduler 中, 任务被分成了两种: **未过期的任务**和**已过期的任务**, 分别存储在 `timerQueue` 和 `taskQueue` 两个队列中.

### 如何区分两种任务

通过任务的**开始时间(startTime)** 和 **当前时间(currentTime)** 比较:

- 当 `startTime > currentTime`, 说明未过期, 存到 `timerQueue`
- 当 `startTime <= currentTime`, 说明已过期, 存到 `taskQueue`

### 入队的任务如何排序

即便是区分了 `timerQueue` 和 `taskQueue`, 但每个队列中的任务也是有不同优先级的, 因此在入队时需要根据**紧急程度**将紧急的任务排在前面. 老版本的 React Scheduler 使用循环链表来串联, 代码比较难懂, 这里不展开.

目前源码中使用[**小顶堆**](https://algorithm.yanceyleo.com/data-structure/tree/binary-heap)这个数据结构实现, 堆是[优先队列](https://algorithm.yanceyleo.com/data-structure/queue/priority-queue)的底层实现, 它在插入或者删除元素的时候, 通过""上浮""和""下沉""操作来使元素自动排序(优先队列经常用来解决算法中 [topK](https://algorithm.yanceyleo.com/leetcode/lcof/40-get-least-numbers) 问题). 需要注意的是, 堆的元素存储在数组中, 而非链式结构. 关于二叉堆相关的逻辑本文不去展开, 有兴趣可以参考我学习[数据结构与算法](https://algorithm.yanceyleo.com)的仓库.

![小顶堆](https://edge.yancey.app/beg/lld7yvf9th-1622692950075)

回到源码, 当我们插入任务时, `timerQueue` 和 `taskQueue` 能保证元素是从小到大排序的. 那排序的依据是什么呢?

- timerQueue 中, 依据任务的开始时间(startTime)排序, 开始时间越早, 说明会越早开始, 开始时间小的排在前面. 任务进来的时候, 开始时间默认是当前时间, 如果进入调度的时候传了延迟时间, 开始时间则是当前时间与延迟时间的和.
- taskQueue 中, 依据任务的过期时间(expirationTime)排序, 过期时间越早, 说明越紧急, 过期时间小的排在前面. 过期时间根据任务优先级计算得出, 优先级越高, 过期时间越早.

### 任务的执行

- 对于 `taskQueue`, 因为里面的任务已经过期了, 需要在 workLoop 中循环执行完这些任务
- 对于 `timerQueue`, 它里面的任务都不会立即执行, 但在 workLoop 方法中会通过 `advanceTimers` 方法来检测第一个任务是否过期, 如果过期了, 就放到 `taskQueue` 中.

相较于单个任务的执行(马上会说到), 任务队列的管理属于宏观层面的范畴. 从 react-reconciler 计算的 Lane, 会被转化成 Scheduler 可识别的**任务优先级**, 然后通过它去管理任务队列中的任务顺序. 总之来讲, **就是越紧急的任务, 它就需要被优先处理**.

### 单个任务的中断及恢复

在循环 taskQueue 执行每一个任务时, 如果某个任务执行时间过长, 达到了时间片限制的时间, 那么该任务必须中断, 以便于让位给更重要的事情(如浏览器绘制), 等高优过期任务完成了, 再恢复执行该任务. Scheduler 要实现这样的调度效果需要两个角色: **任务的调度者**, **任务的执行者**. 调度者调度一个执行者, 执行者去循环 taskQueue, 逐个执行任务. 当某个任务的执行时间比较长, 执行者会根据时间片中断任务执行, 然后告诉调度者: 我现在正执行的这个任务被中断了, 还有一部分没完成, 但现在必须让位给更重要的事情, 你再调度一个执行者吧, 好让这个任务能在之后被继续执行完(任务的恢复). 于是, 调度者知道了任务还没完成, 需要继续做, 它会再调度一个执行者去继续完成这个任务. 通过执行者和调度者的配合, 可以实现任务的中断和恢复. 其实将任务挂起与恢复并不是一个新潮的概念, 它有一个名词叫做[**协程**](https://en.wikipedia.org/wiki/Coroutine), ES6 之后的生成器, 就可以用 yield 关键字来模拟协程的概念.

![time slice](https://edge.yancey.app/beg/hrn331c8no-1622697039929)

## 源码解析

以上就是 Scheduler 的核心原理, talk is cheap, 想要真正搞懂, 还是得深入源码才行. 我切了个分支专门来读[React 源码](https://github.com/learn-frame/react/blob/feature/learn-react/packages/scheduler/src/forks/SchedulerDOM.js), 看完下面的内容可以再去 GayHub 上整体复习下.

### React 和 Scheduler 优先级的转换

我们知道 React 的优先级采用的是 Lane 模型, 而 Scheduler 是一个独立的包, 有自己的一套优先级机制, 因此需要做一个转换. 这里摘录 `react-reconciler/src/ReactFiberWorkLoop.old(new).js` 中的一部分.

```javascript
let newCallbackNode;
// 同步
if (newCallbackPriority === SyncLane) {
  // 执行 scheduleSyncCallback 方法
  // 只不过要区分下 legacy 模式还是 concurrent 模式
  // scheduleSyncCallback 自己有个 syncQueue, 用来承载同步任务
  // 并交由 flushSyncCallbacks 处理这些同步任务后, 再交由下面 scheduleCallback
  // 以最高优先级让 Scheduler 调度
  if (root.tag === LegacyRoot) {
    scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root));
  } else {
    scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
  }

  // 这里我们只谈 scheduleCallback, 即以最高优先级
  // ImmediateSchedulerPriority 来执行同步任务
  if (supportsMicrotasks) {
    scheduleMicrotask(flushSyncCallbacks);
  } else {
    scheduleCallback(ImmediateSchedulerPriority, flushSyncCallbacks);
  }
  newCallbackNode = null;
} else {
  // 异步
  let schedulerPriorityLevel;
  // 需要将 lane 转换为 Scheduler 可识别的优先级
  switch (lanesToEventPriority(nextLanes)) {
    case DiscreteEventPriority:
      schedulerPriorityLevel = ImmediateSchedulerPriority;
      break;
    case ContinuousEventPriority:
      schedulerPriorityLevel = UserBlockingSchedulerPriority;
      break;
    case DefaultEventPriority:
      schedulerPriorityLevel = NormalSchedulerPriority;
      break;
    case IdleEventPriority:
      schedulerPriorityLevel = IdleSchedulerPriority;
      break;
    default:
      schedulerPriorityLevel = NormalSchedulerPriority;
      break;
  }
  // 通过 scheduleCallback 将任务及其优先级传入到 Scheduler 中
  newCallbackNode = scheduleCallback(
    schedulerPriorityLevel,
    performConcurrentWorkOnRoot.bind(null, root)
  );
}
```

### Scheduler 中的优先级

Scheduler 自身维护 6 种优先级, 不过翻了一遍源码 `NoPriority` 没被用过. 它们是计算 expirationTime 的重要依据, 而我们知道 expirationTime 事关 taskQueue 的排序. 该文件位于 `scheduler/src/SchedulerPriorities.js`.

```javascript
export const NoPriority = 0; // 没有任何优先级
export const ImmediatePriority = 1; // 立即执行的优先级, 级别最高
export const UserBlockingPriority = 2; // 用户阻塞级别的优先级, 比如用户输入, 拖拽这些
export const NormalPriority = 3; // 正常的优先级
export const LowPriority = 4; // 低优先级
export const IdlePriority = 5; // 最低阶的优先级, 可以被闲置的那种
```

### scheduleCallback

通过上面的介绍, 我们知道 Scheduler 的主入口是 `scheduleCallback`, 它**负责生成调度任务, 根据任务是否过期将任务放入 timerQueue 或 taskQueue, 然后触发调度行为, 让任务进入调度.** 注意: `enableProfiling` 用来做一些审计和 debugger, 本文不去涉及.

1. 首先计算 `startTime`, 它被用作 `timerQueue` 排序的依据, `getCurrentTime()` 用来获取当前时间, 下面会讲到.
2. 接着计算 `expirationTime`, 它被用作 `taskQueue` 排序的依据, 过期时间通过传入的优先级确定.
3. `newTask` 是 Scheduler 中任务单元的数据结构, 注释写的很清楚, 其中 `sortIndex` 是优先队列(小顶堆)中排序的依据.
4. 根据上面三步的铺垫, 这一步就是根据 `startTime` 和 `currentTime` 的关系将任务放到 timerQueue 或 taskQueue 之中, 然后触发调度行为.

```javascript
function unstable_scheduleCallback(priorityLevel, callback, options) {
  /*
   * (1
   */
  var currentTime = getCurrentTime();

  // timerQueue 根据 startTime 排序
  // 任务进来的时候, 开始时间默认是当前时间, 如果进入调度的时候传了延迟时间
  // 开始时间则是当前时间与延迟时间的和
  var startTime;
  if (typeof options === ""object"" && options !== null) {
    var delay = options.delay;
    if (typeof delay === ""number"" && delay > 0) {
      startTime = currentTime + delay;
    } else {
      startTime = currentTime;
    }
  } else {
    startTime = currentTime;
  }

  /*
   * (2
   */
  // taskQueue 根据 expirationTime 排序
  var timeout;
  switch (priorityLevel) {
    case ImmediatePriority:
      timeout = IMMEDIATE_PRIORITY_TIMEOUT; // -1
      break;
    case UserBlockingPriority:
      timeout = USER_BLOCKING_PRIORITY_TIMEOUT; // 250
      break;
    case IdlePriority:
      timeout = IDLE_PRIORITY_TIMEOUT; // 1073741823 (2^30 - 1)
      break;
    case LowPriority:
      timeout = LOW_PRIORITY_TIMEOUT; // 10000
      break;
    case NormalPriority:
    default:
      timeout = NORMAL_PRIORITY_TIMEOUT; // 5000
      break;
  }

  // 计算任务的过期时间, 任务开始时间 + timeout
  // 若是立即执行的优先级(IMMEDIATE_PRIORITY_TIMEOUT(-1))
  // 它的过期时间是 startTime - 1, 意味着立刻就过期
  var expirationTime = startTime + timeout;

  /*
   * (3
   */
  // 创建调度任务
  var newTask = {
    id: taskIdCounter++,
    callback, // 调度的任务
    priorityLevel, // 任务优先级
    startTime, // 任务开始的时间, 表示任务何时才能执行
    expirationTime, // 任务的过期时间
    sortIndex: -1, // 在小顶堆队列中排序的依据
  };

  if (enableProfiling) {
    newTask.isQueued = false;
  }

  /*
   * (4
   */
  // startTime > currentTime 说明任务无需立刻执行
  // 故放到 timerQueue 中
  if (startTime > currentTime) {
    // timerQueue 是通过 startTime 判断优先级的,
    // 故将 startTime 设为 sortIndex 作为优先级依据
    newTask.sortIndex = startTime;
    push(timerQueue, newTask);

    // 如果 taskQueue 是空的, 并且当前任务优先级最高
    // 那么这个任务就应该优先被设为 isHostTimeoutScheduled
    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
      // 如果超时调度已经在执行了, 就取消掉
      // 因为当前这个任务是最高优的, 需要先处理当前这个任务
      if (isHostTimeoutScheduled) {
        cancelHostTimeout();
      } else {
        isHostTimeoutScheduled = true;
      }
      // Schedule a timeout.
      requestHostTimeout(handleTimeout, startTime - currentTime);
    }
  } else {
    // startTime <= currentTime 说明任务已过期
    // 需将任务放到 taskQueue
    newTask.sortIndex = expirationTime;
    push(taskQueue, newTask);

    if (enableProfiling) {
      markTaskStart(newTask, currentTime);
      newTask.isQueued = true;
    }

    // 如果目前正在对某个过期任务进行调度,
    // 当前任务需要等待下次时间片让出时才能执行
    if (!isHostCallbackScheduled && !isPerformingWork) {
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
    }
  }

  return newTask;
}
```

### getCurrentTime

顾名思义, getCurrentTime 用来获取当前时间, 它优先使用 [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now), 否则使用 `Date.now()`. 提起 performance 我们并不陌生, 它主要被用来收集性能指标. `performance.now()` 返回一个精确到毫秒的 `DOMHighResTimeStamp`(emmm, 一看到 HighRes 就想起大法).

![Sony Hi-Res](https://edge.yancey.app/beg/rc3v7cruxx-1622531131004)

```javascript
let getCurrentTime;
const hasPerformanceNow =
  typeof performance === ""object"" && typeof performance.now === ""function"";

if (hasPerformanceNow) {
  const localPerformance = performance;
  getCurrentTime = () => localPerformance.now();
} else {
  const localDate = Date;
  const initialTime = localDate.now();
  getCurrentTime = () => localDate.now() - initialTime;
}
```

稍微看了下 [chromium 源码](https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/timing/performance.cc;l=1107;drc=28684b63b1e1ece5396dc0e4c03118855710a75f;bpv=1;bpt=1)(反正也看不懂啦),
大抵就是说 `performance.now()` 是个单调递增的时间(`monotonic_time`), 这保证了两个调用之间的差永远不会是负的;
此外还看到通过 `time_lower_digits` 和 `time_upper_digits` 来做了一些降噪处理, 保证计算结果不会太突兀. 此外还有什么[粗化时间算法(coarsen time algorithm)](https://w3c.github.io/hr-time/#dfn-coarsen-time)就更尼玛看不懂了.

```c++
DOMHighResTimeStamp Performance::now() const {
  return MonotonicTimeToDOMHighResTimeStamp(tick_clock_->NowTicks());
}
```

### requestHostTimeout 和 cancelHostTimeout

显然这是一对相爱相杀的好基友. 为了让一个**未过期**的任务能够到达**恰好过期**的状态, 那么需要延迟 `startTime - currentTime` 毫秒就可以了(其实它俩的差就是 XXX_PRIORITY_TIMEOUT), `requestHostTimeout` 就是来做这件事的, 而 `cancelHostTimeout` 就是用来取消这个超时函数的.

```javascript
function requestHostTimeout(callback, ms) {
  taskTimeoutID = setTimeout(() => {
    callback(getCurrentTime());
  }, ms);
}

function cancelHostTimeout() {
  clearTimeout(taskTimeoutID);
  taskTimeoutID = -1;
}
```

### handleTimeout

`requestHostTimeout` 的第一个参数是 `handleTimeout`, 让我们来看看它是来做什么的. 首先调用了 advanceTimers 方法, 这个方法下面具体说, 它主要是用来**更新 timerQueue 和 taskQueue 两个序列, 如果发现 timerQueue 有过期的, 就放到 taskQueue 中**. 接下来如果没有正在调度任务, 就看看 taskQueue 中是否存在任务, 如果有的话就先 flush 掉; 否则就递归执行 `requestHostTimeout(handleTimeout, ...)`. 总之来讲, 这个方法就是要把 timerQueue 中的任务转移到 taskQueue 中.

```javascript
function handleTimeout(currentTime) {
  isHostTimeoutScheduled = false;
  // 更新 timerQueue 和 taskQueue 两个序列
  // 如果发现 timerQueue 有过期的, 就放到 taskQueue 中
  advanceTimers(currentTime);

  // 检查是否已经开始调度
  // 如果正在调度, 就什么都不做
  if (!isHostCallbackScheduled) {
    // 如果 taskQueue 中有任务, 那就先去执行已过期的任务
    if (peek(taskQueue) !== null) {
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
    } else {
      // 如果没有过期任务, 那就接着对最高优的第一个未过期的任务
      // 继续重复这个过程, 直到它可以被放置到 taskQueue
      const firstTimer = peek(timerQueue);
      if (firstTimer !== null) {
        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
      }
    }
  }
}
```

### advanceTimers

这个方法就是用来检查 timerQueue 中的过期任务, 放到 taskQueue. 主要是对小顶堆的各种操作, 直接看注释即可.

```javascript
function advanceTimers(currentTime) {
  let timer = peek(timerQueue);
  while (timer !== null) {
    if (timer.callback === null) {
      // Timer was cancelled.
      pop(timerQueue);

      // 开始时间小于等于当前时间, 说明已过期,
      // 从 taskQueue 移走, 放到 taskQueue
    } else if (timer.startTime <= currentTime) {
      pop(timerQueue);
      // taskQueue 是通过 expirationTime 判断优先级的,
      // expirationTime 越小, 说明越紧急, 它就应该放在 taskQueue 的最前面
      timer.sortIndex = timer.expirationTime;
      push(taskQueue, timer);

      if (enableProfiling) {
        markTaskStart(timer, currentTime);
        timer.isQueued = true;
      }
    } else {
      // 开始时间大于当前时间, 说明未过期, 任务仍然保留在 timerQueue
      // 任务进来的时候, 开始时间默认是当前时间, 如果进入调度的时候传了延迟时间, 开始时间则是当前时间与延迟时间的和
      // 开始时间越早, 说明会越早开始, 排在最小堆的前面
      // Remaining timers are pending.
      return;
    }
    timer = peek(timerQueue);
  }
}
```

### requestHostCallback

不管你接没接触过 React 源码, 想必也听到过**时间切片, 任务中断可恢复**这些概念. `requestHostCallback` 这个方法就是用来调度任务的. 既然是""调度"", 那势必得有指挥的和干活的.

旧的 React 版通过 `requestAnimationFrame` 和 `requestIdleCallback` 进行任务调度与帧对齐, 但在 [[scheduler] Yield many times per frame, no rAF #16214](https://github.com/facebook/react/pull/16214/commits) 这个 pr 中, 这种方式被废弃了. 如果你看过我以前的一篇文章 [剖析 requestAnimationFrame](https://www.yanceyleo.com/post/20506b75-0a04-450d-aeec-6ea08ef25116), 就会发现 rAF 是会受到用户行为的干扰的, 比如切换选项卡, 滚动页面等. 看下面这张图, 前面一部分的斜率大抵就是 `16.7`, 也就是 `1 / 60`, 但我切换了选项卡之后, 帧刷新率立马不稳定了.

![rAF 受到干扰](https://edge.yancey.app/beg/77bab955-9126-4260-89e9-a89b45970fbe.jpg)

此外, rAF 毕竟仰仗显示器的刷新频率, 而市面上的刷新频率层次不齐, 有 60Hz 的, 像苹果的 ProMotion 就到了 120Hz, ~~再加上好的显卡都被拿去挖矿了~~, 兼容起来实在麻烦. 简言之, 这种方式会受到外界因素影响, 无法使 Scheduler 做到百分百掌控.

`requestIdleCallback` 就不详细说了, 它可用在浏览器空闲阶段去执行一些低优先级任务, 而不会影响延迟关键事件, 如动画和输入响应. 具体使用方法可自行去看 [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback) 上的介绍.

目前最新的代码中, Scheduler 通过 MessageChannel 来人为的控制调度频率, 默认的时间切片是 5ms, 可见这个粒度比 ProMotion 还要高. 如果你以前没听说过 MessageChannel, 但一定得听说过 postMessage 这家伙, 它经常被用做宿主跟 iframe 之间的通信. 此外它兼容性上也是好到没朋友.

![MessageChannel](https://edge.yancey.app/beg/hstk3fzgbq-1622612290323)

铺垫的都说完了, 直接看源码. 它做了一波兼容, 如果是 Node.js 或者低端 IE, 就使用 `setImmediate`, 这块不展开说. 在正经的浏览器环境下(IE: 你直接念我身份证好了), 我们通过 MessageChannel 创建一个实例 channel, 该实例有两个 port, 用来互相通信. Scheduler 通过 port2 发送消息(`port.postMessage`), 通过 port1 来接收消息(`port1.onmessage`). 因此, port2 就是那个调度者, port1 是那个收到调度信号真正干活的.

```javascript
let schedulePerformWorkUntilDeadline;

if (typeof setImmediate === ""function"") {
  schedulePerformWorkUntilDeadline = () => {
    setImmediate(performWorkUntilDeadline);
  };
} else {
  const channel = new MessageChannel();
  const port = channel.port2;

  // port1 接收调度信号, 来执行 performWorkUntilDeadline(受)
  channel.port1.onmessage = performWorkUntilDeadline;

  // port 是调度者(攻)
  schedulePerformWorkUntilDeadline = () => {
    port.postMessage(null);
  };
}
```

`requestHostCallback` 将传进来的 `callback` 赋值给全局变量 `scheduledHostCallback`, 如果当前 `isMessageLoopRunning` 是 false, 即没有任务调度, 就把它开启, 然后发送调度信号给 port1 进行调度.

```javascript
function requestHostCallback(callback) {
  scheduledHostCallback = callback;
  if (!isMessageLoopRunning) {
    isMessageLoopRunning = true;

    // postMessage, 告诉 port1 来执行 performWorkUntilDeadline 方法
    schedulePerformWorkUntilDeadline();
  }
}
```

### performWorkUntilDeadline

`performWorkUntilDeadline` 是任务的执行者, 也就是 port1 接收到信号后需要执行的函数, **它用来在时间片内执行任务, 如果没执行完, 用一个新的调度者继续调度**. 首先判断是否有 `scheduledHostCallback`, 如果存在说明存在需要被调度的任务. 计算 deadline 为当前时间加上 yieldInterval(也就是那 5ms). 看到这里相必你就恍然大悟了, deadline 其实就来做时间切片! 接下来设置了一个常量 `hasTimeRemaining` 为 true, 看到这俩名字你是不是想起了 `requestIdleCallback` 的用法了呢. 至于为什么 `hasTimeRemaining` 为 true, 因为不管你的整个任务是否执行完, 给你的时间就是 5ms, 要么超时就中断, 要么不超时就恰好执行完了, 总之时间切片内一定是有剩余时间的.

后面的逻辑直接看代码注释即可, 总结来讲就是任务在时间切片内没有被执行完, 就需要让调度者再次调度一个执行者继续执行任务, 否则这个任务就算执行完了. **判断一个任务执行完成的标记是 hasMoreWork 字段, 下面 workLoop 会讲到**.

```javascript
const performWorkUntilDeadline = () => {
  if (scheduledHostCallback !== null) {
    const currentTime = getCurrentTime();
    // 时间分片
    deadline = currentTime + yieldInterval;
    const hasTimeRemaining = true;

    let hasMoreWork = true;
    try {
      // scheduledHostCallback 去执行真正的任务
      // 如果返回 true, 说明当前任务被中断了
      // 会再让调度者调度一个执行者继续执行任务
      // 下面讲 workLoop 方法时会说到中断恢复的逻辑, 先留个坑
      hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
    } finally {
      if (hasMoreWork) {
        // 如果任务中断了(没执行完), 就说明 hasMoreWork 为 true
        // 这块类似于递归, 就再申请一个调度者来继续执行该任务
        schedulePerformWorkUntilDeadline();
      } else {
        // 否则当前任务就执行完了
        // 关闭 isMessageLoopRunning
        // 并将 scheduledHostCallback 置为 null
        isMessageLoopRunning = false;
        scheduledHostCallback = null;
      }
    }
  } else {
    isMessageLoopRunning = false;
  }
  // Yielding to the browser will give it a chance to paint, so we can
  // reset this.
  needsPaint = false;
};
```

### flushWork

我们早在 `requestHostCallback` 就将 `flushWork` 作为参数赋值给了全局变量 `scheduledHostCallback`, 在上面 `performWorkUntilDeadline` 也调用了该方法, 让我们看看 `flushWork` 用来做什么. 顾名思义, `flushWork` 就是把任务""冲刷""掉, ~~就好比 taskQueue 是马桶, 里面的任务是那啥, flushWork 就是冲水那套机制~~. 当然剖丝抽茧, 该方法的核心就是 return 了 `workLoop`.

```javascript
function flushWork(hasTimeRemaining, initialTime) {
  if (enableProfiling) {
    markSchedulerUnsuspended(initialTime);
  }

  // 由于 requestHostCallback 并不一定立即执行传入的回调函数
  // 所以 isHostCallbackScheduled 状态可能会维持一段时间
  // 等到 flushWork 开始处理任务时, 则需要释放该状态以支持其他的任务被 schedule 进来
  isHostCallbackScheduled = false;

  // 因为已经在执行 taskQueue 的任务了
  // 所以不需要等 timerQueue 中的任务过期了
  if (isHostTimeoutScheduled) {
    isHostTimeoutScheduled = false;
    cancelHostTimeout();
  }

  isPerformingWork = true;
  const previousPriorityLevel = currentPriorityLevel;
  try {
    if (enableProfiling) {
      try {
        return workLoop(hasTimeRemaining, initialTime);
      } catch (error) {
        if (currentTask !== null) {
          const currentTime = getCurrentTime();
          markTaskErrored(currentTask, currentTime);
          currentTask.isQueued = false;
        }
        throw error;
      }
    } else {
      // No catch in prod code path.
      return workLoop(hasTimeRemaining, initialTime);
    }
  } finally {
    // 执行完任务后还原这些全局状态
    currentTask = null;
    currentPriorityLevel = previousPriorityLevel;
    isPerformingWork = false;
    if (enableProfiling) {
      const currentTime = getCurrentTime();
      markSchedulerSuspended(currentTime);
    }
  }
}
```

### 任务中断与恢复 —— workLoop

终于到了尾声, workLoop 可谓是集大成者, 承载了任务中断, 任务恢复, 判断任务完成等功能.

- 循环 taskQueue 执行任务
- 任务状态的判断
  - 如果 taskQueue 执行完成了, 就返回 false, 并从 timerQueue 中拿出最高优的来做超时调度
  - 如果未执行完, 说明当前调度发生了中断, 就返回 true, 下次接着调度(这个 Boolean 类型的返回值, 其实就对应着 `performWorkUntilDeadline` 中的 hasMoreWork)

```javascript
function workLoop(hasTimeRemaining, initialTime) {
  let currentTime = initialTime;

  // 因为是个异步的, 需要再次调整一下 timerQueue 跟 taskQueue
  advanceTimers(currentTime);

  // 最紧急的过期任务
  currentTask = peek(taskQueue);
  while (
    currentTask !== null &&
    !(enableSchedulerDebugging && isSchedulerPaused) // 用于 debugger, 不管
  ) {
    // 任务中断!!!
    // 时间片到了, 但 currentTask 未过期, 跳出循环
    // 当前任务就被中断了, 需要放到下次 workLoop 中执行
    if (
      currentTask.expirationTime > currentTime &&
      (!hasTimeRemaining || shouldYieldToHost())
    ) {
      // This currentTask hasn't expired, and we've reached the deadline.
      break;
    }

    const callback = currentTask.callback;
    if (typeof callback === ""function"") {
      // 清除掉 currentTask.callback
      // 如果下次迭代 callback 为空, 说明任务执行完了
      currentTask.callback = null;

      currentPriorityLevel = currentTask.priorityLevel;

      // 已过期
      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;

      if (enableProfiling) {
        markTaskRun(currentTask, currentTime);
      }

      // 执行任务
      const continuationCallback = callback(didUserCallbackTimeout);
      currentTime = getCurrentTime();

      // 如果产生了连续回调, 说明出现了中断
      // 故将新的 continuationCallback 赋值 currentTask.callback
      // 这样下次恢复任务时, callback 就接上趟了
      if (typeof continuationCallback === ""function"") {
        currentTask.callback = continuationCallback;

        if (enableProfiling) {
          markTaskYield(currentTask, currentTime);
        }
      } else {
        if (enableProfiling) {
          markTaskCompleted(currentTask, currentTime);
          currentTask.isQueued = false;
        }
        // 如果 continuationCallback 不是 Function 类型, 说明任务完成!!!
        // 否则, 说明这个任务执行完了, 可以被弹出了
        if (currentTask === peek(taskQueue)) {
          pop(taskQueue);
        }
      }

      // 上面执行任务会消耗一些时间, 再次重新更新两个队列
      advanceTimers(currentTime);
    } else {
      // 上面的 if 清空了 currentTask.callback, 所以
      // 如果 callback 为空, 说明这个任务就执行完了, 可以被弹出了
      pop(taskQueue);
    }

    // 如果当前任务执行完了, 那么就把下一个最高优的任务拿出来执行, 直到清空了 taskQueue
    // 如果当前任务没执行完, currentTask 实际还是当前的任务, 只不过 callback 变成了 continuationCallback
    currentTask = peek(taskQueue);
  }

  // 任务恢复!!!
  // 上面说到 ddl 到了, 但 taskQueue 还没执行完(也就是任务被中断了)
  // 就返回 true, 这就是恢复任务的标志
  if (currentTask !== null) {
    return true;
  } else {
    // 若任务完成!!!, 去 timerQueue 中找需要最早开始执行的那个任务
    // 进行 requestHostTimeout 调度那一套
    const firstTimer = peek(timerQueue);
    if (firstTimer !== null) {
      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }
    return false;
  }
}
```

### shouldYieldToHost

这个方法没啥可说的, 就是判断是否要让出主线程. 不过它引申出一个比较新潮的 API 即 `navigator.scheduling.isInputPending`, 它用来再不让出主线程的情况下提高响应能力, 不过 Chrome 90 还没有该 API, 想必这是个面向未来的. [Better JS scheduling with isInputPending()](https://web.dev/isinputpending/) 讲得不错, 可以看看.

```javascript
function shouldYieldToHost() {
  if (
    enableIsInputPending &&
    navigator !== undefined &&
    navigator.scheduling !== undefined &&
    navigator.scheduling.isInputPending !== undefined
  ) {
    const scheduling = navigator.scheduling;
    const currentTime = getCurrentTime();
    if (currentTime >= deadline) {
      // There's no time left. We may want to yield control of the main
      // thread, so the browser can perform high priority tasks. The main ones
      // are painting and user input. If there's a pending paint or a pending
      // input, then we should yield. But if there's neither, then we can
      // yield less often while remaining responsive. We'll eventually yield
      // regardless, since there could be a pending paint that wasn't
      // accompanied by a call to `requestPaint`, or other main thread tasks
      // like network events.
      // 需要绘制或者有高优先级的 I/O, 必须得让出主线程
      if (needsPaint || scheduling.isInputPending()) {
        // There is either a pending paint or a pending input.
        return true;
      }
      // There's no pending input. Only yield if we've reached the max
      // yield interval.
      return currentTime >= maxYieldInterval;
    } else {
      // There's still time left in the frame.
      return false;
    }
  } else {
    // `isInputPending` is not available. Since we have no way of knowing if
    // there's pending input, always yield at the end of the frame.

    // task 执行超过了 ddl 就应该让出主进程了
    return getCurrentTime() >= deadline;
  }
}
```

### 取消调度

在 workLoop 的代码中有一段是 `currentTask.callback = null;`, 也就是 Scheduler 以 callback 是否为 null 来判断任务被取消(或者完成了).

```javascript
function unstable_cancelCallback(task) {
  if (enableProfiling) {
    if (task.isQueued) {
      const currentTime = getCurrentTime();
      markTaskCanceled(task, currentTime);
      task.isQueued = false;
    }
  }

  // Null out the callback to indicate the task has been canceled. (Can't
  // remove from the queue because you can't remove arbitrary nodes from an
  // array based heap, only the first one.)
  task.callback = null;
}
```

### 自定义的时间切片频率

为了后续 Scheduler 独立成包, 它开放了设置时间切片的大小, 默认为 5ms, 你可以根据实际情况调整到 0 ~ 125 之间. 不过怎么把握这个度, 咱也不知道咱也不敢问.

```javascript
function forceFrameRate(fps) {
  if (fps < 0 || fps > 125) {
    // Using console['error'] to evade Babel and ESLint
    console[""error""](
      ""forceFrameRate takes a positive int between 0 and 125, "" +
        ""forcing frame rates higher than 125 fps is not supported""
    );
    return;
  }
  if (fps > 0) {
    yieldInterval = Math.floor(1000 / fps);
  } else {
    // reset the framerate
    yieldInterval = 5;
  }
}
```

## 最后

以上全部就是 Scheduler 的源码解析了, 洋洋洒洒两万余字, 一大半都是代码... 除此之外源码中还有一些通用逻辑的封装, 以及一些面向未来的特性文中没有涉及, 有兴趣可以去 GayHub 上翻源码看看. 本文基于 v17.0.2, 未来谁也没法保证它的代码会变成啥样, 先看先享受, 且行且珍惜. 后面如有大的更新, 我会尽力更新文章, 以保证和 master 对齐. 读源码这事儿, 不是一朝一夕的事儿, 也不能只一家之言, 欢迎大家拍砖提意见. 实在是画图苦手, 盗用 shockw4ver 大佬的一张流程图收尾.

![5scdbn97g8-1622629716400](https://edge.yancey.app/beg/5scdbn97g8-1622629716400)

## 参考

- [React 中的优先级管理](https://github.com/7kms/react-illustration-series/blob/master/docs/main/priority.md)
- [React 调度原理(scheduler)](https://github.com/7kms/react-illustration-series/blob/master/docs/main/scheduler.md)
- [探索 React 的内在 —— postMessage & Scheduler](https://segmentfault.com/a/1190000022942008)
- [一篇长文帮你彻底搞懂 React 的调度机制原理](https://segmentfault.com/a/1190000039101758)
- [这可能是最通俗的 React Fiber(时间分片) 打开方式](https://juejin.cn/post/6844903975112671239)

![齋藤飛鳥](https://edge.yancey.app/beg/齋藤飛鳥.gif)
","2025-02-02 03:08:53.930398","2025-02-02 03:08:53.930398"
"840ed909-7490-4faf-9e3b-98c2670d2daf","{GraphQL}",0,0,False,"https://edge.yancey.app/beg/kh9i7s9a-1632639616943.png","Introducing GraphQL","GraphQL 是一种用于 API 的查询语言, 并且提供已有数据查询的运行时, 它诞生于 2015 年, 由 Facebook 开发, 2018 年 11 月 7 日，Facebook 将 GraphQL 项目转移到新成立的 GraphQL 基金会. 目前 Facebook, Twitter, Netflix, PayPal 各厂已经在生产环境使用 GraphQL 了, GitHub API v4 也已全面使用 GraphQL.","![原则](https://edge.yancey.app/beg/ol37cccd-1632636908526.jpg)

### 精准、可预测地返回数据

传统的 RESTful 接口, 后端传递多少字段, 前端就得接收多少字段. 因此, 有时候前端只需要几个字段, 但后端返回一大串(尤其是历史悠久的接口), 这不但对前端筛选接口字段增加了难度, 还可能会造成潜在的性能问题. 而 GraphQL 使得客户端能够准确地获得它需要的数据, 而且没有任何冗余, 并且 GraphQL 筛选这些字段的过程不依赖于服务器, 而是它自己运行时.

```ts
export const POSTS = gql`
  query Posts($input: PaginationInput!) {
    posts(input: $input) {
      total
      page
      pageSize
      items {
        _id
        title
        summary
      }
    }
  }
```

```ts
@ObjectType()
export class SMSModel {
  @Field()
  @IsMobilePhone(""zh-CN"")
  @IsNotEmpty()
  public readonly phoneNumber: string;

  @Field()
  @Length(6)
  @IsNumberString()
  @IsNotEmpty()
  public readonly smsCode: string;
}
```

### 只请求一个接口

下面这个例子是一个经典的 RESTful 风格接口, 可以看到一套增删改查需要请求不同的 url, 这就导致了需要进行多个 TCP 连接. 虽然 HTTP2 提供了多路复用(同域名下所有通信都在单个连接上完成, 同个域名只需要占用一个 TCP 连接, 使用一个连接并行发送多个请求和响应)的特性. 但在网络仍然较慢的移动环境下, 我们仍希望尽可能的减少 HTTP 请求, GraphQL 的应用也能表现得足够迅速.

```ts
GET /posts
GET /post/:id
POST /post
PUT /post/:id
DELETE /post/:id
```

```ts
{
  operationName: ""Posts"",
  query: ""..."",
  variables: {
    input: {
      page: 1,
      pageSize: 10,
    },
  },
}
```

## SDL(schema definition languages)

### Type Language

GraphQL 不依赖于任何编程语言, 因为我们并不依赖于任何特定语言的句法句式, 它有自己的一套模式.

```graphql
type Language {
  code: String!
  name: String!
  native: String!
}

type Location {
  geoname_id: Float!
  capital: String!
  languages: [Language!]!
  country_flag: String!
  country_flag_emoji: String!
  country_flag_emoji_unicode: String!
  calling_code: String!
  is_eu: Boolean!
  created_at: DateTime!
}
```

1. `Language` 代表 GraphQL `对象类型`, 一般用来约定后端的 response.
2. `code`, `name`, `native` 是 `Language` 类型上的`字段`, 这意味着你在查询 `Language` 时只能查找这三个字段中的一个或多个, 查找任何其他字段将会报错.
3. `code: String!` 意味着 `code` 的**标量**是 `String`, 感叹号意味着该字段是非空的, 如果后端返回改字段是空的, 也会报错.
4. `languages: [Language!]!` 意味着 `languages` 的类型是 `Language 数组`, 且该数组不能为空.

```graphql
type Query {
  getPosts(input: PaginationInput!): PostModel!
}

type Mutation {
  createPost(input: CreatePostInput!): PostItemModel!
}

input CreatePostInput {
  posterUrl: String!
  title: String!
  summary: String!
  content: String!
  tags: [String!]!
  lastModifiedDate: String!
  isPublic: Boolean
}
```

`Query` 和 `Mutation` 是两个内置的特殊类型, 你可以将其理解为 RESTful 中的 `GET` 和 `POST`, 前者用于查询, 后者用于增删改. 虽然使用 `Query` 可以进行增删改, 但为了语义化, 建议分开使用.

第一个语句定义一个查询, `getPost` 可以类比为 RESTful 接口中的路径; 而 `input` 则可以类比放在 body 中的参数, 它是 `CreatePostInput` 类型, 且是必传的, `input` 类型定义一次查询或变更中传递的对象参数; 该查询返回 `PostModel` 类型的数据, 且该数据必须为非空. 第二个语句定义一次变更, 语义同理.

### Scalar

""标量"", 可以理解为 GraphQL 中字段的基础类型, 默认有 Int, Float, String, Boolean, ID 五种. 有时候你需要扩展适合自己业务的标量, 每个标量需要实现 `parseValue`, `serialize`, `parseLiteral` 三个方法, 如下是 `DateScalar`.

```ts
import { Scalar, CustomScalar } from ""@nestjs/graphql"";
import { Kind, ValueNode } from ""graphql"";

@Scalar(""Date"")
export class DateScalar implements CustomScalar<number, Date> {
  description = ""Date custom scalar type"";

  parseValue(value: number): Date {
    return new Date(value); // value from the client
  }

  serialize(value: Date): number {
    return value.getTime(); // value sent to the client
  }

  parseLiteral(ast: ValueNode): Date {
    if (ast.kind === Kind.INT) {
      return new Date(ast.value);
    }
    return null;
  }
}
```

标量的目的是能够更加精确的确定一个字段的类型, 不过写个新的确实比较麻烦, 好在 [graphql-scalars](https://www.graphql-scalars.dev/docs/usage/regex) 预设了大约 50 个标量, 比如 PositiveInt, NegativeInt, DateTime, Date, EmailAddress, HexColorCode 等等.

### Enum

枚举类型是一种特殊的标量, 它限制在一个特殊的可选值集合内. 这让你能够:

1. 验证这个类型的任何参数是可选值的某一个
2. 与类型系统沟通, 一个字段总是一个有限值集合的其中一个值

```graphql
enum PostStatus {
  DRAFT
  PUBLISH
}
```

### Interfaces

跟许多类型系统一样, GraphQL 支持接口. 一个接口是一个抽象类型, 它包含某些字段, 而对象类型必须包含这些字段, 才能算实现了这个接口.

```graphql
interface Common {
  status_msg: String!
  status_code: Int!
}

type User implements Common {
  id: ID!
  name: String!
  email: String!
  status_msg: String!
  status_code: Int!
}
```

## 代码优先

在真实的开发中, 我们可以像上面一样, 通过编写 GraphQL 原生语言来创建 GraphQL SDL, 当然我们也可以通过代码优先的方式, 即通过 TypeScript 装饰器来生成. 下面的代码, 除了定义字段的类型, 比如 `posterUrl` 的类型是 `String` 标量, 且为非空; 还能""夹带私货"", 比如限制 `posterUrl` 是 `url` 格式的字符串, 这样就更加细粒度的对数据类型进行限制.

```ts
@InputType()
export class CreatePostInput {
  @Field({ nullable: false })
  @IsString()
  @IsUrl({ protocols: [""https""], require_protocol: true })
  @IsNotEmpty()
  public readonly posterUrl: string;

  @Field({ nullable: false })
  @IsString()
  @MinLength(1)
  @MaxLength(20)
  @IsNotEmpty()
  public readonly title: string;

  @Field({ nullable: false })
  @IsString()
  @IsNotEmpty()
  public readonly summary: string;

  @Field({ nullable: false })
  @IsString()
  @IsNotEmpty()
  public readonly content: string;

  @Field(() => [String], { nullable: false })
  @IsArray()
  @IsString({ each: true })
  @ArrayNotEmpty()
  @ArrayUnique()
  @IsNotEmpty()
  public readonly tags: string[];

  @Field({ nullable: false })
  @IsString()
  @IsNotEmpty()
  public readonly lastModifiedDate: string;

  @Field({ nullable: true })
  public readonly isPublic?: boolean;
}
```

下面的代码则是 GraphQL 的解析器, 同样通过注解的方式来创建 Query 和 Mutation:

- `@Query(() => PostItemModel)` 代表着返回值为 `PostItemModel` 类型;
- `getPostById` 定义这个查询的名称;
- `@Args({ name: ""id"", type: () => ID })` 用来定义传参, 我需要传递一个字段 id, 它的标量为 ID

```ts
@Resolver()
export class PostsResolver {
  constructor(private readonly postsService: PostsService) {
    this.postsService = postsService;
  }

  @Query(() => PostItemModel)
  public async getPostById(@Args({ name: ""id"", type: () => ID }) id: string) {
    return this.postsService.findOneById(id); // 处理 SQL
  }

  @Mutation(() => PostItemModel)
  @UseGuards(GqlAuthGuard)
  public async createPost(@Args(""input"") input: CreatePostInput) {
    return this.postsService.create(input); // 处理 SQL
  }
}
```

## 前端

![GrapqhQL](https://edge.yancey.app/beg/bc4vglh0-1632634977155.jpg)

GraphQL 在前端的本质表现就是向你的接口, 如 `https://api.example.com/graphql` 上发送一个 POST 请求, 而请求的 body 就如上图所示. 但为了更加的和 GrapqhQL 语法配合, 前端涌现了一些不错的库, 如 Facebook 自家的 [relay](https://relay.dev/), relay 经历了两次重大迭代, 目前 Facebook 官网用的是最新一代, 名字叫 relay morden.

![facebook](https://edge.yancey.app/beg/yjveqxkz-1632635487617.jpg)

虽然 relay 是一个开源项目, 但它更多是为 Facebook 内部业务服务, 因此外部人用起来比较难受. 目前最广泛的框架则是 [Apollo](https://www.apollographql.com/), 它支持基于 Hooks 的 React 前端框架, 也支持 Vue, Angular, Android 和 iOS, 也提供了基于 Node.js 的后端框架 Appolo Server.

![apollo](https://edge.yancey.app/beg/fza63an6-1632635764280.jpg)

`fragment` 是用来定义片段, 如下面的例子, 我们定义查询一篇文章, 返回的是一篇文章实体; 修改一篇文章, 返回的也是文章修改后的实体. 这样它们的返回值基本都是一样的, 为了不写多次, 可以通过 fragment 来进行提取, 简化代码书写.

第二段代码, 请求的变更是 `createPost`, 它的参数 `input` 是 `CreatePostInput` 类型, 且为必传. 因为我们使用了 fragment, 因此需要将相应片段注入进来.

第三段代码就是真正在 jsx 中发起请求了, 通过 hooks 可以方便的处理请求体, loading, 返回值, 错误处理等等...

```ts
const POST_FRAGMENT = gql`
  fragment PostFragment on PostItemModel {
    _id
    posterUrl
    title
    summary
    content
    tags
    lastModifiedDate
    like
    pv
    isPublic
    createdAt
    updatedAt
  }
`;

export const CREATE_ONE_POST = gql`
  mutation CreatePost($input: CreatePostInput!) {
    createPost(input: $input) {
      ...PostFragment
    }
  }
  ${POST_FRAGMENT}
`;

const [createPost, { loading }] = useMutation<
  CreatePostMutation,
  CreatePostVars
>(CREATE_ONE_POST, {
  onCompleted(data) {
    const newPost = data.createPost;
    enqueueSnackbar(""Create success!"", { variant: ""success"" });
  },
  onError() {},
});
```

## Introspection

在真实的开发中, 我们会在后端定义一系列的 query, mutation, input, type, enum, scalar, interface. 而 GraphQL 支持一套强大的内省系统, 通过内省系统, 我们可以反查后端设计的 schema 的集合. 内省系统的另一个功能则是辅助开发 GraphQL 工具, 通过查询出来的内部 schema, 可以搭建出强大的 IDE. 如下代码可以查询出 `PostItemModel` 这个类型的所有信息.

```graphql
{
  __type(name: ""PostItemModel"") {
    name
    fields {
      name
      type {
        name
        kind
      }
    }
  }
}
```

```ts
{
  ""data"": {
    ""__type"": {
      ""name"": ""PostItemModel"",
      ""fields"": [
        {
          ""name"": ""_id"",
          ""type"": {
            ""name"": null,
            ""kind"": ""NON_NULL""
          }
        },
        {
          ""name"": ""posterUrl"",
          ""type"": {
            ""name"": null,
            ""kind"": ""NON_NULL""
          }
        },
        {
          ""name"": ""title"",
          ""type"": {
            ""name"": null,
            ""kind"": ""NON_NULL""
          }
        },
        {
          ""name"": ""summary"",
          ""type"": {
            ""name"": null,
            ""kind"": ""NON_NULL""
          }
        },
        {
          ""name"": ""content"",
          ""type"": {
            ""name"": null,
            ""kind"": ""NON_NULL""
          }
        },
        {
          ""name"": ""tags"",
          ""type"": {
            ""name"": null,
            ""kind"": ""NON_NULL""
          }
        },
        {
          ""name"": ""lastModifiedDate"",
          ""type"": {
            ""name"": null,
            ""kind"": ""NON_NULL""
          }
        },
        {
          ""name"": ""like"",
          ""type"": {
            ""name"": null,
            ""kind"": ""NON_NULL""
          }
        },
        {
          ""name"": ""pv"",
          ""type"": {
            ""name"": null,
            ""kind"": ""NON_NULL""
          }
        },
        {
          ""name"": ""isPublic"",
          ""type"": {
            ""name"": null,
            ""kind"": ""NON_NULL""
          }
        },
        {
          ""name"": ""createdAt"",
          ""type"": {
            ""name"": null,
            ""kind"": ""NON_NULL""
          }
        },
        {
          ""name"": ""updatedAt"",
          ""type"": {
            ""name"": null,
            ""kind"": ""NON_NULL""
          }
        },
        {
          ""name"": ""prev"",
          ""type"": {
            ""name"": ""PostItemModel"",
            ""kind"": ""OBJECT""
          }
        },
        {
          ""name"": ""next"",
          ""type"": {
            ""name"": ""PostItemModel"",
            ""kind"": ""OBJECT""
          }
        }
      ]
    }
  }
}
```

## 安全

### 生产环境关闭 `debug`

如果开启 `debug` 模式, 在出错时会展示错误的堆栈信息.

![debug 模式会展示堆栈信息](https://edge.yancey.app/beg/dg0wpl8n-1632382810570.jpg)

### 生产环境关闭 `playground`

`playground` 应当作为一种辅助自测工具, 其不应该暴露到线上.

### 生产环境关闭 `introspection`

得益于内省, 可以轻松获取到 GraphQL server 内部的信息, 如各种类型, 标量等. 这些信息不应该在线上被三方直接通过代码采集到.

### 控制多层深度的查询

如下可能会造成昂贵的查询, 重则导致后端崩溃. 可以使用 [graphql-depth-limit](https://github.com/stems/graphql-depth-limit) 来指定最多查询的层级.

```graphql
query {
  author(id: 42) {
    posts {
      author {
        posts {
          author {
            posts {
              author {
                # and so on...
              }
            }
          }
        }
      }
    }
  }
}
```

### 控制分页数据量

如下最多一次将能获取十万条数据, 显而易见会带来性能问题. 你可以通过 [graphql-input-number](https://github.com/joonhocho/graphql-input-number) 在 resolver 中限制数字的最大值.

```ts
query {
  authors(first: 1000) {
    name
    posts(last: 100) {
      title
      content
    }
  }
}
```

当然, 如果你使用了 `class-validator`, 也可以通过如下方式来限制.

```ts
@InputType()
export class SomeNumberInput {
  @IsInt()
  @Min(1)
  @Max(10)
  public readonly pageSize: number;
}
```

## 参考

- [9 Ways To Secure your GraphQL API — GraphQL Security Checklist](https://www.apollographql.com/blog/graphql/security/9-ways-to-secure-your-graphql-api-security-checklist/)
","2025-02-02 03:08:56.450204","2025-02-02 03:08:56.450204"
"857e45fa-8d83-4e4e-a546-27f6212ab226","{搞机,Charles}",0,0,False,"https://edge.yancey.app/beg/x2pt4x3k-1634027451958.jpg","手摸手教你高版本安卓安装 Charles 证书","众所周知(其实以前我也不知道), 在安卓 7 以上, 系统收敛了证书权限. 也就是说你在 Charles 下载了证书, 然后通过手机安装, 只会安装到用户列表中, 而安卓只信任系统级别的证书, 所以你安装的证书仍然不能访问 HTTPS.","## 解决方案

![Charles 证书只存在于用户列表](https://edge.yancey.app/beg/thn9jsxa-1634026441468.png)


![扑街图鉴](https://edge.yancey.app/beg/mdpdqj50-1634026521272.png)

这里使用小米 11 PRO 来演示. 首先你得把手机 root 掉, 当然猴米比较蛋疼, 得先解锁手机, 解锁手机需要先用小米账号申请, 申请成功后需要等待 168 小时(7 天) 才能解锁(注意解锁手机会抹掉手机数据); 解锁完毕后, 就可以在手机安装开发版 ROM 了, 注意这个 ROM 普通小米账号下载不到, 得是深度玩家账号. 因此我建议去某宝租一个小米账号, 一把梭. 这里不多赘述解锁和 root, 都是泪.

打开 Charles, 首先把证书下载下来.

![下载证书](https://edge.yancey.app/beg/fjrw6oe6-1634026604637.png)

然后在终端执行下面的脚本. 注意, 下面的脚本是我从网上看到了, 然鹅我电脑的 openssl 是 v2.8.3(可通过 openssl version 查看版本), 但通过第二个脚本解析出来的不能用, 但第一个成功了, 很迷.

```bash
#openssl版本在<1.0执行上面

openssl x509 -inform PEM -subject_hash_old -in xxx.pem
        
#openssl版本>1.0 执行下面

openssl x509 -inform PEM -subject_hash -in xxx.pem
```

![证书 hash](https://edge.yancey.app/beg/jewn9h90-1634027003982.png)

记录上面图片中红框的 hash 值 `1dcbf3b0`, 将你的 `xxx.pem` 重命名成 `1dcbf3b0.0` 待用.

在电脑上安装 `adb`, 这玩意儿可以让你通过脚本跟安卓手机进行交互. 然后数据线连接你的手机, 记得打开 USB 调试模式.

```
brew install --cask android-platform-tools
```

在终端执行 `adb devices`, 不出意外能看到你的手机, 找不到说明你手机没插好.


![查找设备](https://edge.yancey.app/beg/wms7qgzk-1634027065945.png)

然后执行 `adb root`, 来切换到 root 模式.


![进入 root 权限](https://edge.yancey.app/beg/o4d074h9-1634027123275.png)

使用 `adb disable-verify` 禁用安卓的系统验证.

![禁用安卓的系统验证](https://edge.yancey.app/beg/mvah872u-1634027187460.png)

使用 `adb remount` 重新挂载下手机, 如果下一步执行不了, 可以执行下该步骤.

![重新挂载手机](https://edge.yancey.app/beg/2eo5qs93-1634027155339.png)


最后通过如下命令, 将你修改后的证书传到系统认证根证书列表中.

```
adb push Downloads/1dcbf3b0.0 /system/etc/security/cacerts/
```

![复制证书到系统目录](https://edge.yancey.app/beg/ziwt6axq-1634027240840.png)

重启下手机, 就会发现系统下已经安装了 Charles 的证书. 愉快地抓包吧~

![可以抓包啦!](https://edge.yancey.app/beg/c44wnsz3-1634027276343.png)","2025-02-02 03:08:58.560847","2025-02-02 03:08:58.560847"
"bebadd04-89da-4dca-8086-d226dad919ce","{极客时间,重学前端}",0,0,False,"https://edge.yancey.app/beg/xcyh8iwq-1641197283211.jpg","《重学前端》学习笔记","两年前买的课, 以前看过一遍, 今年再来咀嚼咀嚼. 重学前端的目的一是立足标准, 系统性总结和整理前端知识, 建立自己的认知和方法论; 二是放眼团队, 从业务和工程角度思考前端团队的价值和发展需要.","## 知识图谱

![知识图谱](https://edge.yancey.app/beg/vuskujcg-1641221332611.jpg)

对于任何计算机语言来说, 必定是**用规定的文法, 去表达特定语义, 最终操作运行时**的一个过程. 而 **程序 = 算法 + 数据结构**, 对运行时来说, 类型就是数据结构, 执行过程就是算法.

- 文法
  - 词法
  - 语法
- 语义
- 运行时
  - 类型
  - 执行过程

而对于 HTML, 大致分为以下几个部分:

1. 文档元信息: 通常是出现在 head 标签中的元素, 包含了描述文档自身的一些信息;
2. 语义相关: 扩展了纯文本, 表达文章结构, 不同语言要素的标签;
3. 链接: 提供到文档内和文档外的链接;
4. 替换型标签: 引入声音, 图片, 视频等外部元素替换自身的一类标签;
5. 表单: 用于填写和提交信息的一类标签;
6. 表格: 表头, 表尾, 单元格等表格的结构.

## JavaScript

### Undefiend 和 void 0

undefiend 在 JavaScript 中是一个**变量**, 而非关键字, 因此执行 `let undefined = 1;` 是可以的, 为了防止这个问题, 就有了 `void 0` 来代替 undefined.

### String

String 有最大长度是 2^53 - 1, 即 9007199254740991, 其实和 `Number.MAX_SAFE_INTEGER` 相等. 这个所谓最大长度, 并不完全是你理解中的字符数, 因为 String 的意义并非""字符串"", 而是字符串的 UTF16 编码, 我们字符串的操作 charAt, charCodeAt, length 等方法针对的都是 UTF16 编码. 所以, 字符串的最大长度, 实际上是受字符串的编码长度影响的.

### Number

JavaScript 中的 Number 类型基本符合 IEEE 754-2008 规定的双精度浮点数规则, 但是 JavaScript 为了表达几个额外的语言场景(比如不让除以 0 出错, 而引入了无穷大的概念), 规定了几个例外情况:

- NaN, 占用了 9007199254740990, 这原本是符合 IEEE 规则的数字
- Infinity, 无穷大
- Infinity, 负无穷大

```ts
console.log(NaN === NaN); // false
console.log(Object.is(NaN, NaN)); // true
console.log(+0 === -0); // true
console.log(Object.is(+0, -0)); // false
```

根据双精度浮点数的定义, Number 类型中有效的整数范围是 -0x1fffffffffffff 至 0x1fffffffffffff, 所以 Number 无法精确表示此范围外的整数, 这些应该使用 BigInt 来表示. 根据 IEEE 的定义, number 运算会被转换为二进制进行运算, 而后转换为十进制; 0.1 转换后会变成无限循环小数, 即浮点数运算精度问题. 这也是经典的 0.1 + 0.2 为什么不等于 0.3, 当然你可以用下面两种方式来解决, 或者每个数字都乘以 10 再比较.

```ts
Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON;
```

### Symbol

symbol 用于创建一个独一无二的值, 可以用于做唯一标识, 也可以用于描述对象的属性(最重要的特性就是用语匿名属性).

```ts
const symbol = Symbol(""an anonymous variable"");
const symbol1 = Symbol(""an anonymous1 variable"");
const symbol2 = Symbol(""an anonymous2 variable"");

const o = {
  a: 1,
  symbol: 2,
};

// 需要注意的是, 只有手动往对象中添加 symbol 的 key,
// Object.getOwnPropertySymbols() 才能获取到的
// 初始化对象时添加的 symbol 的 key 是不能被 Object.getOwnPropertySymbols() 获取到的
o[symbol1] = 3;

Object.defineProperty(o, symbol2, {
  value: ""hello"",
});

const keys = Object.keys(o); // [ 'a', 'symbol' ] 注意这个 symbol 是个字符串字面量, 不是那个真实的 symbol
const values = Object.values(o); // [ 1, 2 ] 能拿到初始化时创建的 symbol 的值, 但不能获取后续手动添加的 symbol 的值
const keys2 = Object.getOwnPropertyNames(o); // [ 'a', 'symbol' ] 注意这个 symbol 是个字符串字面量, 不是那个真实的 symbol
const keys3 = Object.getOwnPropertySymbols(o); // [ Symbol(an anonymous1 variable), Symbol(an anonymous2 variable) ]
```

此外, 部署了 Symbol.iterator 的对象可以使用 for...of, 原本只有 Array, Map 等可以使用 for...of, 对象是不可以的.

```ts
var o = new Object();

o[Symbol.iterator] = function () {
  var v = 0;
  return {
    next: function () {
      return { value: v++, done: v > 10 };
    },
  };
};

for (var v of o) {
  console.log(v); // 0 1 2 3 ... 9
}
```

### Object

3 与 new Number(3) 是完全不同的值, 它们一个是 Number 类型, 一个是对象类型. Number, String 和 Boolean, 三个构造器是两用的, 当跟 new 搭配时, 它们产生对象, 当直接调用时, 它们表示强制类型转换. Symbol 函数比较特殊, 直接用 new 调用它会抛出错误, 但它仍然是 Symbol 对象的构造器.

![类型转换](https://edge.yancey.app/beg/3e4lm1zt-1641739086767.webp)

我们借加法运算符来看一下 ECMAScript 的规范.

![加法p](https://edge.yancey.app/beg/cdufnwb6-1652626892220.webp)

- 把第一个表达式 (AdditiveExpression) 的值赋值给左引用 (lref)。
- 使用 GetValue(lref) 获取左引用 (lref) 的计算结果，并赋值给左值。
- 使用 ReturnIfAbrupt(lval) 如果报错就返回错误。
- 把第二个表达式 (MultiplicativeExpression) 的值赋值给右引用 (rref)。
- 使用 GetValue(rref) 获取右引用 (rref) 的计算结果，并赋值给 rval。
- 使用 ReturnIfAbrupt(rval) 如果报错就返回错误。
- 使用 ToPrimitive(lval) 获取左值 (lval) 的计算结果，并将其赋值给左原生值 (lprim)。
- 使用 ToPrimitive(rval) 获取右值 (rval) 的计算结果，并将其赋值给右原生值 (rprim)-
- 如果 Type(lprim) 和 Type(rprim) 中有一个是 String，则：
  - 把 ToString(lprim) 的结果赋给左字符串 (lstr)；
  - 把 ToString(rprim) 的结果赋给右字符串 (rstr)；
  - 返回左字符串 (lstr) 和右字符串 (rstr) 拼接的字符串。
- 把 ToNumber(lprim) 的结果赋给左数字 (lnum)。
- 把 ToNumber(rprim) 的结果赋给右数字 (rnum)。
- 返回左数字 (lnum) 和右数字 (rnum) 相加的数值。

通俗地理解，V8 会提供了一个 ToPrimitive 方法，其作用是将 a 和 b 转换为原生数据类型，其转换流程如下：

- 先检测该对象中是否存在 valueOf 方法，如果有并返回了原始类型，那么就使用该值进行强制类型转换；
- 如果 valueOf 没有返回原始类型，那么就使用 toString 方法的返回值；
- 如果 vauleOf 和 toString 两个方法都不返回基本类型值，便会触发一个 TypeError 的错误。

#### String2Number

有三种方式可以将字符串转换为数字, 分别是:

- Number
- parseInt
- parseFloat.

```ts
parseFloat(""0.0314E+2""); // 3.14(可以正确处理科学计数法)
parseInt(""314E+2""); // 314(对科学计数法不感冒)
Number(""0.0314E+2""); // 3.14(可以正确处理科学计数法)

parseInt(""0xff"", 16); // 255(可以正确处理非十进制)
parseFloat(""0xff""); // 0(无法正确处理非十进制)
Number(""0xff""); // 255(可以正确处理非十进制)
```

可见 Number 更加的通用好使.

#### Number2String

注意一点就好, 较大的数字会被转成科学计数法.

```ts
String(10000000000000000000000); // '1e+22'
```

#### 装箱和拆箱

所谓装箱就是将基本类型转换为对象类型, 拆箱就是将对象类型转换为基本类型.

装箱分为显式装箱和隐式装箱. 显式装箱是指主动将基本类型转换为对象类型. 而隐式装箱是运行时自动完成的.
JavaScript 的字符串字面量原本是无法调用任何方法的, 只有字符串对象才能调用方法. 这就涉及到隐式装箱.

```ts
// 显式装箱
var a = new Number(1);

// 显式装箱
// 虽然 Symbol 没有 new, 但可以用如下操作获取 Symbol 对象
var symbolObject = function () {
  return this;
}.call(Symbol(""a""));

// 显式装箱
// 如下操作也可以获取 Symbol 对象
Object(Symbol(""a""));

// 隐式装箱
var num = 123;
num.toFixed(2);

// var c = new Number(123);
// c.toFixed(2);
// c = null;
```

每一类装箱对象皆有私有的 Class 属性, 这些属性可以用 Object.prototype.toString 获取, 这也是获取数据类型最准确的方式. 但需要注意的是, call 本身会产生装箱操作, 所以需要配合 typeof 来区分基本类型还是对象类型.

```ts
var symbolObject = Object(Symbol(""a""));
console.log(Object.prototype.toString.call(symbolObject)); //[object Symbol]
```

下面再谈一谈拆箱, 所谓拆箱就是**对象类型到基本类型的转换**, 对象到 String 和 Number 的转换都遵循""先拆箱再转换""的规则. 通过拆箱转换, 把对象变成基本类型, 再从基本类型转换为对应的 String 或者 Number. 拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型. 如果 valueOf 和 toString 都不存在, 或者没有返回基本类型, 则会产生类型错误 TypeError.

1. 判断对象是否实现 `[Symbol.toPrimitive]` 属性, 如果实现调用它, 并判断返回值是否为基础类型, 如果不是, 执行下一步.
2. 如果转换类型为 string, 依次尝试调用 toString() 和 valueOf() 方法, 如果 toString() 存在, 并正确返回值类型就不会执行 valueOf().
3. 如果转换类型为 number/default, 依次尝试调用 valueOf() 和 toString(), 如果 valueOf() 存在, 并正确返回值类型就不会执行 toString().

以 `+[]` 为例, 因为数组未实现 `[Symbol.toPrimitive]` 并且它是一个 number 转换, 会先触发调用 valueOf() 方法, 该方法返回的是空数组本身, 它不属于基础类型, 因此会再尝试调用 toString() 方法, 返回空字符串, 然后相当于执行 `+''`, 即返回 0.

以 `[] + ''` 为例, 因为数组未实现 `[Symbol.toPrimitive]` 并且它是一个 string 转换, 会调用 toString() 方法, 返回空字符串, 然后相当于执行 `'' + ''`, 即返回空字符串.

```ts
var o = {
  valueOf: () => {
    console.log(""valueOf"");
    return {};
  },
  toString: () => {
    console.log(""toString"");
    return {};
  },
};

o * 2;
// valueOf
// toString
// TypeError
```

而 Object2String 是先执行 toString 再执行 valueOf.

```ts
var o = {
  valueOf: () => {
    console.log(""valueOf"");
    return {};
  },
  toString: () => {
    console.log(""toString"");
    return {};
  },
};

String(o);
// toString
// valueOf
// TypeError
```

在 ES6 后, 还可以使用 Symbol.toPrimitive 来覆盖 valueOf.

```ts
var o = {
  valueOf: () => {
    console.log(""valueOf"");
    return {};
  },
  toString: () => {
    console.log(""toString"");
    return {};
  },
};

o[Symbol.toPrimitive] = () => {
  console.log(""toPrimitive"");
  return ""hello"";
};

console.log(o + """");
// toPrimitive
// hello

console.log(o * 2);
// toPrimitive
// NaN
```

这里简单说下 valueOf, 它用来返回值为该对象的原始值, JavaScript 的许多内置对象都重写了该函数, 以实现更适合自身的功能需要:

| 对象    | 返回值                                                 |
| ------- | ------------------------------------------------------ |
| Array   | 返回数组对象本身                                       |
| Boolean | 布尔值                                                 |
| Date    | 存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC |
| Number  | 数字值                                                 |
| Object  | 对象本身, 这是默认情况                                 |
| String  | 字符串值                                               |
|         | Math 和 Error 对象没有 valueOf 方法                    |

#### 规范类型

- List 和 Record: 用于描述函数传参过程.
- Set: 主要用于解释字符集等.
- Completion Record: 用于描述异常, 跳出等语句执行过程.
- Reference: 用于描述对象属性访问, delete 等.
- Property Descriptor: 用于描述对象的属性.
- Lexical Environment 和 Environment Record: 用于描述变量和作用域.
- Data Block: 用于描述二进制数据.

#### typeof

尤其注意 `typeof null === ""object""`, 因为 `null` 是一个对象. 此外还有 `typeof function(){} === ""function""`

![typeof](https://edge.yancey.app/beg/qa48ri2i-1641831313173.webp)

#### JavaScript 对象的两类属性

[你可能不知道的 Object.defineProperty()](https://www.yanceyleo.com/post/9a055382-39a0-4c0b-9148-12d6da2852ed)

可以通过 Object.defineProperty() 来定义属性描述, 可以通过 Object.getOwnPropertyDescriptor() 来查看属性描述.

数据属性:

- value: 就是属性的值.
- writable: 决定属性能否被赋值.
- enumerable: 决定 for in 能否枚举该属性.
- configurable: 决定该属性能否被删除或者改变特征值.

访问器属性:

- getter: 函数或 undefined, 在取属性值时被调用.
- setter: 函数或 undefined, 在设置属性值时被调用.
- enumerable: 决定 for in 能否枚举该属性.
- configurable: 决定该属性能否被删除或者改变特征值.

```ts
var o = { a: 1 };
Object.defineProperty(o, ""b"", {
  value: 2,
  writable: false,
  enumerable: false,
  configurable: true,
});
Object.getOwnPropertyDescriptor(o, ""a""); // {value: 1, writable: true, enumerable: true, configurable: true}
Object.getOwnPropertyDescriptor(o, ""b""); // {value: 2, writable: false, enumerable: false, configurable: true}
o.b = 3; // 无法改变
console.log(o.b); // 2

// getter / setter
var o = {
  get a() {
    return 1;
  },
  set a(v) {
    this._a = v;
  },
};

console.log(o.a); // 1
o.a = 2;
console.log(o._a); // 2z
```

#### 通过 Symbol.toStringTag 来表示该对象的自定义类型标签

```ts
var o = { [Symbol.toStringTag]: ""MyObject"" };
o.toString(); // ""[object MyObject]""

class ValidatorClass {
  get [Symbol.toStringTag]() {
    return ""Validator"";
  }
}

Object.prototype.toString.call(new ValidatorClass()); // ""[object Validator]""
```

#### 复习下 new

- 以构造器的 prototype 属性为原型, 创建新对象
- 将 this 和调用参数传给构造器, 执行
- 如果构造器返回的是对象, 则返回, 否则返回第一步创建的对象

```ts
function myNew(Con, ...args) {
  var obj = Object.create(Con.prototype);
  var ret = Con.apply(obj, args);
  return typeof ret === ""object"" ? ret : obj;
}
```

#### 复习下 Object.create()

用于根据某个对象的原型来创建对象. 下面的 polyfill 无法做到与原生的 Object.create 一致, 一个是不支持第二个参数, 另一个是不支持 null 作为原型.

```ts
function myCreate(prototype) {
  var F = function () {};
  cls.prototype = prototype;
  return new F();
}
```

#### JavaScript 中的对象分类

- 宿主对象（host Objects）: 由 JavaScript 宿主环境提供的对象, 它们的行为完全由宿主环境决定.
- 内置对象（Built-in Objects）: 由 JavaScript 语言提供的对象.
  - 固有对象（Intrinsic Objects ）: 由标准规定, 随着 JavaScript 运行时创建而自动创建的对象实例.
  - 原生对象（Native Objects）: 可以由用户通过 Array, RegExp 等内置构造器或者特殊语法创建的对象.
  - 普通对象（Ordinary Objects）: 由对象字面量, Object 构造器或者 class 关键字定义类创建的对象, 它能够被原型继承.

#### 宿主对象

所谓宿主对象就是指除了 JS 内置对象, 浏览器或 Node.js 提供的那些对象. 像浏览器中, window 会挂载 JS 内置对象和 W3C 的各种标准中规定了 Window 对象的其它属性.

宿主对象也分为固有的和用户可创建的两种, 比如 document.createElement 就可以创建一些 DOM 对象. 宿主也会提供一些构造器, 比如我们可以使用 new Image 来创建 img 元素.

#### 内置对象 - 固有对象

[Well-Known Intrinsic Objects](https://262.ecma-international.org/9.0/#sec-well-known-intrinsic-objects)

#### 内置对象 - 原生对象

![6cb1df319bbc7c7f948acfdb9ffd99d0.webp](https://edge.yancey.app/beg/906y37ra-1642323397550.webp)

这些构造器创建的对象多数使用了私有字段, 例如, 这些字段使得原型继承方法无法正常工作.

- Error: [[ErrorData]]
- Boolean: [[BooleanData]]
- Number: [[NumberData]]
- Date: [[DateValue]]
- RegExp: [[RegExpMatcher]]
- Symbol: [[SymbolData]]
- Map: [[MapData]]

#### 函数对象

函数对象的定义是: 具有[[call]]私有字段的对象, 构造器对象的定义是: 具有私有字段[[construct]]的对象. 任何对象只需要实现[[call]], 它就是一个函数对象, 可以去作为函数被调用. 而如果它能实现[[construct]], 它就是一个构造器对象, 可以作为构造器被调用.

但对于宿主和内置对象来说, 它们实现[[call]]（作为函数被调用）和[[construct]]（作为构造器被调用）不总是一致的. 再比如基本类型（String, Number, Boolean）, 它们的构造器被当作函数调用, 则产生类型转换(装箱)的效果.

值得一提的是, 箭头函数不能被用做构造器.

```ts
console.log(typeof new Date()); // 'object'
console.log(typeof Date()); // 'string'
```

### 事件循环

- 首先我们分析有多少个宏任务；
- 在每个宏任务中, 分析有多少个微任务；
- 根据调用次序, 确定宏任务中的微任务执行次序；
- 据宏任务的触发规则和调用次序, 确定宏任务的执行次序；
- 确定整个顺序.

不论代码顺序如何, d 必定发生在 c 之后, 因为 Promise 产生的是 JavaScript 引擎内部的微任务, 而 setTimeout 是浏览器 API, 它产生宏任务.

```ts
var r = new Promise(function (resolve, reject) {
  console.log(""a"");
  resolve();
});
setTimeout(() => console.log(""d""), 0);
r.then(() => console.log(""c""));
console.log(""b"");
```

我们把宿主发起的任务称为宏观任务, 把 JavaScript 引擎发起的任务称为微观任务. 许多的微观任务的队列组成了宏观任务.

### 执行上下文

JavaScript 标准把一段代码（包括函数）, 执行所需的所有信息定义为: ""执行上下文"".

在 ES2018 中, 执行上下文又变成了这个样子, this 值被归入 lexical environment, 但是增加了不少内容.

- lexical environment: 词法环境, 当获取变量或者 this 值时使用.
- variable environment: 变量环境, 当声明变量时使用.
- code evaluation state: 用于恢复代码执行位置.
- Function: 执行的任务是函数时使用, 表示正在被执行的函数.
- ScriptOrModule: 执行的任务是脚本或者模块时使用, 表示正在被执行的代码.
- Realm: 使用的基础库和内置对象实例. 比如一个网页有它的 window 对象, 这个网页创建的 iframe 中也有自己的 window 对象
- Generator: 仅生成器上下文有这个属性, 表示当前生成器.

```ts
// 立即执行函数的推荐写法
void (function () {
  var a;
  //code
})();
```

### 函数种类

```ts
function foo() {}

const foo = () => {};

function* foo() {}

class C {
  foo() {}
}

class Foo {
  constructor() {}
}

async function foo() {}

const foo = async () => {}

async function foo*() {}
```

### this 关键字的行为

```ts
function showThis() {
  console.log(this);
}

var o = {
  showThis,
};

showThis(); // global(如果是严格模式, 这里为 undefined)
o.showThis(); // o
```

普通函数的 this 值由**调用它所使用的引用**决定. 当获取函数的表达式, 它实际上返回的并非函数本身, 而是一个 Reference 类型. Reference 类型由两部分组成: **一个对象和一个属性值**. 因此 o.showThis 产生的 Reference 类型, 即由对象 o 和属性 `showThis` 构成, 那么 this 就指向 o.

JavaScript 标准定义了 [[thisMode]] 私有属性, 它有三个取值:

- lexical: 表示从上下文中找 this, 这对应了箭头函数.
- global: 表示当 this 为 undefined 时, 取全局对象, 对应了普通函数.
- strict: 当严格模式时使用, this 严格按照调用时传入的值, 可能为 null 或者 undefined.

函数创建新的执行上下文中的词法环境记录时, 会根据[[thisMode]]来标记新纪录的[[ThisBindingStatus]]私有属性. 代码执行遇到 this 时, 会逐层检查当前词法环境记录中的[[ThisBindingStatus]], 当找到有 this 的环境记录时获取 this 的值. 箭头函数绑定最近的对象, 下面这个例子 this 都是 o.

```ts
var o = {};
o.foo = function foo() {
  console.log(this);
  return () => {
    console.log(this);
    return () => console.log(this);
  };
};

o.foo()()(); // o, o, o
```

### Completion 类型

下面这个例子, 即便 try 语句中 return 0, 仍然会执行到 finally.

```ts
function foo() {
  try {
    return 0;
  } catch (err) {
  } finally {
    console.log(""a"");
  }
}
```

而下面这个例子, finally 语句直接覆盖 try 里面的返回值.

```ts
function foo() {
  try {
    return 0;
  } catch (err) {
  } finally {
    return 1;
  }
}

console.log(foo()); // 1
```

这一机制的基础正是 JavaScript 语句执行的完成状态(Completion Record), 它用于**描述异常, 跳出等语句执行过程**. Completion Record 表示一个语句执行完之后的结果, 它有三个字段:

- [[type]] 表示完成的类型, 有 break continue return throw 和 normal 几种类型
- [[value]] 表示语句的返回值, 如果语句没有, 则是 empty
- [[target]] 表示语句的目标, 通常是一个 JavaScript 标签

![语句汇总](https://edge.yancey.app/beg/1zmu8848-1643010754700.webp)

### 普通语句

在 JavaScript 中. 我们把不带控制能力的语句称为普通语句. 普通语句执行后, 会得到 [[type]] 为 normal 的 Completion Record, JavaScript 引擎遇到这样的 Completion Record, 会继续执行下一条语句.

这些语句中, 只有表达式语句会产生 [[value]], 当然, 从引擎控制的角度, 这个 value 并没有什么用处.

如果你经常使用 Chrome 自带的调试工具, 可以知道, 输入一个表达式, 在控制台可以得到结果, 但是在前面加上 var, 就变成了 undefined. Chrome 控制台显示的正是语句的 Completion Record 的[[value]].

![Chrome 控制台](https://edge.yancey.app/beg/nfq2b40p-1643011105029.webp)

### 语句块

语句块就是拿大括号括起来的一组语句, 它是一种语句的复合结构, 可以嵌套. 我们需要注意的是语句块内部的语句的 Completion Record 的[[type]] 如果不为 normal, 会打断语句块后续的语句执行. 比如 [[type]] 为 return 或者 throw.

```ts
// 这里的normal, empty, empty 分别对应指的是[[type]], [[value]], [[target]]

// 下面语句块中的四句都是普通语句
{
  var i = 1; // normal, empty, empty
  i++; // normal, 1, empty
  console.log(i); //normal, undefined, empty
} // normal, undefined, empty

// 加了 return 之后的 Completion Record
{
  var i = 1; // normal, empty, empty
  return i; // return, 1, empty
  i++;
  console.log(i);
} // return, 1, empty
```

控制类语句分成两部分, 一类是对其内部造成影响, 如 if, switch, while/for, try. 另一类是对外部造成影响如 break, continue, return, throw, 这两类语句的配合, 会产生控制代码执行顺序和执行逻辑的效果.

![语句块组合](https://edge.yancey.app/beg/rqfio9x3-1643020117008.webp)

### 带标签的语句

任何 JavaScript 语句是可以加标签的, 在语句前加冒号即可. 大部分时候, 这个东西类似于注释, 没有任何用处. 唯一有作用的时候是: 与完成记录类型中的 target 相配合, 用于跳出多层循环.

break/continue 语句如果后跟了关键字, 会产生带 target 的完成记录. 一旦完成记录带了 target, 那么只有拥有对应 label 的循环语句会消费它.

```ts
outer: while (true) {
  inner: while (true) {
    break outer;
  }
}
console.log(""finished"");
```

像 rust 也有标签, 都是类似的功能.

```rust
// 嵌套循环
    let mut count = 0;
    // 给外层循环一个标签, 以便内部循环使用
    'counting_up: loop {
        println!(""count = {}"", count);
        let mut remaining = 10;

        loop {
            println!(""remaining = {}"", remaining);
            // 停掉内部循环
            if remaining == 9 {
                break;
            }

            // 停掉外部循环
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!(""End count = {}"", count); // 2
```

### 词法分析

词法分析技术上可以使用状态机或者正则表达式来进行.

- WhiteSpace(空白字符)
- LineTerminator(换行符)
- Comment(注释)
- Token
  - IdentifierName(标识符名称), 典型案例是我们使用的变量名, 注意这里关键字也包含在内了.
  - Punctuator(符号), 我们使用的运算符和大括号等符号. NumericLiteral 数字直接量, 就是我们写的数字.
  - StringLiteral(字符串直接量), 就是我们用单引号或者双引号引起来的直接量.
  - Template(符串模板), 用反引号 ` 括起来的直接量.

但上面的无法覆盖所有的场景, 比如 JavaScript 不但支持除法运算符 `/` 和 `/=`, 还支持用斜杠括起来的正则表达式 `/abc/`. 但是, 这时候对词法分析来说, 其实是没有办法处理的, 所以 JavaScript 的解决方案是定义两组词法, 然后靠语法分析传一个标志给词法分析器, 让它来决定使用哪一套词法.

再如模板字面量和正则都有 `}`, 标准中还不得不把除法, 正则表达式直接量和 `}` 从 token 中单独抽出来, 形成如下四种形式.

| expectRegex | expectTemplate | InputElement                     |
| ----------- | -------------- | -------------------------------- |
| false       | false          | InputElementDiv                  |
| false       | true           | InputElementTemplateTail         |
| true        | false          | InputElementRegExp               |
| true        | true           | InputElementRegExpOrTemplateTail |

### 空白符号 Whitespace

空白符号最常见的就是普通空格, 不过还有其他的:

- \<HT>(或称\<TAB>) 是 U+0009, 是缩进 TAB 符, 也就是字符串中写的 \t .
- \<VT>是 U+000B, 也就是垂直方向的 TAB 符 \v, 这个字符在键盘上很难打出来, 所以很少用到.
- \<FF>是 U+000C, Form Feed, 分页符, 字符串直接量中写作 \f , 现代已经很少有打印源程序的事情发生了, 所以这个字符在 JavaScript 源代码中很少用到.
- \<SP>是 U+0020, 就是最普通的空格了.
- \<NBSP>是 U+00A0, 非断行空格, 它是 SP 的一个变体, 在文字排版中, 可以避免因为空格在此处发生断行, 其它方面和普通空格完全一样. 多数的 JavaScript 编辑环境都会把它当做普通空格(因为一般源代码编辑环境根本就不会自动折行). HTML 中, 很多人喜欢用的 `&nbsp;` 最后生成的就是它了.
- \<ZWNBSP>(旧称\<BOM>) 是 U+FEFF, 这是 ES5 新加入的空白符, 是 Unicode 中的零宽非断行空格, 在以 UTF 格式编码的文件中, 常常在文件首插入一个额外的 U+FEFF, 解析 UTF 文件的程序可以根据 U+FEFF 的表示方法猜测文件采用哪种 UTF 编码方式. 这个字符也叫做""bit order mark""

![更多空白符号](https://edge.yancey.app/beg/2vy2zw95-1643027049011.webp)

### 换行符 LineTerminator

- \<LF> 是 U+000A, 就是最正常换行符, 在字符串中的\n.
- \<CR> 是 U+000D, 这个字符真正意义上的""回车"", 在字符串中是\r, 在一部分 Windows 风格文本编辑器中, 换行是两个字符\r\n.
- \<LS> 是 U+2028, 是 Unicode 中的行分隔符.
- \<PS> 是 U+2029, 是 Unicode 中的段落分隔符.

大部分 LineTerminator 在被词法分析器扫描出之后, 会被语法分析器丢弃, 但是换行符会影响 JavaScript 的两个重要语法特性: 自动插入分号和 no line terminator 规则.

### 注释 Comment

```ts
/* MultiLineCommentChars */
// SingleLineCommentChars
```

### 标识符名称 IdentifierName

IdentifierName 可以以 $, \_ 或者 Unicode 字母开始, 除了开始字符以外, IdentifierName 中还可以使用 Unicode 中的连接标记, 数字, 以及连接符号.

### 符号 Punctuator

```ts
{ ( ) [ ] . ... ; , < > <= >= == != === !== + - * % ** ++ -- << >> >>> & | ^ ! ~ && || ? : = += -= *= %= **= <<= >>= >>>= &= |= ^= => / /= }
```

### 数字直接量 NumericLiteral

JavaScript 规范中规定的数字直接量可以支持四种写法: 十进制数, 二进制整数, 八进制整数和十六进制整数.

十进制的 Number 可以带小数, 小数点前后部分都可以省略, 但是不能同时省略. 比如 0.01, .01, 12, 12.01.

下面这个例子, 第一个就是错的, 因为编译器会把 `12.` 看成一个整体, 所以我们要想让点单独成为一个 token, 就要加入空格.

```ts
12.toString() // ❌
12 .toString() // ✅
```

### 字符串直接量 StringLiteral

JavaScript 中的 StringLiteral 支持单引号和双引号两种写法. 单双引号的区别仅仅在于写法, 在双引号字符串直接量中, 双引号必须转义, 在单引号字符串直接量中, 单引号必须转义. 有特别意义的字符包括有 SingleEscapeCharacter 所定义的 9 种.

![SingleEscapeCharacter](https://edge.yancey.app/beg/g7uzbfiu-1643029987546.webp)

### 正则表达式直接量 RegularExpressionLiteral

正则表达式由 Body 和 Flags 两部分组成, 其中 Body 部分至少有一个字符, 第一个字符不能是 \*(因为 /\* 跟多行注释有词法冲突).

### 字符串模板 Template

```shell
`a${b}c${d}e`;

`a${
  b
}c${
  d
}e`;
```

- `a${ 这个被称为模板头
- c${ 被称为模板中段
- }e` 被称为模板尾
- b 和 d 都是普通标识符

此外, 模板支持添加处理函数的写法:

```ts
function f() {
  console.log(arguments);
}

var a = ""world"";
f`Hello ${a}!`; // [[""Hello "", ""!""], world]
```

### 编译原理实战 -- 一个四则运算的解释器

- 定义四则运算: 产出四则运算的词法定义和语法定义.
- 词法分析: 把输入的字符串流变成 token.
- 语法分析: 把 token 变成抽象语法树 AST.
- 解释执行: 后序遍历 AST, 执行得出结果.

#### 定义四则运算

其实比较好理解, 就是诸如 `1 + 3 * 2` 这种.

#### 四则运算的词法分析

- Token
  - Number: 1 2 3 4 5 6 7 8 9 0 的组合
  - Operator: + , -, \*, / 之一
- Whitespace: \<SP>
- LineTerminator: \<LF> \<CR>

#### 四则运算的语法分析

大多数语法分析都使用 BNF(Backus-Naur Form) 是描述编程语言的文法. 巴科斯范式是一种用于表示上下文无关文法的语言, 上下文无关文法描述了一类形式语言. 因为加减乘除有优先级, 所以我们可以认为加法是由若干个乘法再由加号或者减号连接成的.

```ts
<Expression> ::=
    <AdditiveExpression><EOF>

<AdditiveExpression> ::=
    <MultiplicativeExpression>
    |<AdditiveExpression><+><MultiplicativeExpression>
    |<AdditiveExpression><-><MultiplicativeExpression>
```

#### 词法分析 - 状态机

词法分析有两种方案: 一种是状态机, 一种是正则表达式. 这里使用状态机.

```ts
let token = [];

const isNumberChar = (char) =>
  char === ""1"" ||
  char === ""2"" ||
  char === ""3"" ||
  char === ""4"" ||
  char === ""5"" ||
  char === ""6"" ||
  char === ""7"" ||
  char === ""8"" ||
  char === ""9"" ||
  char === ""0"";

const start = (char) => {
  if (isNumberChar(char)) {
    token.push(char);
    return inNumber;
  }

  if (char === ""+"" || char === ""-"" || char === ""*"" || char === ""/"") {
    emmitToken(char, char);
    return start;
  }

  if (char === "" "") {
    return start;
  }

  if (char === ""\r"" || char === ""\n"") {
    return start;
  }
};

const inNumber = (char) => {
  if (isNumberChar(char)) {
    token.push(char);
    return inNumber;
  } else {
    emmitToken(""Number"", token.join(""""));
    token = [];
    return start(char);
  }
};

// 运行状态机
const emmitToken = (type, value) => {
  console.log(value);
};

const input = ""1024 + 2 * 256"";

let state = start;

for (const c of input.split("""")) {
  state = state(c);
}

state(Symbol(""EOF""));
```

#### 语法分析(AST)

假设我们通过上一步的词法分析, 得到如下一个 token 数组.

```ts

var tokens = [{
    type:""Number"",
    value: ""1024""
}, {
    type:""+""
    value: ""+""
}, {
    type:""Number"",
    value: ""2""
}, {
    type:""*""
    value: ""*""
}, {
    type:""Number"",
    value: ""256""
}, {
    type:""EOF""
}];
```

然后写语法解析.

```ts
function Expression(source) {
  if (
    source[0].type === ""AdditiveExpression"" &&
    source[1] &&
    source[1].type === ""EOF""
  ) {
    let node = {
      type: ""Expression"",
      children: [source.shift(), source.shift()],
    };
    source.unshift(node);
    return node;
  }
  AdditiveExpression(source);
  return Expression(source);
}
function AdditiveExpression(source) {
  if (source[0].type === ""MultiplicativeExpression"") {
    let node = {
      type: ""AdditiveExpression"",
      children: [source[0]],
    };
    source[0] = node;
    return AdditiveExpression(source);
  }
  if (
    source[0].type === ""AdditiveExpression"" &&
    source[1] &&
    source[1].type === ""+""
  ) {
    let node = {
      type: ""AdditiveExpression"",
      operator: ""+"",
      children: [],
    };
    node.children.push(source.shift());
    node.children.push(source.shift());
    MultiplicativeExpression(source);
    node.children.push(source.shift());
    source.unshift(node);
    return AdditiveExpression(source);
  }
  if (
    source[0].type === ""AdditiveExpression"" &&
    source[1] &&
    source[1].type === ""-""
  ) {
    let node = {
      type: ""AdditiveExpression"",
      operator: ""-"",
      children: [],
    };
    node.children.push(source.shift());
    node.children.push(source.shift());
    MultiplicativeExpression(source);
    node.children.push(source.shift());
    source.unshift(node);
    return AdditiveExpression(source);
  }
  if (source[0].type === ""AdditiveExpression"") return source[0];
  MultiplicativeExpression(source);
  return AdditiveExpression(source);
}
function MultiplicativeExpression(source) {
  if (source[0].type === ""Number"") {
    let node = {
      type: ""MultiplicativeExpression"",
      children: [source[0]],
    };
    source[0] = node;
    return MultiplicativeExpression(source);
  }
  if (
    source[0].type === ""MultiplicativeExpression"" &&
    source[1] &&
    source[1].type === ""*""
  ) {
    let node = {
      type: ""MultiplicativeExpression"",
      operator: ""*"",
      children: [],
    };
    node.children.push(source.shift());
    node.children.push(source.shift());
    node.children.push(source.shift());
    source.unshift(node);
    return MultiplicativeExpression(source);
  }
  if (
    source[0].type === ""MultiplicativeExpression"" &&
    source[1] &&
    source[1].type === ""/""
  ) {
    let node = {
      type: ""MultiplicativeExpression"",
      operator: ""/"",
      children: [],
    };
    node.children.push(source.shift());
    node.children.push(source.shift());
    node.children.push(source.shift());
    source.unshift(node);
    return MultiplicativeExpression(source);
  }
  if (source[0].type === ""MultiplicativeExpression"") return source[0];

  return MultiplicativeExpression(source);
}

var source = [
  {
    type: ""Number"",
    value: ""3"",
  },
  {
    type: ""*"",
    value: ""*"",
  },
  {
    type: ""Number"",
    value: ""300"",
  },
  {
    type: ""+"",
    value: ""+"",
  },
  {
    type: ""Number"",
    value: ""2"",
  },
  {
    type: ""*"",
    value: ""*"",
  },
  {
    type: ""Number"",
    value: ""256"",
  },
  {
    type: ""EOF"",
  },
];
var ast = Expression(source);

console.log(ast);
```

#### 解释执行

最后是解释执行, 我们根据不同的节点类型和其它信息, 来计算出结果.

```ts
function evaluate(node) {
  if (node.type === ""Expression"") {
    return evaluate(node.children[0]);
  }
  if (node.type === ""AdditiveExpression"") {
    if (node.operator === ""-"") {
      return evaluate(node.children[0]) - evaluate(node.children[2]);
    }
    if (node.operator === ""+"") {
      return evaluate(node.children[0]) + evaluate(node.children[2]);
    }
    return evaluate(node.children[0]);
  }
  if (node.type === ""MultiplicativeExpression"") {
    if (node.operator === ""*"") {
      return evaluate(node.children[0]) * evaluate(node.children[2]);
    }
    if (node.operator === ""/"") {
      return evaluate(node.children[0]) / evaluate(node.children[2]);
    }
    return evaluate(node.children[0]);
  }
  if (node.type === ""Number"") {
    return Number(node.value);
  }
}
```

### 自动插入分号规则

- 要有换行符, 且下一个符号是不符合语法的, 那么就尝试插入分号.
- 有换行符, 且语法中规定此处不能有换行符, 那么就自动插入分号.
- 源代码结束处, 不能形成完整的脚本或者模块结构, 那么就自动插入分号.

下面这个例子中, `let a = 1` 后面没有分号, 但有一个换行符, 且如果连接且下一个符号 void 是不符合语法的, 因此引擎会尝试在 `let a = 1` 后面插入分号.

![引擎会尝试插入分号](https://edge.yancey.app/beg/wfjsjaw7-1644494497462.jpg)

JavaScript 中有一个 `[no LineTerminator here]` 的规则, 来约束下面几种场景不能有换行:

- 变量名 与 ++/-- 之间
- continue/break 与 label 之间
- async/return/throw/yield 后面
- 箭头函数参数括号和 => 之间

![no LineTerminator here 规则](https://edge.yancey.app/beg/mg7w2jim-1644494506671.jpg)

按照这个规则, 下面这个例子中, `a` 和下面的 `++` 不能有换行, 而这个 `++` 可以和 `b` 结合, 同理, `b` 后面的 ++ 可以和 `c` 结合. 最终表现如下面代码所示.

```ts
var a = 1,
  b = 1,
  c = 1;
a;
++b;
++c;
```

再如下面两个紧挨着的 IIFE, 第一个立即执行函数可以执行, 打印出 1, 第二个就直接报错了. 这段代码看似两个独立执行的函数表达式, 但是其实第三组括号被理解为传参, 导致抛出错误.

![IIFE](https://edge.yancey.app/beg/gdgsgqdv-1644495640642.jpg)

下面这个例子中, 根据 JavaScript 自动插入分号规则, 带换行符的注释也被认为是有换行符, 而恰好的是, return 也有 `[no LineTerminator here]` 规则的要求. 所以这里会自动插入分号.

![return](https://edge.yancey.app/beg/9kd1kxlv-1644495649563.jpg)

因此本意是返回 1, 但 return 后面自动加了分号, 就变成了 `return;`, 也就是 undefined.

```ts
function f() {
  return;
  /*
        This is a return value.
    */ 1;
}

f();
```

下面列举一些不写分号可能带来的坑:

![不写分号](https://edge.yancey.app/beg/l42bpvro-1644496466568.jpeg)

他们被卷成了下面的形式, 造成出错.

```ts
var a = [[]] /*这里没有被自动插入分号*/[(3, 2, 1, 0)]
  .forEach((e) => console.log(e));

var x = 1,
  g = { test: () => 0 },
  b = 1 /*这里没有被自动插入分号*/ / a / g.test(""abc"");
console.log(RegExp.$1);

var f = function () {
  return """";
};
var g = f/*这里没有被自动插入分号*/ `Template`.match(/(a)/);
console.log(RegExp.$1);
```

### 模块的引用

具体看这篇文章, [简析 AMD / CMD / UMD / CommonJS / ES Module](https://www.yanceyleo.com/post/7e95f2ef-adb3-4d1c-a0dc-1b910682dd65), 下面简单复习下.

下面这个例子, b 引用 a, 在 b 中调用方法来改变 a, 发现 a 也随之改变. 因为 esm 相当于是导出的是一个引用, 他们指向的都是同一个地址.

```ts
/* a.js */
export var a = 1;

export function modify() {
  a = 2;
}

/* b.js */

import { a, modify } from ""./a.js"";

console.log(a); // 1

modify();

console.log(a); // 2
```

### 函数提升

好吧, 以前只知道函数提升, 没考虑过判断语句中的提升. 在非严格模式下, 下面这句打出 undefined, 这意味着 foo 函数仍被提升, 只不过被提升成 undefined 了, 否则打印一个不存在的变量直接报错. 这说明 function 在预处理阶段仍然发生了作用, 在作用域中产生了变量, 没有产生赋值, 赋值行为发生在了执行阶段.

```ts
console.log(foo); // undefined
if (true) {
  function foo() {}
}
```

再看一下 class, class 是没有任何提升的, 如果在 `class A {}` 之前尝试获取 A, 直接报错, 以下两种都会报错.

```ts
console.log(c); // 报错
class c {}

var c = 1;
function foo() {
  console.log(c); // 报错
  class c {}
}
foo();
```

### 指令序言(Directive Prologs)

JavaScript 中唯一的指令序言就是 `""use strict"";`, 设计指令序言的目的是, 留给 JavaScript 的引擎和实现者一些统一的表达方式, 在静态扫描时指定 JavaScript 代码的一些特性. 看下面这个例子:

```ts
""use strict"";
function f() {
  console.log(this); // 如果不是严格模式, 则打印出 Global 或者 Window; 否则打印出 null
}
f.call(null);
```

### 语句

在 JavaScript 标准中, 语句分成**声明**和**语句**. 我们又可以基于此划分为普通语句和声明型语句.

![普通语句](https://edge.yancey.app/beg/7cxfus22-1644548676745.webp)

![声明型语句](https://edge.yancey.app/beg/pd4uwy0o-1644548684667.webp)

语句块很简单, 就是用大括号包裹, 当然这会产生块级作用域, 这和 Rust 表现是一致的.

```ts
{
  let x = 1;
}

console.log(x); // 报错
```

`for...in` 语句用来遍历部署了 `{enumerable: true}` 的对象, 值得注意的是它还会遍历原型链上的属性.

```ts
let o = {
  a: 10,
  b: 20,
};

// 会遍历到原型上的
o.__proto__.sayHi = function sayHi() {};

// 但不会遍历到""不可枚举""的属性
Object.defineProperty(o, ""c"", {
  enumerable: false,
  value: 30,
});

for (let p in o) console.log(p);
// 10
// 20
// sayHi
```

`for of` 循环和 `for await of` 循环用于遍历部署了 iterator 的对象, 常见的比如数组, NodeList. 当然你也可以手动给一个对象添加 iterator 属性.

```ts
let o = {
  [Symbol.iterator]: () => ({
    _value: 0,
    next() {
      if (this._value == 10)
        return {
          done: true,
        };
      else
        return {
          value: this._value++,
          done: false,
        };
    },
  }),
};

for (let e of o) {
  console.log(e);
}
```

在实际中, 生成器也可以使用 `for of`.

```ts
function* foo() {
  yield 0;
  yield 1;
  yield 2;
  yield 3;
}

for (let e of foo()) {
  console.log(e);
}
```

此外, JavaScript 还为异步生成器函数配备了异步的 for of. 下面这段代码定义了一个异步生成器函数, 异步生成器函数每隔一秒生成一个数字, 这是一个无限的生成器. 接下来, 我们使用 for await of 来访问这个异步生成器函数的结果, 我们可以看到, 这形成了一个每隔一秒打印一个数字的无限循环. 但是因为我们这个循环是异步的, 并且有时间延迟, 所以, 这个无限循环的代码可以用于显示时钟等有意义的操作.

```ts
function sleep(duration) {
  return new Promise(function (resolve, reject) {
    setTimeout(resolve, duration);
  });
}
async function* foo() {
  i = 0;
  while (true) {
    await sleep(1000);
    yield i++;
  }
}

for await (let e of foo()) {
  console.log(e);
}
```

break 语句和 continue 语句没啥可说的, break 语句用于跳出循环语句或者 switch 语句, continue 语句用于结束本次循环并继续循环. 不过这俩都可以使用""标签""语法.

```ts
outer: for (let i = 0; i < 100; i++) {
  inner: for (let j = 0; j < 100; j++)
    if (i == 50 && j == 50) {
      break outer;
    }
}

outer: for (let i = 0; i < 100; i++) {
  inner: for (let j = 0; j < 100; j++) {
    if (i >= 50 && j == 50) {
      continue outer;
    }
  }
}
```

with 语句基本不用, 是个设计错误, 它用于把对象的属性在它内部的作用域内变成变量.

```ts
let o = { a: 1, b: 2 };
with (o) {
  console.log(a, b);
}
```

let 和 const, 这俩没啥可说的, 不过下面这个例子还是值得学习的, 在 if 的作用域中, 变量 a 声明执行到之前, 我们访问了变量 a, 这时会抛出一个错误, 这说明 const 声明仍然是有预处理机制的. 在执行到 const 语句前, 我们的 JavaScript 引擎就已经知道后面的代码将会声明变量 a, 从而不允许我们访问外层作用域中的 a.

```ts
const a = 2;
if (true) {
  console.log(a); //抛错
  const a = 1;
}
```

#### 表达式语句

PrimaryExpression(主要表达式), 它是表达式的最小单位, 它所涉及的语法结构也是优先级最高的, 也包括直接量, 函数, 类, 数组, 正则表达式等等.

```ts
""abc"";
123;
null;
true;
false;
(class {});
[];
/abc/g;
this;
```

MemberExpression(成员表达式), 就是访问对象成员的, 比如对象和数组.

```ts
function F() {
  // new.target 用于判断该函数的调用是被 new 出来的, 还是直接当做普通函数调用的
  console.log(new.target);
}

F(); // undefined
new F(); // F

// super 则是构造函数中, 用于访问父类的属性的语法
super.b;

// 带函数名的模板表示把模板的各个部分算好后传递给一个函数
function ff(...args) {
  console.log(args); // [[""a"", ""b""], 2];
}
undefined;
ff`a${1 + 1}b`;
```

此外还有 NewExpression (NEW 表达式) 和 Call Expression (调用表达式) 统称 LeftHandSideExpression(左值表达式). 直观地讲, 左值表达式就是可以放到等号左边的表达式. 左值表达式最经典的用法是用于构成 AssignmentExpression (赋值表达式).

```ts
a = b;
// 连续赋值
a = b = c = d;

// *=, /=, %=, +=, -=, <<=, >>=, >>>=, &=, ^=, |=, **=
a += b;
```

赋值表达式可以构成 Expression 表达式的一部分, 在 JavaScript 中, 表达式就是用逗号运算符连接的赋值表达式. 比赋值运算优先级更低的就是逗号运算符.

```ts
(a = b), (b = 1), null;
```

## 语义化标签

- 语义类标签对开发者更为友好, 使用语义类标签增强了可读
- 文字表现力丰富, 更适合搜索引擎检索(SEO), 也可以让搜索引擎爬虫更好地获取到更多有效信息, 有效提升网页的搜索量, 并且语义类还可以支持读屏软件

```html
<hgroup>
  <h1>JavaScript对象</h1>
  <h2>我们需要模拟类吗？</h2>
</hgroup>
<p>balah balah</p>
```

section 标签不仅仅是一个""有语义的 div"", 它会改变 h1-h6 的语义. section 的嵌套会使得其中的 h1-h6 下降一级, 因此, 在 HTML5 以后, 我们只需要 section 和 h1 就足以形成文档的树形结构:

```html
<section>
  <h1>HTML语义</h1>
  <p>balah balah balah balah</p>
  <section>
    <h1>弱语义</h1>
    <p>balah balah</p>
  </section>
  <section>
    <h1>结构性元素</h1>
    <p>balah balah</p>
  </section>
  ......
</section>
```

### abbr 标签表示缩写

```html
<abbr title=""World Wide Web"">WWW</abbr>
```

### hr

hr 标签 1 表示故事走向的转变或者话题的转变, 装饰性的分割线用 css 即可.

### 表示征引的标签

在 HTML 中, 有三个跟引述相关的标签 blockquote 表示段落级引述内容, q 表示行内的引述内容, cite 表示引述的作品名.在文章的结尾处, 有对应的 References 一节, 这一节中所有的作品名称也应该加入 cite 标签.

### 表示定义概念的标签 dfn

```html
<p>
  However, the two are not the same. The <dfn>Internet</dfn> is a global system
  of interconnected computer networks.
</p>
```

### nav, ol, ul

用于表达目录.

```html
<nav>
  <h2>Contents</h2>
  <ol>
    <li><a href=""..."">History</a></li>
    <li>
      <a href=""..."">Function</a>
      <ol>
        <li><a href=""..."">Linking</a></li>
        <li><a href=""..."">Dynamic updates of web pages</a></li>
        ...
      </ol>
    </li>
    ...
  </ol>
  `
</nav>
```

### pre, samp, code

使用了 pre 标签, 表示这部分内容是预先排版过的, 不需要浏览器进行排版. 又因为这是一段计算机程序的**示例**输出, 可以使用 samp 标签.

```html
<pre><samp>
GET /home.html HTTP/1.1
Host: www.example.org
</samp></pre>
```

![更多语义化标签](https://edge.yancey.app/beg/hhp6sls5-1643093245926.webp)

## css

CSS 的顶层样式表由两种规则组成的规则列表构成, 一种被称为 at-rule, 也就是 at 规则, 另一种是 qualified rule, 也就是普通规则. at-rule 由一个 @ 关键字和后续的一个区块组成, 如果没有区块, 则以分号结束.

### at-rule

#### @charset

@charset 用于提示 CSS 文件使用的字符编码方式, 它如果被使用, 必须出现在最前面. 这个规则只在给出语法解析阶段前使用, 并不影响页面上的展示效果.

```css
@charset ""utf-8"";
```

#### @import

@import 用于引入一个 CSS 文件, 除了 @charset 规则不会被引入, @import 可以引入另一个文件的全部内容.

```css
@import ""mystyle.css"";
@import url(""mystyle.css"");
```

#### @media

media 就是大名鼎鼎的 media query 使用的规则了, 它能够对设备的类型进行一些判断.在 media 的区块内, 是普通规则列表.

```css
@media print {
  body {
    font-size: 10pt;
  }
}
```

#### @page

page 用于分页媒体访问网页时的表现设置, 页面是一种特殊的盒模型结构, 除了页面本身, 还可以设置它周围的盒.

```css
@page {
  size: 8.5in 11in;
  margin: 10%;

  @top-left {
    content: ""Hamlet"";
  }
  @top-right {
    content: ""Page "" counter(page);
  }
}
```

#### @counter-style

counter-style 产生一种数据, 用于定义列表项的表现.

```css
@counter-style triangle {
  system: cyclic;
  symbols: ‣;
  suffix: "" "";
}
```

#### @keyframes

keyframes 产生一种数据, 用于定义动画关键帧.

```css
@keyframes diagonal-slide {
  from {
    left: 0;
    top: 0;
  }

  to {
    left: 100px;
    top: 100px;
  }
}
```

#### @fontface

fontface 用于定义一种字体, icon font 技术就是利用这个特性来实现的.

```css
@font-face {
  font-family: Gentium;
  src: url(http://example.com/fonts/Gentium.woff);
}

p {
  font-family: Gentium, serif;
}
```

#### 其他

- @support: support 检查环境的特性, 它与 media 比较类似.
- @namespace: 用于跟 XML 命名空间配合的一个规则, 表示内部的 CSS 选择器全都带上特定命名空间.
- @viewport: 用于设置视口的一些特性, 不过兼容性目前不是很好, 多数时候被 HTML 的 meta 代替.
- @color-profile 是 SVG1.0 引入的 CSS 特性, 但是实现状况不怎么好.
- @document 还没讨论清楚, 被推迟到了 CSS4 中.
- @font-feature-values.

### qualified rule

#### 选择器

![选择器](https://edge.yancey.app/beg/rpcgkxtc-1643095994795.webp)

#### css variables

```css
:root {
  --main-color: #06c;
  --accent-color: #006;
}

#foo h1 {
  color: var(--main-color);
}
```

#### css values

- CSS 范围的关键字: initial, unset, inherit, 任何属性都可以的关键字.
- 字符串: 比如 content 属性.
- URL: 使用 url() 函数的 URL 值.
- 整数 / 实数: 比如 flex 属性.
- 维度: 单位的整数 / 实数, 比如 width 属性.
- 百分比: 大部分维度都支持.
- 颜色: 比如 background-color 属性.
- 图片: 比如 background-image 属性.
- 2D 位置: 比如 background-position 属性.
- 函数: 来自函数的值, 比如 transform 属性.
  - calc(): 基本的表达式计算, 它支持加减乘除四则运算
  - max(): 表示取两数中较大的一个
  - min(): 表示取两数之中较小的一个
  - clamp(): 给一个值限定一个范围, 超出范围外则使用范围的最大或者最小值
  - toggle(): 在规则选中多于一个元素时生效, 它会在几个值之间来回切换, 比如我们要让一个列表项的样式圆点和方点间隔出现
  - attr(): 允许 CSS 接受属性值的控制

### \<head> 标签

head 标签用于承载元信息, 其中有 \<title>, \<base>, \<meta> 标签, 这里着重说下 meta:

meta 标签是一组键值对, 它是一种通用的元信息表示标签. 在 head 中可以出现任意多个 meta 标签. 一般的 meta 标签由 name 和 content 两个属性来定义. name 表示元信息的名, content 则用于表示元信息的值.

- `<meta charset=""UTF-8"" >`, 描述了 HTML 文档自身的编码形式
- 具有 http-equiv 属性的 meta, 如 `<meta http-equiv=""content-type"" content=""text/html; charset=UTF-8"">`
  - content-type 添加了 content-type 这个 http 头, 并且指定了 http 编码方式.
  - content-language 指定内容的语言
  - default-style 指定默认样式表
  - refresh 刷新
  - set-cookie 模拟 http 头 set-cookie, 设置 cookie
  - x-ua-compatible 模拟 http 头 x-ua-compatible, 声明 ua 兼容性
  - content-security-policy 模拟 http 头 content-security-policy, 声明内容安全策略.
- name 为 viewport 的 meta, 如 `<meta name=""viewport"" content=""width=500, initial-scale=1"">`
  - width: 页面宽度, 可以取值具体的数字, 也可以是 device-width, 表示跟设备宽度相等.
  - height: 页面高度, 可以取值具体的数字, 也可以是 device-height, 表示跟设备高度相等.
  - initial-scale: 初始缩放比例.
  - minimum-scale: 最小缩放比例.
  - maximum-scale: 最大缩放比例.
  - user-scalable: 是否允许用户缩放.
- 预定义的 meta
  - author: 页面作者.
  - description: 页面描述, 这个属性可能被用于搜索引擎或者其它场合.
  - generator: 生成页面所使用的工具, 主要用于可视化编辑器, 如果是手写 HTML 的网页, 不需要加这个 meta.
  - keywords: 页面关键字, 对于 SEO 场景非常关键.
  - referrer: 跳转策略, 是一种安全考量.
  - theme-color: 页面风格颜色, 实际并不会影响页面, 但是浏览器可能据此调整页面之外的 UI(如窗口边框或者 tab 的颜色).

### css 选择器

![简单选择器](https://edge.yancey.app/beg/7xz6ssdf-1643098093472.webp)

#### 类型选择器和全体选择器

类型选择器最简单的就是选择一个 dom 标签, 但是 a 标签存在于 svg 中, 也有超链接的形式, 可以通过带命名空间的类型选择器来区分. 此外全体选择器就是 \* 了, 一般 reset-css 这种东西会用到.

```css
@namespace svg url(http://www.w3.org/2000/svg);
@namespace html url(http://www.w3.org/1999/xhtml);
svg|a {
  stroke: blue;
  stroke-width: 1;
}
html|a {
  font-size: 40px;
}
```

#### id 选择器和类选择器

不多说, 最重要的是能知晓 css 选择器优先级, 可以看 [关于 css 优先级](https://www.yanceyleo.com/post/a529f531-bd56-4809-b5ed-8d91ddfcbd02).

#### 属性选择器

| 选择器             | 描述                                                        |
| ------------------ | ----------------------------------------------------------- |
| [attribute]        | 用于选取带有指定属性的元素                                  |
| [attribute=value]  | 用于选取带有指定属性和值的元素                              |
| [attribute~=value] | 用于选取属性值中包含指定词汇的元素                          |
| [attribute=value]  | 用于选取带有以指定值开头的属性值的元素, 该值必须是整个单词. |
| [attribute^=value] | 匹配属性值以指定值开头的每个元素.                           |
| [attribute$=value] | 匹配属性值以指定值结尾的每个元素.                           |
| [attribute*=value] | 匹配属性值中包含指定值的每个元素.                           |

#### 伪类选择器

- :empty 伪类表示没有子节点的元素, 这里有个例外就是子节点为空白文本节点的情况
- :nth-child 和 :nth-last-child 这是两个函数型的伪类
- :nth-last-child 的区别仅仅是从后往前数.
- :first-child :last-child 分别表示第一个和最后一个元素.
- :only-child 按字面意思理解即可, 选中唯一一个子元素.
- :any-link 表示任意的链接, 包括 a, area 和 link 标签都可能匹配到这个伪类.
- :link 表示未访问过的链接, :visited 表示已经访问过的链接.
- :hover 表示鼠标悬停在上的元素.
- :active 表示用户正在激活这个元素, 如用户按下按钮, 鼠标还未抬起时, 这个按钮就处于激活状态.
- :focus 表示焦点落在这个元素之上.:target 用于选中浏览器 URL 的 hash 部分所指示的元素.
- :not 伪类

### 伪元素

- ::first-line
- ::first-letter
- ::before
- ::after

## HTML 链接

提到 HTML 链接能想到的有 a 标签, 其实还有下面这么多.

![链接.png](https://edge.yancey.app/beg/ykrk1lqy-1643187179882.png)

## area 类型

特别说一下 area 类型. area 是整个 html 规则中唯一支持非矩形热区的标签, 它的 shape 属性支持三种类型.

- 圆形: circle 或者 circ, coords 支持三个值, 分别表示中心点的 x,y 坐标和圆形半径 r.
- 矩形: rect 或者 rectangle, coords 支持两个值, 分别表示两个对角顶点 x1, y1 和 x2, y2.
- 多边形: poly 或者 polygon, coords 至少包括 6 个值, 表示多边形的各个顶点.

```html
<p>
  Please select a shape:
  <img
    src=""shapes.png""
    usemap=""#shapes""
    alt=""Four shapes are available: a red hollow box, a green circle, a blue triangle, and a yellow four-pointed star.""
  />
  <map name=""shapes"">
    <area shape=""rect"" coords=""50,50,100,100"" />
    <!-- the hole in the red box -->
    <area shape=""rect"" coords=""25,25,125,125"" href=""red.html"" alt=""Red box."" />
    <area
      shape=""circle""
      coords=""200,75,50""
      href=""green.html""
      alt=""Green circle.""
    />
    <area
      shape=""poly""
      coords=""325,25,262,125,388,125""
      href=""blue.html""
      alt=""Blue triangle.""
    />
    <area
      shape=""poly""
      coords=""450,25,435,60,400,75,435,90,450,125,465,90,500,75,465,60""
      href=""yellow.html""
      alt=""Yellow star.""
    />
  </map>
</p>
```

## 文档流

在 CSS 标准中, 规定了如何排布每一个文字或者盒的算法, 这个算法依赖一个排版的""当前状态"", CSS 把这个当前状态称为""格式化上下文(formatting context). `格式化上下文 + 盒 / 文字 = 位置 (formatting context + boxes/charater = positions)`.

复习下块级格式化上下文:

- 浮动元素;
- 绝对定位元素;
- 非块级但仍能包含块级元素的容器(如 inline-blocks, table-cells, table-captions);
- 块级的能包含块级元素的容器, 且属性 overflow 不为 visible

![vertical](https://edge.yancey.app/beg/1d5bukrs-1643265415239.webp)

## 替换元素

常见的替换元素: script, image, picture, audio, video, iframe. 他们可以通过 src 属性; srcset 属性; source 标签; srcdoc 属性传入资源.

从性能的角度考虑, 建议同时给出图片的宽高, 因为替换型元素加载完文件后, 如果尺寸发生变换, 会触发重排版.

### iframe 的安全性

iframe 标签能够嵌入一个完整的网页. 不过, 在移动端, iframe 受到了相当多的限制, 它无法指定大小, 里面的内容会被完全平铺到父级页面上. 同时很多网页也会通过 http 协议头禁止自己被放入 iframe 中. iframe 标签也是各种安全问题的重灾区. opener, window.name, 甚至 css 的 opacity 都是黑客可以利用的漏洞.

在新标准中, 为 iframe 加入了 sandbox 模式和 srcdoc 属性, 这样, 给 iframe 带来了一定的新场景. 这个例子中, 使用 srcdoc 属性创建了一个新的文档, 嵌入在 iframe 中展示, 并且使用了 sandbox 来隔离. 这样, 这个 iframe 就不涉及任何跨域问题.

```html
<iframe sandbox srcdoc=""<p>Yeah, you can see it <a href=""/gallery?mode=cover&amp;amp;page=1"">in my gallery</a>.""></iframe>
```

## 贝塞尔曲线

贝塞尔曲线是一种插值曲线, 它描述了两个点之间差值来形成连续的曲线形状的规则. 一个量(可以是任何矢量或者标量)从一个值到变化到另一个值, 如果我们希望它按照一定时间平滑地过渡, 就必须要对它进行插值. 它最大的特点就是""平滑"". 时间曲线平滑, 意味着较少突兀的变化, 这是一般动画设计所追求的.

## HSL 颜色

颜色是从人类的视觉原理建模, 应该说是十分科学了. 但是, 人类对颜色的认识却并非来自自己的神经系统, 当我们把阳光散射, 可以得到七色光: 红橙黄绿蓝靛紫, 实际上, 阳光接近白光, 它包含了各种颜色的光, 它散射之后, 应该是个基本连续的. 这说明对人的感知来说, 颜色远远大于红, 绿, 蓝. 因此, HSL 这样的颜色模型被设计出来了, 它用一个值来表示人类认知中的颜色, 我们用专业的术语叫做色相(H). 加上颜色的纯度(S)和明度(L), 就构成了一种颜色的表示.

![ HSL 颜色](https://edge.yancey.app/beg/rmgvozli-1643271870854.webp)

## 考古: DTD

在 HTML 中, 规定了两种文本语法, 一种是普通的文本节点, 另一种是 CDATA 文本节点. 文本节点看似是普通的文本, 但是, 其中有两种字符是必须做转义的, 就是 < 和 &.如果我们从某处拷贝了一段文本, 里面包含了大量的 < 和 &, 那么我们就有麻烦了, 这时候, 就轮到我们的 CDATA 节点出场了.

DTD 的全称是 Document Type Definition, 也就是文档类型定义. 上个时代走过来的前端, 一定还记得 HTML4.01 有三种 DTD. 分别是严格模式, 过渡模式和 frameset 模式. 当然 h5 已经变成了 `<!DOCTYPE html>`.

## 浏览器过程

- 浏览器首先使用 HTTP 协议或者 HTTPS 协议, 向服务端请求页面;
- 把请求回来的 HTML 代码经过解析, 构建成 DOM 树;
- 计算 DOM 树上的 CSS 属性;
- 最后根据 CSS 属性对元素逐个进行渲染, 得到内存中的位图;
- 一个可选的步骤是对位图进行合成, 这会极大地增加后续绘制的速度;
- 合成之后, 再绘制到界面上.

从 HTTP 请求回来, 就产生了流式的数据, 后续的 DOM 树构建, CSS 计算, 渲染, 合成, 绘制, 都是尽可能地流式处理前一步的产出: 即不需要等到上一步骤完全结束, 就开始处理上一步的输出, 这样我们在浏览网页时, 才会看到逐步出现的页面.

HTTP 协议是基于 TCP 协议出现的, 对 TCP 协议来说, TCP 协议是一条双向的通讯通道, HTTP 在 TCP 的基础上, 规定了 Request-Response 的模式. 这个模式决定了通讯必定是由浏览器端首先发起.

## HTTPS

![https 过程](https://edge.yancey.app/beg/6dpuitzl-1643278529808.jpeg)

证书验证阶段

- 浏览器发起 HTTPS 请求
- 服务端返回 HTTPS 证书
- 客户端验证证书是否合法, 如果不合法则提示告警

数据传输阶段

- 当证书验证合法后, 在本地生成随机数
- 通过公钥加密随机数, 并把加密后的随机数传输到服务端
- 服务端通过私钥对随机数进行解密
- 服务端通过客户端传入的随机数构造对称加密算法, 对返回结果内容进行加密后传输

### 为什么数据传输是用对称加密?

首先, 非对称加密的加解密效率是非常低的, 而 http 的应用场景中通常端与端之间存在大量的交互, 非对称加密的效率是无法接受的; 另外, 在 HTTPS 的场景中只有服务端保存了私钥, 一对公私钥只能实现单向的加解密, 所以 HTTPS 中内容传输加密采取的是对称加密, 而不是非对称加密.

### 为什么需要 CA 认证机构颁发证书

HTTP 协议被认为不安全是因为传输过程容易被监听者勾线监听, 伪造服务器, 而 HTTPS 协议主要解决的便是网络传输的安全性问题. 首先我们假设不存在认证机构, 任何人都可以制作证书, 这带来的安全风险便是经典的""中间人攻击""问题. 由于缺少对证书的验证, 所以客户端虽然发起的是 HTTPS 请求, 但客户端完全不知道自己的网络已被拦截, 传输内容被中间人全部窃取.

![中间人攻击](https://edge.yancey.app/beg/t4gmqggv-1643278965188.jpeg)

1.本地请求被劫持(如 DNS 劫持等), 所有请求均发送到中间人的服务器

2.中间人服务器返回中间人自己的证书

3.客户端创建随机数, 通过中间人证书的公钥对随机数加密后传送给中间人, 然后凭随机数构造对称加密对传输内容进行加密传输

4.中间人因为拥有客户端的随机数, 可以通过对称加密算法进行内容解密

5.中间人以客户端的请求内容再向正规网站发起请求

6.因为中间人与服务器的通信过程是合法的, 正规网站通过建立的安全通道返回加密后的数据

7.中间人凭借与正规网站建立的对称加密算法对内容进行解密

8.中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输

9.客户端通过与中间人建立的对称加密算法对返回结果数据进行解密

### 浏览器如何验证证书的合法性

浏览器发起 HTTPS 请求时, 服务器会返回网站的 SSL 证书, 浏览器需要对证书做以下验证:

1.验证域名, 有效期等信息是否正确. 证书上都有包含这些信息, 比较容易完成验证;

2.判断证书来源是否合法. 每份签发证书都可以根据验证链查找到对应的根证书, 操作系统, 浏览器会在本地存储权威机构的根证书, 利用本地根证书可以对对应机构签发证书完成来源验证;

3.判断证书是否被篡改. 需要与 CA 服务器进行校验;

4.判断证书是否已吊销. 通过 CRL(Certificate Revocation List 证书注销列表)和 OCSP(Online Certificate Status Protocol 在线证书状态协议)实现, 其中 OCSP 可用于第 3 步中以减少与 CA 服务器的交互, 提高验证效率

以上任意一步都满足的情况下浏览器才认为证书是合法的.

## 解析 HTML 代码, 构建 DOM 树

以 p 标签为例, HTML 的""第一个词""是 `<p`, 因为 `<p>` 太大了, p 标签里会有一些属性.

![token 分析](https://edge.yancey.app/beg/yn0k7f5k-1643364795993.webp)

在接受第一个字符之前, 我们完全无法判断这是哪一个词(token), 不过, 随着我们接受的字符越来越多, 拼出其他的内容可能性就越来越少.

比如, 我们接受了一个字符 ""<"", 就知道这不是一个文本节点. 之后我们再读一个字符, 比如就是 x, 那么我们一下子就知道这不是注释和 CDATA 了, 接下来我们就一直读, 直到遇到"">""或者空格, 这样就得到了一个完整的词(token)了. 实际上, 我们每读入一个字符, 其实都要做一次决策, 而且这些决定是跟""当前状态""有关的. 这种解析的手段一般使用状态机来实现.

状态机的初始状态, 我们仅仅区分 ""< ""和 ""非 <"":

- 如果获得的是一个非 < 字符, 那么可以认为进入了一个文本节点;
- 如果获得的是一个 < 字符, 那么进入一个标签状态.

不过当我们在标签状态时, 则会面临着一些可能性.

- 比如下一个字符是""!"", 那么很可能是进入了注释节点或者 CDATA 节点.
- 如果下一个字符是 ""/"", 那么可以确定进入了一个结束标签.
- 如果下一个字符是字母, 那么可以确定进入了一个开始标签.
- 如果我们要完整处理各种 HTML 标准中定义的东西, 那么还要考虑"" ? """"% ""等内容.

![词法解析](https://edge.yancey.app/beg/22tf7ee8-1643367220602.webp)

再通过分词的结果构建成 DOM tree 就可以供浏览器使用了.

## 解析 CSS

在构建 DOM 的过程, 从父到子, 从先到后, 一个一个节点构造. 并且挂载到 DOM 树上的, `在此过程中, 同步也会把 CSS 属性计算出来`. 一个 compound-selector 是检查一个元素的规则, 而一个复合型选择器, 则是由数个 compound-selector 通过前面讲的符号连接起来的. 复习一下所有的选择器.

- `空格`: 后代, 选中它的子节点和所有子节点的后代节点.
- `>`: 子代, 选中它的子节点.
- `+`: 直接后继选择器, 选中它的下一个相邻节点.
- `~`: 后继, 选中它之后所有的相邻节点.
- `||`: 列, 选中表格中的一列.

以后代选择器为例: 当我们找到了匹配 a#b 的元素时, 我们才会开始检查它所有的子代是否匹配 .cls, 除了前进一段的情况, 我们还需要处理后退的情况, 当遇到 `</a>` 时, 必须使得规则 a#b .cls 回退一步, 这样第三个 span 才不会被选中. 后代选择器的作用范围是父节点的所有子节点, 因此规则是在匹配到本标签的结束标签时回退.

```html
<style>
a#b .cls {
    width: 100px;
}
</style>


<a id=b>
    <span>1<span>
    <span class=cls>2<span>
</a>
<span class=cls>3<span>
```

## 小谈排版

浏览器又可以支持元素和文字的混排, 元素被定义为占据长方形的区域, 还允许边框, 边距和留白, 这个就是所谓的盒模型. 在正常流的基础上, 浏览器还支持两类元素: 绝对定位元素和浮动元素. 绝对定位元素把自身从正常流抽出, 直接由 top 和 left 等属性确定自身的位置, 不参加排版计算, 也不影响其它元素. 绝对定位元素由 position 属性控制. 浮动元素则是使得自己在正常流的位置向左或者向右移动到边界, 并且占据一块排版空间. 浮动元素由 float 属性控制. 除了正常流, 浏览器还支持其它排版方式, 比如现在非常常用的 Flex 排版, 这些排版方式由外部元素的 display 属性来控制(注意, display 同时还控制元素在正常流中属于 inline 等级还是 block 等级).

## 渲染 & 合成 & 绘制

DOM 渲染到页面上指的是把模型变成位图的过程, 这里的位图就是在内存里建立一张二维表格, 把一张图片的每个像素对应的颜色保存进去(位图信息也是 DOM 树中占据浏览器内存最多的信息, 我们在做内存占用优化时, 主要就是考虑这一部分).

浏览器中渲染这个过程, 就是把每一个元素对应的盒变成位图. 这里的元素包括 HTML 元素和伪元素, 一个元素可能对应多个盒(比如 inline 元素, 可能会分成多行). 每一个盒对应着一张位图. 渲染可以分成图形和文字两大类.

盒的背景, 边框, SVG 元素, 阴影等特性, 都是需要绘制的图形类. 字形分为像素字形和矢量字形两种. 通常的字体, 会在 6px 8px 等小尺寸提供像素字形, 比较大的尺寸则提供矢量字形. 矢量字形本身就需要经过渲染才能继续渲染到元素的位图上去. 目前最常用的字体库是 Freetype, 这是一个 C++ 编写的开源的字体库.

当然像阴影这种, 它可能非常巨大, 或者渲染到非常遥远的位置, 所以为了优化, 浏览器实际的实现中会把阴影作为一个独立的盒来处理. 当父子元素的相对位置发生变化时, 可以保证渲染的结果能够最大程度被缓存, 减少重新渲染.

合成是一种优化策略, 合成的目标就是提高性能, 根据这个目标, 我们建立的原则就是最大限度减少绘制次数原则. 看两个极端例子, 假如所有的元素都合成, 那么一旦改变了任何一个 CSS 属性, 这个合成的位图就废了; 假如不做合成, 每次我们都必须要重新绘制所有的元素, 这显然是性能不好的. 因此, 好的合成策略是""猜测""可能变化的元素, 把它排除到合成之外. 典型的像 transform 这些会触发合成层. css3 还有一个属性 `will-change` 可以主动告知引擎进行合成.

绘制是把""位图最终绘制到屏幕上, 变成肉眼可见的图像""的过程. 我们已经得到了每个元素的位图, 并且对它们部分进行了合成, 那么绘制过程, 实际上就是按照 z-index 把它们依次绘制到屏幕上. 计算机图形学中, 使用的方案就是""脏矩形""算法, 也就是把屏幕均匀地分成若干矩形区域. 当鼠标移动, 元素移动或者其它导致需要重绘的场景发生时, 我们只重新绘制它所影响到的几个矩形区域就够了. 比矩形区域更小的影响最多只会涉及 4 个矩形, 大型元素则覆盖多个矩形. 设置合适的矩形区域大小, 可以很好地控制绘制时的消耗. 设置过大的矩形会造成绘制面积增大, 而设置过小的矩形则会造成计算复杂.

TIPS: 重排涉及到排版; 重绘, 涉及到渲染合成绘制.

## DOM

DOM API 大致会包含 4 个部分:

- 节点: DOM 树形结构中的节点相关 API.
- 事件: 触发和监听事件相关 API.
- Range: 操作文字范围相关 API.
- 遍历: 遍历 DOM 需要的 API.

### Node 节点

![Node 节点](https://edge.yancey.app/beg/6x5dl7si-1643446819367.webp)

Node 是 DOM 树继承关系的根节点, 它定义了 DOM 节点在 DOM 树上的操作, 首先, Node 提供了一组属性, 来表示它在 DOM 树中的关系, 它们是:

- parentNode
- childNodes
- firstChild
- lastChild
- nextSibling
- previousSibling

Node 中也提供了操作 DOM 树的 API, 主要有下面几种:

- appendChild
- insertBefore
- removeChild
- replaceChild

除此之外, Node 还提供了一些高级 API:

- compareDocumentPosition 是一个用于比较两个节点中关系的函数
- contains 检查一个节点是否包含另一个节点的函数
- isEqualNode 检查两个节点是否完全相同
- isSameNode 检查两个节点是否是同一个节点, 实际上在 JavaScript 中可以用""===""
- cloneNode 复制一个节点, 如果传入参数 true, 则会连同子元素做深拷贝

DOM 标准规定了节点必须从文档的 create 方法创建出来, 不能够使用原生的 JavaScript 的 new 运算. 于是 document 对象有这些方法.

- createElement
- createTextNode
- createCDATASection
- createComment
- createProcessingInstruction
- createDocumentFragment
- createDocumentType

### Element 与 Attribute

Node 提供了树形结构上节点相关的操作, 而大部分时候, 我们比较关注的是元素. 元素对应了 HTML 中的标签, 它既有子节点, 又有属性. 所以 Element 子类中, 有一系列操作属性的方法. 首先, 我们可以把元素的 Attribute 当作字符串来看待, 也可以当作节点来看待.

- getAttribute
- setAttribute
- removeAttribute
- hasAttribute
- getAttributeNode
- setAttributeNode

当然查找元素就太熟悉不过了:

- querySelector
- querySelectorAll
- getElementById
- getElementsByName
- getElementsByTagName
- getElementsByClassName

通过 Node 的相关属性, 我们可以用 JavaScript 遍历整个树. 实际上, DOM API 中还提供了 NodeIterator 和 TreeWalker 来遍历树.

```ts
// NodeIterator
var iterator = document.createNodeIterator(
  document.body,
  NodeFilter.SHOW_TEXT | NodeFilter.SHOW_COMMENT,
  null,
  false
);
var node;
while ((node = iterator.nextNode())) {
  console.log(node);
}

// TreeWalker
var walker = document.createTreeWalker(
  document.body,
  NodeFilter.SHOW_ELEMENT,
  null,
  false
);
var node;
while ((node = walker.nextNode())) {
  if (node.tagName === ""p"") node.nextSibling();
  console.log(node);
}
```

### Range

Range 一般用于富文本编辑类, 可以和 Selection API 配合, 挺有意思, 有空玩玩.

![Jietu20220129-180331.jpg](https://edge.yancey.app/beg/xy2kaecp-1643450623665.jpg)

```ts
var range = document.getSelection().getRangeAt(0);
range.startContainer.data.slice(22, 36); // 范围, 这个范围是以文字为最小
```

### 命名空间

在 HTML 场景中, 需要考虑命名空间的场景不多. 最主要的场景是 SVG. 创建元素和属性相关的 API 都有带命名空间的版本.

- document
  - createElementNS
  - createAttributeNS
- Element

  - getAttributeNS
  - setAttributeNS
  - getAttributeNodeNS
  - setAttributeNodeNS
  - removeAttributeNS
  - hasAttributeNS
  - attributes.setNamedItemNS
  - attributes.getNamedItemNS
  - attributes.removeNamedItemNS

若要创建 Document 或者 Doctype, 也必须要考虑命名空间问题. DOM 要求从 document.implementation 来创建.

- document.implementation.createDocument
- document.implementation.createDocumentType
- document.implementation.createHTMLDocument

## CSSOM & CSSOM View

document 的 styleSheets 属性表示文档中的所有样式表, 这是一个只读的列表, 我们可以用方括号运算符下标访问样式表, 也可以使用 item 方法来访问, 它有 length 属性表示文档中的样式表数量. 样式表只能使用 style 标签或者 link 标签创建, 不可通过 `document.styleSheets` 创建. 此外还有一个 `window.getComputedStyle(elt, pseudoElt);` 方法, 注意这个会造成重排.

```ts
document.styleSheets;

// 修改样式表里的数据
document.styleSheets[0].insertRule(""p { color:pink; }"", 0);
document.styleSheets[0].removeRule(0);

// 获取 at-rules
document.styleSheets[0].cssRules;
```

CSSOM View 这一部分的 API, 可以视为 DOM API 的扩展, 它在原本的 Element 接口上, 添加了显示相关的功能, 这些功能, 又可以分成三个部分: 窗口部分, 滚动部分和布局部分.

### 窗口 API

窗口 API 窗口 API 用于操作浏览器窗口的位置, 尺寸等. 通过这些属性和方法, 我们可以读取视口的滚动位置和操纵视口滚动.

- moveTo(x, y) 窗口移动到屏幕的特定坐标;
- moveBy(x, y) 窗口移动特定距离;
- resizeTo(x, y) 改变窗口大小到特定尺寸;
- resizeBy(x, y) 改变窗口大小特定尺寸.
- window.open() 打开新窗口

### 元素滚动 API

- scrollTop 元素的属性, 表示 Y 方向上的当前滚动距离.
- scrollLeft 元素的属性, 表示 X 方向上的当前滚动距离.
- scrollWidth 元素的属性, 表示元素内部的滚动内容的宽度, 一般来说会大于等于元素宽度.
- scrollHeight 元素的属性, 表示元素内部的滚动内容的高度, 一般来说会大于等于元素高度.
- scroll(x, y) 使得元素滚动到特定的位置, 有别名 scrollTo, 支持传入配置型参数 {top, left}.
- scrollBy(x, y) 使得元素滚动到特定的位置, 支持传入配置型参数 {top, left}.
- scrollIntoView(arg) 滚动元素所在的父元素, 使得元素滚动到可见区域, 可以通过 arg 来指定滚到中间, 开始或者就近.

### 布局 API

![布局 API](https://edge.yancey.app/beg/rcojgefk-1643514426551.webp)

### 元素的布局 API

- `getClientRects()`: 返回一个列表, 里面包含元素对应的每一个盒所占据的客户端矩形区域, 这里每一个矩形区域可以用 x, y, width, height 来获取它的位置和尺寸
- `getBoundingClientRect()`: 这个 API 的设计更接近我们脑海中的元素盒的概念, 它返回元素对应的所有盒的包裹的矩形区域, 需要注意, 这个 API 获取的区域会包括当 overflow 为 visible 时的子元素区域

![元素的布局 API](https://edge.yancey.app/beg/xvz3mvl5-1643514672099.jpg)

### 捕获和冒泡

事件一般由键盘, 鼠标, 触摸屏. 这其中, 触摸屏和鼠标又有一定的共性, 它们被称作 pointer 设备, 所谓 pointer 设备, 是指它的输入最终会被抽象成屏幕上面的一个点. 那么, 把这个坐标转换为具体的元素上事件的过程, 就是捕获过程了. 而冒泡过程, 则是符合人类理解逻辑的: 当你按电视机开关时, 你也按到了电视机. 所以我们可以认为, 捕获是计算机处理事件的逻辑, 而冒泡是人类处理事件的逻辑.

在一个事件发生时, 捕获过程跟冒泡过程总是先后发生, 跟你是否监听毫无关联. 在我们实际监听事件时, 我建议这样使用冒泡和捕获机制: 默认使用冒泡模式, 当开发组件时, 遇到需要父元素控制子元素的行为, 可以使用捕获机制.

addEventListener 有三个参数:

- 事件名称;
- 事件处理函数;
- 捕获还是冒泡.

事件处理函数不一定是函数, 也可以是个 JavaScript 具有 handleEvent 方法的对象, 看下例子:

```ts
const o = {
  handleEvent: (event) => console.log(event),
};

document.body.addEventListener(""keydown"", o, false);
```

第三个参数不一定是 bool 值, 也可以是个对象, 它提供了更多选项.

- once: 只执行一次.
- passive: 承诺此事件监听不会调用 preventDefault, 这有助于性能.
- useCapture: 是否捕获, 否则冒泡

### 焦点

键盘事件是由焦点系统控制的, 焦点系统也是视障用户访问的重要入口. 焦点系统认为整个 UI 系统中, 有且仅有一个""聚焦""的元素, 所有的键盘事件的目标元素都是这个聚焦元素. Tab 键被用来切换到下一个可聚焦的元素, 焦点系统占用了 Tab 键, 但是可以用 JavaScript 来阻止这个行为. 浏览器 API 还提供了 API 来操作焦点.

```ts
document.body.focus();

document.body.blur();
```

### 自定义事件

除了来自输入设备的事件, 还可以自定义事件.

```ts
function registerHistoryEvent() {
  var _wr = function (type) {
    var orig = history[type];
    return function () {
      var rv = orig.apply(this, arguments);
      var e = new Event(type);
      e.arguments = arguments;
      window.dispatchEvent(e);
      return rv;
    };
  };
  history.pushState = _wr(""pushState"");
  history.replaceState = _wr(""replaceState"");
}
```
","2025-02-02 03:08:59.781173","2025-02-02 03:08:59.781173"
"f8548db0-263b-4362-8e43-997a9098c85a","{中台,极客时间}",0,0,False,"https://edge.yancey.app/beg/30nz2lp8-1644165953699.jpg","《说透中台》读书笔记","前几年中台还火的时候买了这个课, 一直没看. 如今这个概念终于臭了 😂, 当个乐子看完这篇专栏, 万一有什么启发, 万一呢.","## 中台发展史

中台这个概念, 无论是从涉及领域的宽度还是从战略到落地的纵深高度来讲, 都是非常非常大的, 向上可以触及到行业趋势, 企业使命愿景战略, 向下又可以落地到分布式架构, 遗留系统重构, 架构演进与守护, 质量保证等等各个方面. 而且就算是同一个行业, 每家企业还都不一样.

在 2008 年, 随着阿里巴巴战略的调整, 天猫顺势而生. 但因为其相较于于淘宝, 有其自身的特点, 所以当时天猫和淘宝就出现了重复建设的问题, 也就是现在大家经常提到的烟囱式系统架构. 烟囱式的系统架构, 造成了大量的重复建设和资源浪费, 怎么办呢? 最自然的想法就是将重复的组织和系统进行整合.

Supercell 是芬兰一家游戏厂商, 造出了部落战争, 海岛奇兵等 APP, 催生了这么多火遍全球游戏的企业, 却只有不到 200 名员工, 而负责一款游戏的每个团队平均也只有 5 到 7 名团队成员.

他们的战略是以最快的速度推出公测版, 让市场来评判, 来验证产品的好坏. 一旦产品不成功, 则迅速放弃, 此时不但不会有任何惩罚, 反而团队会举杯庆祝, 之后立即做出调整继续迅速寻找新的方向. 这就是典型的精益创业的套路.

想让这个机制得以正常运转, 必须有一个前提, 就是产品的构建时间要足够短, 试错的成本要足够低, 这样才能保证团队在大量的试错中, 通过不断从失败中学习, 持续迭代调整, 尽快找到正确的方向, 让创新成功的进度条快速前进. 而背后支撑这个机制得以实现的, 就是 Supercell 经过 6 年时间沉淀下来的游戏开发过程中那些公共的, 通用的游戏素材和算法. 基于这些像乐高积木一样的基础素材和算法, 才可以同时支持几个小团队在几周时间内像搭积木一样快速研发出一款新游戏.

**中台是强调资源整合, 能力沉淀的平台体系, 企业引入这套体系可以避免重复造轮子, 减少重复性工作, 省出大量时间和精力投入到更重要的事情上.**

中台火爆的契机:

- 互联网企业的样板效应, 某里巴巴忽悠的概念, 其他厂当然要卷啦
- ToC 不好干了, 大家都去卷 ToB 了
- 早期公司内部卷的各个系统烟囱林立, 数据孤岛, 需要用中台做一波收敛和聚合
- 经济大形势不好, 没啥新业务, 互联网企业通过卷中台战略, 把能力进行沉淀与复用, 用确定性来应对不确定性
- 卷 KPI(沃·兹基硕德)

## 什么是中台

中台其实就是企业级能力复用平台.

- ""企业级""定义了中台的范围, 区分开了单系统的服务化与微服务;
- ""能力""定义了中台的主要承载对象, 能力的抽象解释了各种各样中台的存在;
- ""复用""定义了中台的核心价值, 传统的平台化对于易复用性和前台的用户体验并没有给予足够的关注, 中台的提出和兴起, 让人们通过可复用性将目光更多的从平台内部设计转换到平台对于前台业务的支撑上;
- ""平台""定义了中台的主要形式, 区别于传统的应用系统拼凑的方式, 通过对于更细粒度能力的识别与平台化沉淀, 实现企业能力的柔性复用, 更好地支撑前台业务.

## 中台的种类

中台最常见的是业务数据双中台, 不过只要有卷的地方, 就有更多其他平台.

### 业务数据双中台

业务中台就是在产生数据, 数据中台是做数据的二次加工, 并将结果再服务于业务, 为业务进行数据和智能的赋能. 嗯, 一听就是阿里味儿, 冲得很.

![业务数据双中台](https://edge.yancey.app/beg/9wehffdo-1643534474247.webp)

业务, 更白话一些来说, 就是为了售出产品, 换取利润, 各行业中需要处理的商业上的相关事务. 所以在早期我们通常会把销售叫作业务员. 网易副总裁汪源就曾在网易云创峰会上提到过: ""所有的中台都是业务中台"". 因为从广义上来看所有的中台, 不论是业务中台还是数据中台, 亦或其他, 都是为业务, 为企业可以更好地以更低的成本, 更高的质量, 更快的响应速度售出产品, 换取利润服务的. 换个角度看, 从企业架构的层面看, 应用架构, 技术架构, 数据架构都是要匹配公司的业务架构的, 因为""业务"", 即售出产品, 换取利润是企业的核心目标.

我们常提到的业务中台, 是狭义层面的业务概念, 业务中台需要具体承载支撑业务开展的必要业务元素, 封装着为了保障业务可以顺利开展需要解决的必要问题空间的解决方案. 我们常提到的业务中台, 通过将不同业务线解决相同问题域的解决方案进行抽象与封装, 通过配置化, 插件化, 服务化等机制兼顾各条业务线的特性需求, 实现对于不同业务线的业务支撑. 比如电商的业务中台可以这样划分:

![业务中台](https://edge.yancey.app/beg/barzcrn8-1643542376305.webp)

同样数据中台就比较好理解, 就是卷 BI 平台, 大部分企业都进行了多年的数据仓库建设, 技术有足够的储备, 所以也比较好卷. 对于数据中台与传统数仓和数据平台的区别, 关键在于数据中台相对于数仓, 大数据平台, 向前台, 向业务又迈出了一步, 不再只是关心技术层面大数据底座的打造, 同时开始更多地关注企业层面的数据治理以及数据资产化的内容: 包括但不限于数据的资产化管理(质量, 成本, 安全), 数据服务的构建, 数据的体系化建设(统一模型和指标)等.

![数据中台](https://edge.yancey.app/beg/2fr3cwlf-1643544833942.webp)

总结一番, 业务中台与数据中台相辅相成, 互相支撑, 互为输入输出. 业务中台承载了企业的通用业务能力, 为多业务线赋能; 数据中台通过对于业务数据的二次加工, 并反馈回业务中台, 为业务进行数据和智能方面的赋能. 两者的紧密配合一起为企业构建起了商业战场强大的后方炮火群, 这也就构成了最著名的业务数据双中台模式.

### 其他中台

除此之外还有一些非主流的中台:

- 技术中台: 简单来讲就是在 CloudNative 下将使用云或其他基础设施的能力, 各种技术中间件的能力进行整合和包装. 过滤掉技术细节, 提供简单一致, 易于使用的应用技术基础设施的能力接口, 助力前台和业务中台, 数据中台的快速建设. 以我的经验, 就是公司内部的云平台.
- 研发中台: 按他的说法就是关注开发效能管理的平台叫作研发中台, 比如持续集成这种, 我觉得也可以集成到技术中台叭.
- 移动中台: App 开发过程中的通用技术组件进行封装沉淀, App 持续集成, 发布治理平台之类的
- 管理中台: 应该就是内部 OA, ERP 系统平台化
- 组织中台: 组织中台很像企业中的内部风投和创新孵化机构, 为前台组织和团队构建创新型前台应用提供类似于投资评估(项目甄别), 投资管理, 投后管理(孵化与风控), 真正从组织和制度上支撑前台组织和应用的快速迭代和规模化创新.
- 其他: 财务中台, 采购中台, 供应链中台, AI 中台, 运营中台, 安全中台

## 如何落地中台

中台是企业级的能力复用平台, 那首先中台关注的是企业级发展的问题, 一般我们把这种级别问题常常称之为企业的战略问题, 而每家企业的战略不同, 其核心能力也不同, 自然每家企业的中台也各不相同. 因此中台的痛点也很明显.

- 中台的界限本身就比较模糊, 逐渐成了所有前台业务团队共享的一个内部外包团队, 所有的业务都会不断地提需求过来, 需求拥堵和排期的问题开始出现
- 干系方众多, 前边有各个业务前台团队, 后边还要集成企业已有的各种核心系统, 各方对于中台都有不同的理解和诉求, 甚至有些不同干系方的诉求都会相互矛盾和冲突, 中台团队夹在中间很难受
- 虽然响应各个前台业务的需求, 但是真正落地后前台业务也不怎么爱用, 提需求的时候一个比一个积极, 真正做完了需要前台接入的时候, 又是用各种理由推脱, 不太愿意接入

因此我们应该提前想清楚四个问题:

### 中台建设的愿景是什么

""万事不决看愿景"", 愿景帮助我们了解自己中台建设的目标, 帮助我们判断哪些事情是符合中台建设愿景的, 作为中台团队我们需要去考虑. 在这之外, 更重要的是帮我们判断哪些事情不是中台要去做的, 为中台做减法, 这点在中台的建设过程中其实更加重要. 这个愿景是需要所有的角色, 上到企业管理层, 下到每一位中台的相关人员都要明确并达成一致的.

### 中台的客户是谁

在中台建设之前, 我们最好先搞清楚中台如果作为一款产品, 它的用户是谁? 客户又是谁? 用户和客户是一个群体么? 除了用户和客户还有哪些干系方? 他们对于中台都有什么期望, 这些期望又是否一致. 中台建设虽然需要兼顾各方的利益, 但更多主要还是解决企业管理层对于公司长期生存与可持续发展的恐惧与焦虑问题. 中台也不应该只是极力去满足各方的诉求, 中台团队毕竟不是业务的外包团队. 中台需要有自己的思想和规划, 要能做到听得进别人的话, 但是还要明确自己的目标, 走自己的路.

### 中台的钱由谁出

作者的意思是人和资源从哪出, 是从业务方抽调, 还是招兵买马新搭建团队. 从投资结构来讲, 基本上可以分为两种类型, 即""众筹模式""和""投融资模式"". 依鄙人来看, 基本模式是从现存业务方孵化, 搞大了再专门抽成团队.

### 中台的目标怎么验证

ToC 的收益很容易获得, 可以相对容易地找到一些量化指标来度量产品的成功与否, 比如常见的用户数量, 用户活跃度或是市场覆盖率等. 但中台很难说**前台之所以有这些成果, 都是我中台的赋能效果**. 相反如果中台在使用过程中出现了故障, 还极易被业务方甩锅. 因此, **以终为始, 在建设前就应该思考如何验证和度量中台**, 例如 alibaba 的中台考核方案就是 `40% 稳定性 +25% 业务创新 +20% 服务接入量 +15% 客户满意度`.

![如何落地中台](https://edge.yancey.app/beg/2ia2c2xl-1643614922131.webp)

## 中台建设方法论

一般我们做得更多的是系统级别或是单条业务级别的系统建设或改造. 而在做中台的时候, 我们处理的完全是高一个级别和范围的事情, 已经跳出单个产品, 单条业务线, 涉及到企业的层面, 即**企业级**的范畴. 既然是企业级的问题, 你将面对的就是企业的组织问题, 即""利益分配"", 你卷走了部分业务, 势必会造成别的团队失去了一定利益. 比如最常碰到的就是为什么要配合中台? 我为什么要把数据给中台? 我为什么要用中台. 此外, 你将面对的将是企业的业务全貌, 甚至是那些未来才会出现的, 现在还不知道长什么样子的潜在的创新业务.

再谈一谈传统 EA(Enterprise Architecture), 传统的 EA 方法多是基于业务流程的梳理, 大多的产出物就是企业要采购像 ERP, CRM 这样的系统来解决特定领域的问题. 传统的 EA 方法更多是解决当时信息化背景下的问题, 也就是基于现状(As-is)的业务梳理, 考虑如何通过系统的构建来解决业务流程的信息化改造问题. 而目前大家在构建中台时, 往往信息化程度已经非常高了, 该有的系统都有了, 而中台建设甚至是大家经常挂在嘴边的数字化建设, 更多是为了未来(To-be)的业务发展和创新的问题.

于是这哥们卷出了 D4 模型, 他通过把中台从整体规划到落地交付的过程划分了四个不同的阶段, 包含了两次发散与收敛的过程. 这个方法践行了 Think Big, Start Small, Move Fast 的原则, 既要想得长远, 又要快速切入, 并保持持续演进. 中台背后的本质问题, 其实是一个面向用户与创新的平台型企业架构的问题.

![D4 模型](https://edge.yancey.app/beg/61owdte6-1643634865427.webp)

### Discovery

在中台规划前先建立全局视野, 在这个过程中我们以企业愿景和战略为输入, 结合行业趋势, 竞争对手分析, 用户客群分析, 业务现状分析, IT 资产盘点, 全方位多角度地理解企业的战略市场环境以及业务及 IT 全貌, 帮助我们做出最正确的判断.

D4 的前两部分 Discovery 和 Define 合起来, 就是一个在企业级先发散再收敛的过程. 有的公司叫作 Portfolio Discovery, 简称为 PD, 是一个 4-8 周的头脑风暴工作坊. 翻译成中文就是投资组合规划, 应用在企业里就相当于产品线规划. PD 的主要目的就是做充分的发散和调研, 也就是利用各种工具和手段帮助我们充分了解行业趋势, 竞争对手的情况, 公司的战略分解以及自下而上的现状调研等信息和环境, 为下一个阶段 Define 的收敛.

![Discovery](https://edge.yancey.app/beg/7uzgjhwb-1643639772919.webp)

Discovery 过程又分为三个阶段:

#### 由外到内: 行业与竞争对手分析

实际上就是产品调研, 以 **点 - 线 - 面 - 体** 理论为基础. ""点""指的就是中台这个事, 它可能只是一家企业发展到一定阶段的产物, 不是开始也不是结束. 要从一家企业的发展过程这条主线上来看待中台这件事情, 来看这个点. 它从哪里来? 为什么会出现? 又将向哪儿去? 甚至思考中台的下一个阶段会是什么? 会被什么替代? ""面""就是看多家同行业怎么搞的. 这不废话嘛... 竞品分析当然得看多家公司, 要不 PPT 都写不明白. ""体""就是跳出同行业, 比如传统银行金融业也可能在卷类似中台点东西.

总之这个理论的好处一是可以借(抄)鉴(袭)竞品的思路成果, 二是通过学习其他行业, 跳出互联网思维定势, 能够实现企业跨行业的跃进. 最后作者还提到常用的分析手段有五力模型, SWOT, 商业模式画布, 竞争对手产品线分析, 竞争态势分析矩阵等. 这些概念 PM 应该比较熟吧, 毕竟天下产品一大抄 (不是.

#### 自上而下: 企业战略分解

就是""向上管理""嘛. **所谓战略, 就是如何达成目标与能力的平衡, 并根据环境变换做出合适的调整.** 战略平衡三角形可以辅助我们理解战略这个概念:

![战略平衡三角形](https://edge.yancey.app/beg/ygqszuy7-1643690641251.webp)

依据战略平衡三角形, 在企业的愿景和目标已经确定的情况下:

- 企业战略就可以简化理解成: 结合**企业自身**的能力与其所处的环境, 到底需要采取什么样的举措, 才能实现企业预定的愿景和目标呢?
- 而企业战略分解就可以简化理解成: 结合**企业各部门自身**的能力与其所处的环境, 到底需要采取什么样的举措, 才能实现企业预定的愿景和目标呢?

精益价值树(Lean Value Tree) 用来帮助做战略愿景的分解. 精益价值树是一种以价值成效为导向, 用于分析和沟通业务愿景, 战略与投资的工具. 它的核心是建立从愿景, 目标到投资举措自上而下的对齐, 因此采用一种逐层分解的树形结构.

![Lean Value Tree](https://edge.yancey.app/beg/m3fnsycx-1643701925840.webp)

这个过程, 就是我说的自上而下的战略分解过程. 而某一个中台, 它可能只是最终推导出的一个具体的举措而已, 向上还是要能追溯到对于企业愿景和目标的关联性和价值上, 匹配和对应企业的愿景目标.

#### 自下而上: 现状调研与分析

尊重过去遇到的所有问题, 收集汇总痛点; 另一方面又要求我们能跳出过去的限制, 重新从业务出发, 从用户出发, 去重新探索基于新技术, 新架构下的一些新的可能性. 例如高层访谈, 干系人地图, 组织架构分析, 战略设计思维, 业务架构现状梳理, 用户旅程, 服务蓝图, 领域驱动设计, 应用系统现状梳理, 技术架构现状梳理等等. (虽然我觉得很难, 逃).

### Define: 企业数字化全景规划

基于之前 Discovery 发散的各维度信息进行收敛与分析, 对于中台的架构进行定义. 通过对跨业务线的业务梳理进行重合度分析, 并结合领域分析对业务表象之后的企业核心问题域做进一步展开和重合度分析, 一起来收敛推导基于中台的企业架构设计.

企业架构方法最常见的方法是 TOGAF, 它基本思路就是从企业最新的愿景战略以及运营模式出发, 设计企业的 To-Be 业务架构, 然后依次推导, 一步一步推导数据架构, 应用架构, 技术架构. 在整个企业架构设计的过程中融入了领域驱动设计(DDD), 结合事件风暴, 对业务流程背后的问题域进行分析, 以及通过不同业务线的问题域重合度分析, 帮助我们透过流程洞见企业各业务的本质, 寻找共性业务元素. 而中台实际就是提炼**业务数据, 业务功能, 业务流程以及通用的技术能力**.

![企业数字化全景规划](https://edge.yancey.app/beg/295hnqu5-1643784763395.webp)

1. 分析各业务线现状, 再结合识别的痛点做的根因分析, 对于现有的业务架构进行改进, 设计改进后的业务架构方案.
2. 参考战略分解后对于各条业务线的目标和举措, 使新的业务架构设计同时匹配企业战略要求以及解决短期战术痛点.
3. 对于改进后的业务架构, 做跨业务线的比对和分析, 以此来发现不同业务线的业务功能及业务流程的重叠情况.
4. 使用领域驱动设计, 针对于每条业务线, 做问题域和限界上下文分析以及关键聚合的识别, 从领域的角度深入一层审视业务的本质.
5. 对于各条业务线分析出来的领域分析视图, 做横向比对和投影, 类似于将几张半透明的画摞在一起, 来找相交部分一样, 找出共性.
6. 结合现有的业务架构及应用架构, 做各条线的应用架构设计改进.
7. 基于跨域的业务架构分析和跨域的领域分析, 讨论判断多条业务线的业务重合度.
8. 最后基于战略重要性, 紧急程度, 成本, 资源就绪情况, 技术就绪情况, 风险, 痛点 Mapping 等做优先级排序, 产生最终的路线图.

### Design

就是正常的需求设计, 包括产品级的业务需求分析, 功能及架构设计, 实施计划等, 在 Design 阶段我们需要回答产品的愿景, 边界, 产品形态, 技术架构, 交付计划, 成本预估等等.

设计的过程就不说了, 没啥意思, 文中讲的都很虚. 不过在真正开发前需要去做两点:

- 运营前置: 制定迭代计划及接入计划
- 度量前置: 定义验证指标

运营前置就是在开发前就先站在接入方的角度来制定迭代计划和接入计划, 毕竟业务都是并行了, 越往后拖越难以接入. 度量前置自不用说, 提前想好度量指标后面好去邀功.

![成功度量](https://edge.yancey.app/beg/dm05hhzr-1644163552060.webp)

### Delivery

用快速迭代和基于反馈的调整, 最大程度地弥补由中台建设本身的复杂度带来的设计偏差和其他的交付问题, 并且注重架构的治理与守护, 减少实现与设计的偏离.

敏捷关注的是价值确定的情况下, 如何通过小步快跑的迭代方式按节奏交付价值; 而精益关注的则是在价值并不确定的情况下, 如何用最小成本, 快速定位到真正价值点.

![精益产品研发流程](https://edge.yancey.app/beg/6q07dh57-1644163950877.webp)

除了中台的建设过程, 同样不能忽略中台的运营, 治理与演进. 重要要搞清的就是中台产品的用户划分, 因为台作为一个公共服务部门, 一定会碰到多个前台的需求, 排期, 质量要求, 非功能需求出现不同的情况. 而中台的资源有限, 且有自己的愿景, 不可能无条件地满足所有前台用户的诉求, 往往就会陷入疲于应对的状态, 对前台的响应和服务质量也会急速降低.

```shell
# NFR(Non-Functional Requirement, 非功能性需求)
# SLA (Service-Level Agreement, 服务等级协议)
Offering = Capability + SLA/NFR
```

最常见的就是三层用户划分机制(3 tiers customer segmentation)

![三层用户划分机制](https://edge.yancey.app/beg/luyfa9nh-1644164301366.webp)

## 互联网需要中台吗

互联网企业需要中台, 不是锦上添花, 而是生存所迫, 是因为**恐惧**. 因为竞争过于惨烈, 谁能抢到用户, 谁能获取用户的芳心, 谁能留住用户, 谁就能干掉别人获得成功. 这不是政治需要, 也不是技术需要, 这是**生存需要**, 是一场你死我活的搏杀. 所以, 互联网企业天生眼里盯着的就是用户, 这是为了生存, 刻在了基因里的. 而用户, 则被**惯坏了**, 又要求你产品层出不穷, 不断迭代更新; 还得要经济便宜, 不舍得多付出一点成本.

这两类需求本身就是矛盾的, 又要灵活又要经济, 企业还没的选择, 为了生存也必须无条件地继续满足用户的各种""无理要求"".

而在企业层面, 中台这个新的中间层的产生, 就是为了调和这个""灵活""与""经济""的矛盾. 前台纵向, 承载了企业的灵活性; 中台横向, 承载的是企业的经济性; 而前台与中台的分离, 博弈与平衡, 本质上就是企业作为一个整体灵活性与经济性的分离, 博弈与平衡.

## 总结

看完了整个文档, 说实话我还是没明白中台和后台的区别, 尤其是在这个中台已经被拉下神坛的时代更是如此. 不过如果面对一个新事物, 下面这段话我认为是值得收藏的.

永远保持好奇, 先接纳, 再判断. 不要轻易把门关上, 可能会错失掉一些新的东西, 就算是进去转了一圈, 最后发现并没有什么新的价值, 其实也没有多大的损失, 学习有时候不能太功利. 不过话也要说回来, 也要有自己的主动思考能力, 需要快速判断概念是否值得继续投资自己的资源, 毕竟人的精力也是有限的, 不要在价值不大的新概念上浪费太多的精力, 及时踩下刹车. 而对于如何判断是否需要""止损"":

- 新的技术在解决什么问题? 为什么之前的技术不能解决? 它的核心突破点是什么? 本质是什么?
- 新的技术和其他解决类似问题的技术有什么关系? 有什么区别?
- 新的技术为什么在现在这个时间段出现? 为什么在现在爆发? 为什么之前没人想到这种新的解决方案?
- 新的技术和我现在正在做的事情是否相关? 新的技术和我想做的事情或方向是否相关?

![新兴技术成熟曲线](https://edge.yancey.app/beg/0r0e0iuj-1643783566207.webp)
","2025-02-02 03:09:03.46206","2025-02-02 03:09:03.46206"
"e97d6018-8ea0-4748-8400-5ec1bf4b21b4","{Poem,鈍感力}",0,0,False,"https://edge.yancey.app/beg/2ii1sp0h-1644587386743.jpg","《钝感力》读书笔记","分享今年的第一本书读书笔记, keep calm and grace.","

## 谈钝感力与健康

对健康最为重要的, 就是让自己全身的血液总是能够顺畅地流淌. 为此, 需要让全身的血管一直处于舒张状态. 控制血管的神经叫做自律神经. 尽量避免刺激自律神经, 让其总是保持一种放松的状态. 这对促进全身的血液循环畅通无阻极为关键.

人体中几乎所有的血管都是由神经来控制的. 这些神经一般被称为**自律神经**, 其中包括**交感神经**和**副交感神经**, 两者起着相反的作用. 比如说, 交感神经随着紧张, 烦躁, 不安等情绪的不断加剧, 会令人的血管变窄, 血压升高. 副交感神经的作用正好相反, 可以起到使人血管扩张, 情绪放松, 降低血压的作用.

为了让血管保持舒张状态, 血液顺畅地流淌, **就要让血管常处于副交感神经的支配之下. 同时, 交感神经也必须处于静止状态.**. 保持开朗, 放松的心态, 是让血液循环畅通无阻的最佳方法.

## 谈钝感力与睡眠

任何事物都是""过犹不及"", 看得过于清晰, 在精神卫生方面也有负面影响.许多时候, 钝感比敏感更加有益. 钝感的人和敏感的人相比, 前者肯定可以更为悠闲自在, 胸襟开阔, 因此也能更加健康长寿.

睡眠能力不单指睡眠良好, 同时还包括了迅速起床所必需的觉醒能力. 所以, 这里所称的""睡眠能力""包括入睡和起床两方面的含义. 睡眠不仅能让人的身体得到休息, 而且能使人的头脑和精神得到休养. 睡眠能力较差的人有一个共同之处, 就是大都属于多思多虑那种类型. ""笨拙的想法和休息不相上下"", 这句俗语说的就是, 若左思右想也无事于补, 还不如横下心来闭眼休息.

## 谈钝感力与嫉妒和讽刺

一般嫉妒, 中伤别人的人, 其自身境遇多数不如对方. 比如, 在公司遭到嫉妒的都是工作能力强的人, 相反,嫉妒别人的人大多能力平平, 甚至较差. 另外, 遭人嫉妒者大多生活幸福, 而嫉妒人的人则通常不如前者. 如果能想到这一层, 对于那些中伤与嫉妒就会不太在意了. 因为遭人嫉妒者, 是由于其自身条件优越, 造成对方因羡慕而嫉妒的. 想到嫉妒别人的人比遭受嫉妒的人更加可怜, 更加辛苦, 因此, 与其说怨恨嫉妒之人, 还不如说应该向对方道谢才对.

看问题的角度不同, 人们的感受也截然不同, 任何事情都应灵活地从积极的方面进行思考. 而钝感力就是这种思维方式的动力. 不要听到一些不中听的话就如临大敌, 而应该仔细思考对方那么说的原因, 体察对方的心情. 这种胸怀宽广的钝感力, 可以在我们的日常生活中起到极大的作用.

## 谈钝感力与感情维系

喜欢对方, 希望将彼此的恋爱关系延续下去, 就要在某些方面拥有原谅对方的胸怀. 假如对任何事情都抱着眼里容不得沙子的态度, 锱铢必较, 双方都会因此而窒息,彼此之间的关系很快就会土崩瓦解.

## 谈钝感力与接纳他人

面对他人各式各样的毛病, 有些人耿耿于怀, 有些人不太在乎, 有些人视若无睹. 人们的感觉各自不同, 但有一点非常明确, 就是只有对各种不快的毛病忽略不计, 泰然处之, 才能开朗大度地生活下去.

## 谈钝感力与适应环境

一般来说, 伤口痊愈首先是由皮肤表面长出一层薄膜, 然后伤口下面的肉芽就长了出来. 与此同时, 伤口两侧的皮肤开始合拢, 很快连在一起, 伤口就愈合了. 在伤口痊愈的过程中, 倘若出现细菌感染或者抓挠伤口的情况, 痊愈时间就会延长, 伤口甚至还会恶化. 然而, 如果只是轻伤的, 只要先用消毒液轻轻擦拭伤口,  再将适量的药膏涂在伤口上, 然后缠上绷带, 不久伤口自然就好了, 这就是所谓的自愈能力.

我们把人体根据外界温度变化进行自我调节, 使体温保持在一定温度的作用, 称为人体的`恒常性`. 人体的这种特性是与生俱来的, 能让我们的身体适应各种各样的环境变化. 能够针对外界的各种变化, 及时调整身体状态, 很快适应环境, 我们一般把这种能力称为`适应环境的能力`. 广而言之, 这种能力不仅包括适应外界气温与气压变化, 而且也包括能够轻而易举地适应各种人际关系, 社会状况的能力.

## 总结

世界上不仅仅存在敏锐聪慧这种才能. 相比之下, 不为琐事动摇的钝感, 才是人们生活中最为重要的基本才能. 而且, 只有具备这种钝感力, 敏锐和敏感才能真正成为真正的才能, 从而在人生的道路上发挥其应有的作用.
","2025-02-02 03:09:04.916276","2025-02-02 03:09:04.916276"
"0a816f77-80d5-49f2-9eaf-4041ac7742a5","{Vite}",0,0,False,"https://edge.yancey.app/beg/z2mk2xcb-1698219035916.jpg","Vite 源码解析(6) - HMR 原理","todo","## getShortName
我们知道在 moduleGraph 中会存储各种 Map, 比如 dToModuleMap, 它们的 key 是文件的**绝对路径**. 而 getShortName 函数就是把绝对路径路径变成相对路径. 比如说: `/Users/XXXXXX/code/learn-frame/learn-react/src/index.css` 变成 `src/index.css`.
```ts
export function getShortName(file: string, root: string): string {
  return file.startsWith(root + ""/"") ? path.posix.relative(root, file) : file;
}
```
## handleHMRUpdate
在 createServer 函数中, 当 chokidar 监听到变化时, 首先会更新模块依赖图. 接下来就是执行 handleHMRUpdate 函数, 来保证 Hot Module Replacement.
```ts
watcher.on(""change"", async (file) => {
  file = normalizePath$3(file);
  if (file.endsWith(""/package.json"")) {
    return invalidatePackageData(packageCache, file);
  }
  // invalidate module graph cache on file change
  moduleGraph.onFileChange(file);
  if (serverConfig.hmr !== false) {
    try {
      await handleHMRUpdate(file, server);
    } catch (err) {
      ws.send({
        type: ""error"",
        err: prepareError(err),
      });
    }
  }
});
```
handleHMRUpdate 函数主要根据不同的文件进行不同的热更新策略, 比如 vite.config.js, env 的更新直接重启后端服务. index.html 文件的更新就直接刷新页面, 其他文件的变更就要执行 updateModules 函数.
```ts
export async function handleHMRUpdate(
  file: string,
  server: ViteDevServer
): Promise<void> {
  const { ws, config, moduleGraph } = server;
  // 上面说了, getShortName 用来获取相对路径
  const shortFile = getShortName(file, config.root);
  // 可以理解为获取文件名, 比如:
  // /Users/XXXXXX/code/learn-frame/learn-react/src/index.css -> index.css
  const fileName = path.basename(file);
  // configFile: '/Users/XXXXXX/code/learn-frame/learn-react/vite.config.ts',
  // configFileDependencies: [ '/Users/XXXXXX/code/learn-frame/learn-react/vite.config.ts' ],
  const isConfig = file === config.configFile;
  const isConfigDependency = config.configFileDependencies.some(
    (name) => file === name
  );
  // 是否为 env 文件
  const isEnv =
    config.inlineConfig.envFile !== false &&
    (fileName === "".env"" || fileName.startsWith("".env.""));
  // 如果是 vite 的配置文件或者 env 文件
  // 直接重启服务
  if (isConfig || isConfigDependency || isEnv) {
    // auto restart server
    debugHmr(`[config change] ${colors.dim(shortFile)}`);
    config.logger.info(
      colors.green(
        `${path.relative(process.cwd(), file)} changed, restarting server...`
      ),
      { clear: true, timestamp: true }
    );
    try {
      await server.restart();
    } catch (e) {
      config.logger.error(colors.red(e));
    }
    return;
  }
  debugHmr(`[file change] ${colors.dim(shortFile)}`);
  // (dev only) the client itself cannot be hot updated.
  // 我们知道 vite 在 client 会注入 /vite/dist/client/env.mjs 这个脚本, 用于跟后端进行 ws 交互等操作.
  // 下面这段代码就是如果改了这个文件, 就完整刷新页面
  // 当然这个只针对于 Vite 开发环境, 写业务不用关心这个, 因为也动不了
  if (file.startsWith(normalizedClientDir)) {
    ws.send({
      type: ""full-reload"",
      path: ""*"",
    });
    return;
  }
  // 复习下 fileToModulesMap
  // fileToModulesMap 的 key 为模块的绝对路径(不带 hash 和 query), value 为 ModuleNode 的集合
  const mods = moduleGraph.getModulesByFile(file);
  // check if any plugin wants to perform custom HMR handling
  const timestamp = Date.now();
  const hmrContext: HmrContext = {
    file,
    timestamp,
    modules: mods ? [...mods] : [],
    // readModifiedFile 函数下面说, 总之就是读取文件内容的字符串
    read: () => readModifiedFile(file),
    server,
  };
  // 过一下所有的 plugin, 如果你的 plugin 带了 handleHotUpdate
  // 就用 plugin 处理一波
  for (const plugin of config.plugins) {
    if (plugin.handleHotUpdate) {
      const filteredModules = await plugin.handleHotUpdate(hmrContext);
      if (filteredModules) {
        hmrContext.modules = filteredModules;
      }
    }
  }
  // 如果当前改动的文件没有对应的模块依赖
  if (!hmrContext.modules.length) {
    // html file cannot be hot updated
    // 它有可能是 index.html 文件, 此时直接 full-reload 一把梭即可
    if (file.endsWith("".html"")) {
      config.logger.info(colors.green(`page reload `) + colors.dim(shortFile), {
        clear: true,
        timestamp: true,
      });
      ws.send({
        type: ""full-reload"",
        path: config.server.middlewareMode
          ? ""*""
          : ""/"" + normalizePath(path.relative(config.root, file)),
      });
    } else {
      // loaded but not in the module graph, probably not js
      debugHmr(`[no modules matched] ${colors.dim(shortFile)}`);
    }
    return;
  }
  // 对于不是 vite.config.js(ts, mjs) 的, 也不是 env, 或者 index.html 的
  // 就要更新它的模块依赖, 下面这个函数
  updateModules(shortFile, hmrContext.modules, timestamp, server);
}
```
## updateModules
updateModules 根据被修改文件的路径清空对应的 ModuleNode 中缓存的源码
```ts
export function updateModules(
  file: string,
  modules: ModuleNode[],
  timestamp: number,
  { config, ws }: ViteDevServer
): void {
  const updates: Update[] = [];
  const invalidatedModules = new Set<ModuleNode>();
  let needFullReload = false;
  for (const mod of modules) {
    // 由于当前文件对应的代码发生了变化, 所以在 ModuleGraph 层面,
    // 需要使前文件对应的模块们失效, 这个函数下面说.
    invalidate(mod, timestamp, invalidatedModules);
    // 如果 needFullReload, 就跳过本次循环
    if (needFullReload) {
      continue;
    }
    const boundaries = new Set<{
      boundary: ModuleNode;
      acceptedVia: ModuleNode;
    }>();
    const hasDeadEnd = propagateUpdate(mod, boundaries);
    if (hasDeadEnd) {
      needFullReload = true;
      continue;
    }
    updates.push(
      ...[...boundaries].map(({ boundary, acceptedVia }) => ({
        type: `${boundary.type}-update` as Update[""type""], // 有 js-update 和 css-update 两种
        timestamp,
        path: boundary.url,
        acceptedPath: acceptedVia.url,
      }))
    );
  }
  if (needFullReload) {
    config.logger.info(colors.green(`page reload `) + colors.dim(file), {
      clear: true,
      timestamp: true,
    });
    ws.send({
      type: ""full-reload"",
    });
  } else {
    config.logger.info(
      updates
        .map(({ path }) => colors.green(`hmr update `) + colors.dim(path))
        .join(""\n""),
      { clear: true, timestamp: true }
    );
    ws.send({
      type: ""update"",
      updates,
    });
  }
}
```
## propagateUpdate
```ts
function propagateUpdate(
  node: ModuleNode,
  boundaries: Set<{
    boundary: ModuleNode;
    acceptedVia: ModuleNode;
  }>,
  currentChain: ModuleNode[] = [node]
): boolean /* hasDeadEnd */ {
  // #7561
  // if the imports of `node` have not been analyzed, then `node` has not
  // been loaded in the browser and we should stop propagation.
  if (node.id && node.isSelfAccepting === undefined) {
    return false;
  }
  if (node.isSelfAccepting) {
    boundaries.add({
      boundary: node,
      acceptedVia: node,
    });
    // additionally check for CSS importers, since a PostCSS plugin like
    // Tailwind JIT may register any file as a dependency to a CSS file.
    for (const importer of node.importers) {
      if (isCSSRequest(importer.url) && !currentChain.includes(importer)) {
        propagateUpdate(importer, boundaries, currentChain.concat(importer));
      }
    }
    return false;
  }
  if (!node.importers.size) {
    return true;
  }
  // #3716, #3913
  // For a non-CSS file, if all of its importers are CSS files (registered via
  // PostCSS plugins) it should be considered a dead end and force full reload.
  if (
    !isCSSRequest(node.url) &&
    [...node.importers].every((i) => isCSSRequest(i.url))
  ) {
    return true;
  }
  for (const importer of node.importers) {
    const subChain = currentChain.concat(importer);
    if (importer.acceptedHmrDeps.has(node)) {
      boundaries.add({
        boundary: importer,
        acceptedVia: node,
      });
      continue;
    }
    if (currentChain.includes(importer)) {
      // circular deps is considered dead end
      return true;
    }
    if (propagateUpdate(importer, boundaries, subChain)) {
      return true;
    }
  }
  return false;
}
```
## invalidate
如果你看过 ModuleGraph 的那篇, 模块依赖图里面也有个 invalidate 方法, 下面这个函数也大差不差. 但需要注意的是最后这一段:
```ts
mod.importers.forEach((importer) => {
  if (!importer.acceptedHmrDeps.has(mod)) {
    invalidate(importer, timestamp, seen);
  }
});
```
这段代码遍历了当前 mod 的 importers, 也就是引用了该模块的父模块. 然后找到**父模块中不依赖该模块热更新的模块**, 把它们失效掉. 这样做的目的是, 对于上层模块来说, 如果没有监听子模块更新, 当子模块更新时, 这些上层模块也需要重新加载, 否则它们引用的就是旧的 mod 了.
```ts
function invalidate(mod: ModuleNode, timestamp: number, seen: Set<ModuleNode>) {
  // 当前模块已经 invalidate 过了, 跳过.
  if (seen.has(mod)) {
    return;
  }
  seen.add(mod);
  // lastInvalidationTimestamp 是最后失效的时间, 如果你的模块时间戳超过它, 说明就过期了
  mod.lastHMRTimestamp = timestamp;
  // 把经过插件转换后的结果失效掉
  mod.transformResult = null;
  // ssr 相关
  mod.ssrModule = null;
  mod.ssrError = null;
  mod.ssrTransformResult = null;
  // 由于当前模块失效了, 遍历引用了当前模块的上层模块们,
  // 如果上层模块不接受当前模块的热更新
  // 也直接失效掉.
  mod.importers.forEach((importer) => {
    if (!importer.acceptedHmrDeps.has(mod)) {
      invalidate(importer, timestamp, seen);
    }
  });
}
```
## readModifiedFile
```ts
const Stats = {
  dev: 16777220,
  mode: 33188,
  nlink: 1,
  uid: 502,
  gid: 20,
  rdev: 0,
  blksize: 4096,
  ino: 55877411,
  size: 8366,
  blocks: 24,
  atimeMs: 1655982536691.7463,
  mtimeMs: 1655869817954.8062,
  ctimeMs: 1655869817954.8062,
  birthtimeMs: 1655693116465.197,
  atime: new Date(""2022-06-23T11:08:56.692Z""),
  mtime: new Date(""2022-06-22T03:50:17.955Z""),
  ctime: new Date(""2022-06-22T03:50:17.955Z""),
  birthtime: new Date(""2022-06-20T02:45:16.465""),
};
```","2025-02-02 03:09:42.850967","2025-02-02 03:09:42.850967"
"da50fb43-c15e-496d-b6e6-7c05c161d2bf","{Vite}",0,0,False,"https://edge.yancey.app/beg/cjwmv3qo-1698219240369.jpg","Vite 源码解析(7) - 依赖预构建","todo","todo","2025-02-02 03:09:43.987282","2025-02-02 03:09:43.987282"
"f6576bfd-acea-41b1-b6b9-39a092471b01","{Backend,Kubernetes}",0,0,False,"https://edge.yancey.app/beg/3o9hovnh-1731643180511.jpg","How to deploy Nest.js microservices using Kubernetes","The aim of the project is to use Nest.js to build a microservice project that communicate via gRPC and a gateway service to expose API, use RabbitMQ to handle message queues, and ELK for log management. Finally, Docker and Kubernetes will be used for building and deploying those services.","To view the full example, please visit [learn-backend](https://github.com/yancey-learning-tech/learn-backend) on GitHub.
## Code Structure
```bash
.
├── apps
│   ├── gateway
│   │   ├── src
│   │   │   ├── gateway.module.ts
│   │   │   ├── gateway.controller.ts
│   │   │   └── main.ts
│   │   └── tsconfig.app.json
│   ├── product
│   │   ├── src
│   │   │   ├── main.ts
│   │   │   ├── product.module.ts
│   │   │   └── product.controller.ts
│   │   └── tsconfig.app.json
├── docker
│   ├── Dockerfile.gateway
│   └── Dockerfile.product
├── k8s
│   ├── gateway-deployment.yaml
│   └── product-deployment.yaml
├── proto
│   └── product.proto
├── types
│   └── proto
│       └── product.ts
├── tsconfig.build.json
├── tsconfig.json
├── nest-cli.json
├── package.json
├── pnpm-lock.yaml
```
## Using Nest.js to create monorepo
First, follow the [Workspaces](https://docs.nestjs.com/cli/monorepo) guide to create a Nest.js monorepo project.
```ts
nest new gateway
cd gateway
nest generate app product
```
## Using gRPC for communication
A microservice is essentially an application that uses a different transport layer than HTTP. We can use gRPC, Thrift, or even just TCP as the transport layer. In this case, we will use gRPC.
[gRPC](https://grpc.io/) is a modern open source high performance Remote Procedure Call (RPC) framework that can run in any environment. It can efficiently connect services in and across data centers with pluggable support for load balancing, tracing, health checking and authentication. It is also applicable in last mile of distributed computing to connect devices, mobile applications and browsers to backend services.
![image.png](https://edge.yancey.app/beg/aighp64f-1731989931539.png)
### Protocol Buffers
Since microservice code can be written in various programming languages, we need a language-neutral, platform-neutral, and extensible mechanism for serializing structured data. By default, gRPC uses [Protocol Buffers](https://protobuf.dev/).
The follows code defines protobuf to the `product` microservice.
```proto
syntax = ""proto3"";
package product;
message Product {
  string id = 1;
  string name = 2;
  string description = 3;
  double unitPrice = 4;
  int32 inventoryQuantity = 5;
  string createdAt = 6;
  string updatedAt = 7;
}
message CreateProductRequest {
  string name = 1;
  string description = 2;
  double unitPrice = 3;
  int32 inventoryQuantity = 4;
}
message CreateProductResponse { Product product = 1; }
message GetProductRequest { string id = 1; }
message GetProductResponse { Product product = 1; }
message UpdateProductRequest {
  string id = 1;
  string name = 2;
  string description = 3;
  double unitPrice = 4;
  int32 inventoryQuantity = 5;
}
message UpdateProductResponse { Product product = 1; }
message DeleteProductRequest { string id = 1; }
message DeleteProductResponse { bool success = 1; }
service ProductService {
  rpc CreateProduct(CreateProductRequest) returns (CreateProductResponse);
  rpc GetProduct(GetProductRequest) returns (GetProductResponse);
  rpc UpdateProduct(UpdateProductRequest) returns (UpdateProductResponse);
  rpc DeleteProduct(DeleteProductRequest) returns (DeleteProductResponse);
}
```
### protoc
Since this is a TypeScript project, it is better to transform the protobuf definitions into TypeScript interfaces. We use [`ts-protoc`](https://github.com/stephenh/ts-proto) to compile protobuf files to TypeScript interfaces.
First, you need to install [`protoc`](https://grpc.io/docs/protoc-installation/) on your computer. If you are using macOS, simply run:
```bash
brew install protobuf
```
Next, add the follows command to the scripts section of your package.json:
```bash
""proto-ts"": ""protoc --plugin=./node_modules/.bin/protoc-gen-ts_proto --ts_proto_out=./types ./proto/*.proto --ts_proto_opt=nestJs=true,addGrpcMetadata=true,addNestjsRestParameter=true,outputEncodeMethods=false,outputJsonMethods=false,outputClientImpl=false""
```
This command not only generates TypeScript interfaces, but also generates controller interface for Nest.js.
```ts
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v5.28.3
// source: proto/product.proto
/* eslint-disable */
import { Metadata } from '@grpc/grpc-js'
import { GrpcMethod, GrpcStreamMethod } from '@nestjs/microservices'
import { Observable } from 'rxjs'
export const protobufPackage = 'product'
export interface Product {
  id: string
  name: string
  description: string
  unitPrice: number
  inventoryQuantity: number
  createdAt: string
  updatedAt: string
}
export interface CreateProductRequest {
  name: string
  description: string
  unitPrice: number
  inventoryQuantity: number
}
export interface CreateProductResponse {
  product: Product | undefined
}
export interface GetProductRequest {
  id: string
}
export interface GetProductResponse {
  product: Product | undefined
}
export interface UpdateProductRequest {
  id: string
  name: string
  description: string
  unitPrice: number
  inventoryQuantity: number
}
export interface UpdateProductResponse {
  product: Product | undefined
}
export interface DeleteProductRequest {
  id: string
}
export interface DeleteProductResponse {
  success: boolean
}
export const PRODUCT_PACKAGE_NAME = 'product'
export interface ProductServiceClient {
  createProduct(
    request: CreateProductRequest,
    metadata: Metadata,
    ...rest: any
  ): Observable<CreateProductResponse>
  getProduct(
    request: GetProductRequest,
    metadata: Metadata,
    ...rest: any
  ): Observable<GetProductResponse>
  updateProduct(
    request: UpdateProductRequest,
    metadata: Metadata,
    ...rest: any
  ): Observable<UpdateProductResponse>
  deleteProduct(
    request: DeleteProductRequest,
    metadata: Metadata,
    ...rest: any
  ): Observable<DeleteProductResponse>
}
export interface ProductServiceController {
  createProduct(
    request: CreateProductRequest,
    metadata: Metadata,
    ...rest: any
  ):
    | Promise<CreateProductResponse>
    | Observable<CreateProductResponse>
    | CreateProductResponse
  getProduct(
    request: GetProductRequest,
    metadata: Metadata,
    ...rest: any
  ):
    | Promise<GetProductResponse>
    | Observable<GetProductResponse>
    | GetProductResponse
  updateProduct(
    request: UpdateProductRequest,
    metadata: Metadata,
    ...rest: any
  ):
    | Promise<UpdateProductResponse>
    | Observable<UpdateProductResponse>
    | UpdateProductResponse
  deleteProduct(
    request: DeleteProductRequest,
    metadata: Metadata,
    ...rest: any
  ):
    | Promise<DeleteProductResponse>
    | Observable<DeleteProductResponse>
    | DeleteProductResponse
}
export function ProductServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      'createProduct',
      'getProduct',
      'updateProduct',
      'deleteProduct'
    ]
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(
        constructor.prototype,
        method
      )
      GrpcMethod('ProductService', method)(
        constructor.prototype[method],
        method,
        descriptor
      )
    }
    const grpcStreamMethods: string[] = []
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(
        constructor.prototype,
        method
      )
      GrpcStreamMethod('ProductService', method)(
        constructor.prototype[method],
        method,
        descriptor
      )
    }
  }
}
export const PRODUCT_SERVICE_NAME = 'ProductService'
```
## Starting RabbitMQ Docker Container
[RabbitMQ](https://www.rabbitmq.com/) is a reliable and mature messaging and streaming broker, which is easy to deploy on cloud environments, on-premises, and on your local machine. We use `docker compose` to start a simply container.
```yaml
services:
  rabbitmq:
    image: rabbitmq:3-management
    restart: always
    container_name: rabbitmq
    ports:
      - 5672:5672
      - 15672:15672
    environment:
      - RABBITMQ_DEFAULT_USER=root
      - RABBITMQ_DEFAULT_PASS=password
    volumes:
      - /var/lib/docker/volumes/rabbitmq:/var/lib/rabbitmq
```
Then, visit [http://localhost:15672/](http://localhost:15672/) to open the management platform.
![rabbitmq management platform](https://edge.yancey.app/beg/92i5z46c-1732004913576.png)
## Starting ELK Docker Container
The ELK Stack is a powerful suite of open-source tools designed for searching, analyzing, and visualizing log data in real-time. It consists of three main components: Elasticsearch, a search and analytics engine; Logstash, a data processing pipeline that collects, parses, and stores logs; and Kibana, a visualization tool that allows users to explore and interact with data stored in Elasticsearch. Together, these tools provide a robust solution for managing and analyzing large volumes of log data from various sources, making it easier to monitor and troubleshoot applications and infrastructure.
First, create `logstash/pipeline/logstash.conf` and add the configuration as follows:
```bash
input {
  beats {
    port => 5000
  }
}
filter {
  # Add your filters here
}
output {
  elasticsearch {
    hosts => [""elasticsearch:9200""]
    index => ""%{[@metadata][beat]}-%{+YYYY.MM.dd}""
  }
  stdout { codec => rubydebug }
}
```
Then, run the follows `docker-compose.yaml` file via `docker compose up -d`:
```yaml
services:
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.16.0
    container_name: elasticsearch
    restart: 'always'
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
      - bootstrap.memory_lock=true
      - ""ES_JAVA_OPTS=-Xms512m -Xmx512m""
    ulimits:
      memlock:
        soft: -1
        hard: -1
    volumes:
      - esdata:/usr/share/elasticsearch/data
    ports:
      - ""9200:9200""
      - ""9300:9300""
    networks:
      - elk
  logstash:
    image: docker.elastic.co/logstash/logstash:8.16.0
    container_name: logstash
    restart: 'always'
    volumes:
      - ./logstash/pipeline:/usr/share/logstash/pipeline
    ports:
      - ""5044:5044""
      - ""9600:9600""
    networks:
      - elk
    depends_on:
      - elasticsearch
  kibana:
    image: docker.elastic.co/kibana/kibana:8.16.0
    container_name: kibana
    restart: 'always'
    environment:
      - ELASTICSEARCH_URL=http://elasticsearch:9200
    ports:
      - ""5601:5601""
    networks:
      - elk
    depends_on:
      - elasticsearch
networks:
  elk:
    driver: bridge
volumes:
  esdata:
    driver: local
```
## Nest.js Microservice
Instantiating a microservice is as straightforward as setting up a normal HTTP service. Simply follow the [Nest.js Microservices](https://docs.nestjs.com/microservices/basics) instructions. In this case, we also integrateELK and RabbitMQ.
### apps/product/main.ts
There are two important points to note:
1. If `product.proto` imports other `.proto` files, such as `common.proto`, you must also include the `common.proto` file. There are two ways to address this:

Option 1: Directly import `common.proto` into the `protoPath`:
    
```bash
protoPath: [join(process.cwd(), 'proto/product.proto'), join(process.cwd(), 'proto/common.proto')],
```

Option 2: Load the entire `proto` directory.   
   
```bash
loader: {
  includeDirs: [process.cwd(), 'proto']
}
```
2. Configure the service to listen on `0.0.0.0:10087` instead of `localhost:10087`. This is because each Kubernetes Pod operates within its own network namespace, and `localhost` just refers to the Pod’s loopback address. Other Pods cannot communicate with it using `localhost`.
```ts
import { ecsFormat } from '@elastic/ecs-winston-format'
import { NestFactory } from '@nestjs/core'
import { MicroserviceOptions, Transport } from '@nestjs/microservices'
import { WinstonModule } from 'nest-winston'
import { join } from 'path'
import * as winston from 'winston'
import { ElasticsearchTransport } from 'winston-elasticsearch'
import { ProductModule } from './product.module'
// Using winston and ELK instead of the official logger
export const logger = WinstonModule.createLogger({
  instance: winston.createLogger({
    level: 'info',
    format: ecsFormat(),
    transports: [
      new ElasticsearchTransport({
        level: 'info',
        indexPrefix: 'learn-backend-logging', // Remember this line and we'll use it to config Kibana Data View
        indexSuffixPattern: 'YYYY-MM-DD',
        clientOpts: {
          node: 'http://0.0.0.0:9200',
          maxRetries: 5,
          requestTimeout: 10000,
          sniffOnStart: false,
          tls: { rejectUnauthorized: false }
        }
      })
    ]
  })
})
async function bootstrap() {
  const app = await NestFactory.createMicroservice<MicroserviceOptions>(
    ProductModule,
    {
      transport: Transport.GRPC,
      options: {
        package: 'product',
        protoPath: join(process.cwd(), 'proto/product.proto'),
        url: '0.0.0.0:10087'
      },
      logger
    }
  )
  await app.listen()
}
bootstrap()
```
### apps/product/product.module.ts
```ts
import { ConfigModule } from '@app/config'
import { RabbitMQModule } from '@golevelup/nestjs-rabbitmq'
import { Logger, Module } from '@nestjs/common'
import { ProductController } from './product.controller'
import { ProductService } from './product.service'
@Module({
  imports: [
    ConfigModule,
    RabbitMQModule.forRoot(RabbitMQModule, {
      exchanges: [{ name: 'MQ_SERVICE', type: 'topic' }],
      uri: 'amqp://root:password@0.0.0.0:5672',
      connectionInitOptions: { wait: false },
      deserializer: (message: Buffer) => {
        return message
      },
      serializer: (msg: unknown) => {
        const encodedMessage = JSON.stringify(msg)
        return Buffer.from(encodedMessage)
      }
    })
  ],
  controllers: [ProductController],
  providers: [ProductService, Logger]
})
export class ProductModule {}
```
### apps/product/product.controller.ts
After running the `pnpm run proto-ts` command, you will generate the `ProductServiceController` interface. You can implement it and create the template code as follows:
```ts
import { AmqpConnection, RabbitSubscribe } from '@golevelup/nestjs-rabbitmq'
import { Controller, Logger } from '@nestjs/common'
import { GrpcMethod } from '@nestjs/microservices'
import { Observable } from 'rxjs'
import {
  CreateProductRequest,
  CreateProductResponse,
  DeleteProductRequest,
  DeleteProductResponse,
  GetProductRequest,
  GetProductResponse,
  ProductServiceController,
  UpdateProductRequest,
  UpdateProductResponse
} from 'types/proto/product'
@Controller()
export class ProductController implements ProductServiceController {
  constructor(private readonly logger: Logger, private readonly amqpConnection: AmqpConnection,) {}
  @GrpcMethod('ProductService', 'CreateProduct')
  createProduct(
    request: CreateProductRequest
  ): Promise<CreateProductResponse> | CreateProductResponse {
     throw new Error('Method not implemented.')
  }
  @GrpcMethod('ProductService', 'GetProduct')
  getProduct(
    request: GetProductRequest
  ):
    | Promise<GetProductResponse>
    | Observable<GetProductResponse>
    | GetProductResponse {
    // record log to elasticsearch
    this.logger.log('call getProduct rpc')
    // publish rabbitmq message
    this.amqpConnection.publish(
      'MQ_SERVICE',
      'get_product_by_id',
      request
    )
    return {}
  }
  updateProduct(
    request: UpdateProductRequest
  ):
    | Promise<UpdateProductResponse>
    | Observable<UpdateProductResponse>
    | UpdateProductResponse {
    throw new Error('Method not implemented.')
  }
  deleteProduct(
    request: DeleteProductRequest
  ):
    | Promise<DeleteProductResponse>
    | Observable<DeleteProductResponse>
    | DeleteProductResponse {
    throw new Error('Method not implemented.')
  }
  @RabbitSubscribe({
    exchange: 'MQ_SERVICE',
    routingKey: 'get_product_by_id'
  })
  public async subscribe(content: Buffer, msg: unknown) {
    const message = JSON.parse(content.toString())
    console.log(message, msg)
  }
}
```
## Nest.js Gateway
The Gateway service is simply a HTTP service, we want to use it call Product microservice service and expose the APIs.
### apps/gateway/main.ts
```ts
import { NestFactory } from '@nestjs/core'
import { GatewayModule } from './gateway.module'
async function bootstrap() {
  const app = await NestFactory.create(GatewayModule)
  await app.listen(10086)
}
bootstrap()
```
### apps/gateway/gateway.module.ts
To call the Product microservice, you need to register it at first.
Kubernetes uses an internal `DNS name` system for service discovery. We will name the Product microservice service `product-service` at the follows chapter. In production, you can reach the Product microservice using `product-service:10087`, while in development, you just use `0.0.0.0:10087`.
```ts
import { ConfigModule } from '@app/config'
import { Logger, Module } from '@nestjs/common'
import { ClientsModule, Transport } from '@nestjs/microservices'
import { join } from 'path'
import { GatewayController } from './gateway.controller'
@Module({
  imports: [
    ClientsModule.register([
      {
        name: 'ORDER_SERVICE',
        transport: Transport.GRPC,
        options: {
          url:
            process.env.NODE_ENV === 'production'
              ? 'product-service:10087' // For Kubernetes production environment
              : '0.0.0.0:10087', // For local development environment 
          package: 'product',
          protoPath: join(process.cwd(), 'proto/product.proto'),
          loader: {
            includeDirs: [process.cwd(), 'proto']
          }
        }
      }
    ]),
  ],
  providers: [GatewayController]
})
export class GatewayModule {}
```
### apps/gateway/gateway.controller.ts
```ts
import { Metadata } from '@grpc/grpc-js'
import {
  Controller,
  Get,
  Inject,
  Logger,
  OnModuleInit,
  Param
} from '@nestjs/common'
import { ClientGrpc } from '@nestjs/microservices'
import { Observable } from 'rxjs'
import {
  GetProductResponse,
  ProductServiceController
} from 'types/proto/product'
@Controller()
export class GatewayController implements OnModuleInit {
  private productService: ProductServiceController
  constructor(@Inject('PRODUCT_SERVICE') private productClient: ClientGrpc) {}
  onModuleInit() {
    this.productService =
      this.productClient.getService<ProductServiceController>('ProductService')
  }
  @Get(':id')
  getProduct(
    @Param('id') id: string
  ):
    | Promise<GetProductResponse>
    | Observable<GetProductResponse>
    | GetProductResponse {
    const metadata = new Metadata()
    return this.productService.getProduct(
      {
        id
      },
      metadata
    )
  }
}
```
## Dockerfile
With the code phrase completed, we are now writing Dockerfiles for the Gateway service and the Product service.
### docker/Dockerfile.gateway
```yaml
FROM node:20-alpine AS builder
WORKDIR /app
COPY package.json pnpm-lock.yaml ./
RUN npm install -g pnpm
RUN pnpm install
COPY . .
RUN pnpm build gateway
FROM node:20-alpine AS runner
WORKDIR /app
COPY --from=builder /app/dist/apps/gateway ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY package.json .
COPY proto ./proto
ENV NODE_ENV=production
EXPOSE 10086
CMD [""node"", ""dist/main""]
```
### docker/Dockerfile.product
```yaml
FROM node:20-alpine AS builder
WORKDIR /app
COPY package.json pnpm-lock.yaml ./
RUN npm install -g pnpm
RUN pnpm install
COPY . .
RUN pnpm build product
FROM node:20-alpine AS runner
WORKDIR /app
COPY --from=builder /app/dist/apps/product ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY package.json .
COPY proto ./proto
ENV NODE_ENV=production
EXPOSE 10087
CMD [""node"", ""dist/main""]
```
Finally, run the follows commands in the root path:
```bash
docker build -t commerce/gateway-service:0.0.1 -f docker/Dockerfile.gateway .
docker build -t commerce/product-service:0.0.1 -f docker/Dockerfile.product .
```
![Docker Images](https://edge.yancey.app/beg/5fk50ukj-1732005307311.png)
## Set up Kubernetes Dashboard
Firstly, install `helm` on your computer. If you are using macOS, simply run:
```bash
brew install helm
```
Then, install Kubernetes Dashboard package:
```bash
# Add kubernetes-dashboard repository
helm repo add kubernetes-dashboard https://kubernetes.github.io/dashboard/
# Deploy a Helm Release named ""kubernetes-dashboard"" using the kubernetes-dashboard chart
helm upgrade --install kubernetes-dashboard kubernetes-dashboard/kubernetes-dashboard --create-namespace --namespace kubernetes-dashboard
```
![k8s-1.png](https://edge.yancey.app/beg/heaaswp4-1731642990477.png)
Once Kubernetes Dashboard is installed, you can verify it using the follows command:
```bash
kubectl get svc -n kubernetes-dashboard
```
![k8s-2.png](https://edge.yancey.app/beg/z4tvhtp1-1731643006669.png)
### Creating Account and Token
> Follow the [instruction](https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md).
First, create a Kubernetes manifest file to create a service account. For example:
```bash
apiVersion: v1
kind: ServiceAccount
metadata:
  name: admin-user
  namespace: kube-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: admin-user
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: admin-user
  namespace: kube-system
```
Next, apply the above configuration to the Kubernetes cluster.
```bash
kubectl create -f k8s-dashboard-account.yaml
```
Next, generate a token using the follows command:
```bash
kubectl -n kube-system create token admin-user
```
### Starting Kubernetes Dashboard Server
```bash
kubectl -n kubernetes-dashboard port-forward svc/kubernetes-dashboard-kong-proxy 8443:443
```
Finally, fill out your token on the field.
![k8s-3.png](https://edge.yancey.app/beg/e8o4uh2v-1731642976338.png)
## Kubernetes Deployment
### k8s/gateway-deployment.yaml
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: gateway-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: gateway
  template:
    metadata:
      labels:
        app: gateway
    spec:
      containers:
        - name: gateway
          image: commerce/gateway-service:0.0.1
          ports:
            - containerPort: 10086
---
apiVersion: v1
kind: Service
metadata:
  name: gateway-service
spec:
  selector:
    app: gateway
  ports:
    - port: 10086
      targetPort: 10086
  type: LoadBalancer
```
### k8s/product-deployment.yaml
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: product-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: product
  template:
    metadata:
      labels:
        app: product
    spec:
      containers:
        - name: product
          image: commerce/product-service:0.0.1
          ports:
            - containerPort: 10087
          env:
            - name: NODE_ENV
              value: production
---
apiVersion: v1
kind: Service
metadata:
  name: product-service
spec:
  selector:
    app: product
  ports:
    - port: 10087
      targetPort: 10087
  type: ClusterIP
```
Finally, run `kubectl apply -f k8s/` to deploy your services.
![image.png](https://edge.yancey.app/beg/p99e9ux4-1732006033687.png)
## Kibana Configuration
Submit some logs in advance to let ElasticSearch generate **index**, visit [https://localhost:9200/_cat/indices?v](https://localhost:9200/_cat/indices?v) to check whether your index successfully added.
![show all index](https://edge.yancey.app/beg/yv0nuib6-1732006146359.png)
Visit [http://localhost:5601/app/management/kibana/dataViews](http://localhost:5601/app/management/kibana/dataViews) to create data view, the `index pattern` matches the `indexPrefix` you configured.
![create data view](https://edge.yancey.app/beg/26aeg366-1732006176923.png)
Finally visit [http://localhost:5601/app/discover](http://localhost:5601/app/discover) and select your data view, and the logs will be displayed on the right panel.
![display your logs](https://edge.yancey.app/beg/5qfm13po-1732006203729.png)
To install the kube-prometheus-stack, you can use a Helm chart. This is a Kubernetes monitoring solution that integrates Prometheus, Alertmanager, Grafana, and other tools. Below are the installation steps:
## Add the Prometheus Community Repository
Add and update the Helm repository:
```bash
helm repo add prometheus-community <https://prometheus-community.github.io/helm-charts>
helm repo update
```
### Install kube-prometheus-stack
Choose a namespace (it is recommended to create a new one):
```bash
kubectl create namespace monitoring
```
Install the kube-prometheus-stack:
```bash
helm install kube-prometheus-stack prometheus-community/kube-prometheus-stack -n monitoring --set prometheus-node-exporter.hostRootFsMount.enabled=false
```
### Verify Installation
Check if all related pods are running correctly:
```bash
kubectl get pods -n monitoring
```
![image.png](https://edge.yancey.app/beg/74wxe9kv-1732106064278.png)
If the pods are running, services like Grafana and Prometheus will be exposed as ClusterIP. Use the following command to view the services:
```bash
kubectl get svc -n monitoring
```
![image.png](https://edge.yancey.app/beg/l7klkfnb-1732106006361.png)
### Access Grafana
The default username is `admin`, and you can retrieve the `password` with this command:
```bash
kubectl get secret -n monitoring kube-prometheus-stack-grafana -o jsonpath=""{.data.admin-password}"" | base64 --decode
```
Expose the Grafana service (e.g., using kubectl port-forward):
```bash
kubectl port-forward -n monitoring svc/kube-prometheus-stack-grafana 9999:80
```
Then, visit [http://localhost:9999](http://localhost:9999) and log in with the credentials retrieved in the previous step.


![image.png](https://edge.yancey.app/beg/xp3nwz4d-1732106384649.png)

## Summary
This is an MVP version of a Nest.js microservices project, covering the basics of coding, building, and deploying. However, there’s still a long way to go. Challenges such as security, high availability, and performance optimization remain to be addressed. If you have ideas or suggestions, feel free to reach out to me [@YanceyOfficial](https://twitter.com/YanceyOfficial) on X or comment this article directly. Your input is always welcome as we work towards making this project more robust and production-ready.","2025-02-02 03:09:44.788605","2025-02-02 03:09:44.788605"
"ef137e52-fcbe-4b4e-b273-d2f61220bd5b","{Poem}",0,0,False,"https://edge.yancey.app/beg/glx4p7hn-1645088748099.jpg","そのうちプラン","这本书还是前年去苏州玩在诚品书店买的, 台湾翻译成「今天就先酱」,一本休闲的绘本. 摘录了四十几张有趣的图片.","![0](https://edge.yancey.app/beg/8x3nvbp5jv_1645087879601.webp)
![1](https://edge.yancey.app/beg/um90fawgky_1645087886756.webp)
![2](https://edge.yancey.app/beg/eurnebgb14_1645087893249.webp)
![3](https://edge.yancey.app/beg/0m67r1six9_1645087898157.webp)
![4](https://edge.yancey.app/beg/yz2aq521m2_1645087904403.webp)
![5](https://edge.yancey.app/beg/l4eeky9h72_1645087910575.webp)
![6](https://edge.yancey.app/beg/ug0mmf4k46_1645087916912.webp)
![7](https://edge.yancey.app/beg/ci4ldr2t5w_1645087922169.webp)
![8](https://edge.yancey.app/beg/2wn1gyk3fn_1645087925946.webp)
![9](https://edge.yancey.app/beg/98w50c3tdw_1645087931430.webp)
![10](https://edge.yancey.app/beg/u7jcscoj8j_1645087937061.webp)
![11](https://edge.yancey.app/beg/vx5wuw53zj_1645087942530.webp)
![12](https://edge.yancey.app/beg/vdozotvs5p_1645087948465.webp)
![13](https://edge.yancey.app/beg/2vrbasacbq_1645087954088.webp)
![14](https://edge.yancey.app/beg/b797jyi2fk_1645087959520.webp)
![15](https://edge.yancey.app/beg/5tq1ujth05_1645087964921.webp)
![16](https://edge.yancey.app/beg/esju22c7q8_1645087970730.webp)
![17](https://edge.yancey.app/beg/cvbwa9fl4j_1645087976622.webp)
![18](https://edge.yancey.app/beg/98hh3cwfzb_1645087982293.webp)
![19](https://edge.yancey.app/beg/l34gjmqbez_1645087987650.webp)
![20](https://edge.yancey.app/beg/52ygf699lx_1645087993629.webp)
![21](https://edge.yancey.app/beg/1cn91u4zza_1645087998967.webp)
![22](https://edge.yancey.app/beg/r8wst69bru_1645088004452.webp)
![23](https://edge.yancey.app/beg/mmqgsx5sps_1645088010529.webp)
![24](https://edge.yancey.app/beg/j2q6seq81p_1645088016854.webp)
![25](https://edge.yancey.app/beg/lk2bjkwke5_1645088022866.webp)
![26](https://edge.yancey.app/beg/544kl80p0l_1645088028482.webp)
![27](https://edge.yancey.app/beg/qlyco31vkc_1645088034665.webp)
![28](https://edge.yancey.app/beg/43r6a3x2eo_1645088041179.webp)
![29](https://edge.yancey.app/beg/yan36bywm1_1645088047335.webp)
![30](https://edge.yancey.app/beg/mqigwlvpxw_1645088053334.webp)
![31](https://edge.yancey.app/beg/86unvhpou1_1645088059564.webp)
![32](https://edge.yancey.app/beg/0dzsrxhebj_1645088065374.webp)
![33](https://edge.yancey.app/beg/fjvs9ihatp_1645088070999.webp)
![34](https://edge.yancey.app/beg/u7si79ofyv_1645088076519.webp)
![35](https://edge.yancey.app/beg/r6dxtwvjog_1645088082279.webp)
![36](https://edge.yancey.app/beg/55w7yujni8_1645088087887.webp)
![37](https://edge.yancey.app/beg/dupga2wyxe_1645088093458.webp)
![38](https://edge.yancey.app/beg/givbz96geg_1645088098680.webp)
![39](https://edge.yancey.app/beg/z2bpd21vr9_1645088104099.webp)
![40](https://edge.yancey.app/beg/rr7xn9s1c8_1645088109068.webp)
![41](https://edge.yancey.app/beg/ag2z0tykpu_1645088114521.webp)
![42](https://edge.yancey.app/beg/hzk4qrxsrq_1645088120165.webp)
![43](https://edge.yancey.app/beg/2qns8u5b9v_1645088125722.webp)
![44](https://edge.yancey.app/beg/10jm3p442c_1645088131133.webp)
![45](https://edge.yancey.app/beg/76j9c6x70g_1645088135233.webp)","2025-02-02 03:09:06.22351","2025-02-02 03:09:06.22351"
"413d36af-7f0a-44f4-8b76-7c5bcbfd0d0b","{JavaScript}",0,0,False,"https://edge.yancey.app/beg/scribmu6-1647007744905.jpg","《JS 核心原理解析》笔记","这个月读的周爱民老师的一门课, 老实说全是底层, 够难懂的, 后面还得二刷三刷...","## 引子

JavaScript 是一门多范型语言,也称为混合范型语言, 它既有 OOP 的特性, 也有函数式的特性. JavaScript 的简单来自于此, 复杂也来自于此; 生存能力来自于此, 抨击诟病也来自于此. JavaScript 主要包括 5 个方面的语言特性: 结构化编程, 面向对象编程, 动态语言, 函数式语言和并行语言. JavaScript 中, 有语句和表达式两种基本的可执行元素.

## 谈一谈 JavaScript 的动态类型和弱类型

在声明变量之前需要先定义变量类型, 我们把这种在使用之前就需要确认其变量数据类型的称为**静态语言**. 相反地, 我们把在运行过程中需要检查数据类型的语言称为**动态语言**.

考察这段 Javascript 语句, `if (1)`, 1 实际会被隐式转成 true. 这种支持隐式类型转换的语言称为**弱类型语言**, 不支持隐式类型转换的语言称为**强类型语言**.

![语言类型图](https://edge.yancey.app/beg/reqtqxp6-1650285585224.webp)

JavaScript 是一种弱类型的, 动态的语言:

- 弱类型, 意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型, JavaScript 引擎在运行代码的时候自己会计算出来.
- 动态, 意味着你可以使用同一个变量保存不同类型的数据.

## 谈一谈 delete

我们使用 delete 最多的场景就是删除对象中的某个 key, 这是操作的一个引用类型. 其实仔细想想, `delete 0` 相当于删除一个基本类型, 甚至你还可以删除全局对象的某个 key, 比如在浏览器环境中, 你可以 `delete scrollX`. 因此, `delete x`, x 可以是引用类型, 也可以是基本类型, 也可以是全局对象(当然它也是引用类型).

首先看 `delete 0`, 0 是一个具体的字面量值, 是不可能删除掉的, 但 `delete 0` 仍然会返回 true, 这只表明执行过程中没有异常, 但实际的执行行为是""什么也没发生"". 你显然不可能真的将 0 从执行系统中清理出去.

那么接下来, 就还剩下删除变量和删除属性, 由于全局变量实际上是通过全局对象的属性来实现的, 因此删除变量也就存在识别这两种行为的必要性. 出于 JavaScript 是动态语言这项特性, 从根本上来说, 我们是没有办法在语法分析期来判断 x 的性质的, 需要有一种方法在运行期来标识 x 的性质, 以便进一步地处理它.

对于一门编译型语言来说, 0 可以是原始类型 0, 也可以是数值类型 `Number(0)`. 但在编译之前, 也就是语法分析的阶段, 0 仅仅是一个 Token. 一个记号是没有语义的, 记号既可以是语言能识别的, 也可以是语言不能识别的. 唯有把这二者同时纳入语言范畴, 那么这个语言才能识别所谓的""语法错误"". 因此, 这个语法实际起作用的是一个对象的属性, 也就是""删除对象的成员"". **是删除 x 这个成员, 而不是删除 x 这个值**.

表达式的值, 在 ECMAScript 的规范中, 称为**引用**. 对于 delete 0, 实际上是在说: JavaScript 将 0 视为一个表达式, 并尝试删除它的求值结果.

- 如果它是值, 则按照传统的 JavaScript 的约定返回 true;
- 如果它是一个引用, 那么对该引用进行分析, 以决定如何操作.

ECMAScript 约定: 任何表达式计算的结果(Result)要么是一个值, 要么是一个引用. delete {} 这个对象字面量 , 当它被作为表达式执行的时候, 结果也是一个值.

所有赋值操作的含义, 是将右边的**值**, 赋给左边用于包含该值的**引用**. 如果 x 放在左边作为 lhs, 那么它是引用; 如果放在右边作为 rhs, 那么就是值. 所以 `x = x` 的语义并不是**x 赋给 x**, 而是**把值 x 赋给引用 x**.

而对于 `obj.x()`, 如果 obj.x 只是值, 或者它作为右手端, 那么它就不能**携带** obj 这个对象, 也就完成不了后续的方法调用操作.

所以, **delete x**归根到底, 是在删除一个表达式的, 引用类型的结果(Result), 而不是在删除 x 表达式, 或者这个删除表达式的值(Value).

- delete 运算符尝试删除值数据时, 会返回 true, 用于表示没有错误(Error).
- delete 0 的本质是删除一个表达式的值(Result).
- delete x 与上述的区别只在于 Result 是一个引用(Reference)
- delete 其实只能删除一种引用, 即对象的成员(Property)

因此, 在 JavaScript 中. 引用类型, 也就是 Obeject, Fuction 这些, 归因于它们存在于堆內存; 而基础类型, 如 Number, String, Boolean, null, undefined, 归因于它们存在于栈内存. 但注意的是引用和引用类型是不同的概念.

最后写几个例子:

```ts
let x = 1;
delete x; // false

delete unexistingVariable; // true

const o = {};
Object.defineProperty(o, ""name"", {
  value: ""yancey"",
  configurable: false,
});
delete o.name; // false
```

## 谈一谈声明语句

至今为止, 除标签声明之外, JavaScript 中一共只有六条声明用的语句: let, const, var, function, import, class. 此外还有两个不太严格的声明语句, 分别是 `for(var|let|const x ...)` 和 `try...catch`. 比如 `var a = 1`, var a 就是一个声明, 后面是一个赋值运算.

除上述的语法, 用户是没有其它方式来在当前的代码上下文中声明出一个标识符来的, 因为所有的声明都有以下两个特征:

- 意味着 JavaScript 将可以通过**静态**语法分析发现那些声明的标识符
- 标识符对应的变量 / 常量**一定**会在用户代码执行前就已经被创建在作用域中.

下面这个例子, 正是由于 var y 所声明的那个标识符在函数 f() 创建(它自己的闭包)时就已经存在, 所以才阻止了 console.log(y)访问全局环境中的 y. 类似的, let x 所声明的那个 x 其实也已经存在 f() 函数的上下文环境中. 访问它之所以会抛出异常(Exception), 不是因为它不存在, 而是因为这个标识符被拒绝访问了(临时死区).

```ts
var y = ""outer"";
function f() {
  console.log(y); // undefined
  console.log(x); // throw a Exception
  let x = 100;
  var y = 100;
}
```

### 变量提升

JavaScript 是允许访问还没有绑定值的 var 所声明的标识符的, 这种标识符后来统一约定称为变量声明(VarDelcs); 而 let/const 则称为词法声明(LexicalDecls). JavaScript 环境在创建一个 var 变量名后, 会初始化绑定一个 undefined 值. 而 let/const 则会初始化绑定一个 undefined, 而 let/const 没这个待遇, 它们在缺省情况下就是""还没有绑定值""的标识符, 且 const 必须赋初值.

回到上面六条声明用的语句, 函数是按 varDecls 的规则声明的; 类 1 的内部是严格模式, 名字按 let 处理; import 按照 const 的规则处理. 因此所有的声明本质上只有三种处理模式: var 变量声明, let 变量声明和 const 常量声明.

补充, import 语句会发生变量提升的效果, 这是因为 ESModule 根据 import 构建依赖树, 所以在代码运行前名字就是已经存在于上下文, 然后在运行模块最顶层代码, 给名字绑定值, 就出现了变量提升的效果.

### 赋值

将右操作数(的值)赋给左操作数(的引用), 一个赋值表达式的左边和右边其实都是表达式.

```ts
LeftHandSideExpression < = | AssignmentOperator > AssignmentExpression
```

### 向一个不存在的变量赋值

现在的 JavaScript 环境仍然是通过将全局对象初始化为一个全局闭包来实现的. 但是为了得到一个尽可能与其它变量环境相似的声明效果(varDecls), ECMAScript 规定在这个全局对象之外再维护一个变量名列表(varNames), 所有在静态语法分析期或在 eval() 中使用 var 声明的变量名就被放在这个列表中. 然后约定, 这个变量名列表中的变量是""直接声明的变量"", 不能使用 delete 删除.

当然 let, const 是不存在这种事情的, 它们不会被挂在 global 下.

```ts
// 这两个都挂在了全局对象上, 可以通过 global. 获取
// 不同的是, a 是不可删除的, b 是可删除的
// 是否能够被删除可通过 configurable 属性符来判断
var a = 100;
x = 200;

Object.getOwnPropertyDescriptor(global, ""a"");
// { value: 100, writable: true, enumerable: true, configurable: false }

Object.getOwnPropertyDescriptor(global, ""x"");
// { value: 200, writable: true, enumerable: true, configurable: true }
```

因此回到今天讨论的这行代码 `var x = y = 100`, 在这行代码中, 等号的右边是一个表达式 y = 100, 它发生了一次**向不存在的变量赋值**, 所以它隐式地声明了一个全局变量 y, 并赋值为 100. x 和 y 是两个不同的东西, 前者是声明的名字, 后者是一个赋值过程可能创建的变量名.

var 关键字所声明的, 事实上有且仅有 x 一个变量名, 变量 y 会因为赋值操作而导致 JavaScript 引擎**意外**创建一个全局变量, 去除掉`var x` 之后剩下的部分, 并不是一个严格意义上的**赋值运算**, 而是被称为**初始器(Initializer)**的语法组件. 因此, x 只是一个表达名字的, 静态语法分析期作为标识符来理解的字面文本, 而不是一个表达式. 而对于 `x = y = 0`, x 是一个表达式了, 它被严格地称为**赋值表达式的左手端(lhs)操作数**.

```ts
Initializer: = AssignmentExpression
```

关于全局变量有两个规则:

1. 向没有声明的变量名赋值, 会隐式地创建一个全局变量;
2. 全局变量会被绑定为全局对象(global)的属性.

```ts
var a = 1;
b = 2;

window.a; // 1
window.b; // 2
```

## a.x = a = { n: 2} 经典问题

```ts
var a = { n: 1 },
  ref = a;
a.x = a = { n: 2 };
console.log(a.x); // undefined
console.log(ref.x); // { n: 2 }
```

首先, 对于第一行, 声明一个 a 变量, 赋值为 `{ n: 1 }`. 对于第二行, **因为 js 操作是从左往右**, a.x 先执行, 给 a 这个引用里面添加一个 x 属性, x 属性是什么呢? 看等号右边, 为一个赋值表达式(可以把连续赋值看作一个嵌套函数, 等号左边都是引用, 右边都是值, 执行是从前往后, 但赋值是从后往前), 那么要做的就是求赋值表达式的值; 即 `a = { n: 2 }`, 这是第一次赋值, 这时候 a 这个变量的引用已经发生了变化, 指向了另一块地址, 这时候过去的 a 的引用地址就找不到了. 那么对于第三行, 当你再打印 a.x 时, 这里面的 a 其实是新的引用地址, 打印出来自然是 undefined,

![拆解](https://edge.yancey.app/beg/nl5r8o6z-1644745550550.jpg)

## 谈一谈 export

ECMAScript 6 模块是静态装配的, 而传统的 Node.js 模块却是动态加载的.

```ts
// 导出""声明的(名字)""
export <let/const/var> x ...;
export function x() ...
export class x ...
export {x, y, z, ...};

// 导出""重命名的(名字)""
export { x as y, ...};
export { x as default, ... };

// 导出""其它模块的(名字)""
export ... from ...;

// 导出""值""
export default <expression>
```

`export default` 虽然简单, 却是对导出名字的非常必要的补充. 这样一来, 用户既可以导出那些有名字的数据, 也可以导出那些没有名字的数据, 即一个模块中所有的数据都可以被导出了.

以 `export var x = 100;` 为例, 在导出的时候. 就是在某个名字表登记上一个名字 x 而已, 这也是 JavaScript 在模块装载之前对 export 所做的全部工作; 而从 import 角度考虑, 比如 `import { x } from 'xxx'`, 它是按照语法在当前模块中声明名字, 添加一个当前模块对目标模块的依赖项. 通过这种方式, JavaScript 就可以依据所有它能在静态文本中发现的 import 语句来形成模块依赖树, 最后就可以找到这个模块依赖树最顶端的根模块, 并尝试加载之.

export 事实上就只能导出**名字和值**. 然而一旦它能导出**名字和值**, 也就意味着它能导出一个模块中的**全部内容**. 在导入导出的过程中, 没有任何一行用户的 JavaScript 代码是被执行过的, 源代码只被理解为静态的, 没有逻辑的代码文本. 这意味着, **在处理 export/import 语句的全程, 没有表达式被执行.**

在看下面的例子, 如同 `var x = 100;` 在执行阶段需要有一个将值 100 绑定给变量 x 的过程, export default 也应当有类似的过程来将结果绑定到 default 这个名字上. 在静态装配阶段, 名字 default 只是被初始化为一个**单次绑定的, 未初始化的标识符**. 因此后续找到并遍历模块依赖树的所有模块, 执行这些模块最顶层的代码. 这意味着, **所谓模块的装配过程, 就是执行一次顶层代码而已.**

```ts
export var x = 100;
export default function() {}
export var default = function() {}
```

### 对于匿名函数的 export

**它并不是导出了一个匿名函数表达式, 而是导出了一个匿名函数定义(Anonymous Function Definition)**. 下面这个例子, 如果默认导出一个匿名函数, 它会被默认导出到一个名字为 default 的名字空间中.

```ts
// b.js
export default function () {}

// a.js
import B from ""./b.js"";
B.name; // 'default'
```

如果是个具名函数, 导出后就还会用到这个名字. 其实这种写法在 React 的函数组件中是很常见的做法.

```ts
// b.js
export default function b() {}

// a.js
import B from ""./b.js"";
B.name; // 'b'
```

### 其他

- `export var x = ''` 就意味着在当前模块环境中创建的是一个变量, 并可以修改等等. 但是当它被导入时, 在 import 语句所在的模块中却是一个常量, 因此总是不可写的
- 由于 `export default` 没有显式地约定名字 default 应该按 let/const/var 的哪一种来创建, 因此 JavaScript 缺省将它创建成一个普通的变量(var), 但即使是在当前模块环境中, 它事实上也是不可写的, 因为你无法访问一个命名为""default""的变量, 因此它是一个关键字.
- 所谓匿名函数, 仅仅是当它直接作为操作数时, 才是真正匿名的, 如 `function(){}.name; // ''`.
- 由于类表达式, 在本质上就是函数, 它的表现形式和上述一致(参考 React 类组件).
- 导出项(的名字)总是作为词法声明被声明在当前模块作用域中的, 这意味着它不可删除, 且不可重复导出.
- 对于 export 来说是模块的导出表, 对于 import 来说就是名字空间, 如果用户代码不使用 `import * as ...` 的语法来创建这个名字空间, 那么该名字表就只存在于 JavaScript 的词法分析过程中, 而不会(或并不必要)创建它在运行期的实例

## 一个偏门的概念 - for 循环的代价

先复习一下, 在 ECMAScript 6 之后, JavaScript 实现了块级作用域. 然而, 绝大多数 JavaScript 语句都并没有自己的块级作用域. 从语言设计的原则上来看, 越少作用域的执行环境调度效率也就越高, 执行时的性能也就越好. 像 switch, try...catch 是块级作用域, 而 if, for, while 等都不是块级作用域.

在 JavaScript 的具体执行过程中, 作用域是被作为环境的上下文来创建的. 如果将 for 语句的块级作用域称为 forEnv, 并将上述为循环体增加的作用域称为 loopEnv, 那么 loopEnv 它的外部环境就指向 forEnv. 于是在 loopEnv 看来, 变量 i 其实是登记在父级作用域 forEnv 中, 并且 loopEnv 只能使用它作为名字 i 的一个引用. 更准确地说, 在 loopEnv 中访问变量 i, 在本质上就是通过环境链回溯来查找标识符(Resolve identifier, or Get Identifier Reference).

下面这个例子创建了一些定时器. 当定时器被触发时, 函数会通过它的闭包(这些闭包处于 loopEnv 的子级环境中)来回溯, 并试图再次找到那个标识符 i. 然而, 当定时器触发时, 整个 for 迭代有可能都已经结束了. 这其实就是几百年前那个经典的面试题 —— **for 循环为 var 遇上 setTimeout 的问题.** ES6 之前的解法是通过闭包, 当然之后换成 let 即可, 但换成 let 其实是会有代价的.

因为要想使用 let 的方式符合预期, 这个 loopEnv 就必须是**随每次迭代变化的**. 也就是说, 需要为每次迭代都创建一个新的作用域副本, 这称为迭代环境(iterationEnv), 因此, 每次迭代在实际上都并不是运行在 loopEnv 中, 而是运行在该次迭代自有的 iterationEnv 中. 也就是说, 在语法上这里只需要两个块级作用域, 而实际运行时却需要为其中的第二个块级作用域创建无数个副本. 这就是 for 语句中使用 let/const 这种块级作用域声明所需要付出的代价. 这个循环体越大, 支持的层次越多, 那么这个环境的创建也就越频繁, 代价越高昂. 再加上可以使用函数闭包将环境传递出去, 或交给别的上下文引用, 这里的负担就更是雪上加霜了. 有个说法是**循环与函数递归在语义上等价**, 其实不然, 像上面这种, 循环带来的代价并不小.

换句话说, 绝大多数语句并没有块级作用域, 因为它们不需要. 而需要块级作用域的 for 语句, 根本的需求是需要处理多次迭代中的变量暂存, 这个是有很大开销的.

```ts
for (let i in [1, 2, 3]) {
  setTimeout(() => console.log(i), 1000);
}
```

对于一门编译型语言来说, 0 可以是原始类型 0, 也可以是数值类型 `Number(0)`. 但在编译之前, 也就是语法分析的阶段, 0 仅仅是一个 Token. 一个记号是没有语义的, 记号既可以是语言能识别的, 也可以是语言不能识别的. 唯有把这二者同时纳入语言范畴, 那么这个语言才能识别所谓的""语法错误"". 因此, 这个语法实际起作用的是一个对象的属性, 也就是""删除对象的成员"". **是删除 x 这个成员, 而不是删除 x 这个值**. 不过终归有一点是没错的: 既然没办法表达异常, 而 delete 0 又不产生异常, 那么它自然就该返回 true. 所以, delete 这个操作的正式语法设计并不是""删除某个东西"", 而是""删除一个表达式的结果"".

## 谈一谈 break

所谓可中断语句其实只有两种, 包括全部的循环语句, 以及 switch 语句. 在这两种语句内部使用的 break, 采用的就是这种处理机制, 即中断当前语句, 将执行逻辑交给下一语句. 第二种还有标签语句, JavaScript 和 Rust 都有该语法. 当然除了 break, 也可以是 continue.

```ts
// 在 if 语句的两个分支中都可以使用 break
// 在分支中深层嵌套的语句中也是可以使用 break 的
aaa: if (true) {
   ...
}
else {
  ...
  break aaa;
}

// 在 try...catch...finally 中也可以使用 break
bbb: try {
  ...
}
finally {
  break bbb;
}
```

在重学前端的课程学到了即便在 try 中 return 了, 还是会执行 finally 里面的代码, 这涉及 JavaScript 语句执行的完成状态(Completion Record), 如果在 try 或 try..finally 块中使用了 return, 那么这个 break 将发生于最后一行语句之后, 但是却是在 return 语句之前. 下面的代码会依次打印出 Hi, Here, 101. 换句话说, 虽然 try 里面有 return, 但到了 finally 语句的时候, 把 try 里面给 break 掉了, 这得以继续执行下面的语句. 因此, break 将语句的代码块理解为位置, 而不是理解为作用域 / 环境.

```ts
var i = 100;
function foo() {
  bbb: try {
    console.log(""Hi"");
    return i++; //  <- 位置 1: i++ 表达式将被执行
  } finally {
    break bbb;
  }
  console.log(""Here"");
  return i; //  <- 位置 2
}

function f() {
  try {
    return 1;
  } finally {
    console.log(""finally"");
  }

  console.log(""a""); // 执行不到了
}
```

JavaScript 的执行机制包括**执行权**和**数据资源**两个部分, 分别映射可计算系统中的**逻辑**与**数据**. 而块级作用域(也称为词法作用域)以及其他的作用域本质上就是一帧数据, 以保存执行现场的一个瞬时状态(也就是每一个执行步骤后的现场快照). 而 JavaScript 的运行环境被描述为一个后入先出的栈, 这个栈顶永远就是当前**执行权**的所有者持用的那一帧数据, 也就是代码活动的**现场**.

- 块级作用域以及其他的作用域本质上就是一帧数据, 交由所谓**环境**来管理;
- 函数是通过 CALL/RETURN 来模拟上述**数据帧**在栈上的入栈与出栈过程, 也称为调用栈;
- 执行现场是上述环境和调用栈的一个瞬时快照(包括栈上数据的状态和执行的**位置**).

所以, **作用域**就是在上述过程中被操作的一个对象.

- 作用域退出, 就是函数 RETURN.
- 作用域挂起, 就是执行权的转移.
- 作用域的创建, 就是一个闭包的初始化.
- ...

而 `break labelName` 这一语法独立于**执行过程** 的体系, 它表达一个位置的跳转, 而不是一个数据帧在栈上的进出栈. 这是 labelName 独立于标识符体系(也就是词法环境)所带来的附加收益. 当然 JavaScript 用来抹平这种跳转所带来的影响, 需要额外的设计.

### 语句执行的完成状态(Completion Record)

语句执行与函数执行并不一样. 函数是求值, 所以返回的是对该函数求值的结果(Result), 该结果或是值(Value), 或是结果的引用(Reference). 而语句是命令, 语句执行的返回结果是该命令得以完成的状态(Completion, Completion Record Specification Type). 语句执行总是返回它的完成状态.

在 ECMAScript 规范层面, 本质上所有 JavaScript 的执行都是语句执行(这很大程度上解释了为什么 eval 是执行语句). 因此, ECMAScript 规范中对执行的描述都称为**运行期语义(Runtime Semantics)**, 它描述一个 JavaScript 内部的行为或者用户逻辑的行为的过程与结果. 也就是说这些运行期语义都最终会以一个完成状态(Completion)来返回. 例如:

- 一个函数的调用: 调用函数——执行函数体(EvaluateBody)并得到它的**完成**结果(result).
- 一个块语句的执行: 执行块中的每行语句, 得到它们的**完成**结果(result).

这些结果(result)包括的状态有五种, 称为完成的类型:

- 正常完成(normal)
- 一个函数调用的返回(return)
- 循环过程中的继续下次迭代(continue)
- 中断(break)
- 异常(throw)

所以当运行期出现了一这个称为**中断(break)**的状态时, JavaScript 引擎需要找到这个**break**标示的目标位置(result.Target), 然后与当前语句的标签(如果有的话)对比:

- 如果一样, 则取 break 源位置的语句执行结果为值(Value)并以正常完成状态返回;
- 如果不一样, 则继续返回 break 状态.

在这个示例中, **break aaa**语句是发生于 bbb 标签所示块中的. 但当这个中断发生时:

- 标签化语句 bbb 将首先捕获到这个语句完成状态, 并携带有标签 aaa
- 由于 bbb 语句完成时检查到的状态中的中断目标(Target)与自己的标签不同, 所以它将这个状态继续作为自己的完成状态, 返回给外层的 aaa 标签化语句 aaa;
- 语句 aaa 得到上述状态, 并对比标签成功, 返回结果为语句 `3 + 4` 的值(作为完成状态传出).

```ts
console.log(
  eval(`
  aaa: {
    1 + 2;
    bbb: {
     3 + 4;
     break aaa;
    }
  }
`)
);
// 输出值: 7
```

下面是一些有用的结论, 任何被 break 的代码上下文中, 最后执行语句必然会是**break 语句**本身. **break 语句**不返回任何值(ECMAScript 内部约定用**Empty**值来表示); **不返回任何值**的语句, 也不会影响任何语句的既有返回值. **break 语句**返回值的两个关键特性的由来: 它的类型必然是**break**; 它的返回值必然是**空(Empty)**. 无论如何, 语句总是一个树或子树(除了空语句可以做叶子结点), 而表达式可以是一个子树或一个叶子结点.

## 谈一谈 JavaScript 中的模版

模板, 其实就是一种特殊的可执行结构. 所有特殊可执行结构其实都是来自于某种固定的, 确定的逻辑. 这些逻辑语义是非常明确的, 输入输出都很确定, 这样才能被设计成一个标准的, 易于理解的可执行结构. 模版, 是一种**特殊的可执行结构**. 模板字面量是所有可执行结构的集大成者. 它本身是一个特殊的可执行结构, 但是它调动了包括引用, 求值, 标识符绑定, 内部可执行结构存储, 以及执行函数调用在内的全部能力. 下面列举 JavaScript 中语言及语法层面定义的特殊可执行结构.

### 参数表

在 JavaScript 语言的内核中, 参数表其实是一个独立的语法组件, 用于描述函数传参过程, 说白了就是把参数放在 arguments 列表中, 然后让 arguments 中的值与参数表中的名字对应起来. 下面是一些有用的概念.

- 对于函数来说, 参数表就是在函数调用时传入的参数 0 到 n;
- 对于构造器以及构造器的 new 运算来说, 参数表就是 new 运算的一个运算数;
- 既然提到了 arguments, 那么**箭头函数**是没有的, 也就意味着箭头函数没有参数表;
- 简单参数(Simple Parameter List), 就是可以在形式参数表中可以明确数出参数个数的, 没有使用扩展风格声明参数的参数表;
- 非简单的参数列表(Non-Simple Parameter List)也好理解, 像默认参数, 剩余参数等.

```ts
// 代理和反射中的 argArray 就是参数表
handler.apply = function (target, thisArgument, argArray) {};
```

### 扩展风格的参数表

稍微扩展一下默认参数, 剩余参数. 下面这个例子, 在语法分析期, JavaScript 就得帮助该参数登记下 100 这个值. 然后在实际处理这个参数时, 至少需要一个赋值表达式的操作, 用来将这个值与它的名字绑定起来. 所以, foo() 函数调用时, 总有一段执行逻辑来访问形式参数表以及执行这个赋值表达式.

```ts
function foo(x = 100) {}
```

下面这个例子, 由于表达式可以引用上下文中的其它变量, 因此上面的所谓登记, 就不能只是记下一个字面量值那么简单, 必须登记一个表达式, 并且在**运行时**执行它.

```ts
var x = 0;
function foo(i = x++) {
  console.log(i);
}
foo(); // 0
foo(); // 1
```

而剩余参数出现之前, 类似的替代方法只有 `Function.apply`. 而参数展开是通过**生成器**是实现的.

```ts
foo(...args);
foo.apply(args);
```

TIPS: 函数参数不允许出现重名参数的原因. 使用传统的简单参数时, 只需要将调用该参数时传入的实际参数与参数对象(arguments)绑定就可以了; 而使用非简单参数时, 需要通过**初始器赋值**来完成名字与值的绑定, 通常将实际参数与参数对象绑定时, 只需要映射两个数组的下标即可, 而**初始器赋值\*\***需要通过名字来索引值以实现绑定, 因此一旦出现重名参数就无法处理了.

### 赋值模版

模板赋值是 ECMAScript 6 之后提供一种声明标识符的语法, 该语法依赖一个简单的赋值过程, 等号的左侧称为赋值模板(AssignmentPattern), 而右侧称为值(Value). 在 JavaScript 中, 任何出现类似语法或语义过程的位置, 本质上都可以使用模板赋值的. 也就是说, 即使没有这个赋值符号(等号), 只要语义是\*\*向左操作数(lhs)上的标识符, 赋以右操作数(rhs)的值, 那么它就适用于模板赋值.

```ts
a = b;
```

下面这个例子, foo 函数传入一个对象, 且对象的 key 为 x 和 y, 在调用的时候, 它会严格匹配传入的对象的 key 是否与赋值模版的 key 对应. 即**向参数表中的形式参数(的名字), 赋以实际参数的值**.

```ts
function foo({ x, y }) {
  console.log(x, y); // 1 2
}

foo({ x: 1, z: 3, y: 2 });
```

所有这些地方的赋值模板, 都是在语法解析期就被分析出来, 并在 JavaScript 内部作为一个可执行结构存放着. 然后在运行期, 会用它们来完成一个**从右操作数按模板取值, 并赋值给左操作数**的过程, 简言之叫做**名字和值的绑定**. 当然, 对于上面匹配到的值, 我们还得使用这个名字以便进行更多的运算, 那么这个**找到名字并使用名字**的过程称为**发现(Resolve binding)**, 其结果称为**引用(reference)**. 而引用不是简单的一个语法标识符, 也可以是一个可执行结构, 比如 `""use strict""` 这个指令, 因为它是引用, 也是可执行结构, 对待它, JavaScript 只需要像调用函数一样, 将它处理成一段确定逻辑就可以了.

如 `obj.foo`, 它被称为属性引用(Property Reference). 属性引用不是简单的标识符引用, 而是一个属性存取运算的结果. 它是为数不多的, 可以存储原表达式信息, 并将该信息传递到后续表达式的特殊结构. 这与 JavaScript 中的方法调用这一语义的特殊实现有关, JavaScript 并不是静态分析的, 因此它无法在语法阶段确定 `obj.foo` 是不是一个函数, 也不知道用户代码在得到 `obj.foo` 这个属性之后要拿来做什么用. 直到 `obj.foo()`, JavaScript 引擎才会意识到这里要调用一个方法. 方法调用的时候是需要将 obj 作为 foo() 函数的 this 值传入, 这个信息只能在上一步的属性存取 obj.foo 中才能得到. 所以 obj.foo 作为一个属性引用, 就有责任将这个信息保留下来, 传递给它的下一个运算. 只有这样, 才能完成一次**将函数作为对象方法调用**的过程. 与参数表和赋值模板有相似的地方, 模板字面量也是将它的形式规格(Formal)作为可执行结构来保存的.

### 模版调用

模板字面量调用(TemplateLiteral Call)是唯一一个会使用模板字面量的引用形态(并且也没有直接引用它的内部结构)的操作. 这种引用形态的模板字面量也被称为标签模板(Tagged Templates), 主要包括模板的位置和那些可计算的标签的信息. 模板字面量的内部结构中, 主要包括将模板多段截开的一个数组, 原始的模板文本(raw)等等. 在引擎处理模板时, 只会将该模板解析一次, 并将这些信息作为一个可执行结构缓存起来(以避免多次解析降低性能).

```ts
var x = 1;
foo = (...args) => console.log(...args);
foo`${x}`;
// [ '', '', { raw: ['', ''] } ] 1
```

## 函数的执行过程

语句执行是命令式范型的体现, 而函数执行代表了 JavaScript 中对函数式范型的理解. 从静态视角来观察, 它就是一个函数对象(Fuction 的实例), 再深入一点函数就是具有 `[[Call]]` 私有属性的对象. 如果不考虑它作为对象的那些特性, 那么函数也无非就是如下三个语义组件组成的(三者缺一不可):

- 参数: 函数总是有参数的, 即使它的形式参数表为空;
- 执行体: 函数总是有它的执行过程, 即使是空的函数体或空语句;
- 结果: 函数总是有它的执行的结果, 即使是 undefined.

JavaScript 的函数是**非惰性求值**的, 也就是说在函数界面上不会传入一个延迟计算的求值过程, 而是**积极地**传入已经求值的结果. 在下面这个示例中, 传入函数 f() 的将是赋值表达式 `a = 100` 完成计算求值之后的结果. 考虑到这个**结果**总是存在**值和引用**两种表达形式, 所以 JavaScript 在这里约定**传值**. 于是, 上述示例代码最终执行到的将是 `f(100)`. 而 `a = 100` 这行表达式执行在函数外上下文环境中, 例子中是全局环境.

```ts
// 一般函数声明
function f(x) {
  console.log(x); // 100
}

// 表达式 a = 100 是非惰性求值的
f((a = 100));
```

接下来才来到具体调用这个函数 f()的步骤中. 而直到这个时候, JavaScript 才需要向环境中的那些名字(例如 function f(x)中的形式参数名 x), **绑定实际传入的值**. 对于这个 x 来说, 由于参数与函数体使用同一个块作用域, 因此如果函数参数与函数内变量同名, 那么它们事实上将是同一个变量. 函数内的三个 x 实际将是同一个变量, 因此这里的 `console.log(x)`将显示变量 x 的传入参数值 100, 而 `var x = 200;` 并不会导致重新声明一个变量, 仅仅是覆盖了既有的 x.

```ts
function f(x) {
  console.log(x); // 100
  var x = 200;
  console.log(x); // 200
}
// 由于非惰性求值, 所以下面的代码在函数调用上完全等义于上例中 f(a = 100)
f(100);
```

因此, 参数的登记过程发生在闭包创建的过程中, 也就是说传入参数的过程执行于函数之外, 比如 `f((a = 100))`, `a = 100` 这个语句是在函数外执行的, 而绑定参数的过程执行于函数内.

## 迭代的过程

```ts
// 迭代函数
function foo(x = 5) {
  return {
    next: () => {
      return { done: !x, value: x && x-- };
    },
  };
}

let x = new Object();
x[Symbol.iterator] = foo; // default `x` is 5
console.log(...x); // 5 4 3 2 1
```

连续的 tor.next() 调用最终仅是为了获取它们的值 `result.value`, 那么如果封装这些值的生成过程, 就可以用一个新的函数来替代一批函数. 这样的一个函数就称为生成器函数. 由于**函数只有一个出口**, 所以用函数的退出是无法映射函数包含一个多次生成值的过程这样的概念的. 如果要实现这一点, 就必须让函数可以多次进入和退出, 或者说通过**挂起**, 保证函数不会报销毁. 同时, 它在挂起当前函数时, 还将函数所在栈上的执行现场移出了调用栈.

- 逻辑上: 它产生一次函数的退出, 并接受下一次 tor.next() 调用所需要的进入;
- 数据上: 它在退出时传出指定的值(结果), 并在进入时携带传入的数据(参数).

```ts
function* foo(x = 5) {
  while (x--) yield x;
}

// 测试
let x = Object.create(null);
x[Symbol.iterator] = foo; // default `x` is 5
console.log(...x); // 4 3 2 1 0
```

## 环境和上下文

环境是 JavaScript 在语言系统中的静态组件, 而上下文是它在执行系统中的动态组件.

### 环境

JavaScript 中, 环境可以细分为四种, 并由两个类别的基础环境组件构成. 这四种环境是: 全局(Global), 函数(Function), 模块(Module)和 Eval 环境; 两个基础组件的类别分别是: 声明环境(Declarative Environment)和对象环境(Object Environment).

这些环境有分为两种类别:

- **声明环境**就是名字表, 可以是引擎内核用任何方式来实现的一个**名字 -> 数据**的对照表;
- **对象环境**是 JavaScript 的一个对象, 用来**模拟 / 映射**成上述的对照表的一个结果.

因此, 所有的**环境**本质上只有一个功能, 就是用来管理**名字 -> 数据**的对照表; **对象环境**只为全局环境的 global 对象, 或 `with (obj)` 语句中的对象 obj 创建, 其他情况下创建的环境, 都必然是**声明环境**.

而对于 var, 会发生变量提升, 也就是在一个变量赋值前就能访问它. 因此, 自 ECMAScript 5 开始约定, ECMAScript 的执行上下文将有两个环境, 一个称为词法环境(Lexical Environment), 另一个就称为变量环境(Variable Environment), 所有传统风格的 var 声明和函数声明通过变量环境来管理. 而在内核上, 全局上下文的词法环境和变量环境指向是一样的. 也就意味着词法变量和 var 变量共用一个名字表, 因此你声明了 var 变量, 那么就不能声明同名的 let/const 变量.

```ts
var x = 100;
let x = 200;
// SyntaxError: Identifier 'x' has already been declared
```

### 执行上下文

上下文指的是一个外部的, 内部的或由全局 / 模块入口映射成的函数. JavaScript 的执行系统由一个执行栈和一个执行队列构成. 在执行队列中保存的是待执行的任务, 称为 Job. 每一个执行上下文都需要关联到一个对照表. 这个对照表, 就称为**词法环境(Lexical Environment)**.

**模块入口**是所有模块的顶层代码的顺序组合, 它们被封装为一个称为顶层模块执行(TopLevelModule Evaluation Job)的函数中来作为模块加载的第一个执行上下文创建. 一般 **.js 文件**也会创建一个脚本执行(Script Evaluation Job) 的函数, 这也是文件加载中所有全局代码块被称为 script 块的原因. **eval** 也是会开启一个执行上下文, JavaScript 为 eval() 所分配的这个执行上下文, 与调用 eval() 时的函数上下文享有同一个环境(包括词法环境和变量环境等等), 并在退出 eval() 时释放它的引用, 以确保同一个环境中同时只有一个逻辑在执行.

对于普通函数被调用, 它也会形成执行上下文, 但它是**被**调用的, 所以它会创建一个 caller(调用者), 由于栈是先入后出的, 因此总是立即执行这个 callee 函数的上下文. 因此所有其他上下文都在执行栈上, 而生成器的上下文(多数时间是)在栈的外面.

### .next()

对于下面的代码, `let tor = foo3();` 看似执行了一次 foo3, 但实际上, 只要你没有调用 `.next()`, 生成器函数体就是没被执行的. 换言之, 生成一个迭代过程, 并将该过程交给了 tor 对象. 因为 tor 是 foo3() 生成器内部迭代过程的一个句柄. 从引擎内的实现过程来说, tor 其实包括状态(state)和执行上下文(context)两个信息, 它是 GeneratorFunction.prototype 的一个实例. 这个 tor 所代表的生成器在创建出来的时候将立即被挂起, 因此状态值(state)初始化置为""启动时挂起(suspendedStart)"", 而当在调用 tor.next() 因 yield 运算而导致的挂起称为 **Yield 时挂起(suspendedYield)**.

```ts
function* foo3() {
  yield 10;
}
let tor = foo3();
```

当 tor.next() 执行时, tor 所包括的 context 信息被压到栈顶执行, 当 tor.next() 退出时, 这个 context 就被从栈上移除.

## 扩展: yield

```ts
function* g1() {
  yield 2;
  yield 3;
  yield 4;
}

function* g2() {
  yield 1;
  yield* g1();
  yield 5;
}

var iterator = g2();

console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { value: 3, done: false }
console.log(iterator.next()); // { value: 4, done: false }
console.log(iterator.next()); // { value: 5, done: false }
console.log(iterator.next()); // { value: undefined, done: true }
```

## 关于 JavaScript OOP 的漫谈

在 ES6 后, JavaScript 内部是明确区分方法与函数的, 即不能对方法做 new 运算, 否则 JavaScript 会报出 is not a constructor 的异常.

```ts
const o = {
  foo() {},
  bar: class A {},
};

new o.foo(); // Uncaught TypeError: o.foo is not a constructor
new o.bar(); // 👌
```

在 ECMAScript 6 之后, 函数可以简单地分为三个大类:

- 类: 只可以做 new 运算;
- 方法: 只可以做调用运算;
- 一般函数: (除部分函数有特殊限制外, 如箭头函数, 生成器函数不能做构造函数), 同时可以做 new 和调用运算.

对于方法:

- 具有一个名为主对象 `[[HomeObject]]` 的内部槽;
- 没有名为构造器 `[[Construct]]` 的内部槽;
- 没有名为 prototype 的属性.

### ES5 构造函数与 ES6 Class 的区别

Class 类中不存在变量提升.

```ts
// ES5
var bar = new Bar(); // 可行
function Bar() {
  this.bar = 42;
}
//ES6
const foo = new Foo(); // Uncaught ReferenceError
class Foo {
  constructor() {
    this.foo = 42;
  }
}
```

Class 内部会启用严格模式

```ts
// ES5
function Bar() {
  baz = 23; // ok
}
var bar = new Bar();

// ES6
class Foo {
  constructor() {
    this.foo = 42;
    foo = 12; // Uncaught ReferenceError: foo is not defined
  }
}
```

Class 内部不能重写类名(修改类名)

```ts
// ES5
function Bar() {
  Bar = ""Baz"";
  this.bar = 42;
}
var bar = new Bar();
console.log(bar); // Bar {bar: 42}
console.log(Bar); // 'Baz'
// ES6
class Foo {
  constructor() {
    this.foo = 42;
    Foo = ""Fol""; // Uncaught TypeError: Assignment to constant variable.
  }
}
let foo = new Foo();
Foo = ""Fol""; // it's ok
```

Class 必须使用 new 调用, 不能直接当函数调用.

```ts
// ES5
function Bar() {}
var bar = Bar(); // it's ok;
// ES6
class Foo {}
let foo = Foo(); // Uncaught TypeError: Class constructor Foo cannot be invoked without 'new'
```

Class 中的所有方法不可枚举

```ts
// ES5
function Bar() {}
Bar.getName = function () {};
Bar.prototype.say = function () {};
console.log(Object.keys(Bar)); // [""getName""]
console.log(Object.keys(Bar.prototype)); // [""say""]

// ES6
class Foo {
  constructor() {}
  static answer() {}
  print() {}
}
console.log(Object.keys(Foo)); // []
console.log(Object.keys(Foo.prototype)); // []
```

Class 的继承有两条继承链

一条是: 子类的 `__proto__` 指向父类; 另一条是: 子类的 prototype 属性的 `__proto__` 指向父类的 prototype 属性; ES6 子类通过 `__proto__` 属性找到父类, 而 ES5 子类通过 `__proto__` 找到 `Function.prototype`.

```ts
// ES5
function Father() {}
function Child() {}
Child.prototype = new Father();
Child.prototype.constructor = Child;
console.log(Child.__proto__ === Function.prototype); // true

// ES6
class Father {}
class Child extends Father {}
console.log(Child.__proto__ === Father); // true
```

ES5 与 ES6 子类 this 的生成顺序不同

ES5 继承是先建立子类实例对象 this, 再调用父类构造函数修饰子类实例; ES6 继承是先建立父类实例对象 this, 再调用子类构造函数修饰 this. 即在子类构造函数中先调用 super() 方法, 之后再能使用 this. 因此所有 ES5 不能继承原生的构造函数, 而 ES6 可以继承. 此外, 既然 this 是祖先类创建的, 也就意味着在刚刚进入构造方法时, this 引用其实是没有值的, 因此必须采用继承父类的行为的技术, 让父类以及祖先类先把 this 构造出来才行.

### 浅谈 super

实现 super 这个关键字的核心, 在于为每一个方法添加一个它所属的类这样的性质, 这个性质被称为主对象 (HomeObject).

- 在类声明中, 如果是类静态声明, 也就是使用 static 声明的方法, 那么主对象就是这个类.
- 对于一般声明, 那么该方法的主对象就是该类所使用的原型, 也就是 AClass.prototype.
- 第三种情况, 如果是对象声明, 那么方法的主对象就是对象本身.

super.xxx 在语言内核上是一个规范类型中的引用, 它被标记成 Super Reference, 并且为这个引用专门添加了一个 thisValue 域, ECMAScript 约定了优先取 Super 引用中的 thisValue 值, 然后再取函数上下文中的. 这个 thisValue 是在执行引擎发现 super 这个标识符(GetIdentifierReference)的时候, 就从当前环境中取出来并绑定给 super 引用的. 因此:

- super 关键字所代表的父类对象, 是通过当前方法的 `[[HomeObject]]` 的原型链来查找的;
- this 引用是从当前环境所绑定的 this 中抄写过来, 并绑定给 super 的.

```ts
class Parent {
  constructor(id) {
    // <- [[HomeObject]]指向MyClass.prototype}
    this.id = id;
  }

  say() {
    console.log(this);
  }
}

class Child extends Parent {
  constructor() {
    super(""1"");
  }

  bark() {
    super.say(); // this 指向的是 Child
    console.log(""bark"");
  }
}
```

关于 constructor, 如果你在 class 中没声明 constructor, 引擎会帮你插进去.

```ts
// 如果在class声明中有extends XXX
class MyClass extends XXX {
  // 自动插入的缺省构造方法
  constructor(...args) {
    super(...args);
  }
}

// 如果在class声明中没有声明extends
class MyClass {
  // 自动插入的缺省构造方法
  constructor() {}
}
```

## 谈一谈 JavaScript 的对象

JavaScript 中的对象, 在本质上就是关联数组(Associative array, 对应于不可索引的块). 数组在本质上就是索引数组(Index array, 对应于可索引的块).

undefined 用于表达一个值/数据不存在, 也就是**非值(non-value)**, 例如 return 没有返回值, 或变量声明了但没有绑定数据. null 用于表达一个对象不存在, 也就是**非对象**, 例如在原型继承中上溯原型链直到根类, 根类没有父类, 因此它的原型就指向 null.

没有属性表的对象称为 null. 而一个原子级别的对象, 意味着它只有一个属性表, 它不继承自任何其他既有的对象, 因此这个属性表的原型也就指向 null. 原子对象是**对象**的最原始的形态. 它的唯一特点就是**原型为 null**.

任何一个对象 x 都可以通过 `Object.setPrototype(x, null)` 语法变成原子对象, 它可以被理解为关联数组; 并且, 如果它有一个称为 `length` 的属性, 那么它就可以被理解为索引数组.

### 隐式类型转换(拆箱)

如果一个运算无法确定类型, 那么在类型转换前, 它的运算数将被预设为 number. 预设类型在 ECMAScript 称为 PreferredType. 比如下面的 `[] + {}`, 加号无法判别两个操作数的预期类型, 因此将被预设为 number. 而被预设为 number 的直接后果是优先调用 valueOf, 如果调用了 valueOf 还是对象的话, 那么就会再去调用 toString. 当然如果能够被预设为 string 的话, 那么就直接调用 toString 即可.

`[]` 拆箱的话会先执行 `[].valueOf()`, 得到的是 `[]`, 并不是原始值, 就执行 `[].toString()`, 得到的结果是 `''`. `{}` 拆箱会先执行 `{}.valueOf()`, 得到的是 `{}`, 并不是原始值, 于是执行 `toString()`, 得到的结果是 `[object Object]`.

- `[] + {}` 就相当于 `"""" + ""[object Object]""`, 结果就是 `[object Object]`.
- `{} + []` 的话, js 会把开头的 `{}` 理解成代码块, 这是因为有自动分号插入(ASI), 变成了 `{}; + []`, 所以这句话就相当于 `+[]`, 也就是等于 `+""""`, 将空字符串转换为数字类型, 结果就是 0.
- `{} + {}` 的话, 也是和上面一样的道理, 相当于 `+""[object Object]""`, 将字符串转化为数字类型, 结果是 NaN.
- `[] + []` 就相当于 `"""" + """"`, 所以结果还是 `""""`.

下面是一段小的总结:

1. 加号运算中, 不能确定左, 右操作数的类型
2. 等值(`==`)运算中, 不能确定左, 右操作数的类型, JavaScript 认为, 如果左, 右操作数之一为 string, number, bigint 和 symbol 四种基础类型之一, 而另一个操作数是对象类型(x), 那么就需要将对象类型转换成基础类型 `ToPrimitive(x)` 来进行比较. 操作数将尽量转换为数字来进行比较, 即最终结果将等效于: Number(x) == Number(y).
3. `new Date(x)` 中, 如果 x 是一个非 `Date()` 实例的对象, 那么将尝试把 x 转换为基础类型 x1; 如果 x1 是字符串, 尝试从字符串中 parser 出日期值; 否则尝试 `x2 = Number(x1)`, 如果能得到有效的数字值, 则用 x2 来创建日期对象. 与上述拆箱相反, Date 的预设类型优先是 string, 因此会先调用 toString(), 再去调用 valueOf().
","2025-02-02 03:09:07.227208","2025-02-02 03:09:07.227208"
"d74059f8-6ba1-431f-9c1c-e36a0c5a15aa","{HTTP}",0,0,False,"https://edge.yancey.app/beg/bwpaxvae-1649090731409.jpg","[HTTP 系列] 第 4 篇 —— HTTPS","这里是《写给前端工程师的 HTTP 系列》, 记得有位大佬曾经说过: 大厂前端面试对 HTTP 的要求比 CSS 还要高, 由此可见 HTTP 的重要程度不可小视. 本篇是该系列的第 4 篇 —— HTTPS.","- [\[HTTP 系列\] 第 1 篇 —— 从 TCP/UDP 到 DNS 解析](https://www.yanceyleo.com/post/3a9d3d47-9977-4579-a756-4bf5af4a3fd4)
- [\[HTTP 系列\] 第 2 篇 —— HTTP 协议那些事](https://www.yanceyleo.com/post/efd566e9-4ee3-4ee2-8448-628414659480)
- [\[HTTP 系列\] 第 3 篇 —— HTTP 缓存那些事](https://www.yanceyleo.com/post/89731d8e-5510-4094-8962-462b127ed5d0)
- [\[HTTP 系列\] 第 4 篇 —— HTTPS](https://www.yanceyleo.com/post/f976717f-9e40-4849-a73f-86c63c0c45e1)
- [\[HTTP 系列\] 第 5 篇 —— 网络安全](https://www.yanceyleo.com/post/953ccf20-7f3b-4d3f-816e-b6e98b26a4da)
- [\[HTTP 系列\] 第 6 篇 —— 从输入 URL 回车到页面呈现](https://www.yanceyleo.com/post/05daeef2-2caf-4ebe-89f0-2ad9cae286c4)

## HTTPS 安全四要素

由于 HTTP 天生**明文传输**的特点, 整个传输过程完全透明, 任何人都能够在链路中截获, 修改或者伪造请求或者响应报文, 数据不具有可信性. 通常认为, 如果通信过程具备了四个特性, 就可以认为是**安全**的, 这四个特性是: 机密性, 完整性, 身份认证和不可否认.

- 机密性(Secrecy/Confidentiality)是指对数据的**保密**, 只能由可信的人访问, 对其他人是不可见的**秘密**, 简单来说就是不能让不相关的人看到不该看的东西.
- 完整性(Integrity, 也叫一致性)是指数据在传输过程中没有被篡改, 不多也不少, **完完整整**地保持着原状.
- 身份认证(Authentication)是指确认对方的真实身份, 也就是**证明你真的是你**, 保证消息只能发送给可信的人.
- 第四个特性是不可否认(Non-repudiation/Undeniable), 也叫不可抵赖, 意思是不能否认已经发生过的行为, 不能**说话不算数**, **耍赖皮**.

对于 HTTPS, 机密性由对称加密保证, 完整性由摘要算法保证, 身份认证和不可否认由非对称加密保证.

## 什么是 HTTPS

HTTPS 的本质是把 HTTP 下层的传输协议由 TCP/IP 换成了 SSL/TLS, 由**HTTP over TCP/IP**变成了**HTTP over SSL/TLS**, 让 HTTP 运行在了安全的 SSL/TLS 协议上, 收发报文不再使用 Socket API, 而是调用专门的安全接口.

![HTTPS 和 HTTP 对比图](https://edge.yancey.app/beg/mxn6p11p-1647791764263.webp)

SSL 即安全套接层(Secure Sockets Layer), 在 OSI 模型中处于第 5 层(会话层), 由网景公司于 1994 年发明, 有 v2 和 v3 两个版本, 而 v1 因为有严重的缺陷从未公开过. SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议, 于是互联网工程组 IETF 在 1999 年把它改名为 TLS(传输层安全, Transport Layer Security), 正式标准化, 目前应用的最广泛的 TLS 是 1.2.

TLS 由记录协议, 握手协议, 警告协议, 变更密码规范协议, 扩展协议等几个子协议组成, 综合使用了对称加密, 非对称加密, 身份认证等许多密码学前沿技术. 浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信, 这些算法的组合被称为**密码套件**(cipher suite, 也叫加密套件).

下面这个例子中可以看出, 使用的 TLS 是 1.2, 客户端和服务器都支持非常多的密码套件, 密码套件的格式为 **密钥交换算法-签名算法-对称加密算法-分组模式-摘要算法**, 下面这个例子协商选定的是 **ECDHE-RSA-AES256-GCM-SHA384**. 即握手时使用 ECDHE 算法进行密钥交换, 用 RSA 签名和身份认证, 握手后的通信使用 AES 对称算法, 密钥长度 256 位, 分组模式是 GCM, 摘要算法 SHA384 用于消息认证和产生随机数. 

![密码套件](https://edge.yancey.app/beg/inp3i46p-1647792347196.webp)

OpenSSL 是一个著名的开源密码学程序库和工具包, 几乎支持所有公开的加密算法和协议, 已经成为了事实上的标准, 许多应用软件都会使用它作为底层库来实现 TLS 功能, 包括常用的 Web 服务器 Apache, Nginx 等.

## 加密

实现机密性最常用的手段是**加密**(encrypt), 就是把消息用某种方式转换成谁也看不懂的乱码, 只有掌握特殊**钥匙**的人才能再转换出原始文本.

这里的**钥匙**就叫做**密钥**(key), 加密前的消息叫**明文**(plain text/clear text), 加密后的乱码叫**密文**(cipher text), 使用密钥还原明文的过程叫**解密**(decrypt), 是加密的反操作, 加密解密的操作过程就是**加密算法**. 所有的加密算法都是公开的, 任何人都可以去分析研究, 而算法使用的**密钥**则必须保密.

**密钥**就是一长串的数字, 但约定俗成的度量单位是**位**(bit), 而不是**字节**(byte). 比如, 说密钥长度是 128, 就是 16 字节的二进制串, 密钥长度 1024, 就是 128 字节的二进制串.

按照密钥的使用方式, 加密可以分为两大类: **对称加密**和**非对称加密**.

### 对称加密

**对称加密**就是指加密和解密时使用的密钥都是同一个, 是**对称**的. 只要保证了密钥的安全, 明文通过该密钥加密, 也通过该密钥解密, 外人拿到的只是一段被加密的乱码, 那整个通信过程就可以说具有了机密性.

![对称加密](https://edge.yancey.app/beg/g95l573a-1647798875927.webp)

TLS 里有非常多的对称加密算法可供选择, 比如 RC4, DES, 3DES, AES, ChaCha20 等, 但前三种算法都被认为是不安全的, 通常都禁止使用, 目前常用的只有 AES 和 ChaCha20. AES 的意思是**高级加密标准**(Advanced Encryption Standard), 密钥长度可以是 128, 192 或 256. 它是 DES 算法的替代者, 安全强度很高, 性能也很好, 而且有的硬件还会做特殊优化, 所以非常流行, 是应用最广泛的对称加密算法. ChaCha20 是 Google 设计的另一种加密算法, 密钥长度固定为 256 位, 纯软件运行性能要超过 AES, 曾经在移动客户端上比较流行, 但 ARMv8 之后也加入了 AES 硬件优化, 所以现在不再具有明显的优势, 但仍然算得上是一个不错的算法.

对称算法还有一个**分组模式(Block cipher, 又称分块加密或块密码)**的概念, 它将明文分成多个等长的模块(block), 使用确定的算法和对称密钥对每组分别加密解密. 这是因为在实际加密中, 一般加密的数据不会只有几百 bit, 而是几 mb, 甚至几 gb. 这样, 加密过程就是每加密 128bit 接着再加密 128bit, 直至将全部数据加密完. 最新的分组模式被称为 AEAD(Authenticated Encryption with Associated Data), 在加密的同时增加了认证的功能, 常用的是 GCM, CCM 和 Poly1305.

把上面这些组合起来, 就可以得到 TLS 密码套件中定义的对称加密算法. 比如, AES128-GCM, 意思是密钥长度为 128 位的 AES 算法, 使用的分组模式是 GCM; ChaCha20-Poly1305 的意思是 ChaCha20 算法, 使用的分组模式是 Poly1305.

### 非对称加密

对称加密看上去好像完美地实现了机密性, 但其中有一个很大的问题: 如何把密钥安全地传递给对方, 术语叫**密钥交换**. 因为在对称加密算法中只要持有密钥就可以解密. 如果你和网站约定的密钥在传递途中被黑客窃取, 那他就可以在之后随意解密收发的数据, 通信过程也就没有机密性可言了.

因此就出现了非对称加密, 它有两个密钥, 一个叫**公钥**(public key), 一个叫**私钥**(private key). 两个密钥是不同的, **不对称**, 公钥可以公开给任何人使用, 而私钥必须严格保密. 公钥和私钥有个特别的**单向**性, 虽然都可以用来加密解密, 但公钥加密后只能用私钥解密, 反过来, 私钥加密后也只能用公钥解密. 非对称加密可以解决**密钥交换**的问题. 网站秘密保管私钥, 在网上任意分发公钥, 你想要登录网站只要用公钥加密就行了, 密文只能由私钥持有者才能解密. 而黑客因为没有私钥, 所以就无法破解密文.

具体来讲:

- 客户端向服务器发起连接请求，获取服务器公钥和证书。
- 客户端将该证书发送到本地信任中心进行验证，确认证书的合法性。
- 客户端使用服务器公钥，对产生的随机会话密钥进行加密，发送给服务器。
- 服务器收到客户端发送的信息后，使用自己的私钥对信息进行解密，得到会话密钥。
- 服务器使用该会话密钥对数据进行加密和解密。

![非对称加密](https://edge.yancey.app/beg/u35cioie-1647801298144.webp)

非对称加密算法要比对称加密算法复杂的多, 在 TLS 里只有很少的几种, 比如 DH, DSA, RSA, ECC 等.

#### RSA 算法

RSA 可能是其中最著名的一个, 几乎可以说是非对称加密的代名词, 它的安全性基于**整数分解**的数学难题, 使用两个超大素数的乘积作为生成密钥的材料, 想要从公钥推算出私钥是非常困难的. 以前 RSA 密钥推荐使用 1024 位, 但随着计算机运算能力的提高, 现在 1024 已经不安全, 普遍认为至少要 2048 位.

第一步选择两个大质数 p 和 q, p 不等于 q, 计算 N=p \* q;

第二步是根据欧拉函数获取 r, 即 `r = φ(N) = φ(p)φ(q) = (p-1)(q-1)`. 欧拉函数 φ(n) 的定义是**小于或等于 n 的正整数中与 n 互质(如果两个或两个以上的整数的最大公约数是 1, 则称它们为互质)的数的数目**.

举个例子, φ(3 \* 5) = 15, 其互质数有 1, 2, 4, 7, 8, 11, 13, 14. 关于欧拉公式的推导可以看[这篇文章](https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0).

#### ECC 算法

ECC(Elliptic Curve Cryptography)是非对称加密里的**后起之秀**, 它基于**椭圆曲线离散对数**的数学难题, 使用特定的曲线方程和基点生成公钥和私钥, 子算法 ECDHE 用于密钥交换, ECDSA 用于数字签名. 目前比较常用的两个曲线是 P-256(secp256r1, 在 OpenSSL 称为 prime256v1)和 x25519. P-256 是 NIST(美国国家标准技术研究所)和 NSA(美国国家安全局)推荐使用的曲线, 而 x25519 被认为是最安全, 最快速的曲线.

比起 RSA, ECC 在安全强度和性能上都有明显的优势. 160 位的 ECC 相当于 1024 位的 RSA, 而 224 位的 ECC 则相当于 2048 位的 RSA. 因为密钥短, 所以相应的计算量, 消耗的内存和带宽也就少, 加密解密的性能就上去了, 对于现在的移动互联网非常有吸引力.

如下图是两个椭圆曲线 `y^2=x^3+7`, `y^2=x^3-x`.

![ECC 算法](https://edge.yancey.app/beg/cx3u6ed8-1647805889570.jpg)

#### ECDHE 算法

先从 ECDHE 算法的名字说起. ECDHE 就是**短暂 - 椭圆曲线 - 迪菲 - 赫尔曼**算法(ephemeral Elliptic Curve Diffie–Hellman), 里面的关键字是**短暂**, **椭圆曲线**和**迪菲 - 赫尔曼**, 我先来讲**迪菲 - 赫尔曼**, 也就是 DH 算法.

DH 算法是一种非对称加密算法, 只能用于密钥交换, 它的数学基础是**离散对数**(Discrete logarithm). 我们知道指数就是幂运算, 对数是指数的逆运算, 是已知底数和真数(幂结果), 反推出指数. 例如, 如果以 10 作为底数, 那么指数运算是 **y=10<sup>x</sup>**, 对数运算是 **y=logx**, 100 的对数是 2, 2 的对数是 0.301. 对数运算的域是实数, 取值是连续的, 而**离散对数**顾名思义, 取值是不连续的, 数值都是整数. 既然要取整, 那必然要涉及到模运算, 也就是取余数.

假设有模数 17, 底数 5, 而对数是 3, 那么有 **5<sup>3</sup> % 17 = 6**, 因此反过来, 以 5 为底, 17 为模数, 6 的离散对数就是 3. 这里的(17, 5)是离散对数的公共参数, 6 是真数, 3 是对数. 知道了对数, 就可以用幂运算很容易地得到真数, 但反过来, 知道真数却很难推断出对数, 于是就形成了一个**单向函数**.

知道了离散对数, 我们来看 DH 算法, 假设 Alice 和 Bob 约定使用 DH 算法来交换密钥.

Alice 和 Bob 需要首先确定模数和底数作为算法的参数, 这两个参数是公开的, 用 P 和 G 来代称, 简单起见我们还是用 17 和 5(P=17, G=5). 然后 Alice 和 Bob 各自选择一个随机整数作为私钥(必须在 1 和 P - 2 之间), 严格保密. 比如 Alice 选择 a = 10, Bob 选择 b = 5.

有了 DH 的私钥, Alice 和 Bob 再计算幂作为公钥, 也就是 **A = (G<sup>a</sup> % P) = 9, B = (G<sup>b</sup> % P) = 14**, 这里的 A 和 B 完全可以公开, 因为根据离散对数的原理, 从真数反向计算对数 a 和 b 是非常困难的.

交换 DH 公钥之后, Alice 手里有五个数：P=17, G=5, a=10, A=9, B=14, 然后执行一个运算：**(B<sup>a</sup> % P)= 8**.

因为离散对数的幂运算有交换律, **B<sup>a</sup> = (G<sup>b</sup> )<sup>a</sup> = (G<sup>a</sup>)<sup>b</sup> = A<sup>b</sup>**, 所以 Bob 计算 **A<sup>b</sup> % P** 也会得到同样的结果 8, 这个就是 Alice 和 Bob 之间的共享秘密, 可以作为会话密钥使用, 也就是 TLS 里的 Pre-Master.

![DH](https://edge.yancey.app/beg/lsjqrrp5-1649089070342.webp)

整个通信过程中, Alice 和 Bob 公开了 4 个信息：P, G, A, B, 其中 P, G 是算法的参数, A 和 B 是公钥, 而 a, b 是各自秘密保管的私钥, 无法获取, 所以黑客只能从已知的 P, G, A, B 下手, 计算 9 或 14 的离散对数. 由离散对数的性质就可以知道, 如果 P 非常大, 那么他很难在短时间里破解出私钥 a, b, 所以 Alice 和 Bob 的通信是安全的.

DH 算法有两种实现形式, 一种是已经被废弃的 DH 算法, 也叫 static DH 算法, 另一种是现在常用的 DHE 算法(有时候也叫 EDH). static DH 交换密钥时就只有客户端的公钥会变, 而服务器公钥不变, 在长期通信时就增加了被破解的风险. 而 DHE 算法的关键在于**E**表示的临时性上(ephemeral), 每次交换密钥时双方的私钥都是随机选择, 临时生成的, 用完就扔掉, 下次通信不会再使用, 相当于**一次一密**, 具有**前向安全**.

ECDHE 算法, 就是把 DHE 算法里整数域的离散对数, 替换成了椭圆曲线上的离散对数. 也就是上面 ECC 算法那张图, 因为椭圆曲线离散对数的计算难度比普通的离散对数更大, 那破解起来就更加困难了.

### 混合加密

虽然非对称加密能解决密钥交换的安全问题, 但由于它们都是基于复杂的数学难题, 运算速度很慢, 而对称加密使用的是位运算, 相对就很快. 即使是 ECC 也要比 AES 差上好几个数量级. 这样虽然保证了安全, 但无法保证速度. 因此, 在实际应用中, TLS 里使用的混合加密方式来保障机密性.

即在通信刚开始的时候使用非对称算法, 比如 RSA, ECDHE, 首先解决密钥交换的问题.

然后用随机数产生对称算法使用的**会话密钥**(session key), 再用公钥加密. 因为会话密钥很短, 通常只有 16 字节或 32 字节, 所以慢一点也无所谓.

对方拿到密文后用私钥解密, 取出会话密钥. 这样, 双方就实现了对称密钥的安全交换, 后续就不再使用非对称加密, 全都使用对称加密. 这样混合加密就解决了对称加密算法的密钥交换问题, 而且安全和性能兼顾, 完美地实现了机密性.

![混合加密示意图](https://edge.yancey.app/beg/w7drrjqk-1647806315377.webp)

## 摘要算法

混合加密保障了数据的机密性, 但仍然无法保障完整性, 因为虽然黑客无法破解机密数据, 但如果给加密后的数据添油加醋, 甚至篡改, 那么最终接收到的数据仍是残缺的. 因此需要一种机制来保障数据的完整性.

实现完整性的手段主要是摘要算法(Digest Algorithm), 也就是常说的散列函数, 哈希函数(Hash Function). 它能够把任意长度的数据**压缩**成固定长度, 而且独一无二的**摘要**字符串, 就好像是给这段数据生成了一个数字**指纹**. 摘要算法实际上是把数据从一个**大空间**映射到了**小空间**, 所以就存在**冲突**(collision, 也叫碰撞)的可能性, 即有两份或多份不同的原文对应相同的摘要. 好的摘要算法必须能够**抵抗冲突**, 让这种可能性尽量地小.

常见的摘要算法有 MD5(Message-Digest 5), SHA-1(Secure Hash Algorithm 1), 能够生成 16 字节和 20 字节长度的数字摘要. 但这两个算法的安全强度比较低, 不够安全, 在 TLS 里已经被禁止使用了. 目前 TLS 推荐使用的是 SHA-2. SHA-2 实际上是一系列摘要算法的统称, 总共有 6 种, 常用的有 SHA224, SHA256, SHA384, 分别能够生成 28 字节, 32 字节, 48 字节的摘要.

因为摘要算法对输入具有**单向性**和**雪崩效应**, 输入的微小不同会导致输出的剧烈变化, 所以也被 TLS 用来生成伪随机数(PRF, pseudo random function).

摘要算法保证了**数字摘要**和原文是完全等价的. 所以, 我们只要在原文后附上它的摘要, 就能够保证数据的完整性. 比如, 你发了条消息: **转账 1000 元**, 然后再加上一个 SHA-2 的摘要. 网站收到后也计算一下消息的摘要, 把这两份**指纹**做个对比, 如果一致, 就说明消息是完整可信的, 没有被修改.

![摘要算法](https://edge.yancey.app/beg/ywqao5x7-1647883741961.webp)

通过使用摘要算法来保障数据的完整性, 但如果是明文传输, 数据仍然是会被泄露的, 因此完整性必须要建立在机密性之上, 在混合加密系统里用会话密钥加密消息和摘要, 这样黑客无法得知明文, 也就没有办法动手脚了. 这里有个术语, 叫哈希消息认证码(HMAC). 它通过特别计算方式之后产生的消息认证码(MAC), 使用密码散列函数, 同时结合一个加密密钥. 它可以用来保证资料的完整性, 同时可以用来作某个消息的身份验证. 具体的算法可参考 [HMAC](https://zh.wikipedia.org/wiki/HMAC).

![哈希消息认证码](https://edge.yancey.app/beg/7eflrll0-1647884511734.webp)

## 数字签名

似乎加密算法结合摘要算法已经保障了数据的机密性和完整性, 但这里有个漏洞. 上面说的都是黑客可以伪装成网站来窃取你的信息, 但反过来, 黑客也可以冒充你向网站发送支付, 转账等消息, 网站没有办法确认你的身份, 钱可能就这么被偷走了. 现实生活中我们通过签名或印章, 来证明**我是我**. 这种只能由本人持有, 而其他任何人都不会有的便是**私钥**.

数字签名的原理其实很简单, 就是把公钥私钥的用法反过来, 之前是公钥加密, 私钥解密, 现在是私钥加密, 公钥解密. 但又因为非对称加密效率太低, 所以私钥只加密原文的摘要, 这样运算量就小的多, 而且得到的数字签名也很小, 方便保管和传输. 签名和公钥一样完全公开, 任何人都可以获取. 但这个签名只有用私钥对应的公钥才能解开, 拿到摘要后, 再比对原文验证完整性, 就可以像签署文件一样证明消息确实是你发的(这个工程的专业术语叫做**验签**). 这种使用私钥加密摘要的策略, 就能够实现**数字签名**, 同时实现**身份认证**和**不可否认**.

![数字签名过程](https://edge.yancey.app/beg/xrm7ssui-1647948635651.webp)

只要你和网站互相交换公钥, 就可以用**签名**和**验签**来确认消息的真实性, 因为私钥保密, 黑客不能伪造签名, 就能够保证通信双方的身份. 比如, 你用自己的私钥签名一个消息**我是小明**. 网站收到后用你的公钥验签, 确认身份没问题, 于是也用它的私钥签名消息**我是某宝**. 你收到后再用它的公钥验一下, 也没问题, 这样你和网站就都知道对方不是假冒的, 后面就可以用混合加密进行安全通信了.

## 数字证书和 CA

上面说道**只要你和网站互相交换公钥, 就可以用**签名**和**验签**来确认消息的真实性**. 不知道你是否有疑惑, 因为公钥是公开的, 谁都可以发布公钥, 我们还缺少防止黑客伪造公钥的手段, 也就是说, 怎么来判断这个公钥就是你或者某宝的公钥呢? 这就需要 CA(Certificate Authority, 证书认证机构)来帮助我们. 它具有极高的可信度, 由它来给各个公钥签名, 用自身的信誉来保证公钥无法伪造, 是可信的.

CA 对公钥的签名认证也是有格式的, 不是简单地把公钥绑定在持有者身份上就完事了, 还要包含序列号, 用途, 颁发者, 有效时间等等, 把这些打成一个包再签名, 完整地证明公钥关联的各种信息, 形成**数字证书**(Certificate).

![CA 证书字段](https://edge.yancey.app/beg/fzhzzodh-1648388697871.jpg)

证书根据等级分为 DV, OV, EV 三种:

| 类型/区别 | 审核内容                             | 颁发周期      | 使用年限    | 浏览器显示形式                         | 适用对象                                                 | 价格                                                |
| --------- | ------------------------------------ | ------------- | ----------- | -------------------------------------- | -------------------------------------------------------- | --------------------------------------------------- |
| DV        | 域名所有权                           | 几分钟-几小时 | 1-2 年      | https + 小锁标志                       | 中小型企业网站, 电子商务网站, 电子邮局服务器, 个人网站等 | 免费                                                |
| OV        | 域名所有权; 企业信息;                | 2-3 个工作日  | 1-2 年      | https + 小锁标志                       | 企业网站, 电子商务网站, 证券, 金融机构等                 | 2,982.40 元/年 <span style=""color: red"">\*</span> |
| EV        | 域名所有权; 企业信息; 第三方数据核查 | 5-7 个工作日  | 一 1-2 年年 | https + 小锁标志 + 绿色网址 + 企业名称 | 银行, 保险, 金融机构, 电子商务网站, 大型企业等           | 6,400 元/年 <span style=""color: red"">\*</span>    |

> 上述价格节选自阿里云单域名每年的价格, 时间为 2022/03/23, 具体价格以实际购买时的价格为准.

不过, CA 怎么证明自己呢? 这还是信任链的问题. 小一点的 CA 可以让大 CA 签名认证, 但链条的最后, 也就是 Root CA, 就只能自己证明自己了, 这个就叫**自签名证书**(Self-Signed Certificate)或者**根证书**(Root Certificate). 你必须相信, 否则整个证书信任链就走不下去了.

![证书自证](https://edge.yancey.app/beg/4azofok4-1647997260175.webp)

有了这个证书体系, 操作系统和浏览器都内置了各大 CA 的根证书, 上网的时候只要服务器发过来它的证书, 就可以验证证书里的签名, 顺着证书链(Certificate Chain)一层层地验证, 直到找到根证书, 就能够确定证书是可信的, 从而里面的公钥也是可信的.

### 证书体系的弱点

证书体系(PKI, Public Key Infrastructure)虽然是目前整个网络世界的安全基础设施, 但绝对的安全是不存在的, 它也有弱点, 还是关键的**信任**二字. 如果 CA 失误或者被欺骗, 签发了错误的证书, 虽然证书是真的, 可它代表的网站却是假的. 还有一种更危险的情况, CA 被黑客攻陷, 或者 CA 有恶意, 因为它(即根证书)是信任的源头, 整个信任链里的所有证书也就都不可信了.

针对第一种, 开发出了 CRL(证书吊销列表, Certificate revocation list)和 OCSP(在线证书状态协议, Online Certificate Status Protocol), 及时废止有问题的证书. 对于第二种, 因为涉及的证书太多, 就只能操作系统或者浏览器从根上**下狠手**了, 撤销对 CA 的信任, 列入**黑名单**, 这样它颁发的所有证书就都会被认为是不安全的.

## ECDHE 详细握手过程

在 HTTP 协议里, 通过三次握手建立连接后, 浏览器会立即发送请求报文. 但现在是 HTTPS 协议, 它需要再用另外一个**握手**过程, 在 TCP 上建立安全连接, 之后才是收发 HTTP 报文. 在讲 TLS 握手之前, 先简单介绍一下 TLS 协议的组成.

TLS 协议有多个模块组成, 比较常用的有记录协议, 警报协议, 握手协议, 变更密码规范协议等.

**记录协议**(Record Protocol)规定了 TLS 收发数据的基本单位: 记录(record). 它有点像是 TCP 里的 segment, 所有的其他子协议都需要通过记录协议发出. 但多个记录数据可以在一个 TCP 包里一次性发出, 也并不需要像 TCP 那样返回 ACK.

**警报协议**(Alert Protocol)的职责是向对方发出警报信息, 有点像是 HTTP 协议里的状态码. 比如, protocol_version 就是不支持旧版本, bad_certificate 就是证书有问题, 收到警报后另一方可以选择继续, 也可以立即终止连接.

**握手协议**(Handshake Protocol)是 TLS 里最复杂的子协议, 要比 TCP 的 SYN/ACK 复杂的多, 浏览器和服务器会在握手过程中协商 TLS 版本号, 随机数, 密码套件等信息, 然后交换证书和密钥参数, 最终双方协商得到会话密钥, 用于后续的混合加密系统.

**变更密码规范协议**(Change Cipher Spec Protocol), 它非常简单, 就是一个**通知**, 告诉对方, 后续的数据都将使用加密保护. 那么反过来, 在它之前, 数据都是明文的.

下面的这张图简要地描述了 TLS 的握手过程, 其中每一个**框**都是一个记录, 多个记录组合成一个 TCP 包发送. 所以, 最多经过两次消息往返(4 个消息)就可以完成握手, 然后就可以在安全的通信环境里发送 HTTP 报文, 实现 HTTPS 协议.

![TLS 协议](https://edge.yancey.app/beg/2gloicuc-1647999700009.webp)

短暂椭圆曲线迪菲 - 赫尔曼密钥交换(Elliptic Curve Diffie - Hellman key exchange, 缩写为 ECDH), 是一种匿名的密钥合意协议(Key-agreement protocol), 这是迪菲 - 赫尔曼密钥交换的变种, 采用椭圆曲线密码学来加强性能与安全性. 在这个协定下, 双方利用由椭圆曲线密码学建立的公钥与私钥对, 在一个不安全的通道中, 建立起安全的共有加密资料. 临时 ECDH(ECDH Ephemeral, ECDHE)能够提供前向安全性.

![ECDHE 详细握手过程](https://edge.yancey.app/beg/jbf7vavm-1648374811554.webp)

### 阶段 1: Client Hello

在 TCP 建立连接之后, 浏览器会首先发一个 **Client Hello** 消息, 也就是跟服务器**打招呼**. 里面有客户端的版本号, 支持的密码套件, 还有一个**随机数**(Client Random), 用于后续生成会话密钥, 具体所有参数在下面. **Client Hello** 的目的就是: **我这边有这些这些信息, 你看看哪些是能用的, 关键的随机数可得留着.**

- 支持的 SSL 版本
- 客户端生成的一个用于生成主密钥(master key)的 32 字节的随机数(主密钥由客户端和服务端的随机数共同生成)
- 会话 ID
- 加密套件
  - 加密算法
  - 密钥交换算法
  - MAC 算法
  - 加密方式(流, 分组)
- 压缩算法(由于压缩会带来安全漏洞(CRIME 攻击, Compression Ratio Info-leak Made Easy), 所以压缩算法这里一般写死成 null, 后面 TLS 1.3 明令禁止使用压缩. 简单说一下攻击原理: 它依赖于攻击者能观察浏览器发送的密文的大小, 并在同时诱导浏览器发起多个精心设计的到目标网站的连接. 攻击者会观察已压缩请求载荷的大小, 其中包括两个浏览器只发送到目标网站的私密 Cookie, 以及攻击者创建的变量内容. 当压缩内容的大小降低时, 攻击者可以推断注入内容的某些部分与源内容的某些部分匹配, 其中包括攻击者想要发掘的私密内容. 使用分治法技术可以用较小的尝试次数解读真正秘密的内容, 需要恢复的字节数会大幅降低)

![Client Hello](https://edge.yancey.app/beg/to2ed2xt-1648319923179.jpg)

下面是客户端支持的所有加密套件, 后面服务端可以选择其中的一个作为此次通信使用的加密套件算法.

![加密套件](https://edge.yancey.app/beg/6ezavr4h-1648320849344.jpg)

### 阶段 2: Server Hello

服务器收到 **Client Hello** 后, 会返回一个 **Server Hello** 消息. 把版本号确认一下, 也给出一个**随机数**(Server Random), 需要客户端也留着, 然后从客户端的列表里选一个作为本次通信使用的密码套件.

- 服务端采纳的本次通讯的 SSL 版本
- 服务端生成的一个用于生成主密钥(master key)的 32 字节的随机数(主密钥由客户端和服务端的随机数共同生成), 它是由随机种子 gmt_unix_time 使用伪随机数函数(PRF)生成的 32 字节随机数.
- 会话 ID: 如果没有建立过连接则对应值为空, 不为空则说明之前建立过对应的连接并缓存.
- 服务端采纳的用于本次通讯的加密套件(从客户端发送的加密套件列表中选出了一个, 下面的例子选出的加密组合是 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, ECDHE_RSA 作为密钥交换算法)
  - 加密算法
  - 密钥交换算法
  - MAC 算法
  - 加密方式(流, 分组)
- 压缩算法(如果支持压缩的话)

![Server Hello](https://edge.yancey.app/beg/rtnrb58y-1648375017814.jpg)

### 阶段 2: Server Certificate

SSL 服务器将**携带自己公钥信息的数字证书**和到根 CA 整个链发给客户端通过 Certificate 消息发送给 SSL 客户端(整个公钥文件都发送过去), 客户端使用这个公钥完成以下任务:

- 客户端可以使用该公钥来验证服务端的身份, 因为只有服务端有对应的私钥能解密它的公钥加密的数据;
- 用于对 **premaster secret** 进行加密, 这个 **premaster secret** 就是用客户端和服务端生成的 Random 随机数来生成的, 客户端用服务端的公钥对其进行了加密后发送给服务端.

下面这个例子, 我们访问的是百度, 它会给我们从百度的证书到根 CA 证书.

![Server Certificate Chain](https://edge.yancey.app/beg/zzats6wk-1648385767041.jpg)

![CA Chain](https://edge.yancey.app/beg/ityhtt6n-1648388509073.jpg)

### 阶段 2: Server Key Exchange

下一步则是密钥交换阶段, Server Key Exchange 消息中包含有密钥交换算法所需要的额外参数, 它是一个可选步骤, 之所以说是可选步骤, 是因为只有在下列场景下这个步骤才会发生:

- 协商采用了 RSA 加密, 但是服务端的证书没有提供 RSA 公钥
- 协商采用了 DH 加密, 但是服务端的证书没有提供 DH 参数
- 协商采用了 fortezza_kea 加密, 但是服务端的证书没有提供参数

总结来说, **Server Key Exchange**这个步骤是对上一步 **Certificate** 的一个补充, 为了让整个 SSL 握手过程能正常进行.

![Server Key Exchange](https://edge.yancey.app/beg/4nq5zant-1648392843770.png)

### 阶段 2: Server Hello Done

SSL 服务器发送 Server Hello Done 消息, 通知 SSL 客户端版本和加密套件协商结束. 这样第一个消息往返就结束了(两个 TCP 包), 结果是客户端和服务器通过明文共享了三个信息: Client Random, Server Random 和 Server Params.

![Server Hello Done](https://edge.yancey.app/beg/4x6gg567-1648392989481.png)

### 阶段 3: Client Key Exchange

客户端这时也拿到了服务器的证书, 开始走证书链逐级验证, 确认证书的真实性, 再用证书公钥验证签名, 就确认了服务器的身份. 利用证书中的公钥加密 SSL 客户端随机生成的 **premaster secret**(通过之前客户端, 服务端分别生成的随机数生成的), 并通过 Client Key Exchange 消息发送给 SSL 服务器. 注意, 这一步完成后, 客户端和服务端都已经保存了**主密钥**(之所以这里叫预备主密钥, 是因为还没有投入使用). 这个**主密钥**会用于之后的 SSL 通信数据的加密. master secret 的伪代码算法如下:

```ts
master_secret = PRF(
  pre_master_secret,
  ""master secret"",
  ClientHello.random + ServerHello.random
);
```

![Client Key Exchange](https://edge.yancey.app/beg/32ujnxab-1648393270773.png)

### 阶段 3: Change Cipher Spec

客户端发送 **Change Cipher Spec**(密钥改变协议), 通知 SSL 服务器后续报文将采用协商好的**主密钥**和加密套件进行加密和 MAC 计算, 即以后咱们都用这个密钥进行通信数据的加密吧. 然后客户端会发送一个 Finished, 表示结束了.

![Change Cipher Spec](https://edge.yancey.app/beg/rc7r05kr-1648393413671.png)

### 阶段 3: Finished

SSL 客户端计算已交互的握手消息(除 Change Cipher Spec 消息外所有已交互的消息)的 Hash 值, 利用协商好的密钥和加密套件处理 Hash 值(计算并添加 MAC 值, 加密等), 并通过 Finished 消息发送给 SSL 服务器. SSL 服务器利用同样的方法计算已交互的握手消息的 Hash 值, 并与 Finished 消息的解密结果比较, 如果二者相同, 且 MAC 值验证成功, 则证明密钥和加密套件协商成功. 意思就是告诉服务器: 后面都改用对称算法加密通信了, 用的就是打招呼时说的 AES, 加密对不对还得你测一下.

### 阶段 4: 客户端发送请求

客户端使用主密钥加密数据, 发送给服务端.

![加密后的数据](https://edge.yancey.app/beg/8blqnzab-1648393278877.png)

### 阶段 4: Change Cipher Spec

同样地, SSL 服务器发送 Change Cipher Spec 消息, 通知 SSL 客户端后续报文将采用协商好的密钥和加密套件进行加密和 MAC 计算.

### 阶段 4: Finished

SSL 服务器计算已交互的握手消息的 Hash 值, 利用协商好的密钥和加密套件处理 Hash 值(计算并添加 MAC 值, 加密等), 并通过 Finished 消息发送给 SSL 客户端. SSL 客户端利用同样的方法计算已交互的握手消息的 Hash 值, 并与 Finished 消息的解密结果比较, 如果二者相同, 且 MAC 值验证成功, 则证明密钥和加密套件协商成功.

SSL 客户端接收到 SSL 服务器发送的 Finished 消息后, 如果解密成功, 则可以判断 SSL 服务器是数字证书的拥有者, 即 SSL 服务器身份验证成功, 因为只有拥有私钥的 SSL 服务器才能从 Client Key Exchange 消息中解密得到 premaster secret, 从而间接地实现了 SSL 客户端对 SSL 服务器的身份验证.

### 阶段 4: 服务端发送响应

最后就是服务端使用协商好的加密算法加密响应数据, 返回给客户端.

### 双向认证

上面说的是**单向认证**握手过程, 只认证了服务器的身份, 而没有认证客户端的身份. 这是因为通常单向认证通过后已经建立了安全通信, 用账号, 密码等简单的手段就能够确认用户的真实身份. 但为了防止账号, 密码被盗, 有的时候(比如网上银行)还会使用 U 盾给用户颁发客户端证书, 实现**双向认证**, 这样会更加安全. 双向认证的流程也没有太多变化, 只是在**Server Hello Done**之后, **Client Key Exchange**之前, 客户端要发送**Client Certificate**消息, 服务器收到后也把证书链走一遍, 验证客户端的身份.

我记录了一份 [gist](https://gist.github.com/YanceyOfficial/6b0bd5579f7fb244044541b7e38e6acc), 可以看到双向认证的流程.

## 谈一谈 TLS 1.3

上面说的是都是基于 TLS 1.2, 它发布于 2008 年, 从现在来看在很多方面已经力不从心了. 因此经过近 30 个草案的反复打磨, TLS 1.3 于 2018 年发布, 再次确立了信息安全领域的新标准. TLS 1.3 的三个目标是**兼容**, **安全**与**性能**.

![TLS 1.3](https://edge.yancey.app/beg/3znd82t2-1648887969787.jpg)

### 兼容 1.1 和 1.2

由于 1.1, 1.2 等协议已经出现了很多年, 屎山已经改不动了, 因此必须要求 TLS 1.3 进行**兼容**. 它采用了**扩展协议(Extension Protocol)**的手段, 通过在记录末尾添加一系列的**扩展字段**来增加新的功能, 老版本的 TLS 不认识它可以直接忽略, 这就实现了**后向兼容**.

在记录头的 Version 字段被兼容性**固定**的情况下, 只要是 TLS1.3 协议, 握手的 **Hello** 消息后面就必须有 **supported_versions** 扩展, 它标记了 TLS 的版本号, 使用它就能区分新旧协议.

```shell
Handshake Protocol: Client Hello
    Version: TLS 1.2 (0x0303)
    Extension: supported_versions (len=11)
        Supported Version: TLS 1.3 (0x0304)
        Supported Version: TLS 1.2 (0x0303)
```

### 更高的安全性

TLS 1.2 在十来年的应用中获得了许多宝贵的经验, 陆续发现了很多的漏洞和加密算法的弱点, 所以 TLS 1.3 就在协议里修补了这些不安全因素. 比如:

- 伪随机数函数由 PRF 升级为 HKDF(HMAC-based Extract-and-Expand Key Derivation Function);
- 明确禁止在记录协议里使用压缩;
- 废除了 RC4, DES 对称加密算法;
- 废除了 ECB, CBC 等传统分组模式;
- 废除了 MD5, SHA1, SHA-224 摘要算法;
- 废除了 RSA, DH 密钥交换算法和许多命名曲线.

这样 TLS1.3 里只保留了 AES, ChaCha20 对称加密算法, 分组模式只能用 AEAD 的 GCM, CCM 和 Poly1305, 摘要算法只能用 SHA256, SHA384, 密钥交换算法只有 ECDHE 和 DHE, 椭圆曲线也被**砍**到只剩 P-256 和 x25519 等 5 种. 基于此, TLS 1.3 的密码套件数量大幅减少:

![TLS 1.3 的密码套件](https://edge.yancey.app/beg/wgscs3uv-1648885988928.webp)

这里还要特别说一下废除 RSA 和 DH 密钥交换算法的原因. 上面我们介绍到 ECDHE, 其实还有一种使用 RSA 来做密钥交换, 但是浏览器默认会使用 ECDHE 而不是 RSA 做密钥交换, 这是因为它不具有**前向安全**(Forward Secrecy). 这是因为 RSA 服务端的私钥是**固定**的, 一旦私钥被破解了, 加密就不安全了. 而 ECDHE 算法在每次握手时都会生成一对临时的公钥和私钥, 即便是某次被破解了, 也只会影响本次通信, 而不会影响后续的. 所以现在主流的服务器和浏览器在握手阶段都已经不再使用 RSA, 改用 ECDHE, 而 TLS1.3 在协议里明确废除 RSA 和 DH 则在标准层面保证了**前向安全**.

此外, TLS 1.3 还做了防恶意降级机制, 如果发现中间人恶意将版本降级到 1.2, 服务器的最后八个字节会被设置为 44 4F 57 4E 47 52 44 01, 即 DOWNGRD01, 支持 TLS 1.3 的客户端就会识别到, 然后发出报警.

### 性能的提升

HTTPS 建立连接时除了要做 TCP 握手, 还要做 TLS 握手, 在 TLS 1.2 中会多花两个消息往返(2-RTT), 可能导致几十毫秒甚至上百毫秒的延迟, 在移动网络中延迟还会更严重. 而 TLS 1.3 因为密码套件大幅度简化(只有 5 个), 也就没有必要再像以前那样走复杂的协商流程了.

此外, TLS1.3 压缩了以前的 **Hello** 协商过程, 删除了 **Key Exchange** 消息, 把握手时间减少到了 **1-RTT**, 效率提高了一倍. 具体的做法还是利用了**扩展**. 客户端在 **Client Hello** 消息里直接用 **supported_groups** 带上支持的曲线, 比如 P-256, x25519, 用**key_share**带上曲线对应的客户端公钥参数, 用 **signature_algorithms** 带上签名算法. 服务器收到后在这些扩展里选定一个曲线和参数, 再用 **key_share** 扩展返回服务器这边的公钥参数, 就实现了双方的密钥交换, 后面的流程就和 TLS 1.2 基本一样了. 如下是 TLS 1.3 握手的概略图.

![TLS 1.3 握手的概略图](https://edge.yancey.app/beg/rgclesir-1648887706093.webp)

除了标准的 **1-RTT** 握手, TLS1.3 还引入了 **0-RTT** 握手, 用 **pre_shared_key** 和 **early_data** 扩展, 在 TCP 连接后立即就建立安全连接发送加密消息.

### TLS 1.3 握手分析

![TLS 1.3 握手分析](https://edge.yancey.app/beg/gitkz6uh-1648887627101.webp)

在 Client Hello 阶段, 除了跟 TLS 1.2 相同的部分, 还增加了 **supported_versions**(支持的版本), **supported_groups**(支持的曲线), **key_share**(曲线对应的参数) 等字段. 具体可以看 [](https://halfrost.com/tls_1-3_introduction/#toc-7)

```shell
Handshake Protocol: Client Hello
    Version: TLS 1.2 (0x0303)
    Random: cebeb6c05403654d66c2329...
    Cipher Suites (18 suites)
        Cipher Suite: TLS_AES_128_GCM_SHA256 (0x1301)
        Cipher Suite: TLS_CHACHA20_POLY1305_SHA256 (0x1303)
        Cipher Suite: TLS_AES_256_GCM_SHA384 (0x1302)
    Extension: supported_versions (len=9)
        Supported Version: TLS 1.3 (0x0304)
        Supported Version: TLS 1.2 (0x0303)
    Extension: supported_groups (len=14)
        Supported Groups (6 groups)
            Supported Group: x25519 (0x001d)
            Supported Group: secp256r1 (0x0017)
    Extension: key_share (len=107)
        Key Share extension
            Client Key Share Length: 105
            Key Share Entry: Group: x25519
            Key Share Entry: Group: secp256r1
```

Server Hello 阶段, 如果确认使用 TLS 1.3, **supported_versions** 会标明使用的是 TLS 1.3, 然后在 **key_share** 扩展带上曲线和对应的公钥参数.

```shell
Handshake Protocol: Server Hello
    Version: TLS 1.2 (0x0303)
    Random: 12d2bce6568b063d3dee2...
    Cipher Suite: TLS_AES_128_GCM_SHA256 (0x1301)
    Extension: supported_versions (len=2)
        Supported Version: TLS 1.3 (0x0304)
    Extension: key_share (len=36)
        Key Share extension
            Key Share Entry: Group: x25519, Key Exchange length: 32
```

这时只交换了两条消息, 客户端和服务器就拿到了四个共享信息: **Client Random** 和 **Server Random**, **Client Params** 和 **Server Params**, 两边就可以各自用 ECDHE 算出 **Pre-Master**, 再用 HKDF 生成主密钥 **Master Secret**, 效率比 TLS 1.2 提高了一大截, 因为不需要在 cipher suite 协商了.

在算出主密钥后, 服务器立刻发出 **Change Cipher Spec** 消息, 比 TLS 1.2 提早进入加密通信, 后面的证书等就都是加密的了, 减少了握手时的明文信息泄露.

这里 TLS1.3 还有一个安全强化措施, 多了个 **Certificate Verify** 消息, 用服务器的私钥把前面的曲线, 套件, 参数等握手数据加了签名, 作用和 **Finished** 消息差不多. 但由于是私钥签名, 所以强化了身份认证和和防窜改.

这两个 **Hello** 消息之后, 客户端验证服务器证书, 再发 **Finished** 消息, 就正式完成了握手, 开始收发 HTTP 报文.

## HTTPS 的优化

我们知道, HTTPS 连接大致上可以划分为两个部分, 第一个是建立连接时的非对称加密握手, 第二个是握手后的对称加密报文传输. 由于目前流行的 AES, ChaCha20 性能都很好, 还有硬件优化, 报文传输的性能损耗可以说是非常地小, 小到几乎可以忽略不计了. 所以, 通常所说的**HTTPS 连接慢**指的就是**刚开始建立连接的那段时间**.

在 TCP 建连之后, 正式数据传输之前, HTTPS 比 HTTP 增加了一个 TLS 握手的步骤, 这个步骤最长可以花费两个消息往返, 也就是 2-RTT. 而且在握手消息的网络耗时之外, 还会有其他的一些**隐形**消耗, 比如:

- 产生用于密钥交换的临时公私钥对(ECDHE);
- 验证证书时访问 CA 获取 CRL 或者 OCSP;
- 非对称加密解密处理**Pre-Master**.

![TLS 握手的耗时之处](https://edge.yancey.app/beg/f3ze23e9-1648991828388.webp)

在最差的情况下, 也就是不做任何的优化措施, HTTPS 建立连接可能会比 HTTP 慢上几百毫秒甚至几秒, 这其中既有网络耗时, 也有计算耗时. 现在已经有了很多行之有效的 HTTPS 优化手段, 运用得好可以把连接的额外耗时降低到几十毫秒甚至是**零**.

### 硬件加速

HTTPS 连接是计算密集型, 首先, 你可以选择更快的 CPU, 最好还内建 AES 优化, 这样即可以加速握手, 也可以加速传输.

其次, 你可以选择 **SSL 加速卡**, 加解密时调用它的 API, 让专门的硬件来做非对称加解密, 分担 CPU 的计算压力. 不过 **SSL 加速卡**也有一些缺点, 毕竟是固件, 就无法得到实时的升级.

所以, 就出现了第三种硬件加速方式: **SSL 加速服务器**, 用专门的服务器集群来彻底**卸载** TLS 握手时的加密解密计算, 性能自然要比单纯的**加速卡**要强大的多.

### 软件加速

软件升级不必多说, 升级下 Nginx, OpenSSL 的版本, 一般都会有提升. 当然 TLS 协议最好就是升级成 TLS 1.3, 如有历史遗留问题暂时只能用 TLS 1.2, 那么握手时使用的密钥交换协议应当尽量选用椭圆曲线的 ECDHE 算法. 它不仅运算速度快, 安全性高, 还支持 **False Start(在 TLS 协商第二阶段, 浏览器发送 ChangeCipherSpec 和 Finished 后, 立即发送加密的应用层数据, 而无需等待服务器端的确认)**, 能够把握手的消息往返由 2-RTT 减少到 1-RTT, 达到与 TLS 1.3 类似的效果. 另外, 椭圆曲线也要选择高性能的曲线, 最好是 x25519, 次优选择是 P-256. 对称加密算法方面, 也可以选用 **AES_128_GCM**, 它能比 **AES_256_GCM** 略快一点点.

在 Nginx 里可以用 **ssl_ciphers**, **ssl_ecdh_curve** 等指令配置服务器使用的密码套件和椭圆曲线, 把优先使用的放在前面, 例如:

```shell
ssl_ciphers     TLS13-AES-256-GCM-SHA384:TLS13-CHACHA20-POLY1305-SHA256:EECDH+CHACHA20;
ssl_ecdh_curve  X25519:P-256;
```

### 证书优化

除了密钥交换, 握手过程中的证书验证也是一个比较耗时的操作, 服务器需要把自己的证书链全发给客户端, 然后客户端接收后再逐一验证. 这里就有两个优化点, 一个是**证书传输**, 一个是**证书验证**.

首先, 服务器的证书应该选择椭圆曲线(ECDSA)证书而不是 RSA 证书, 因为 224 位的 ECC 相当于 2048 位的 RSA, 这即能够节约带宽也能减少客户端的运算量.

客户端的证书验证其实是个很复杂的操作, 除了要公钥解密验证多个证书签名外, 因为证书还有可能会被撤销失效, 客户端有时还会再去访问 CA, 下载 CRL(Certificate revocation list, 证书吊销列表, 由 CA 定期发布, 里面是所有被撤销信任的证书序号, 查询这个列表就可以知道证书是否有效) 或者 OCSP(在线证书状态协议, Online Certificate Status Protocol), 这又会产生 DNS 查询, 建立连接, 收发数据等一系列网络通信, 增加好几个 RTT.

由于 CRL 因为是**定期**发布, 就有**时间窗口**的安全隐患, 而且随着吊销证书的增多, 列表会越来越大, 一个 CRL 经常会上 MB. 所以每次下载这么一个大的 map 实在性能低下. 因此现在已经不使用 CRL 了, 都使用 OCSP, CA 发送查询请求, 让 CA 返回证书的有效状态. 但 OCSP 也要多出一次网络请求的消耗, 而且还依赖于 CA 服务器, 如果 CA 服务器很忙, 那响应延迟也是等不起的.

于是就有了 **OCSP Stapling**, 它可以让服务器预先访问 CA 获取 OCSP 响应, 然后在握手时随着证书一起发给客户端, 免去了客户端连接 CA 服务器查询的时间, 有种 prefetch 內味了.

### 会话复用与会话票证

TLS 握手的重点是算出主密钥 **Master Secret** , 而主密钥每次连接都要重新计算, 未免有点太浪费了, 因此, 复用主密钥缓存的做法就叫**会话复用**(TLS session resumption), 和 HTTP Cache 一样, 也是提高 HTTPS 性能的**大杀器**, 被浏览器和服务器广泛应用.

会话复用分两种, 第一种叫 **Session ID**, 就是客户端和服务器首次连接后各自保存一个会话的 ID 号, 内存里存储主密钥和其他相关的信息. 当客户端再次连接时发一个 ID 过来, 服务器就在内存里找, 找到就直接用主密钥恢复会话状态, 跳过证书验证和密钥交换, 只用一个消息往返就可以建立安全通信.

**Session ID** 是最早出现的会话复用技术, 也是应用最广的, 但它也有缺点, 服务器必须保存每一个客户端的会话数据, 对于拥有百万, 千万级别用户的网站来说存储量就成了大问题, 加重了服务器的负担. 于是, 又出现了第二种 **Session Ticket** 方案. 它有点类似 HTTP 的 Cookie, 存储的责任由服务器转移到了客户端, 服务器加密会话信息, 用 **New Session Ticket** 消息发给客户端, 让客户端保存. 重连的时候, 客户端使用扩展 **session_ticket** 发送 **Ticket** 而不是 **Session ID**, 服务器解密后验证有效期, 就可以恢复会话, 开始加密通信. 不过 **Session Ticket** 方案需要使用一个固定的密钥文件(ticket_key)来加密 Ticket, 为了防止密钥被破解, 保证**前向安全**, 密钥文件需要定期轮换, 比如设置为一小时或者一天.

### 预共享密钥

预共享密钥原理和 **Session Ticket** 差不多, 但在发送 Ticket 的同时会带上应用数据(Early Data), 免去了 1.2 里的服务器确认步骤, 这种方式叫 **Pre-shared Key**, 简称为 **PSK**. 但 **PSK** 也不是完美的, 它为了追求效率而牺牲了一点安全性, 容易受到**重放攻击**(Replay attack)的威胁. 黑客可以截获 **PSK** 的数据, 像复读机那样反复向服务器发送. 解决的办法是只允许安全的 GET/HEAD 方法, 在消息里加入时间戳, **nonce** 验证, 或者**一次性票证**限制重放. 注意, 在 TLS 1.3 废除了 **Session ID** 和 **Session Ticket** 两种方案, 只保留了 **Pre-shared Key**.

![预共享密钥](https://edge.yancey.app/beg/ig3drhos-1649001188389.webp)

## 附录: 配置 HTTPS

以 nginx 为例, 监听 443 端口, 并提供证书的路径.

```shell
listen                443 ssl;

ssl_certificate       xxx_rsa.crt;  # rsa2048 cert
ssl_certificate_key   xxx_rsa.key;  # rsa2048 private key

ssl_certificate       xxx_ecc.crt;  # ecdsa cert
ssl_certificate_key   xxx_ecc.key;  # ecdsa private ke
```

为了提高 HTTPS 的安全系数和性能, 还可以强制 Nginx 只支持 TLS1.2 以上的协议, 打开 **Session Ticket** 会话复用:

```shell
ssl_protocols               TLSv1.2 TLSv1.3;

ssl_session_timeout         5m;
ssl_session_tickets         on;
ssl_session_ticket_key      ticket.key;
```

密码套件的选择方面, 建议是以服务器的套件优先. 这样可以避免恶意客户端故意选择较弱的套件, 降低安全等级, 然后密码套件向 TLS1.3**看齐**, 只使用 ECDHE, AES 和 ChaCha20, 支持 **False Start**. 如果客户端硬件没有 AES 优化, 服务器就会顺着客户端的意思, 优先选择与 AES **等价**的 ChaCha20 算法, 让客户端能够快一点. 可以通过 [SSL Server Test](https://www.ssllabs.com/ssltest/analyze.html) 来测试你的服务器 SSL 的安全性.

```shell
ssl_prefer_server_ciphers on;
ssl_ciphers ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-CHACHA20-POLY1305:ECDHE+AES128:!MD5:!SHA1;

# 如果你的服务器上使用了 OpenSSL 的分支 BorringSSL,
# 那么还可以使用一个特殊的**等价密码组**(Equal preference cipher groups)特性,
# 它可以让服务器配置一组**等价**的密码套件, 在这些套件里允许客户端优先选择
ssl_ciphers
[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305];
```

### SNI

在 HTTP 协议里, 多个域名可以同时在一个 IP 地址上运行, 这就是**虚拟主机**, Web 服务器会使用请求头里的 Host 字段来选择. 但在 HTTPS 里, 因为请求头只有在 TLS 握手之后才能发送, 在握手时就必须选择**虚拟主机**对应的证书, TLS 无法得知域名的信息, 就只能用 IP 地址来区分. 所以, 最早的时候每个 HTTPS 域名必须使用独立的 IP 地址, 非常不方便.

这需要用到 TLS 的**扩展**, 给协议加个 SNI(Server Name Indication)的**补充条款**. 它的作用和 Host 字段差不多, 客户端会在 **Client Hello** 时带上域名信息, 这样服务器就可以根据名字而不是 IP 地址来选择证书.

### 重定向跳转

通过**重定向跳转**技术, 把不安全的 HTTP 网址用 301 或 302 **重定向**到新的 HTTPS 网站, 这在 Nginx 里也很容易做到, 使用 **return** 或 **rewrite** 都可以.

```shell
return 301 https://$host$request_uri; #永久重定向
rewrite ^ https://$host$request_uri permanent; #永久重定向
```

但这种方式有两个问题. 一个是重定向增加了网络成本, 多出了一次请求；另一个是存在安全隐患, 重定向的响应可能会被**中间人**窜改, 实现**会话劫持**, 跳转到恶意网站.

不过有一种叫**HSTS**(HTTP 严格传输安全, HTTP Strict Transport Security)的技术可以消除这种安全隐患. HTTPS 服务器需要在发出的响应头里添加一个**Strict-Transport-Security**的字段, 再设定一个有效期, 例如:

```shell
add_header Strict-Transport-Security max-age=15768000; #182.5days
```

这相当于告诉浏览器: 我这个网站必须严格使用 HTTPS 协议, 在半年之内(182.5 天)都不允许用 HTTP, 你以后就自己做转换吧, 不要再来麻烦我了. 有了**HSTS**的指示, 以后浏览器再访问同样的域名的时候就会自动把 URI 里的**http**改成**https**, 直接访问安全的 HTTPS 网站. 这样**中间人**就失去了攻击的机会, 而且对于客户端来说也免去了一次跳转, 加快了连接速度.

## 小结

TLS 通过以下几点来保证机密性, 完整性, 身份认证和不可否认.

- 摘要算法用来实现完整性, 能够为数据生成独一无二的**指纹**, 常用的算法是 SHA-2;
- 数字签名是私钥对摘要的加密, 可以由公钥解密后验证, 实现身份认证和不可否认;
- 公钥的分发需要使用数字证书, 必须由 CA 的信任链来验证, 否则就是不可信的;
- 作为信任链的源头 CA 有时也会不可信, 解决办法有 CRL, OCSP, 还有终止信任.

TLS 握手小结:

1. HTTPS 协议会先与服务器执行 TCP 握手, 然后执行 TLS 握手, 才能建立安全连接;
2. 握手的目标是安全地交换对称密钥, 需要三个随机数, 第三个随机数**Pre-Master**必须加密传输, 绝对不能让黑客破解;
3. **Hello**消息交换随机数, **Key Exchange**消息交换**Pre-Master**;
4. **Change Cipher Spec**之前传输的都是明文, 之后都是对称密钥加密的密文.

对 TLS 1.2 已知的攻击有 BEAST, BREACH, CRIME, TREAK, LUCKY13, POODLE, ROBOT.
","2025-02-02 03:09:09.568929","2025-02-02 03:09:09.568929"
"d7b03d54-137d-4163-a8ad-5346c367a3b9","{HTTP}",0,0,False,"https://edge.yancey.app/beg/2i7mbp1h-1649954610126.jpg","[HTTP 系列] 第 6 篇 —— 从输入 URL 回车到页面呈现","这里是《写给前端工程师的 HTTP 系列》终极篇, 从输入 URL 回车到页面呈现到底发生了什么. 这篇文章着重会讲浏览器渲染过程, 如前置的 缓存, DNS 解析, TCP, HTTP 等流程一笔带过, 相关内容请浏览本系列的前几篇文章.","- [\[HTTP 系列\] 第 1 篇 —— 从 TCP/UDP 到 DNS 解析](https://www.yanceyleo.com/post/3a9d3d47-9977-4579-a756-4bf5af4a3fd4)
- [\[HTTP 系列\] 第 2 篇 —— HTTP 协议那些事](https://www.yanceyleo.com/post/efd566e9-4ee3-4ee2-8448-628414659480)
- [\[HTTP 系列\] 第 3 篇 —— HTTP 缓存那些事](https://www.yanceyleo.com/post/89731d8e-5510-4094-8962-462b127ed5d0)
- [\[HTTP 系列\] 第 4 篇 —— HTTPS](https://www.yanceyleo.com/post/f976717f-9e40-4849-a73f-86c63c0c45e1)
- [\[HTTP 系列\] 第 5 篇 —— 网络安全](https://www.yanceyleo.com/post/953ccf20-7f3b-4d3f-816e-b6e98b26a4da)
- [\[HTTP 系列\] 第 6 篇 —— 从输入 URL 回车到页面呈现](https://www.yanceyleo.com/post/05daeef2-2caf-4ebe-89f0-2ad9cae286c4)

## 总览

用户发出 URL 请求到页面开始解析的这个过程, 就叫做导航.

- 首先, 浏览器进程接收到用户输入的 URL 请求, 浏览器进程便将该 URL 转发给网络进程.
- 然后, 在网络进程中发起真正的 URL 请求.
- 接着网络进程接收到了响应头数据, 便解析响应头数据, 并将数据转发给浏览器进程.
- 浏览器进程接收到网络进程的响应头数据之后, 发送 **提交导航 (CommitNavigation)** 消息到渲染进程;
- 渲染进程接收到**提交导航**的消息之后, 便开始准备接收 HTML 数据, 接收数据的方式是直接和网络进程建立数据管道;
- 最后渲染进程会向浏览器进程**确认提交**, 这是告诉浏览器进程: **已经准备好接受和解析页面数据了**.
- 浏览器进程接收到渲染进程**提交文档**的消息之后, 便开始移除之前旧的文档, 然后更新浏览器进程中的页面状态.

![总览](https://edge.yancey.app/beg/fq69tz8f-1651527360894.webp)

![资源请求](https://edge.yancey.app/beg/a305mf59-1661142135685.png)

![资源获取](https://edge.yancey.app/beg/bzeynvk4-1661142334817.png)

## 用户输入

当用户在地址栏中输入一个查询关键字时, 地址栏会判断输入的关键字是搜索内容, 还是请求的 URL.

- 如果是搜索内容, 地址栏会使用浏览器默认的搜索引擎, 来合成新的带搜索关键字的 URL.
- 如果判断输入内容符合 URL 规则, 比如输入的是 yanceyleo.com, 那么地址栏会根据规则, 把这段内容加上协议, 合成为完整的 URL, 如 <https://yanceyleo.com>.

当用户输入关键字并键入回车之后, 这意味着当前页面即将要被替换成新的页面, 不过在这个流程继续之前, 浏览器还给了当前页面一次执行 beforeunload 事件的机会, beforeunload 事件允许页面在退出之前执行一些数据清理操作, 还可以询问用户是否要离开当前页面, 比如当前页面可能有未提交完成的表单等情况, 因此用户可以通过 beforeunload 事件来取消导航, 让浏览器不再执行任何后续工作.

比如 react-router, 虽然路由跳转是""假""的, 但它仍然提供了 `Prompt`, 让你在发生 history 变化之前提示用户是否要做些什么.

```ts
<Prompt message=""Are you sure you want to leave?"" />
```

当前页面没有监听 beforeunload 事件或者同意了继续后续流程, 那么浏览器便进入下图的状态:

![开始加载 URL 浏览器状态](https://edge.yancey.app/beg/zlhd9cx2-1649591274626.webp)

从图中可以看出, 当浏览器刚开始加载一个地址之后, 标签页上的图标便进入了加载状态. 但此时图中页面显示的依然是之前打开的页面内容, 并没立即替换为极客时间的页面. 因为需要等待提交文档阶段, 页面内容才会被替换.

## URL 请求过程

浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段: 构建请求, 查找缓存, 准备 IP 和端口, 等待 TCP 队列, 建立 TCP 连接, 发起 HTTP 请求, 服务器处理请求, 服务器返回请求和断开连接.

![总过程](https://edge.yancey.app/beg/pxdh2zwu-1649531732944.webp)

接下来, 便进入了页面资源请求过程. 这时, 浏览器进程会通过进程间通信(IPC)把 URL 请求发送至网络进程, 网络进程接收到 URL 请求后, 会在这里发起真正的 URL 请求流程. 首先会查找缓存, 关于缓存看 [\[HTTP 系列\] —— HTTP 缓存那些事](https://www.yanceyleo.com/post/89731d8e-5510-4094-8962-462b127ed5d0) 这篇文章. 如果命中了强缓存, 就直接使用缓存数据. 如果没有命中强缓存, 就会发起真正的网络请求.

请求前的第一步是要进行 DNS 解析, 以获取请求域名的服务器 IP 地址, 从操作系统, 本地 DNS, 根 DNS, 顶级 DNS, 权威 DNS 的层层解析, 当然这中间有缓存. 关于 [DNS 解析](https://www.yanceyleo.com/post/3a9d3d47-9977-4579-a756-4bf5af4a3fd4#DNS) 看这篇文章. 当然如果用了 CDN, DNS 解析可能会给出 CDN 服务器的 IP 地址, 这样你拿到的就会是 CDN 服务器而不是目标网站的实际地址.

拿到 IP 之后, 接下来就需要获取端口号了. 通常情况下, 如果 URL 没有特别指明端口号, 那么 HTTP 协议默认是 80 端口, 当然 HTTPS 的默认端口号是 443. 这样便可以通过 IP 地址和服务器建立 TCP 连接(三次握手), 当然如果是 HTTPS, 还要建立 TLS 握手. 连接建立之后, 浏览器端会构建请求行, 请求头等信息, 并把和该域名相关的 Cookie 等数据附加到请求头中, 然后向服务器发送构建的请求信息.

![HTTP 报文](https://edge.yancey.app/beg/hdtvj39f-1649530047922.webp)

> 注意, 在 TCP 建立连接之前, Chrome 有个机制, 同一个域名同时最多只能建立 6 个 TCP 连接, 如果在同一个域名下同时有 10 个请求发生, 那么其中 4 个请求会进入排队等待状态, 直至进行中的请求完成. 当然这是 HTTP/1 的特性. 不过 HTTP/2 是可以并行请求资源的, 所以如果使用 HTTP/2, 浏览器只会为每个域名维护一个 TCP 连接.

在接收到服务器返回的响应头后, 网络进程开始解析响应头, 如果发现返回的状态码是 301 或者 302, 那么说明服务器需要浏览器重定向到其他 URL. 这时网络进程会从响应头的 Location 字段里面读取重定向的地址, 这就是告诉了浏览器要重新导航到新的地址上, 然后再发起新的 HTTP 或者 HTTPS 请求, 一切又重头开始了. 如果响应行是 200, 那么表示浏览器可以继续处理该请求.

当浏览器受到相应后, 会根据 Content-Type 的值来决定如何显示响应体的内容. 不同 Content-Type 的后续处理流程也截然不同. 如果 Content-Type 字段的值被浏览器判断为下载类型, 那么该请求会被提交给浏览器的下载管理器, 同时该 URL 请求的导航流程就此结束. 但如果是 HTML, 那么浏览器则会继续进行导航流程. 由于 Chrome 的页面渲染是运行在渲染进程中的, 所以接下来就需要准备渲染进程了.

## 准备渲染进程

默认情况下, Chrome 会为每个页面分配一个渲染进程, 也就是说, 每打开一个新页面就会配套创建一个新的渲染进程. 但如果从一个页面打开了另一个新页面, 而新页面和当前页面属于同一站点的话, 浏览器会让多个页面直接运行在同一个渲染进程中, 官方把这个默认策略叫 **process-per-site-instance**. 如下图, 打开的这三个页面都是运行在同一个渲染进程中, 进程 ID 是 23601.

同一站点(same-site)的含义是只要**根域名**和**协议**相同的站点, 就可以认为是同一个站点. 需要注意的一点是, 如果打开两个 Tab, 即便它们是同一站点, 也会创建两个进程. 你可以通过在某个页面, 使用 `window.open()` 方法来打开新的页面, 这样它们就会使用同一个进程 ID. 也可以使用 `<a href=""https://yanceyleo.com/"" target=""_blank"" class="""">yanceyleo</a>` 的方式, 当然如果带上了 noopener 和 noreferrer 就不会产生上下文了.

在 WHATWG 规范中, 把这一类具有相互连接关系的标签页称为浏览上下文组(browsing context group). 既然提到浏览上下文组, 就有必要提下浏览上下文, 通常情况下, 我们把一个标签页所包含的内容, 诸如 window 对象, 历史记录, 滚动条位置等信息称为浏览上下文. 这些通过脚本相互连接起来的浏览上下文就是浏览上下文组.

Chrome 浏览器会将浏览上下文组中属于同一站点的标签分配到同一个渲染进程中, 这是因为如果一组标签页, 既在同一个浏览上下文组中, 又属于同一站点, 那么它们可能需要在对方的标签页中执行脚本. 因此, 它们必须运行在同一渲染进程中.

![多个页面运行在一个渲染进程中](https://edge.yancey.app/beg/2rrsz1ni-1649603124314.webp)

## 提交文档

提交文档, 就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程:

- 首先当浏览器进程接收到网络进程的响应头数据之后, 便向渲染进程发起**提交文档**的消息;
- 渲染进程接收到**提交文档**的消息后, 会和网络进程建立传输数据的**管道**;
- 等文档数据传输完成之后, 渲染进程会返回**确认提交**的消息给浏览器进程;
- 浏览器进程在收到**确认提交**的消息后, 会更新浏览器界面状态, 包括了安全状态, 地址栏的 URL, 前进后退的历史状态, 并更新 Web 页面.

正是因为有了提交文档的阶段, 所以在浏览器的地址栏里面输入了一个地址后, 之前的页面没有立马消失, 而是要加载一会儿才会更新页面.

![当渲染进程确认提交之后浏览器更新的内容](https://edge.yancey.app/beg/93m8aiuu-1649788453948.webp)

## 浏览器渲染

一旦文档被提交, 渲染进程便开始页面解析和子资源加载. 渲染模块会处理 HTML, CSS, JavaScript 等数据, 最终输出为屏幕上的像素.

![HTML, CSS 和 JavaScript 关系图](https://edge.yancey.app/beg/0qs33e05-1649863627395.webp)

由于渲染机制过于复杂, 所以渲染模块在执行过程中会被划分为很多子阶段, 输入的 HTML 经过这些子阶段, 最后输出像素. 我们把这样的一个处理流程叫做**渲染流水线**. 按照渲染的时间顺序, 流水线可分为如下几个子阶段: 构建 DOM 树, 样式计算, 布局阶段, 分层, 绘制, 分块, 光栅化和合成. 每个阶段都有三个步骤:

- 开始每个子阶段都有其**输入的内容**;
- 然后每个子阶段有其**处理过程**;
- 最终每个子阶段会生成**输出内容**.

![渲染流水线](https://edge.yancey.app/beg/84zclfks-1649863914618.webp)

### 一些小概念

在讲渲染流程之前, 我们先了解一些小概念.

首先我们看显示器是怎么显示图像的. 每个显示器都有固定的刷新频率, 通常是 60HZ, 也就是每秒更新 60 张图片, 更新的图片都来自于显卡中一个叫**前缓冲区**的地方, 显示器所做的任务很简单, 就是每秒固定读取 60 次前缓冲区中的图像, 并将读取的图像显示到显示器上.

显卡的职责就是合成新的图像, 并将图像保存到**后缓冲区**中, 一旦显卡把合成的图像写到后缓冲区, 系统就会让后缓冲区和前缓冲区互换, 这样就能保证显示器能读取到最新显卡合成的图像. 通常情况下, 显卡的更新频率和显示器的刷新频率是一致的. 但有时候, 在一些复杂的场景中, 显卡处理一张图片的速度会变慢, 这样就会造成视觉上的卡顿.

当你通过滚动条滚动页面, 或者通过手势缩放页面时, 屏幕上就会产生动画的效果. 之所以你能感觉到有动画的效果, 是因为在滚动或者缩放操作时, 渲染引擎会通过渲染流水线生成新的图片, 并发送到显卡的后缓冲区.

大多数设备屏幕的更新频率是 60 次/秒, 这也就意味着正常情况下要实现流畅的动画效果, 渲染引擎需要每秒更新 60 张图片到显卡的后缓冲区. 我们把渲染流水线生成的每一副图片称为一帧, 把渲染流水线每秒更新了多少帧称为帧率, 比如滚动过程中 1 秒更新了 60 帧, 那么帧率就是 60Hz(或者 60FPS). 由于用户很容易观察到那些丢失的帧, 如果在一次动画过程中, 渲染引擎生成某些帧的时间过久, 那么用户就会感受到卡顿, 这会给用户造成非常不好的印象.

为了生成一帧图像, 引擎提供了重排, 重绘和合成三种方式. 这三种方式的渲染路径是不同的, 通常渲染路径越长, 生成图像花费的时间就越多. 比如重排, 它需要重新根据 CSSOM 和 DOM 来计算布局树, 这样生成一幅图片时, 会让整个渲染流水线的每个阶段都执行一遍, 如果布局复杂的话, 就很难保证渲染的效率了. 而重绘因为没有了重新布局的阶段, 操作效率稍微高点, 但是依然需要重新计算绘制信息, 并触发绘制操作之后的一系列操作.

相较于重排和重绘, 合成操作的路径就显得非常短了, 并不需要触发布局和绘制两个阶段, 如果采用了 GPU, 那么合成的效率会非常高.

因此, 关于渲染引擎生成一帧图像的几种方式, 按照效率我们推荐合成方式优先, 若实在不能满足需求, 那么就再退后一步使用重绘或者重排的方式. 要解决卡顿问题, 就要解决每帧生成时间过久的问题, 为此 Chrome 对浏览器渲染方式做了大量的工作, 其中最卓有成效的策略就是引入了分层, 分块和合成机制. 我们在下面分层那一部分说到. 下面我们来走一遍浏览器渲染的流程.

### 构建 DOM 树

因为浏览器无法直接理解和使用 HTML, 所以需要将 HTML 转换为浏览器能够理解的结构, 即 DOM 树. 在渲染引擎中, DOM 有三个层面的作用.

- 从页面的视角来看, DOM 是生成页面的基础数据结构.
- 从 JavaScript 脚本视角来看, DOM 提供给 JavaScript 脚本操作的接口, 通过这套接口, JavaScript 可以对 DOM 结构进行访问, 从而改变文档的结构, 样式和内容.
- 从安全视角来看, DOM 是一道安全防护线, 一些不安全的内容在 DOM 解析阶段就被拒之门外了.

![DOM 树](https://edge.yancey.app/beg/qghxbk7j-1649864555613.webp)

你可以在 Chrome 的控制台中输入 `doucment` 回车, 其实就是一个完整的 DOM 树结构. DOM 和 HTML 内容几乎是一样的, 但是和 HTML 不同的是, DOM 是保存在**内存**中树状结构, 可以通过 JavaScript 来查询或修改其内容.

![document 对象](https://edge.yancey.app/beg/f5ft52zo-1649864670309.webp)

#### DOM 树的生成

在渲染引擎内部, 有一个叫 HTML 解析器(HTMLParser)的模块, 它的职责就是负责将 HTML 字节流转换为 DOM 结构. HTML 解析器并不是等整个文档加载完成之后再解析的, 而是网络进程加载了多少数据, HTML 解析器便解析多少数据.

网络进程接收到响应头之后, 会根据响应头中的 content-type 字段来判断文件的类型, 比如 content-type 的值是 **text/html**, 那么浏览器就会判断这是一个 HTML 类型的文件, 然后为该请求选择或者创建一个渲染进程. 渲染进程准备好之后, 网络进程和渲染进程之间会建立一个共享数据的管道, 网络进程接收到数据后就往这个管道里面放, 而渲染进程则从管道的另外一端不断地读取数据, 并同时将读取的数据喂给 HTML 解析器. 你可以把这个管道想象成一个**水管**, 网络进程接收到的字节流像水一样倒进这个**水管**, 而**水管**的另外一端是渲染进程的 HTML 解析器, 它会动态接收字节流, 并将其解析为 DOM.

上面说到代码从网络传输过来是字节流的形式, 字节流转换为 DOM 的流程如下图所示, 下面详细说明.

![字节流转换为 DOM](https://edge.yancey.app/beg/j904npad-1650741239021.webp)

第一个阶段是通过分词器将字节流转换为 Token. V8 编译 JavaScript 过程中的第一步是做词法分析; 解析 HTML 也是一样的, 需要通过分词器先将字节流转换为一个个 Token, 分为 Tag Token 和文本 Token. 上述 HTML 代码通过词法分析生成的 Token 如下所示:

![生成的 Token](https://edge.yancey.app/beg/w57hx1ms-1650741527117.webp)

至于后续的第二个和第三个阶段是**同步**进行的, 需要将 Token 解析为 DOM 节点, 并将 DOM 节点添加到 DOM 树中. HTML 解析器维护了一个 Token 栈结构, 该 Token 栈主要用来计算节点之间的父子关系, 在第一个阶段中生成的 Token 会被按照顺序压到这个栈中. 具体的处理规则如下所示:

- 如果压入到栈中的是 **StartTag Token**, HTML 解析器会为该 Token 创建一个 DOM 节点, 然后将该节点加入到 DOM 树中, 它的父节点就是栈中相邻的那个元素生成的节点.
- 如果分词器解析出来是**Text Token**, 那么会生成一个文本节点, 然后将该节点加入到 DOM 树中, 文本 Token 是不需要压入到栈中, 它的父节点就是当前栈顶 Token 所对应的 DOM 节点.
- 如果分词器解析出来的是 **EndTag Token**, 比如是 EndTag div, HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div, 如果是, 就将 StartTag div 从栈中弹出, 表示该 div 元素解析完成.

```html
<html>
  <body>
    <div>1</div>
    <div>test</div>
  </body>
</html>
```

以上面这段代码为例:

HTML 解析器开始工作时, 会默认创建了一个根为 document 的空 DOM 结构, 同时会将一个 StartTag document 的 Token 压入栈底. 然后经过分词器解析出来的第一个 StartTag html Token 会被压入到栈中, 并创建一个 html 的 DOM 节点, 添加到 document 上.

然后按照同样的流程解析出来 StartTag body 和 StartTag div.

接下来解析出来的是第一个 div 的文本 Token, 渲染引擎会为该 Token 创建一个文本节点, 并将该 Token 添加到 DOM 中, 它的父节点就是当前 Token 栈顶元素对应的节点.

再接下来, 分词器解析出来第一个 EndTag div, 这时候 HTML 解析器会去判断当前栈顶的元素是否是 StartTag div, 如果是则从栈顶弹出 StartTag div.

![HTML 解析器栈实例](https://edge.yancey.app/beg/4rfxbpru-1650742718924.jpeg)

需要注意的是, 如果解析到 `<script>` 标签, 渲染引擎判断这是一段脚本, 此时 HTML 解析器就会暂停 DOM 的解析, 因为接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构. 脚本执行完成之后, HTML 解析器恢复解析过程, 继续解析后续的内容, 直至生成最终的 DOM.

不管是内嵌 JavaScript 脚本还是通过 JavaScript 文件加载的. 其整个执行流程还是一样的: **执行到 JavaScript 标签时, 暂停整个 DOM 的解析, 执行 JavaScript 代码**. 不过通过 JavaScript 文件加载的, 需要先下载这段 JavaScript 代码, 而 JavaScript 文件的下载过程会阻塞 DOM 解析, 而通常下载又是非常耗时的, 会受到网络环境, JavaScript 文件大小等因素的影响. 因此 Chrome 做了一些优化, 比如**预解析操作**: 当渲染引擎收到字节流之后, 会开启一个预解析线程, 用来分析 HTML 文件中包含的 JavaScript, CSS 等相关文件, 解析到相关文件之后, 预解析线程会提前下载这些文件.

如果 JavaScript 文件中没有操作 DOM 相关代码, 就可以将该 JavaScript 脚本设置为异步加载, 通过 async 或 defer 来标记代码. async 和 defer 虽然都是异步的, 不过还有一些差异, 使用 async 标志的脚本文件一旦加载完成, 会立即执行；而使用了 defer 标记的脚本文件, 需要在 DOMContentLoaded 事件之前执行. 具体可以看[关于 script 标签 async 和 defer 属性分析](https://www.yanceyleo.com/post/b6767e52-a557-45b1-8955-8ac5bd77ca02)这篇文章.

```html
<script async type=""text/javascript"" src=""foo.js""></script>
<script defer type=""text/javascript"" src=""foo.js""></script>
```

此外, JavaScript 脚本还是依赖样式表的, 不管该脚本是否操纵了 CSSOM, 都会执行 CSS 文件下载, 解析操作, 再执行 JavaScript 脚本. 这是因为如果 JavaScript 代码里修改了样式, 它必须等到 CSSOM 就绪之后才能修改.

因此, JavaScript 会阻塞 DOM 生成, 而样式文件又会阻塞 JavaScript 的执行. 所以说一般把 CSS 放在最上面, script 放在 body 最下面.

扩展一下: 渲染引擎还有一个安全检查模块叫 XSSAuditor, 是用来检测词法安全的. 在分词器解析出来 Token 之后, 它会检测这些模块是否安全, 比如是否引用了外部脚本, 是否符合 CSP 规范, 是否存在跨站点请求等. 如果出现不符合规范的内容, XSSAuditor 会对该脚本或者下载任务进行拦截.

### 样式计算

在讲样式计算之前, 先说一下渲染流水线视角下的 CSS.

```scss
// theme.css
div {
  color: coral;
  background-color: black;
}
```

```html
<html>
  <head>
    <link href=""theme.css"" rel=""stylesheet"" />
  </head>
  <body>
    <div>hello world</div>
  </body>
</html>
```

如上面的代码, 我们有一个外部的 css 文件, 被 html 文件所引用. 它的渲染流程大致如下图所示. 我们来分析一下.

![含有 CSS 的页面渲染流水线](https://edge.yancey.app/beg/gvcpdn89-1651057312084.webp)

首先是发起主页面的请求, 这个发起请求方可能是渲染进程, 也有可能是浏览器进程, 发起的请求被送到网络进程中去执行. 网络进程接收到返回的 HTML 数据之后, 将其发送给渲染进程, 渲染进程会解析 HTML 数据并构建 DOM. 这里需要特别注意下, 请求 HTML 数据和构建 DOM 中间有一段空闲时间, 这个空闲时间有可能成为页面渲染的瓶颈.

上面我们说道, 当渲染进程接收 HTML 文件字节流时, 会先开启一个预解析线程, 如果遇到 JavaScript 文件或者 CSS 文件, 那么预解析线程会提前下载这些数据. 对于上面的代码, 预解析线程会解析出来一个外部的 theme.css 文件, 并发起 theme.css 的下载. 这里也有一个空闲时间需要你注意一下, 就是在 DOM 构建结束之后, theme.css 文件还未下载完成的这段时间内, 渲染流水线无事可做, 因为下一步是合成布局树, 而合成布局树需要 CSSOM 和 DOM, 所以这里需要等待 CSS 加载结束并解析成 CSSOM.

如果我们加入一段 JS 脚本会怎么样呢? 可以看下面这张图:

```html
<html>
  <head>
    <link href=""theme.css"" rel=""stylesheet"" />
  </head>
  <body>
    <div>hello world</div>
    <script>
      console.log(""hi world"");
    </script>
    <div>hello world</div>
  </body>
</html>
```

![含有内联 JavaScript 脚本和 CSS 的页面渲染流水线](https://edge.yancey.app/beg/1zszvz00-1651065382621.webp)

上面我们提到过在解析 DOM 的过程中, 如果遇到了 JavaScript 脚本, 那么需要先暂停 DOM 解析去执行 JavaScript, 因为 JavaScript 有可能会修改当前状态下的 DOM.

不过在执行 JavaScript 脚本之前, 如果页面中包含了外部 CSS 文件的引用, 或者通过 style 标签内置了 CSS 内容, 那么渲染引擎还需要将这些内容转换为 CSSOM, 因为 JavaScript 有修改 CSSOM 的能力, 所以在执行 JavaScript 之前, 还需要依赖 CSSOM. 也就是说 CSS 在部分情况下也会阻塞 DOM 的生成.

再复杂一点, 如果我们加入一段外部的 JS 脚本会怎么样呢? 可以看下面这张图:

```ts
// foo.js
console.log(""hi world"");
```

```html
<html>
  <head>
    <link href=""theme.css"" rel=""stylesheet"" />
  </head>
  <body>
    <div>hello world</div>
    <script src=""foo.js""></script>
    <div>hello world</div>
  </body>
</html>
```

![含有外部 JavaScript 脚本和 CSS 的页面渲染流水线](https://edge.yancey.app/beg/odbzjzmj-1651077331292.webp)

从图中可以看出来, 在接收到 HTML 数据之后的预解析过程中, HTML 预解析器识别出来了有 CSS 文件和 JavaScript 文件需要下载, 然后就同时发起这两个文件的下载请求, 需要注意的是, 这两个文件的下载过程是重叠的, 所以下载时间按照最久的那个文件来算.

后面的流水线就和前面是一样的了, 不管 CSS 文件和 JavaScript 文件谁先到达, 都要先等到 CSS 文件下载完成并生成 CSSOM, 然后再执行 JavaScript 脚本, 最后再继续构建 DOM, 构建布局树, 绘制页面.

因此我们一般要把 css 放在上面, 把 js 放在最后.

好了, 我们了解到 CSS 的渲染方式后, 来正式讲一讲样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式, 这个阶段大体可分为三步来完成.

#### 把 CSS 转换为浏览器能够理解的结构

CSS 样式主要有三种来源, 分别是:

- 通过 link 引用的外部 CSS 文件
- `<style>` 标记内的 CSS
- 元素 style 属性的内联 CSS

和 HTML 文件一样, 浏览器也是无法直接理解这些纯文本的 CSS 样式, 所以当渲染引擎接收到 CSS 文本时, 会执行一个转换操作, 将 CSS 文本转换为浏览器可以理解的结构, 即 styleSheets. 你可以通过在 Chrome 的控制台中输入 `doucment.styleSheets` 回车, 来查看 CSSOM 树.

![CSSOM 树](https://edge.yancey.app/beg/4e2uyv6p-1649865562163.jpg)

#### 转换样式表中的属性值, 使其标准化

我们知道很多 CSS 属性值有不同的写法, 但能达到相同的结果. 比如 `rgb(0, 0 ,0)`, `black`, `#000`, `#000000` 都可以指黑色. 并且像 2em, blue, bold, 这些类不容易被渲染引擎理解, 所以**需要将所有值转换为渲染引擎容易理解的, 标准化的计算值**, 这个过程就是属性值标准化.

![标准化属性值](https://edge.yancey.app/beg/tuf0eqkd-1649866357765.webp)

从上图中可以看到, 2em 被解析成了 32px, red 被解析成了 `rgb(255, 0, 0)`, bold 被解析成了 700. 在 Chrome 上, 你可以通过 Computed Styles 来查看一个元素被标准化后的属性值.

![Computed Styles](https://edge.yancey.app/beg/55t523xc-1649866681059.jpg)

#### 计算出 DOM 树中每个节点的具体样式

此时样式已经被标准化, 接下来就需要计算 DOM 树中每个节点的样式属性. 这就涉及到 CSS 的**继承规则**和**层叠规则**.

首先讲 CSS 继承, CSS 继承就是每个 DOM 节点都包含有父节点的样式. 比如下面这段代码:

```css
body {
  font-size: 20pxl;
}
p {
  color: blue;
}
span {
  display: none;
}
div {
  font-weight: bold;
  color: red;
}
div p {
  color: green;
}
```

这张样式表最终应用到 DOM 节点的效果如下图所示, 所有子节点都继承了父节点样式. 比如 body 节点的 font-size 属性是 20, 那 body 节点下面的所有节点的 font-size 都等于 20.

![CSS 继承](https://edge.yancey.app/beg/pmo52hgf-1649868393238.webp)

下面这张图是一个真实的例子. 我们选择了 P 标签, 它的具体样式位于区域 2, 我们可以看到它的样式继承关系. 区域 3 是样式来源, 也就是该标签的样式来自哪个文件, 需要注意的是 **UserAgent 样式表**, 它是浏览器提供的一组默认样式, 如果你不提供任何样式, 默认使用的就是 UserAgent 样式.

![样式的继承](https://edge.yancey.app/beg/cedv3qhq-1649868465047.webp)

样式计算过程中的第二个规则是样式层叠. 层叠是 CSS 的一个基本特征, 它定义了如何合并来自多个源的属性值的算法. 它在 CSS 处于核心地位, CSS 的全称**层叠样式表**正是强调了这一点.

总之, 样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式, 在计算过程中需要遵守 CSS 的继承和层叠两个规则. 这个阶段最终输出的内容是每个 DOM 节点的样式, 并被保存在 ComputedStyle 的结构内.

### 布局阶段

现在, 我们有 DOM 树和 DOM 树中元素的样式, 但这还不足以显示页面, 因为我们还不知道 DOM 元素的几何位置信息. 那么接下来就需要计算出 DOM 树中可见元素的几何位置, 我们把这个计算过程叫做布局. Chrome 在布局阶段需要完成两个任务: **创建布局树**和**布局计算**.

#### 创建布局树

DOM 树还含有很多不可见的元素, 比如 head 标签, 还有使用了 `display: none` 属性的元素. 所以在显示之前, 我们还要额外地构建一棵只包含可见元素布局树. 从下图可以看出, DOM 树中所有不可见的节点都没有包含到布局树中. 为了构建布局树, 浏览器需要遍历 DOM 树中的所有可见节点, 并把这些节点加到布局树中; 而不可见的节点会被布局树忽略掉, 如 head 标签下面的全部内容与包含了 `display: none` 属性的元素.

![创建布局树](https://edge.yancey.app/beg/zy4273m1-1649870554094.webp)

#### 布局计算

现在我们有了一棵完整的布局树. 那么接下来, 就要计算布局树节点的坐标位置了. 在执行布局操作的时候, 会把布局运算的结果重新写回布局树中, 所以布局树既是输入内容也是输出内容, 这是布局阶段一个不合理的地方.

针对这个问题, Chrome 团队正在重构布局代码, 下一代布局系统叫 LayoutNG, 试图更清晰地分离输入和输出, 从而让新设计的布局算法更加简单.

### 分层

在布局计算之后, 我们就拿到了所有每个元素的具体位置信息, 但即便如此渲染引擎还是不能开始绘制页面. 这是因为页面中有很多复杂的效果, 如一些复杂的 3D 变换, 页面滚动, 或者使用 z-index 做 z 轴排序等, 如果没有采用分层机制, 从布局树直接生成目标图片的话, 那么每次页面有很小的变化时, 都会触发重排或者重绘机制, 这种牵一发而动全身的绘制策略会严重影响页面的渲染效率. 为了更加方便地实现这些效果, **渲染引擎还需要为特定的节点生成专用的图层, 并生成一棵对应的图层树(LayerTree)**.

这就跟 Photoshop 的图层概念类似, PhotoShop 中一个项目是由很多图层构成的, 每个图层都可以是一张单独图片, 可以设置透明度, 边框阴影, 可以旋转或者设置图层的上下位置, 正是这些图层叠加在一起构成了最终的页面图像.

在这个过程中, 将素材分解为多个图层的操作就称为分层, 最后将这些图层合并到一起的操作就称为合成. 所以, 分层和合成通常是一起使用的.

在 Chrome DevTools 中, 打开 layers tab, 就可以看到你的网站的分层结构.

![分层](https://edge.yancey.app/beg/a2bsd2zq-1649872990387.jpg)

我们看看这些图层和布局树节点之间的关系:

![布局树和图层树关系](https://edge.yancey.app/beg/4pgvq76o-1649911918746.webp)

通常情况下, 并不是布局树的每个节点都包含一个图层, **如果一个节点没有对应的层, 那么这个节点就从属于父节点的图层**. 如上图中的 span 标签没有专属图层, 那么它们就从属于它们的父节点图层. 但不管怎样, 最终每一个节点都会直接或者间接地从属于一个层. 通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层.

首先, 拥有层叠上下文属性的元素会被提升为单独的一层.

页面是个二维平面, 但是层叠上下文能够让 HTML 元素具有三维概念, 这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上. 明确定位属性的元素, 定义透明属性的元素, 使用 CSS 滤镜的元素等, 都拥有层叠上下文属性.

![明确了 Z 轴属性的会被单独提升为一层](https://edge.yancey.app/beg/da0xra3o-1649912284652.webp)

其次, 需要剪裁(clip)的地方也会被创建为图层.

下面这段代码, 宽高都是 200px, 但 div 里的字数很多, 肯定会超过 200\*200 的面积, 这时候就产生了剪裁, 出现这种裁剪情况的时候, 渲染引擎会为文字部分单独创建一个层, 如果出现滚动条, 滚动条也会被提升为单独的层.

```html
<style>
  div {
    width: 200px;
    height: 200px;
    overflow: auto;
    background: gray;
  }
</style>
<body>
  <div>
    <p>
      所以元素有了层叠上下文的属性或者需要被剪裁, 那么就会被提升成为单独一层,
      你可以参看下图:
    </p>
    <p>
      从上图我们可以看到, document层上有 A 和 B 层, 而 B 层之上又有两个图层.
      这些图层组织在一起也是一颗树状结构.
    </p>
    <p>
      图层树是基于布局树来创建的, 为了找出哪些元素需要在哪些层中,
      渲染引擎会遍历布局树来创建层树(Update LayerTree).
    </p>
  </div>
</body>
```

![被裁剪的内容会出现在单独一层](https://edge.yancey.app/beg/96py0g0c-1649917368602.webp)

### 分块

如果说分层是从宏观上提升了渲染效率, 那么分块则是从微观层面提升了渲染效率. 通常情况下, 页面的内容都要比屏幕大得多, 显示一个页面时, 如果等待所有的图层都生成完毕, 再进行合成的话, 会产生一些不必要的开销, 也会让合成图片的时间变得更久.

因此, 合成线程会将每个图层分割为大小固定的图块, 然后优先绘制靠近视口的图块, 这样就可以大大加速页面的显示速度. 不过有时候, 即使只绘制那些优先级最高的图块, 也要耗费不少的时间, 因为涉及到一个很关键的因素, 即**纹理上传**, 这是因为从计算机内存上传到 GPU 内存的操作会比较慢.

为了解决这个问题, Chrome 又采取了一个策略: **在首次合成图块的时候使用一个低分辨率的图片**. 比如可以是正常分辨率的一半, 分辨率减少一半, 纹理就减少了四分之三. 在首次显示页面内容的时候, 将这个低分辨率的图片显示出来, 然后合成器继续绘制正常比例的网页内容, 当正常比例的网页内容绘制完成后, 再替换掉当前显示的低分辨率内容. 这种方式尽管会让用户在开始时看到的是低分辨率的内容, 但是也比用户在开始时什么都看不到要好.

### 图层绘制

在完成图层树的构建之后, 渲染引擎会对图层树中的每个图层进行绘制. 渲染引擎会把一个图层的绘制拆分成很多小的**绘制指令(其实就是执行一些函数)**, 然后再把这些指令按照顺序组成一个待**绘制列表**. 就好比说**先绘制蓝色背景; 再在中间绘制一个红色的圆; 再在圆上绘制绿色三角形**. 你可以通过 Chrome DevTools 中的 layers tab, 了解你的网站在绘制时的绘制指令.

![图层绘制](https://edge.yancey.app/beg/frg2du5f-1649949010973.jpg)

### 栅格化(raster)操作

绘制列表只是用来记录绘制顺序和绘制指令的列表, 而实际上绘制操作是由渲染引擎中的**合成线程**来完成的. 下图描述了渲染主线程和合成线程之间的关系, 当图层的绘制列表准备好之后, 主线程会把该绘制列表提交(commit)给合成线程.

![渲染主线程和合成线程](https://edge.yancey.app/beg/pxmmvgj8-1649950906159.webp)

让我们看一看合成线程是怎样工作的. 首先我们知道通常一个页面很长, 但是用户只能看到其中的一部分, 我们把用户可以看到的这个部分叫做**视口(viewport)**. 换句话说, 如果滚动条很长的话, 用户每次滚动只能看到一小部分, 所以在这种情况下, 要绘制出所有图层内容的话, 就会产生太大的开销, 而且也没有必要.

![图层被划分为图块](https://edge.yancey.app/beg/2wecp2ig-1649951363926.webp)

基于此, 合成线程会将图层划分为**图块(tile)**, 这些图块的大小通常是 `256*256` 或者 `512*512`. 然后合成线程会按照视口附近的图块来优先生成位图, **实际生成位图的操作是由栅格化来执行的**. 因此, **所谓栅格化, 是指将图块转换为位图**. 图块是栅格化执行的最小单位. 渲染进程维护了一个栅格化的线程池, 所有的图块栅格化都是在线程池内执行的.

![合成线程提交图块给栅格化线程池](https://edge.yancey.app/beg/vw9kn9vg-1649951350624.webp)

通常, 栅格化过程都会使用 GPU 来加速生成, 使用 GPU 生成位图的过程叫快速栅格化, 或者 GPU 栅格化, 生成的位图被保存在 GPU 内存中. 由于 GPU 操作是运行在 GPU 进程中, 如果栅格化操作使用了 GPU, 那么最终生成位图的操作是在 GPU 中完成的, 这就涉及到了跨进程操作. 从下图可以看出, 渲染进程把生成图块的指令发送给 GPU, 然后在 GPU 中执行生成图块的位图, 并保存在 GPU 的内存中.

![栅格化过程](https://edge.yancey.app/beg/wp8inuxz-1649951587261.webp)

### 合成和显示

一旦所有图块都被光栅化, 合成线程就会生成一个绘制图块的命令, **DrawQuad**, 然后将该命令提交给浏览器进程. 浏览器进程里面有一个叫 viz 的组件, 用来接收合成线程发过来的 DrawQuad 命令, 然后根据 DrawQuad 命令, 将其页面内容绘制到内存中, 最后再将内存显示在屏幕上.

需要重点关注的是, 合成操作是在合成线程上完成的, 这也就意味着在执行合成操作时, 是不会影响到主线程执行的. 这就是为什么经常主线程卡住了, 但是 CSS 动画依然能执行的原因.

### 渲染完成

至此, 页面就渲染完成了, 此时, 渲染进程会发送一个消息给浏览器进程, 浏览器接收到消息后, 会停止标签图标上的加载动画.

## 加餐: 重排, 重绘, 合成

### 重排

重排意味着更新了元素的几何属性, 如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性, 例如改变元素的宽度, 高度等, 那么浏览器会触发重新布局, 解析之后的一系列子阶段, 这个过程就叫重排. 无疑, 重排需要更新完整的渲染流水线, 所以开销也是最大的.

![重排](https://edge.yancey.app/beg/f1w4trdy-1649954070228.webp)

### 重绘

重绘意味着更新元素的绘制属性, 例如更改某些元素的背景颜色. 从下图可以看出, 由于仅仅改变的是背景颜色, 那么布局阶段将不会被执行, 因为并没有引起几何位置的变换, 所以就直接进入了绘制阶段, 然后执行之后的一系列子阶段, 这个过程就叫重绘. 相较于重排操作, 重绘省去了布局和分层阶段, 所以执行效率会比重排操作要高一些.

![重绘](https://edge.yancey.app/beg/rjwlvg2y-1649954079996.webp)

### 合成

那如果你更改一个既不要布局也不要绘制的属性, 渲染引擎将跳过布局和绘制, 只执行后续的合成操作, 我们把这个过程叫做合成. 下面这个例子, 我们使用了 CSS 的 transform 来实现动画效果, 这可以避开重排和重绘阶段, 直接在非主线程上执行合成动画操作. 这样的效率是最高的, 因为是在非主线程上合成, 并没有占用主线程的资源, 另外也避开了布局和绘制两个子阶段, 所以相对于重绘和重排, 合成能大大提升绘制效率.

![合成](https://edge.yancey.app/beg/5nn230pj-1649954086835.webp)

## 总结

![浏览器渲染总结](https://edge.yancey.app/beg/ihhg3mjn-1649953002344.webp)

1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构.
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets, 计算出 DOM 节点的样式.
3. 创建布局树, 并计算元素的布局信息.
4. 对布局树进行分层, 并生成分层树.
5. 为每个图层生成绘制列表, 并将其提交到合成线程.
6. 合成线程将图层分成图块, 并在光栅化线程池中将图块转换成位图.
7. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程.
8. 浏览器进程根据 DrawQuad 消息生成页面, 并显示到显示器上.
","2025-02-02 03:09:11.864117","2025-02-02 03:09:11.864117"
"a96aba07-e417-43da-9808-e0e5a8f1a6b5","{浏览器架构}",0,0,False,"https://edge.yancey.app/beg/fxemzd7d-1650555135825.jpg","浏览器架构的前生今世","这篇文章是李兵老师《浏览器工作原理与实践》中的一个章节. 其他章节由于以前文章都写过了, 所以那些章节的笔记都补充到以前写过的文章. 由于浏览器架构这块比较独立, 遂单独成文.","## 浏览器的多进程架构

可以做一个实验, 仅仅在 Chrome 中打开一个 tab 页面, 然后点击 Chrome 右上角更多 -> 更多工具 -> 任务管理器. 你会发现, 仅仅打开一个页面, 万恶的 Chrome 却打开了 4 个进程.

![Chrome 的任务管理器](https://edge.yancey.app/beg/ixkja0ki-1649334747108.webp)

### 复习下进程和线程好了

先说下什么是并行, 计算机中的并行处理就是同一时刻处理多个任务, 比如我们要计算下面这三个表达式的值, 并显示出结果.

```rust
let a = 1 + 2;
let b = 20 / 5;
let c = 7 * 8;
println!(""a: {} b: {} c: {}"", a, b, c);
```

这段代码每句话都是一个**任务**, 如果是**单线程**的话, 那就得分四步按照顺序分别执行这四个任务; 如果是**多线程**的话, 可用用三个线程同时执行前三个任务, 再执行第四个显示任务. 可见多线程只需要执行两步, 而单线程需要四步, 使用并行处理能大大提升性能.

接下来说下线程和进程:

多线程可以并行处理任务, 但是**线程是不能单独存在的, 它是由进程来启动和管理的**. **一个进程就是一个程序的运行实例**. 详细解释就是, 启动一个程序的时候, 操作系统会为该程序创建一块内存, 用来存放代码, 运行中的数据和一个执行任务的主线程, 我们把这样的一个运行环境叫**进程**.

![单线程与多线程的进程对比图](https://edge.yancey.app/beg/45mbfggp-1649400608448.webp)

从图中可以看出, 线程是依附于进程的, 而进程中使用多线程并行处理能提升运算效率.

进程和线程之间的关系有以下 4 个特点:

一. **进程中的任意一线程执行出错, 都会导致整个进程的崩溃**. 比如下面这个例子, 在执行到 `20 / 0` 时, 由于分母为 0, 线程会执行出错, 这样就会导致整个进程的崩溃, 当然另外两个线程执行的结果也没有了.

```rust
let a = 1 + 2;
let b = 20 / 0;
let c = 7 * 8;
```

二. **线程之间共享进程中的数据**. 即线程之间可以对进程的公共数据进行读写操作. 从上图可以看出, 线程 1, 线程 2, 线程 3 分别把执行的结果写入 A, B, C 中, 然后线程 2 继续从 A, B, C 中读取数据, 用来显示执行结果.

![线程之间共享进程中的数据示意图](https://edge.yancey.app/beg/4ohgmhjk-1649407511401.webp)

三. **当一个进程关闭之后, 操作系统会回收进程所占用的内存**. 当一个进程退出时, 操作系统会回收该进程所申请的所有资源; 即使其中任意线程因为操作不当导致内存泄漏, 当进程退出时, 这些内存也会被正确回收.

四. **进程之间的内容相互隔离**. 进程隔离是为保护操作系统中进程互不干扰的技术, 每一个进程只能访问自己占有的数据, 也就避免出现进程 A 写入数据到进程 B 的情况. 正是因为进程之间的数据是严格隔离的, 所以一个进程如果崩溃了, 或者挂起了, 是不会影响到其他进程的. 如果进程之间需要进行数据的通信, 这时候, 就需要使用用于进程间通信(IPC, Inter Process Communication)的机制了. 比如 Electron 就有两个进程, 分别是 Main 主进程和 Renderer 渲染进程, 两者的通信也是需要用到 IPC.

### 单进程浏览器

在 2007 年之前, 市面上浏览器都是单进程的. 顾名思义, 单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里, 这些模块包含了网络, 插件, JavaScript 运行环境, 渲染引擎和页面等.

![单进程浏览器示意图](https://edge.yancey.app/beg/283t42ke-1649412440942.webp)

如此多的功能模块运行在一个进程里, 是导致单进程浏览器不稳定, 不流畅和不安全的一个主要因素.

一. **不稳定**. 早期浏览器需要借助于**插件**(比如 Flash)来实现诸如 Web 视频, Web 游戏等各种强大的功能, 但是插件是最容易出问题的模块, 并且还运行在浏览器进程之中, 所以一个插件的意外崩溃会引起整个浏览器的崩溃. 除了插件之外, **渲染引擎模块**也是不稳定的, 通常一些复杂的 JavaScript 代码就有可能引起渲染引擎模块的崩溃. 和插件一样, 渲染引擎的崩溃也会导致整个浏览器的崩溃.

二: **不流畅**. 所有页面的渲染模块, JavaScript 执行环境以及插件都是运行在同一个线程中的, 这就意味着同一时刻只能有一个模块可以执行. 可想而知, 如果丢进去一个死循环代码, 会导致整个浏览器失去响应. 此外, 除了上述脚本或者插件会让单进程浏览器变卡顿外, 页面的内存泄漏也是单进程变慢的一个重要原因. 单线程的页面在关闭的时候, 由于它还是在这个线程呢, 就有可能导致内存没回收干净, 从而导致内存泄漏.

三: **不安全**. 插件体系可以获取到操作系统的任意资源, 当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑. 如果是个恶意插件, 那么它就可以释放病毒, 窃取你的账号密码, 引发安全性问题.

### 早期的多进程浏览器

在 2008 年 Chrome 发布时, 从下面的图可以看出, 页面是运行在单独的渲染进程中的, 同时页面里的插件也是运行在单独的插件进程之中, 而进程之间是通过 IPC 机制进行通信(虚线部分).

![早期的多进程浏览器](https://edge.yancey.app/beg/hprubuxd-1649413696374.webp)

首先, 由于进程是相互隔离的, 所以当一个页面或者插件崩溃时, 影响到的仅仅是当前的页面进程或者插件进程, 并不会影响到浏览器和其他页面, 这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃, 也就是不稳定的问题.

其次, JavaScript 也是运行在渲染进程中的, 所以即使 JavaScript 阻塞了渲染进程, 影响到的也只是当前的渲染页面, 而并不会影响浏览器和其他页面, 因为其他页面的脚本是运行在它们自己的渲染进程中的. 所以当我们再在 Chrome 中运行上面那个死循环的脚本时, 没有响应的仅仅是当前的页面. 对于内存泄漏的解决方法那就更简单了, 因为当关闭一个页面时, 整个渲染进程也会被关闭, 之后该进程所占用的内存都会被系统回收, 这样就轻松解决了浏览器页面的内存泄漏问题.

最后, 采用多进程架构的额外好处是可以使用安全沙箱, Chrome 把插件进程和渲染进程锁在沙箱里面, 这样即使在渲染进程或者插件进程里面执行了恶意程序, 恶意程序也无法突破沙箱去获取系统权限. 而单线程浏览器只有一个主进程, 如果使用了安全沙箱, 主进程对于操作系统的权限就会受到限制, 比如不能对一些位置的文件进行读写操作. 而这些权限浏览器主进程所需要的, 所以安全沙箱是不能应用到浏览器主进程之上的.

### 现在的多线程浏览器

![现在的多线程浏览器](https://edge.yancey.app/beg/3j1n6wh5-1649414603488.webp)

最新的 Chrome 浏览器包括: 1 个浏览器(Browser)主进程, 1 个 GPU 进程, 1 个网络(NetWork)进程, 多个渲染进程和多个插件进程.

- **浏览器进程**. 主要负责界面显示, 用户交互, 子进程管理, 同时提供存储等功能.
- **渲染进程**. 核心任务是将 HTML, CSS 和 JavaScript 转换为用户可以与之交互的网页, 排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中, 默认情况下, Chrome 会为每个 Tab 标签创建一个渲染进程. 出于安全考虑, 渲染进程都是运行在沙箱模式下.
- **GPU 进程**. 其实, Chrome 刚开始发布的时候是没有 GPU 进程的. 而 GPU 的使用初衷是为了实现 3D CSS 的效果, 只是随后网页, Chrome 的 UI 界面都选择采用 GPU 来绘制, 这使得 GPU 成为浏览器普遍的需求. 最后, Chrome 在其多进程架构上也引入了 GPU 进程.
- **网络进程**. 主要负责页面的网络资源加载, 之前是作为一个模块运行在浏览器进程里面的, 直至最近才独立出来, 成为一个单独的进程.
- **插件进程**. 主要是负责插件的运行, 因插件易崩溃, 所以需要通过插件进程来隔离, 以保证插件进程崩溃不会对浏览器和页面造成影响.

这也就回答了开头的问题, 仅仅打开了 1 个页面, 为什么有 4 个进程？因为打开 1 个页面至少需要 1 个网络进程, 1 个浏览器进程, 1 个 GPU 进程以及 1 个渲染进程(一般每个页面就占一个渲染进程), 共 4 个; 如果打开的页面有运行插件的话, 还需要再加上 1 个插件进程. 下面是一些归纳:

1. 如果页面里有 iframe 的话, iframe 也会运行在单独的进程中
2. 如果页面里有插件, 同样插件也需要开启一个单独的进程
3. 如果你装了扩展的话, 扩展也会占用进程
4. 如果 2 个页面属于同一站点(同一站点指同一级域名)的话, 并且从 a 页面中打开的 b 页面, 那么他们会公用一个渲染进程

不过凡事都有两面性, 虽然多进程模型提升了浏览器的稳定性, 流畅性和安全性, 但同样不可避免地带来了一些问题:

- **更高的资源占用**. 因为每个进程都会包含公共基础结构的副本(如 JavaScript 运行环境), 这就意味着浏览器会消耗更多的内存资源.
- **更复杂的体系架构**. 浏览器各模块之间耦合性高, 扩展性差等问题, 会导致现在的架构已经很难适应新的需求了.

### 未来的浏览器架构

为了解决资源占用高和复杂的体系架构问题. Chrome 官方团队使用**面向服务的架构**(Services Oriented Architecture, 简称 **SOA**)的思想设计了新的 Chrome 架构. 原来的各种模块会被重构成独立的服务(Service), 每个服务(Service)都可以在独立的进程中运行, 访问服务(Service)必须使用定义好的接口, 通过 IPC 来通信, 从而构建一个**更内聚, 松耦合, 易于维护和扩展的系统**, 更好实现 Chrome 简单, 稳定, 高速, 安全的目标.

![未来的浏览器架构](https://edge.yancey.app/beg/tsjtf0wy-1649501921729.webp)

同时 Chrome 还提供灵活的弹性架构, 在强大性能设备上会以多进程的方式运行基础服务, 但是如果在资源受限的设备上, Chrome 会将很多服务整合到一个进程中, 从而节省内存占用.

## 安全沙箱

我们知道浏览器被划分为浏览器内核和渲染内核两个核心模块, 其中浏览器内核是由网络进程,浏览器主进程和 GPU 进程组成的, 渲染内核就是渲染进程. 所有的网络资源都是通过浏览器内核来下载的, 下载后的资源会通过 IPC 将其提交给渲染进程. 然后渲染进程会对这些资源进行解析,绘制等操作, 最终生成一幅图片. 但是渲染进程并不负责将图片显示到界面上, 而是将最终生成的图片提交给浏览器内核模块, 由浏览器内核模块负责显示这张图片.

![浏览器内核和渲染进程](https://edge.yancey.app/beg/k3yjmqul-1651483340703.webp)

从上图可以看出, 渲染进程被放到了安全沙箱. 我们知道由于渲染进程需要执行 DOM 解析,CSS 解析,网络图片解码等操作, 如果渲染进程中存在系统级别的漏洞, 那么以上操作就有可能让恶意的站点获取到渲染进程的控制权限, 进而又获取操作系统的控制权限, 这对于用户来说是非常危险的.

此外, 因为网络资源的内容存在着各种可能性, 所以浏览器会默认所有的网络资源都是不可信的, 都是不安全的. 但谁也不能保证浏览器不存在漏洞, 只要出现漏洞, 黑客就可以通过网络内容对用户发起攻击.

但是呢, 如果你下载了一个恶意程序, 但是没有执行它, 那么恶意程序是不会生效的. 同理, 浏览器之于网络内容也是如此, 浏览器可以安全地下载各种网络资源, 但是如果要执行这些网络资源, 比如解析 HTML,解析 CSS,执行 JavaScript,图片编解码等操作, 就可能会产生漏洞. 因此, 浏览器将渲染进程放进了安全沙箱, 这就保证了和操作系统的隔离.

浏览器中的安全沙箱是利用操作系统提供的安全技术, 让渲染进程在执行过程中无法访问或者修改操作系统中的数据, 在渲染进程需要访问系统资源的时候, 需要通过浏览器内核来实现, 然后将访问的结果通过 IPC 转发给渲染进程.

![浏览器内核和渲染进程各自职责](https://edge.yancey.app/beg/li23tylp-1651484531122.webp)

上图描述了浏览器内核和渲染进程各自职责, 让我们逐一分析下:

### 持久存储

由于安全沙箱需要负责确保渲染进程无法直接访问用户的文件系统, 但是在渲染进程内部有访问 Cookie 的需求,有上传文件的需求, 所以现代浏览器将读写文件的操作全部放在了浏览器内核中实现, 然后通过 IPC 将操作结果转发给渲染进程.

- 存储 Cookie 数据的读写. 通常浏览器内核会维护一个存放所有 Cookie 的 Cookie 数据库, 然后当渲染进程通过 JavaScript 来读取 Cookie 时, 渲染进程会通过 IPC 将读取 Cookie 的信息发送给浏览器内核, 浏览器内核读取 Cookie 之后再将内容返回给渲染进程.
- 一些缓存文件的读写也是由浏览器内核实现的, 比如网络文件缓存的读取.

### 网络访问

在渲染进程内部也是不能直接访问网络的, 如果要访问网络, 则需要通过浏览器内核. 不过浏览器内核在处理 URL 请求之前, 会检查渲染进程是否有权限请求该 URL, 比如检查 XMLHttpRequest 或者 Fetch 是否是跨站点请求, 或者检测 HTTPS 的站点中是否包含了 HTTP 的请求.

### 用户交互

在现代浏览器中, 由于每个渲染进程都有安全沙箱的保护, 所以在渲染进程内部是无法直接操作窗口句柄的, 这也是为了限制渲染进程监控到用户的输入事件. 因此:

渲染进程需要渲染出位图. 为了向用户显示渲染进程渲染出来的位图, 渲染进程需要将生成好的位图发送到浏览器内核, 然后浏览器内核将位图复制到屏幕上. 操作系统没有将用户输入事件直接传递给渲染进程, 而是将这些事件传递给浏览器内核. 然后浏览器内核再根据当前浏览器界面的状态来判断如何调度这些事件, 如果当前焦点位于浏览器地址栏中, 则输入事件会在浏览器内核内部处理; 如果当前焦点在页面的区域内, 则浏览器内核会将输入事件转发给渲染进程.

## 站点隔离

所谓站点隔离(Site Isolation)是指 Chrome 将同一站点(包含了相同根域名和相同协议的地址)中相互关联的页面放到同一个渲染进程中执行.

最开始 Chrome 划分渲染进程是以标签页为单位, 也就是说整个标签页会被划分给某个渲染进程. 但每个标签里可能嵌入了 N 个不同的三方 iframe. 这些 iframe 又有可能来自于不同的站点, 这就导致了多个不同站点中的内容通过 iframe 同时运行在同一个渲染进程中.

目前所有操作系统都面临着两个 A 级漏洞——幽灵(Spectre)和熔毁(Meltdown), 这两个漏洞是由处理器架构导致的, 很难修补, 黑客通过这两个漏洞可以直接入侵到进程的内部, 如果入侵的进程没有安全沙箱的保护, 那么黑客还可以发起对操作系统的攻击.

所以如果一个银行站点包含了一个恶意 iframe, 然后这个恶意的 iframe 利用这两个 A 级漏洞去入侵渲染进程, 那么恶意程序就能读取银行站点渲染进程内的所有内容了, 这对于用户来说就存在很大的风险了.

因此 Chrome 几年前就开始重构代码, 将标签级的渲染进程重构为 iframe 级的渲染进程, 然后严格按照同一站点的策略来分配渲染进程, 这就是 Chrome 中的站点隔离. 实现了站点隔离, 就可以将恶意的 iframe 隔离在恶意进程内部, 使得它无法继续访问其他 iframe 进程的内容, 因此也就无法攻击其他站点了.

如下这个例子, iframe.html 和源标签页属于同一站点, 所以它会和源标签页运行在同一个渲染进程中. 其余三个 iframe 各会生成一个渲染进程.

```html
<head>
    <title>站点隔离:demo</title>
    <style>
        iframe {
            width: 800px;
            height: 300px;
        }
    </style>
</head>
<body>
    <div><iframe src=""iframe.html""></iframe></div>
    <div><iframe src=""https://a.com/""></iframe></div>
    <div><iframe src=""https://b.com/""></iframe></div>
    <div><iframe src=""https://c.com""></iframe></div>
</body>
</html>
```

## 任务的动态调度策略

我们知道, 在单消息队列架构下, 存在着低优先级任务会阻塞高优先级任务的情况, 也就是说会发生单消息队列的队头阻塞问题. 因此 Chhrome 提供多条队列, 给予不同的优先级来执行.

但这种也会有一个问题, 因为大多数任务需要保持其相对执行顺序, 比如说我们将用户输入的消息或者合成消息添加进多个不同优先级的队列中, 那么这种任务的相对执行顺序就会被打乱, 甚至有可能出现还未处理输入事件, 就合成了该事件要显示的图片. 因此 Chrome 根据消息类型来实现消息队列, 比如:

- 可以创建输入事件的消息队列, 用来存放输入事件.
- 可以创建合成任务的消息队列, 用来存放合成事件.
- 可以创建默认消息队列, 用来保存如资源加载的事件和定时器回调等事件.
- 还可以创建一个空闲消息队列, 用来存放 V8 的垃圾自动垃圾回收这一类实时性不高的事件.

但这种策略是静态的, 也就是在任何情况下都是输入事件优先, 其次是合成任务... 而我们知道, 页面大致的生存周期大体分为两个阶段, 加载阶段和交互阶段. 虽然在交互阶段, 采用上述这种静态优先级的策略没有什么太大问题的, 但是在页面加载阶段, 如果依然要优先执行用户输入事件和合成事件, 那么页面的解析速度将会被拖慢.

因此, 最终我们有了任务的动态调度策略, 可以看下图.

![动态调度策略](https://edge.yancey.app/beg/eghjlmdy-1651509559623.webp)

在页面加载阶段的场景, 用户的最高诉求是在尽可能短的时间内看到页面, 至于交互和合成并不是这个阶段的核心诉求, 因此我们需要调整策略, 在加载阶段将页面解析, JavaScript 脚本执行等任务调整为优先级最高的队列, 降低交互合成这些队列的优先级.

在交互阶段, 我们在 [\[HTTP 系列\] 第 6 篇 —— 从输入 URL 回车到页面呈现](https://www.yanceyleo.com/post/05daeef2-2caf-4ebe-89f0-2ad9cae286c4) 这篇文章聊到过在显卡中有一块叫着**前缓冲区**的地方, 这里存放着显示器要显示的图像, 显示器会按照一定的频率来读取这块前缓冲区, 并将前缓冲区中的图像显示在显示器上, 不同的显示器读取的频率是不同的, 通常情况下是 60HZ, 也就是说显示器会每间隔 1/60 秒就读取一次前缓冲区.

如果浏览器要更新显示的图片, 那么浏览器会将新生成的图片提交到显卡的后缓冲区中, 提交完成之后, GPU 会将后缓冲区和前缓冲区互换位置, 也就是前缓冲区变成了后缓冲区, 后缓冲区变成了前缓冲区, 这就保证了显示器下次能读取到 GPU 中最新的图片.

这时候我们会发现, 显示器从前缓冲区读取图片, 和浏览器生成新的图像到后缓冲区的过程是不同步的.

![VSync 时钟周期和渲染引擎生成图片不同步问题](https://edge.yancey.app/beg/9x0cf083-1651519904827.webp)

这种显示器读取图片和浏览器生成图片不同步, 容易造成众多问题.

- 如果渲染进程生成的帧速比屏幕的刷新率慢, 那么屏幕会在两帧中显示同一个画面, 当这种断断续续的情况持续发生时, 用户将会很明显地察觉到动画卡住了.
- 如果渲染进程生成的帧速率实际上比屏幕刷新率快, 那么也会出现一些视觉上的问题, 比如当帧速率在 100fps 而刷新率只有 60Hz 的时候, GPU 所渲染的图像并非全都被显示出来, 这就会造成丢帧现象.
- 就算屏幕的刷新频率和 GPU 更新图片的频率一样, 由于它们是两个不同的系统, 所以屏幕生成帧的周期和 VSync 的周期也是很难同步起来的.

为了解决这些问题, 就需要将显示器的时钟同步周期和浏览器生成页面的周期绑定起来, 当显示器将一帧画面绘制完成后, 并在准备读取下一帧之前, 显示器会发出一个垂直同步信号(vertical synchronization)给 GPU, 简称 VSync. 当 GPU 接收到 VSync 信号后, 会将 VSync 信号同步给浏览器进程, 浏览器进程再将其同步到对应的渲染进程, 渲染进程接收到 VSync 信号之后, 就可以准备绘制新的一帧了,

![绑定 VSync 时钟同步周期和浏览器生成页面周期](https://edge.yancey.app/beg/6elnrj5w-1651521002383.webp)

说了这么多, 目的就是要引出**当在执行用户交互的任务时, 将合成任务的优先级调整到最高**. 接下来, 处理完成 DOM, 计算好布局和绘制, 就需要将信息提交给合成线程来合成最终图片了, 然后合成线程进入工作状态. 现在的场景是合成线程在工作了, **那么我们就可以把下个合成任务的优先级调整为最低, 并将页面解析,定时器等任务优先级提升**.

在合成完成之后, 合成线程会提交给渲染主线程提交完成合成的消息, 如果当前合成操作执行的非常快, 比如从用户发出消息到完成合成操作只花了 8 毫秒, 因为 VSync 同步周期是 16.66 毫秒, 那么这个 VSync 时钟周期内就不需要再次生成新的页面了. 那么从合成结束到下个 VSync 周期内, 就进入了一个空闲时间阶段, 那么就可以在这段空闲时间内执行一些不那么紧急的任务, 比如 V8 的垃圾回收, 或者通过 `window.requestIdleCallback()` 设置的回调任务等, 都会在这段空闲时间内执行.

虽然动态调度策略已经很完美了, 那就是在某个状态下, 一直有新的高优先级的任务加入到队列中, 这样就会导致其他低优先级的任务得不到执行, 这称为任务饿死. Chromium 为了解决任务饿死的问题, 给每个队列设置了执行权重, 也就是如果连续执行了一定个数的高优先级的任务, 那么中间会执行一次低优先级的任务, 这样就缓解了任务饿死的情况.

所以说, 采用 setTimeout 来触发动画每帧的绘制, 那么其绘制时机是很难和 VSync 时钟保持一致的, 所以 JavaScript 中又引入了 window.requestAnimationFrame, 用来和 VSync 的时钟周期同步, rAF 的回调任务会在每一帧的开始执行.

再扯远一点, 这不就是 React Scheduler 的核心原理嘛, 有兴趣可以阅读我的另一篇文章 [深入""时间管理大师"" —— React Scheduler](https://www.yanceyleo.com/post/b55fde65-db55-4f9e-adb0-8bd7d194a56a)
","2025-02-02 03:09:14.165552","2025-02-02 03:09:14.165552"
"1df65a7c-7ae9-4e62-8f78-57f4f80edb92","{前端性能面面观}",0,0,False,"https://edge.yancey.app/beg/1z8pbzzp-1651259020678.jpg","前端性能面面观","总结了一波前端性能相关的东西, 包括 HTTP, 渲染级别的性能优化等等.","## 网络级别关键性能指标

### 延迟

延迟是指 IP 数据包从一个网络端点到另一个网络端点所花费的时间, 与之相关的是往返时延(RTT), 它延迟的时间的两倍. 延迟是制约 Web 性能的主要瓶颈, 尤其对于 HTTP 这样的协议, 因为其中包含大量往返于服务器的请求.

### 带宽

只要带宽没有饱和, 两个网络端点之间的连接会一次处理尽可能多的数据量. 依据 Web 页面引用资源的大小和网络连接的传输能力, 带宽可能会成为性能的瓶颈.

### DNS 查询

在客户端能够获取 Web 页面前, 它需要通过域名系统(DNS)把主机名称转换成 IP 地址获取的 HTML 页面中所引用的各个不同域名也需要转换; 幸运的是, 一个域名只需转换一次.

### 建立连接时间

在客户端和服务器之间建立连接需要往返数据应答, 称为""三次握手"". 握手时间一般与客户端和服务器之间的延迟有关. 握手过程包括客户端向服务器发起一个 SYN 包, 接着服务器返回对应 SYN 的 ACK 响应以及新的 SYN 包, 然后客户端返回对应的 ACK.

![三次握手](https://edge.yancey.app/beg/u5wog30b-1661145834037.png)

### TLS 协商时间

如果客户端发起 HTTPS 连接, 它还需要进行传输层安全协议(TLS)协商; TLS 用来取代安全套接层(SSL). 除了服务器和客户端的计算处理耗时之外, TLS 还会造成额外的往返传输.

上面这些, 客户端还没有真正发起 HTTP 请求, 却已经用掉了 DNS 查询的往返时间, 以及 TCP 和 TLS 的耗时. 下面的指标严重依赖于页面内容本身或服务器性能, 而不是网络.

### 首字节时间(TTFB)

TTFB 是指客户端从开始定位到 Web 页面, 至接收到主体页面响应的第一字节所耗费的时间. 它包含了之前提到的各种耗时, 还要加上服务器处理时间. 对于主体页面上的资源, TTFB 测量的是从浏览器发起请求至收到其第一字节之间的耗时.

### 内容下载时间

等同于被请求资源的最后字节到达时间(TTLB).

### 开始渲染时间

表示客户端的屏幕上什么时候开始显示内容. 这个指标测量的是用户看到空白页面的时长.

### 文档加载完成时间(又叫页面加载时间)

这是客户端浏览器认为页面加载完毕的时间.

## 当下与未来 Web 页面面临的问题

上面是 Web 性能的核心指标, 而互联网的发展趋势导致现在的网页资源越来越多, 以下几个日益增长的问题:

### 更多的字节

毫无疑问的是, Web 页面引用的内容每年都在增长, 图片越来越大, JavaScript 和 CSS 也越来越大. 内容体量变大意味着(客户端需要)下载更多的字节, 也意味着更长的页面加载时间.

### 更多的资源

页面引用的资源不仅变大, 而且数量也增多了. 引用更多的资源会导致总耗时增加, 因为所有的资源都需要获取并解析.

### 更高的复杂度

随着我们添加更多, 更丰富的功能, Web 页面和所依赖的资源正变得越来越复杂. 复杂度提升, 伴随而来的是计算渲染 Web 页面的时间不断延长, 尤其是在处理能力较弱 的移动设备上.

### 更多的域名

Web 页面并不是从单一的域名拉取下来的, 大多数 Web 页面会关联数十个域名. 每出现一个新域名都会增加 DNS 查询耗时, 建立连接耗时, 以及 TLS 协商耗时.

### 更多的 TCP socket

为了应对某些方面的增加, 客户端会对同一个域名开启多个 socket. 这增加了与域名对应的服务器协商建立连接的开销, 也加重了设备负担, 还有可能导致网络连接过载, 引发出错重传和缓存过满, 并降低有效带宽.

## 网络性能优化最佳实践

- **DNS 查询优化**: 比如使用 dns-prefetch;
- **TCP 优化**: 使用 preconnect; 通过使用 CDN, 大幅减少建立新连接的通信延迟; 实施最新的 TLS 最佳实践来优化 HTTPS;
- **避免重定向**: 重定向通常触发与额外域名建立连接, 增加耗时. 你可以通过利用 CDN 代替客户端在云端实现重定向; 如果是同一域名的重定向, 使用 Web 服务器上的 rewrite 规则, 避免重定向.
- **客户端缓存(强缓存)**: 不多说, 看 [\[HTTP 系列\] 第 3 篇 —— HTTP 缓存那些事](https://www.yanceyleo.com/post/89731d8e-5510-4094-8962-462b127ed5d0) 即可.
- **条件缓存(协商缓存)**: 不多说, 看 [\[HTTP 系列\] 第 3 篇 —— HTTP 缓存那些事](https://www.yanceyleo.com/post/89731d8e-5510-4094-8962-462b127ed5d0) 即可.
- **网络边缘的缓存**: 除了隐私和时间敏感性资源, 只要在多用户间可共享, 并且能够接受一定程度的旧数据, 都可以放到网络边缘的缓存. 哪怕即使仅仅缓存几秒或几分钟, 只要可以接受, 也可以缓存起来, 当需要更新, 手动刷新 CDN 即可.
- **压缩和代码极简化**: 源代码的压缩; Web 服务器 gzip 和 deflate, Brotli 的压缩.
- **避免阻塞 CSS/JS**: CSS 放 `<haed>`; JS 放 `<body>` 之后. script 标签用好 async, defer. 可以看 [关于 script 标签 async 和 defer 属性分析](https://yanceyleo.com/post/b6767e52-a557-45b1-8955-8ac5bd77ca02) 这篇文章.
- **图片优化**: 去掉图片元信息, 例如题材地理位置信息, 时间戳, 尺寸和像素信息; 避免图片过载, 也就是需要小图的地方放了个大图, 没必要.
- 
## HTTP/2 网络性能优化最佳实践

有一些在 HTTP/1.1 上的优化, 在 HTTP/2 反倒会起到反作用. 下面介绍一下.

![HTTP/1优化技巧, 以及HTTP/2的相关建议](https://edge.yancey.app/beg/4ndkd7rs-1661174594373.png)

### 雪碧图

在 HTTP/2 中, 针对特定资源的请求不再是阻塞式的, 很多请求可以并行处理; 于是就性能而言, 生成精灵图就失去意义了.

### 域名拆分(域名分片)

在 HTTP/1.1, 为了利用浏览器针对每个域名开启多个连接, 会将域名进行拆分(sharding). 但在由于 HTTP/2 没有限制并发请求(unlimited concurrent requests), 因此启用 HTTP/2 后, 就没必要再使用域名分片来解决并发限制了.

因此, 在 HTTP/2 上, 尽可能使用更少的域名, 反倒是更好的.

### 禁用 cookie 的域名

因为 cookie 是会被默认带上的, 在 HTTP/1.1 中, 由于没有头部压缩, 设置禁用 cookie 的域名是个合理的建议; 在在 HTTP/2 上, 由于首部是被压缩, 就无需禁用了.

## 用户对性能的感知

- 当用户请求一个网站时, 如果在 1 秒内看不到关键内容, 用户会产生任务被中断的感觉.
- 当用户点击某些按钮时, 如果 100ms 内无法响应, 用户会感受到延迟.
- 如果 Web 中的动画没有达到 60fps, 用户会感受到动画的卡顿.

## 页面生命周期的优化手段

通常一个页面有三个阶段: 加载阶段, 交互阶段和关闭阶段. 我们从这三个角度来分别讨论各自的优化点.

- 加载阶段, 是指从发出请求到渲染出完整页面的过程, 影响到这个阶段的主要因素有网络和 JavaScript 脚本.
- 交互阶段, 主要是从页面加载完成到用户交互的整合过程, 影响到这个阶段的主要因素是 JavaScript 脚本.
- 关闭阶段, 主要是用户发出关闭指令后页面所做的一些清理操作.

### 加载阶段

对于加载阶段, 抑或说从发起 URL 请求开始, 到首次显示页面的内容, 在视觉上又分为三个阶段:

第一个阶段, 等请求发出去之后, 到提交数据阶段, 这时页面展示出来的还是之前页面的内容. 详细内容仍然可以看[\[HTTP 系列\] 第 6 篇 —— 从输入 URL 回车到页面呈现](https://www.yanceyleo.com/post/05daeef2-2caf-4ebe-89f0-2ad9cae286c4)这篇文章的讲解.

第二个阶段, 提交数据之后渲染进程会创建一个空白页面, 我们通常把这段时间称为**解析白屏**, 并等待 CSS 文件和 JavaScript 文件的加载完成, 生成 CSSOM 和 DOM, 然后合成布局树, 最后还要经过一系列的步骤准备首次渲染.

第三个阶段, 等首次渲染完成之后, 就开始进入完整页面的生成阶段了, 然后页面会一点点被绘制出来.

影响第一个阶段的因素主要是网络或者是服务器处理这块儿, 这个不多说, 它主要跟服务端的质量有关. 提升服务器性能, 加一些像 redis 这样的缓存, 使用 CDN 等等都是好办法.

影响第二个阶段的主要问题是白屏时间, 如果白屏时间过久, 就会影响到用户体验. 为了缩短白屏时间, 我们来挨个分析这个阶段的主要任务, 包括了解析 HTML, 下载 CSS, 下载 JavaScript, 生成 CSSOM, 执行 JavaScript, 生成布局树, 绘制页面一系列操作. 通常情况下的瓶颈主要体现在下载 CSS 文件, 下载 JavaScript 文件和执行 JavaScript. 所以要想缩短白屏时长, 可以有以下策略:

- 通过内联 JavaScript, 内联 CSS 来移除这两种类型的文件下载, 这样获取到 HTML 文件之后就可以直接开始渲染流程了.
- 但并不是所有的场合都适合内联, 要避免大的内联脚本, 因为在解析 HTML 的过程中, 解析和编译也会占用主线程; 那么还可以尽量减少文件大小, 比如通过 webpack 等工具移除一些不必要的注释, 并压缩 JavaScript 文件.
- 还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 async 或者 defer.
- 对于大的 CSS 文件, 可以通过媒体查询属性, 将其拆分为多个不同用途的 CSS 文件, 这样只有在特定的场景下才会加载特定的 CSS 文件.

![加载阶段渲染流水线](https://edge.yancey.app/beg/bg9cn8mx-1651211554297.webp)

我们知道并非所有的资源都会阻塞页面的首次绘制, 比如图片, 音频, 视频等文件就不会阻塞页面的首次渲染; 而 JavaScript, 首次请求的 HTML 资源文件, CSS 文件是会阻塞首次渲染的, 因为在构建 DOM 的过程中需要 HTML 和 JavaScript 文件, 在构造渲染树的过程中需要用到 CSS 文件. 我们把这些能阻塞网页首次渲染的资源称为**关键资源**.

第一个是关键资源个数. 关键资源个数越多, 首次页面的加载时间就会越长. 比如上图中的关键资源个数就是 3 个, 1 个 HTML 文件, 1 个 JavaScript 和 1 个 CSS 文件.

第二个是关键资源大小. 通常情况下, 所有关键资源的内容越小, 其整个资源的下载时间也就越短, 那么阻塞渲染的时间也就越短. 上图中关键资源的大小分别是 6KB, 8KB 和 9KB, 那么整个关键资源大小就是 23KB.

第三个是请求关键资源需要多少个 RTT(Round Trip Time). 当使用 TCP 协议传输一个文件时, 比如这个文件大小是 0.1M, 由于 TCP 的特性, 这个数据并不是一次传输到服务端的, 而是需要拆分成一个个数据包来回多次进行传输的. RTT 就是这里的往返时延. 它是网络中一个重要的性能指标, 表示从发送端发送数据开始, 到发送端收到来自接收端的确认, 总共经历的时延. 通常 1 个 HTTP 的数据包在 14KB 左右, 所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了, 也就是说需要 8 个 RTT.

我们可以结合上图来看看它的关键资源请求需要多少个 RTT. 首先是请求 HTML 资源, 大小是 6KB, 小于 14KB, 所以 1 个 RTT 就可以解决了. 至于 JavaScript 和 CSS 文件, 这里需要注意一点, 由于渲染引擎有一个预解析的线程, 在接收到 HTML 数据之后, 预解析线程会快速扫描 HTML 数据中的关键资源, 一旦扫描到了, 会立马发起请求, 你可以认为 JavaScript 和 CSS 是同时发起请求的, 所以它们的请求是重叠的, 那么计算它们的 RTT 时, 只需要计算体积最大的那个数据就可以了. 这里最大的是 CSS 文件(9KB), 所以我们就按照 9KB 来计算, 同样由于 9KB 小于 14KB, 所以 JavaScript 和 CSS 资源也就可以算成 1 个 RTT. 也就是说, 上图中关键资源请求共花费了 2 个 RTT.

因此来说, 在加载阶段, 总的优化原则就是减少关键资源个数, 降低关键资源大小, 降低关键资源的 RTT 次数.

- 如何减少关键资源的个数? 一种方式是可以将 JavaScript 和 CSS 改成内联的形式, 比如上图的 JavaScript 和 CSS, 若都改成内联模式, 那么关键资源的个数就由 3 个减少到了 1 个. 另一种方式, 如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作, 则可以改成 async 或者 defer 属性; 同样对于 CSS, 如果不是在构建页面之前加载的, 则可以添加媒体取消阻止显现的标志. 当 JavaScript 标签加上了 async 或者 defer, CSSlink 属性之前加上了取消阻止显现的标志后, 它们就变成了非关键资源了.
- 如何减少关键资源的大小? 可以压缩 CSS 和 JavaScript 资源, 移除 HTML, CSS, JavaScript 文件中一些注释内容, 也可以通过前面讲的取消 CSS 或者 JavaScript 中关键资源的方式.
- 如何减少关键资源 RTT 的次数? 可以通过减少关键资源的个数和减少关键资源的大小搭配来实现. 除此之外, 还可以使用 CDN 来减少每次 RTT 时长.

### 交互阶段

谈交互阶段的优化, 其实就是在谈渲染进程渲染帧的速度, 因为在交互阶段, 帧的渲染速度决定了交互的流畅度. 因此交互阶段的页面优化实际上就是讨论渲染引擎是如何渲染帧的, 否则就无法优化帧率. 结合下面这张图片, 我们来一起回顾下交互阶段是如何生成一个帧的. 大部分情况下, 生成一个新的帧都是由 JavaScript 通过修改 DOM 或者 CSSOM 来触发的. 还有另外一部分帧是由 CSS 来触发的.

![交互阶段渲染流水线](https://edge.yancey.app/beg/u5hcj6e5-1651255789562.webp)

如果在计算样式阶段发现有布局信息的修改, 那么就会触发**重排**操作, 然后触发后续渲染流水线的一系列操作, 这个代价是非常大的. 同样如果在计算样式阶段没有发现有布局信息的修改, 只是修改了颜色一类的信息, 那么就不会涉及到布局相关的调整, 所以可以跳过布局阶段, 直接进入绘制阶段, 这个过程叫**重绘**. 不过重绘阶段的代价也是不小的. 还有另外一种情况, 通过 CSS 实现一些变形, 渐变, 动画等特效, 这是由 CSS 触发的, 并且是在合成线程上执行的, 这个过程称为**合成**. 因为它不会触发重排或者重绘, 而且合成操作本身的速度就非常快, 所以执行合成是效率最高的方式.

#### 减少 JavaScript 脚本执行时间

首先第一个优化方案是减少 JavaScript 脚本执行时间. 有时 JavaScript 函数的一次执行时间可能有几百毫秒, 这就严重霸占了主线程执行其他渲染任务的时间. 针对这种情况我们可以采用以下两种策略:

- 一种是将一次执行的函数分解为多个任务, 使得每次的执行时间不要过久.
- 另一种是采用 Web Workers, 把一些和 DOM 操作无关且耗时的任务放到 Web Workers 中去执行.

#### 避免强制同步布局

在介绍强制同步布局之前, 我们先来聊聊正常情况下的布局操作. 通过 DOM 接口执行添加元素或者删除元素等操作后, 是需要重新计算样式和布局的, 不过正常情况下这些操作都是在另外的任务中异步完成的, 这样做是为了避免当前的任务占用太长的主线程时间.

```html
<html>
  <body>
    <div id=""mian_div"">
      <li id=""time_li"">time</li>
      <li>geekbang</li>
    </div>
    <p id=""demo"">强制布局demo</p>
    <button onclick=""foo()"">添加新元素</button>
    <script>
      function foo() {
        let main_div = document.getElementById(""mian_div"");
        let new_node = document.createElement(""li"");
        let textnode = document.createTextNode(""time.geekbang"");
        new_node.appendChild(textnode);
        document.getElementById(""mian_div"").appendChild(new_node);
      }
    </script>
  </body>
</html>
```

对于上面这段代码, 我们可以使用 Performance 工具来记录添加元素的过程. 从图中可以看出来, 执行 JavaScript 添加元素是在一个任务中执行的, 重新计算样式布局是在另外一个任务中执行, 这就是正常情况下的布局操作.

![Performance 记录添加元素的执行过程](https://edge.yancey.app/beg/omo6mj80-1651256969251.webp)

而所谓强制同步布局, 是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中. 我们对上面的代码做了一点修改. 将新的元素添加到 DOM 之后, 我们又调用了 `main_div.offsetHeight` 来获取新 `main_div` 的高度信息. 如果要获取到 `main_div` 的高度, 就需要重新布局, 所以这里在获取到 `main_div` 的高度之前, JavaScript 还需要强制让渲染引擎默认执行一次布局操作. 从下图可以看出, 计算样式和布局都是在当前脚本执行过程中触发的, 这就是强制同步布局.

```ts
function foo() {
  let main_div = document.getElementById(""mian_div"");
  let new_node = document.createElement(""li"");
  let textnode = document.createTextNode(""time.geekbang"");
  new_node.appendChild(textnode);
  document.getElementById(""mian_div"").appendChild(new_node);
  // 由于要获取到 offsetHeight,
  // 但是此时的 offsetHeight 还是老的数据,
  // 所以需要立即执行布局操作
  console.log(main_div.offsetHeight);
}
```

![Performance 记录添加元素的执行过程](https://edge.yancey.app/beg/brwukra3-1651257138836.webp)

我们可以优化下这个例子, 由于查询 `main_div.offsetHeight` 跟它添加了子节点没关系, 所以我们可以在上面就先获取 `main_div` 的 offsetHeight 信息就好了.

```ts
function foo() {
  let main_div = document.getElementById(""mian_div"");
  // 挪到前面
  console.log(main_div.offsetHeight);
  let new_node = document.createElement(""li"");
  let textnode = document.createTextNode(""time.geekbang"");
  new_node.appendChild(textnode);
  document.getElementById(""mian_div"").appendChild(new_node);
}
```

#### 避免布局抖动

还有一种比强制同步布局更坏的情况, 那就是布局抖动. 所谓布局抖动, 是指在一次 JavaScript 执行过程中, 多次执行强制布局和抖动操作. 比如下面这个例子, 我们在一个 for 循环语句里面不断读取属性值, 每次读取属性值之前都要进行计算样式和布局, 这会大大影响当前函数的执行效率. 这种情况的避免方式和强制同步布局一样, 都是尽量不要在修改 DOM 结构时再去查询一些相关值.

```ts
function foo() {
  let time_li = document.getElementById(""time_li"");
  for (let i = 0; i < 100; i++) {
    let main_div = document.getElementById(""mian_div"");
    let new_node = document.createElement(""li"");
    let textnode = document.createTextNode(""time.geekbang"");
    new_node.appendChild(textnode);
    new_node.offsetHeight = time_li.offsetHeight;
    document.getElementById(""mian_div"").appendChild(new_node);
  }
}
```

![Performance 中关于布局抖动的表现](https://edge.yancey.app/beg/6hgbrnvt-1651257536697.webp)

#### 合理利用 CSS 合成动画

我们在[\[HTTP 系列\] 第 6 篇 —— 从输入 URL 回车到页面呈现](https://www.yanceyleo.com/post/05daeef2-2caf-4ebe-89f0-2ad9cae286c4)这篇文章讲到了分层, 分块, 光栅化等等. 其实有一些技巧来利用分层技术优化代码.

在写 Web 应用的时候, 你可能经常需要对某个元素做几何形状变换, 透明度变换或者一些缩放操作, 如果使用 JavaScript 来写这些效果, 会牵涉到整个渲染流水线, 所以 JavaScript 的绘制效率会非常低下. 这时你可以使用 will-change 来告诉渲染引擎你会对该元素做一些特效变换, CSS 代码如下:

```scss
.box {
  will-change: transform, opacity;
}
```

这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作, 这时候渲染引擎会将该元素单独实现一帧, 等这些变换发生时, 渲染引擎会通过合成线程直接去处理变换, 这些变换并没有涉及到主线程, 这样就大大提升了渲染的效率. 这也是 CSS 动画比 JavaScript 动画高效的原因.

所以, 如果涉及到一些可以使用合成线程来处理 CSS 特效或者动画的情况, 就尽量使用 will-change 来提前告诉渲染引擎, 让它为该元素准备独立的层. 但是凡事都有两面性, 每当渲染引擎为一个元素准备一个独立层的时候, 它占用的内存也会大大增加, 因为从层树开始, 后续每个阶段都会多一个层结构, 这些都需要额外的内存, 所以你需要恰当地使用 will-change.

#### 避免频繁的垃圾回收

我们知道 JavaScript 使用了自动垃圾回收机制, 如果在一些函数中频繁创建临时对象, 那么垃圾回收器也会频繁地去执行垃圾回收策略. 这样当垃圾回收操作发生时, 就会占用主线程, 从而影响到其他任务的执行, 严重的话还会让用户产生掉帧, 不流畅的感觉. 所以要尽量避免产生那些临时垃圾数据, 可以尽可能优化储存结构, 尽可能避免小颗粒对象的产生.

## Chrome 开发者工具

工欲善其事, 必先利其器. 要想对网页的性能状况有系统的认知, 首先要求我们能够熟练使用 Chrome 开发者工具, Chrome 开发者工具为我们提供了通过界面访问或者编辑 DOM 和 CSSOM 的能力, 还提供了强大的调试功能和查看性能指标的能力. 它一共包含了 10 个功能面板, 包括了 Elements, Console, Sources, NetWork, Performance, Memory, Application, Security, Audits 和 Layers. 下图是这十个 Tab 的具体功能. 我们在本篇文章中着重讲 NetWork 和 Performance.

![十个 Tab 的具体功能](https://edge.yancey.app/beg/96hc3cmj-1650732264469.webp)

## 网络面板

网络面板由控制器, 过滤器, 抓图信息, 时间线, 详细列表和下载信息概要这 6 个区域构成.

![网络面板](https://edge.yancey.app/beg/9vqt2trv-1650736950606.webp)

### 控制器

- 红色圆点的按钮, 表示**开始 / 暂停抓包**.
- **全局搜索**按钮, 这个功能就非常重要了, 可以在所有下载资源中搜索相关内容, 还可以快速定位到某几个你想要的文件上.
- Disable cache, 即**禁止从 Cache 中加载资源**的功能, 它在调试 Web 应用的时候非常有用, 因为开启了 Cache 会影响到网络性能测试的结果.
- Online 按钮, 是**模拟 2G/3G**功能, 它可以限制带宽, 模拟弱网情况下页面的展现情况, 然后你就可以根据实际展示情况来动态调整策略, 以便让 Web 应用更加适用于这些弱网.
- 
![控制器](https://edge.yancey.app/beg/6t6zeyao-1650737030718.webp)

### 过滤器

网络面板中的过滤器, 主要就是起过滤功能. 因为有时候一个页面有太多内容在详细列表区域中展示了, 而你可能只想查看 JavaScript 文件或者 CSS 文件, 这时候就可以通过过滤器模块来筛选你想要的文件类型.

### 抓图信息

抓图信息区域可以用来分析用户等待页面加载时间内所看到的内容, 分析用户实际的体验情况. 比如, 如果页面加载 1 秒多之后屏幕截图还是白屏状态, 这时候就需要分析是网络还是代码的问题了. (勾选面板上的 **Capture screenshots** 即可启用屏幕截图)

#### 时间线

时间线主要用来展示 HTTP, HTTPS, WebSocket 加载的状态和时间的一个关系, 用于直观感受页面的加载过程. 如果是多条竖线堆叠在一起, 那说明这些资源被同时被加载. 至于具体到每个文件的加载信息, 还需要用到下面要讲的详细列表.

### 详细列表
这个区域是最重要的, 它详细记录了每个资源从发起请求到完成请求这中间所有过程的状态, 以及最终请求完成的数据信息. 通过该列表, 你就能很容易地去诊断一些网络问题.

#### 列表的属性

列表的属性包括 Name, Status, Type, Initiator 等等, 支持拖拽排序.

![列表的属性](https://edge.yancey.app/beg/ydzsjlto-1650737426441.webp)

#### 详细信息

详细信息可以看到请求列表中任意一项的请求行和请求头信息, 还可以查看响应行, 响应头和响应体等等.

![详细信息](https://edge.yancey.app/beg/xfp5l92w-1650737588143.webp)

#### 单个资源的时间线

了解了每个资源的详细请求信息之后, 我们再来分析单个资源请求时间线, 这就涉及具体的 HTTP 请求流程了. 我们简单回顾一下这个流程: 我们介绍过发起一个 HTTP 请求之后, 浏览器首先查找缓存, 如果缓存没有命中, 那么继续发起 DNS 请求获取 IP 地址, 然后利用 IP 地址和服务器端建立 TCP 连接, 再发送 HTTP 请求, 等待服务器响应; 不过, 如果服务器响应头中包含了重定向的信息, 那么整个流程就需要重新再走一遍. 而这个流程的可视化就通过时间线面板可以很好的展示出来.

![Timing](https://edge.yancey.app/beg/b0nuizzd-1650739688934.webp)

第一个是 **Queuing**, 也就是排队的意思, 当浏览器发起一个请求的时候, 会有很多原因导致该请求不能被立即执行, 而是需要排队等待. 导致请求处于排队状态的原因有很多:

- 首先, 页面中的资源是有优先级的, 比如 CSS, HTML, JavaScript 等都是页面中的核心文件, 所以优先级最高; 而图片, 视频, 音频这类资源就不是核心资源, 优先级就比较低. 通常当后者遇到前者时, 就需要**让路**, 进入待排队状态.
- 其次, 我们前面也提到过, 浏览器会为每个域名最多维护 6 个 TCP 连接, 如果发起一个 HTTP 请求时, 这 6 个 TCP 连接都处于忙碌状态, 那么这个请求就会处于排队状态.
- 最后, 网络进程在为数据分配磁盘空间时, 新的 HTTP 请求也需要短暂地等待磁盘分配结束.

等待排队完成之后, 就要进入发起连接的状态了. 不过在发起连接之前, 还有一些原因可能导致连接过程被推迟, 这个推迟就表现在面板中的 **Stalled** 上, 它表示停滞的意思.

如果你使用了代理服务器, 还会增加一个 **Proxy Negotiation** 阶段, 也就是代理协商阶段, 它表示代理服务器连接协商所用的时间, 不过在上图中没有体现出来, 因为这里我们没有使用代理服务器.

接下来, 就到了 **Initial connection/SSL** 阶段了, 也就是和服务器建立连接的阶段, 这包括了建立 TCP 连接所花费的时间; 不过如果你使用了 HTTPS 协议, 那么还需要一个额外的 SSL 握手时间, 这个过程主要是用来协商一些加密信息的.

和服务器建立好连接之后, 网络进程会准备请求数据, 并将其发送给网络, 这就是 **Request sent** 阶段. 通常这个阶段非常快, 因为只需要把浏览器缓冲区的数据发送出去就结束了, 并不需要判断服务器是否接收到了, 所以这个时间通常不到 1 毫秒.

数据发送出去了, 接下来就是等待接收服务器第一个字节的数据, 这个阶段称为 **Waiting (TTFB)**, 通常也称为**第一字节时间**. TTFB 是反映服务端响应速度的重要指标, 对服务器来说, TTFB 时间越短, 就说明服务器响应越快.

接收到第一个字节之后, 进入陆续接收完整数据的阶段, 也就是 **Content Download** 阶段, 这意味着从第一字节时间到接收到全部响应数据所用的时间.

### 优化时间线上耗时项

下面我们针对 Timing 的每个项目针对性地进行优化.

#### 排队时间过久

排队时间过久, 大概率是由浏览器为每个域名最多维护 6 个连接导致的, 在 HTTP/1 的时候可以使用**域名分片**技术, 即将网络资源分散到多个域名下, 就可以减少单域名的连接数量. 当然你升到 HTTP/2 之后就无需 care 这件事情了.

#### TTFB 时间过久

TTFB 时间过久大概率由以下几个原因构成:

- **服务器生成页面数据的时间过久**. 对于动态网页来说, 服务器收到用户打开一个页面的请求时, 首先要从数据库中读取该页面需要的数据, 然后把这些数据传入到模板中, 模板渲染后, 再返回给用户. 服务器在处理这个数据的过程中, 可能某个环节会出问题.
- **网络的原因**. 比如使用了低带宽的服务器, 或者本来用的是电信的服务器, 可联通的网络用户要来访问你的服务器, 这样也会拖慢网速.
- **发送请求头时带上了多余的用户信息**. 比如一些不必要的 Cookie 信息, 服务器接收到这些 Cookie 信息之后可能需要对每一项都做处理, 这样就加大了服务器的处理时长.

面对第一种服务器的问题, 你可以想办法去提高服务器的处理速度, 比如通过增加各种缓存的技术; 针对第二种网络问题, 你可以使用 CDN 来缓存一些静态文件; 至于第三种, 你在发送请求时就去尽可能地减少一些不必要的 Cookie 数据信息.

#### Content Download 时间过久

如果单个请求的 Content Download 花费了大量时间, 有可能是字节数太多的原因导致的. 这时候你就需要减少文件大小, 比如压缩, 去掉源码中不必要的注释等方法.

### 下载信息概要

一般关注 DOMContentLoaded 和 Load 两个事件.

- DOMContentLoaded 这个事件发生后, 说明页面已经构建好 DOM 了, 这意味着构建 DOM 所需要的 HTML 文件, JavaScript 文件, CSS 文件都已经下载完成了.
- Load 事件说明浏览器已经加载了所有的资源(图像, 样式表等).

## 性能指标

- FP(First Paint) 首次绘制, 即渲染进程拿到下载好的 HTML 数据开始进行 DOM 解析
- FCP(First Contentful Paint) 首次绘制内容
- FMP(First Meaningful Paint) 首次有意义的绘制
- TBT(Total Blocking Time) 第一次有内容的绘制(FCP)和交互(TTI)之间的总时间
- TTI(Time To Interactive) 可交互时间: 应用在视觉上都已渲染出了, 完全可以响应用户的输入
- FCI(First CPU Idle) 首次 CPU 空闲时间: 代表着一个网页已经满足了最小程度的与用户发生交互行为的时刻
- FPS(Frames Per Second) 每秒帧率
- TTFB(Time to first byte) 发出页面请求到接收到应答数据第一个字节所花费的毫秒数
- LCP(Largest Contentful Paint) 最大内容绘制, 即首屏内容完全绘制完成时, 应小于 2.5s
- FID(First Input Delay) 首次输入延迟
- CLS(Cumulative Layout Shift) CLS 度量在页面的整个生命周期中发生的每个意外布局更改的所有单独布局更改得分的总和

![7041b4d913a12d4d53041e8ed8b30499.webp](https://edge.yancey.app/beg/pbauqn1t-1651523211952.webp)

## performance.timing

```ts
let times = {};
let t = window.performance.timing;
// 重定向时间
times.redirectTime = t.redirectEnd - t.redirectStart;
// DNS 查询耗时
times.dnsTime = t.domainLookupEnd - t.domainLookupStart;
// TTFB 读取页面第一个字节的时间
times.ttfbTime = t.responseStart - t.navigationStart;
// DNS 缓存时间
times.appcacheTime = t.domainLookupStart - t.fetchStart;
// 卸载页面的时间
times.unloadTime = t.unloadEventEnd - t.unloadEventStart;
// TCP 连接耗时
times.tcpTime = t.connectEnd - t.connectStart;
// request 请求耗时
times.reqTime = t.responseEnd - t.responseStart;
// 解析 DOM 树耗时
times.analysisTime = t.domComplete - t.domInteractive;
// 白屏时间
times.blankTime = t.domLoading - t.navigationStart;
// domReadyTime
times.domReadyTime = t.domContentLoadedEventEnd - t.fetchStart;
```

## PWA

普通网页的缺陷:

- 首先, Web 应用缺少离线使用能力, 在离线或者在弱网环境下基本上是无法使用的. 而用户需要的是沉浸式的体验, 在离线或者弱网环境下能够流畅地使用是用户对一个应用的基本要求.
- 其次, Web 应用还缺少了消息推送的能力, 因为作为一个 App 厂商, 需要有将消息送达到应用的能力.
- 最后, Web 应用缺少一级入口, 也就是将 Web 应用安装到桌面, 在需要的时候直接从桌面打开 Web 应用, 而不是每次都需要通过浏览器来打开.

针对以上 Web 缺陷, PWA 提出了两种解决方案: 通过引入 Service Worker 来试着解决离线存储和消息推送的问题, 通过引入 manifest.json 来解决一级入口的问题.

Service Worker 的主要思想是在页面和网络之间增加一个拦截器, 用来缓存和拦截请求. 在没有安装 Service Worker 之前, WebApp 都是直接通过网络模块来请求资源的. 安装了 Service Worker 模块之后, WebApp 请求资源时, 会先通过 Service Worker, 让它判断是返回 Service Worker 缓存的资源还是重新去网络请求资源. 一切的控制权都交由 Service Worker 来处理.

我们知道 JavaScript 和页面渲染流水线的任务都是在页面主线程上执行的, 如果一段 JavaScript 执行时间过久, 那么就会阻塞主线程, 使得渲染一帧的时间变长, 从而让用户产生卡顿的感觉.

为了避免 JavaScript 过多占用页面主线程时长的情况, 浏览器实现了 Web Worker 的功能. Web Worker 的目的是让 JavaScript 能够运行在页面主线程之外, 不过由于 Web Worker 中是没有当前页面的 DOM 环境的, 所以在 Web Worker 中只能执行一些和 DOM 无关的 JavaScript 脚本, 并通过 postMessage 方法将执行的结果返回给主线程. 所以说在 Chrome 中, Web Worker 其实就是在渲染进程中开启的一个新线程, 它的生命周期是和页面关联的.

不过 Web Worker 是临时的, 每次 JavaScript 脚本执行完成之后都会退出, 执行结果也不能保存下来, 如果下次还有同样的操作, 就还得重新来一遍. 所以 Service Worker 需要在 Web Worker 的基础之上加上储存功能.

另外, 由于 Service Worker 还需要会为多个页面提供服务, 所以还不能把 Service Worker 和单个页面绑定起来. 在目前的 Chrome 架构中, Service Worker 是运行在浏览器进程中的, 因为浏览器进程生命周期是最长的, 所以在浏览器的生命周期内, 能够为所有的页面提供服务.

![PWA](https://edge.yancey.app/beg/z3o4jq6k-1650722871655.webp)

## 图片选型

### JPEG(Joint Photographic Experts Group)

JPEG(联合图像专家小组), 是一种针对彩色照片而广泛使用的**有损**压缩图形格式, 它是一种栅格图形.

它适合颜色丰富的照片、彩色图, 大焦点图、通栏 banner 图; 结构不规则的图. 但它不适合线条图形和文字、图标图形, 并且不支持透明度.

### PNG(Portable Network Graphics)

PNG(便携式网络图形)是一种**无损**压缩的栅格图形格式, 支持索引、灰度、RGB 三种颜色方案以及 Alpha 通道等特性. 最高支持 24 位彩色图像(PNG-24)和 8 位灰度图像(PNG-8).

它适合纯色、透明、线条绘图, 图标; 边缘清晰、有大块相同颜色区域; 颜色数较少, 但需要半透明. 由于是无损压缩, 对于颜色丰富的大图不友好.

### GIF(Graphics Interchange Format)

GIF(图像互换格式)是一种栅格图形文件格式, 以 8 位色(即 256 种颜色)重现真彩色的图像, 支持完全透明和完全不透明, 采用 LZW 压缩算法进行编码.

它适合一些动画, 动态图标. 但由于是个像素只有 8 比特, 不适合存储彩色图片.

### Webp

Webp 可为图像提供无损压缩和有损压缩, 优秀算法能同时保证一定程序上的图像质量和比较小的体积; 可以插入多帧, 实现动画效果; 可以设置透明度; 采用 8 位压缩算法. 无损的 Webp 比 PNG 小 26%, 有损的 Webp 比 JPEG 小 25-34％, 比 GIF 有更好的动画.

## 图片加载策略

### 图片懒加载

图片出现在视口时再加载.

### 响应式图片

```html
<picture>
  <source media=""(max-width: 799px)"" srcset=""elva-480w-close-portrait.jpg"" />
  <source media=""(min-width: 800px)"" srcset=""elva-800w.jpg"" />
  <img src=""elva-800w.jpg"" alt=""Chris standing up holding his daughter Elva"" />
</picture>
```

### 逐步加载图像

- 使用统一占位符
- 使用 LQIP(Low Quality Image Placeholders), 低质量图像占位符
- 使用 SQIP(SVG Quality Image Placeholders), SVG 图像占位符

## CSS 优化

CSS 样式文件链接尽量放在页面头部. CSS 加载不会阻塞 DOM tree 解析, 但是会阻塞 DOM Tree 渲染, 也会阻塞后面 JS 执行. 任何 body 元素之前, 可以确保在文档部分中解析了所有 CSS 样式(内联和外联), 从而减少了浏览器必须重排文档的次数. 如果放置页面底部, 就要等待最后一个 CSS 文件下载完成, 此时会出现""白屏"", 影响用户体验.

## 总结

![前端性能优化](https://edge.yancey.app/beg/quaky10q-1650778952349.png)","2025-02-02 03:09:15.662905","2025-02-02 03:09:15.662905"
"16963e2f-8d0a-4a8c-8a9d-a89cc438ab75","{HTTP}",0,0,False,"https://edge.yancey.app/beg/wmz3n7j7-1651443449297.jpg","[HTTP 系列] 第 5 篇 —— 网络安全"," 这里是《写给前端工程师的 HTTP 系列》, 记得有位大佬曾经说过: 大厂前端面试对 HTTP 的要求比 CSS 还要高, 由此可见 HTTP 的重要程度不可小视. 文章写作计划如下, 视情况可能有一定的删减, 本篇是该系列的第 5 篇 —— 网络安全.","- [\[HTTP 系列\] 第 1 篇 —— 从 TCP/UDP 到 DNS 解析](https://www.yanceyleo.com/post/3a9d3d47-9977-4579-a756-4bf5af4a3fd4)
- [\[HTTP 系列\] 第 2 篇 —— HTTP 协议那些事](https://www.yanceyleo.com/post/efd566e9-4ee3-4ee2-8448-628414659480)
- [\[HTTP 系列\] 第 3 篇 —— HTTP 缓存那些事](https://www.yanceyleo.com/post/89731d8e-5510-4094-8962-462b127ed5d0)
- [\[HTTP 系列\] 第 4 篇 —— HTTPS](https://www.yanceyleo.com/post/f976717f-9e40-4849-a73f-86c63c0c45e1)
- [\[HTTP 系列\] 第 5 篇 —— 网络安全](https://www.yanceyleo.com/post/953ccf20-7f3b-4d3f-816e-b6e98b26a4da)
- [\[HTTP 系列\] 第 6 篇 —— 从输入 URL 回车到页面呈现](https://www.yanceyleo.com/post/05daeef2-2caf-4ebe-89f0-2ad9cae286c4)

## 同源策略

如果两个 URL 的协议, 域名和端口都相同, 我们就称这两个 URL 同源. 浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的. 两个不同的源之间若想要相互访问资源或者操作 DOM, 那么会有一套基础的安全策略的制约, 我们把这称为同源策略. 具体来讲, 同源策略主要表现在 DOM, Web 数据和网络这三个层面.

同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作. 如果是同源的页面, 它们之间可以相互操作 DOM, 否则无法相互操作 DOM. 因为如果任何三方都可以插入一段脚本, 恶意篡改 DOM 和恶意操作 DOM, 那么就会导致网站的安全问题, 这也就是所谓的 XSS, 下面会讲到. 有时候我们经常需要两个不同源的 DOM 之间进行通信, 于是浏览器中又引入了跨文档消息机制, 可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信.

在数据层面, 同源策略限制了不同源的站点读取当前站点的 Cookie, IndexDB, LocalStorage 等数据. 由于同源策略, 我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie, IndexDB 或者 LocalStorage 等内容. 同样的, 如果不限制脚本的插入, 恶意脚本可以轻松的获取到 Cookie, IndexDB 或者 LocalStorage 等数据. 关于 cookie 的详细内容可以看 [\[HTTP 系列\] 第 2 篇 —— HTTP 协议那些事](https://www.yanceyleo.com/post/efd566e9-4ee3-4ee2-8448-628414659480) 这篇文章, 里面讲到了诸如 httpOnly, secure, signed, sameSite 等 cookie 的特性.

在网络层面, 同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点.

## CORS

上面说到同源策略保证了在网络层面, 非同源 URL 不可以发送请求, 这也就是所谓的跨域. 跨域针对的是那些复杂请求, 首先我们来区分下简单请求和复杂请求.

简单请求的请求方法是以下三种方法之一:

- HEAD
- GET
- POST

并且 HTTP 的头信息不超出以下几种字段:

- Accept
- Accept-Language
- Content-Language
- Last-Event-ID
- Content-Type: 只限于三个值 application/x-www-form-urlencoded, multipart/form-data, text/plain

凡是不同时满足上面两个条件, 就属于非简单请求.

但现实情况下, 这大大限制了生产力, 比如我的网站的后端服务是 `https://api.yanceyleo.com`, 而前端网站是 `https://yanceyleo.com`, 这就造成了跨域. 为了解决这个问题, 你可以在后端配置 CORS, 以使用 nodejs 的中间件为例:

```ts
app.enableCors({
  origin: [/\.?yanceyleo\.com$/, /\.?yancey\.app$/],
  methods: ""GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS"",
  credentials: true,
  preflightContinue: false,
  optionsSuccessStatus: 204,
  allowedHeaders: ""*"",
});
```

对于复杂请求, 浏览器会发送一个 OPTIONS 的预检请求, 如果服务器支持, 就会返回一个响应, 否则就会返回一个错误. OPTIONS 请求与 HEAD 类似, 一般也是用于客户端查看服务器的性能. 这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法, 该方法会用'\*'来代替资源名称, 向服务器发送 OPTIONS 请求, 可以测试服务器功能是否正常. JavaScript 的 XMLHttpRequest 对象进行 CORS 跨域资源共享时, 就是使用 OPTIONS 方法发送嗅探请求, 以判断是否有对指定资源的访问权限.

关于更多解决[跨域](https://mp.weixin.qq.com/s/OC9yEU6JasHxXH_M2b6bHA)问题的思路可以看这篇文章.

## HTTP 劫持

大多数情况是运营商 HTTP 劫持, 当我们使用 HTTP 请求请求一个网站页面的时候, 网络运营商会在正常的数据流中插入精心设计的网络数据报文, 让客户端(通常是浏览器)展示错误的数据, 通常是一些弹窗, 宣传性广告或者直接显示某网站的内容, 大家应该都有遇到过.

## DNS 劫持

DNS 劫持就是通过劫持了 DNS 服务器, 通过某些手段取得某域名的解析记录控制权, 进而修改此域名的解析结果, 导致对该域名的访问由原 IP 地址转入到修改后的指定 IP, 其结果就是对特定的网址不能访问或访问的是假网址, 从而实现窃取资料或者破坏原有正常服务的目的. DNS 劫持比之 HTTP 劫持更加过分, 简单说就是我们请求的是 `http: //www.a.com/index.html` , 直接被重定向了 `http: //www.b.com/index.html`.

## 跨站脚本攻击

XSS 全称是 Cross Site Scripting, 为了与 CSS 区分开来, 故简称 XSS. XSS 是一种常见的 web 安全漏洞, 它允许攻击者将恶意代码植入到提供给其它用户使用的页面中. 它可以造成如下几种危害:

- 可以窃取 Cookie 信息. 恶意 JavaScript 可以通过 **document.cookie** 获取 Cookie 信息, 然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器; 恶意服务器拿到用户的 Cookie 信息之后, 就可以在其他电脑上模拟用户的登录, 然后进行转账等操作. 可以监听用户行为. 恶意 JavaScript
- 可以使用 **addEventListener** 接口来监听键盘事件, 比如可以获取用户输入的信用卡等信息, 将其发送到恶意服务器. 黑客掌握了这些信息之后, 又可以做很多违法的事情.
- 可以通过修改 DOM 伪造假的登录窗口, 用来欺骗用户输入用户名和密码等信息. 还可以在页面内生成浮窗广告, 这些广告会严重地影响用户体验.

### 跨站脚本攻击的形式

通常情况下, 主要有存储型 XSS 攻击、反射型 XSS 攻击和基于 DOM 的 XSS 攻击三种方式来注入恶意脚本.

- 存储型 XSS: 用户私信/网站评论里面用户输入了恶意代码, 被提交到了数据库, 在请求接口后渲染时造成 XSS

- 反射型 XSS: 用户将一段含有恶意代码的 URL 提交给 Web 服务器, Web 服务器接收到请求时, 又将恶意代码反射给了浏览器端

- DOM 型: 前端代码不严谨, 导致如使用 innerHTML 时插入了不安全的代码, 或者遭受了 HTTP 劫持 或者 DNS 劫持

### 如何防止跨站脚本攻击

- 服务器对输入脚本进行过滤或转码, 过滤特殊字符 `/[""'&<>]/`
- 开启 httpOnly(很多 xss 的目的就是为了获取 cookies)
- 充分利用 CSP, 限制加载其他域下的资源文件, 禁止向第三方域提交数据, 禁止执行内联脚本和未授权的脚本

![httpOnly](https://edge.yancey.app/beg/rc99ktp0-1651441086509.jpg)

## CSRF 跨站请求伪造

CSRF 英文全称是 Cross-site request forgery, 是指黑客引诱用户打开黑客的网站, 在黑客的网站中, 利用用户的登录状态发起的跨站请求. 简单来讲, CSRF 攻击就是黑客利用了用户的登录状态, 并通过第三方的站点来做一些坏事, 和 XSS 不同的是, CSRF 攻击不需要将恶意代码注入用户的页面, 仅仅是利用服务器的漏洞和用户的登录状态来实施攻击. 它的攻击有两种形式.

### 跨站请求伪造的形式

第一种是通过 GET 请求的漏洞:

- 受害者登录合法网站 a.com, 并保留了登录凭证(Cookie).
- 攻击者引诱受害者访问了黑客网站 b.com.
- b.com 向 a.com 发送了一个请求: a.com/act=xx.浏览器会默认携带 a.com 的 Cookie.
- a.com 接收到请求后, 对请求进行验证, 并确认是受害者的凭证, 误以为是受害者自己发送的请求.
- a.com 以受害者的名义执行了 act=xx.
- 攻击完成, 攻击者在受害者不知情的情况下, 冒充受害者, 让 a.com 执行了自己定义的操作.

第二种是通过 POST 请求的漏洞, 也就是伪造表单:

```html
<!DOCTYPE html>
<html>
  <body>
    <h1>黑客的站点, CSRF攻击演示</h1>
    <form
      id=""hacker-form""
      action=""https://time.geekbang.org/sendcoin""
      method=""POST""
    >
      <input type=""hidden"" name=""user"" value=""hacker"" />
      <input type=""hidden"" name=""number"" value=""100"" />
    </form>
    <script>
      document.getElementById(""hacker-form"").submit();
    </script>
  </body>
</html>
```

### 如何防止 CSRF 攻击

CSRF 攻击的根本原因是服务器的漏洞, 发起 CSRF 攻击有三大必要条件:

- 目标站点一定要有 CSRF 漏洞;
- 用户要登录过目标站点, 并且在浏览器上保持有该站点的登录状态;
- 需要引诱用户打开一个第三方站点, 可以是黑客的站点, 也可以是一些论坛.

第一个方案是充分利用好 Cookie 的 SameSite 属性, 我们知道黑客会利用用户的登录状态来发起 CSRF 攻击, 而 Cookie 正是浏览器和服务器之间维护登录状态的一个关键数据, SameSite 属性只允许同站点的 Cookie 访问, 即:

- 如果是从第三方站点发起的请求, 那么需要浏览器禁止发送某些关键 Cookie 数据到服务器;
- 如果是同一个站点发起的请求, 那么就需要保证 Cookie 数据正常发送.

SameSite 选项通常有 Strict、Lax 和 None 三个值:

- Strict 最为严格. 如果 SameSite 的值是 Strict, 那么浏览器会完全禁止第三方 Cookie. 简言之, 如果你从极客时间的页面中访问 InfoQ 的资源, 而 InfoQ 的某些 Cookie 设置了 SameSite = Strict 的话, 那么这些 Cookie 是不会被发送到 InfoQ 的服务器上的. 只有你从 InfoQ 的站点去请求 InfoQ 的资源时, 才会带上这些 Cookie.
- Lax 相对宽松一点. 在跨站点的情况下, 从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie. 但如果在第三方站点中使用 Post 方法, 或者通过 img、iframe 等标签加载的 URL, 这些场景都不会携带 Cookie
- 而如果使用 None 的话, 在任何情况下都会发送 Cookie 数据.

第二个方案是验证请求的来源站点, 也就是使用 HTTP 请求头中的 Referer 和 Origin 属性. Referer 是 HTTP 请求头中的一个字段, 记录了该 HTTP 请求的来源地址, 而 Origin 记录了该 HTTP 请求的来源站点的地址. 从下图可以看出, Origin 属性只包含了域名信息, 并没有包含具体的 URL 路径, 这是 Origin 和 Referer 的一个主要区别. 服务器的策略是优先判断 Origin, 如果请求头中没有包含 Origin 属性, 再根据实际情况判断是否使用 Referer 值.

![Referer 和 Origin](https://edge.yancey.app/beg/3gyli4sp-1651442617493.webp)

第三个方案是 CSRF Token, 这是针对上面 POST 请求漏洞的一个做法. 第一步在浏览器向服务器发起请求时, 服务器生成一个 CSRF Token. CSRF Token 其实就是服务器生成的字符串, 然后将该字符串植入到返回的页面中. 第二步, 在浏览器端如果要发起转账的请求, 那么需要带上页面中的 CSRF Token, 然后服务器会验证该 Token 是否合法. 如果是从第三方站点发出的请求, 那么将无法获取到 CSRF Token 的值, 所以即使发出了请求, 服务器也会因为 CSRF Token 不正确而拒绝请求.

以前年轻时写 Django 的时候它会自动给表单带上 CSRF Token, 不过这种做法只能针对服务端渲染的页面, SPA 就没办法了.

```ts
<!DOCTYPE html>
<html>
<body>
    <form action=""https://time.geekbang.org/sendcoin"" method=""POST"">
      <input type=""hidden"" name=""csrf-token"" value=""nc98P987bcpncYhoadjoiydc9ajDlcn"">
      <input type=""text"" name=""user"">
      <input type=""text"" name=""number"">
      <input type=""submit"">
    </form>
</body>
</html>
```

## 洪泛攻击

在三次握手过程中. 服务器发送 SYN-ACK 之后. 收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect). 此时服务器处于 SYN_RCVD 状态. 当收到 ACK 后. 服务器才能转入 ESTABLISHED 状态.

所以在短时间内伪造大量的不存在的 IP. 向服务器不断发送 SYN 包. 由于源地址是不存在的. 服务器需要不断的向客户端重新发送 `SYN/ACK` 直到超时. 这些伪造的 SYN 包将长时间占用未连接队列. 而正常的 SYN 被丢弃. 因此洪泛攻击会导致服务器运行缓慢. 严重会引起网络堵塞甚至系统瘫痪. 洪泛攻击是一种典型的 DoS/DDoS 攻击. 当你的服务器出现大量的 `半连接`. 几乎就可以认为遭受到了洪泛攻击.

如何预防洪泛攻击呢? 完全阻止是不可能的. 毕竟敌人在暗处. 服务器在明处. 网上介绍了几种方式: **缩短 SYN 超时时间**. **增加最大半连接数**. **过滤网关防护**. **SYN cookies** 等. 不过我认为这些方法都没什么卵用. 还是老老实实买 DDoS 高防吧.

## 中间人攻击

中间人攻击(Man-in-the-MiddleAttack)是指攻击者与通讯的两端分别创建独立的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过一个私密的连接与对方直接对话, 但事实上整个会话都被攻击者完全控制. 在中间人攻击中, 攻击者可以拦截通讯双方的通话并插入新的内容. 网络犯罪分子在信息发送者和信息接收者之间实质上是充当**中间人**, 因此被称为**中间人攻击**. 这些攻击非常常见, 尤其是在公共 WiFi 上. 由于公共 WiFi 通常不安全, 您无法知道谁在监控或截获 Web 流量, 因为任何人都可以登录.

- 客户端发送请求到服务端, 请求被中间人截获.

- 服务器向客户端发送公钥.

- 中间人截获公钥, 保留在自己手上. 然后自己生成一个**伪造的**公钥, 发给客户端.

- 客户端收到伪造的公钥后, 生成加密 hash 值发给服务器.

- 中间人获得加密 hash 值, 用自己的私钥解密获得真秘钥. 同时生成假的加密 hash 值, 发给服务器.

- 服务器用私钥解密获得假密钥. 然后加密数据传输给客户端.

### MITM 类型

#### 恶意接入点

恶意接入点是安装在合法网络上的无线接入点. 这使得网络犯罪分子能够截获或监控传入流量, 并通常将其全部重新路由至不同的网络, 以鼓励下载恶意软件或勒索用户.

#### ARP 欺骗

此攻击在局域网上使用虚假的 ARP 消息将攻击者的 MAC 地址与受害者的 IP 地址连接在一起. 受害者发送到局域网的任何数据都会被重新路由至网络犯罪分子的 MAC 地址, 从而允许网络犯罪分子随意截获和操纵数据.

#### HTTPS 欺骗

当用户连接到具有 https:// 前缀的安全网站时, 网络犯罪分子会向浏览器发送虚假的安全证书. 这**欺骗**了浏览器, 使其认为连接是安全的, 而事实上, 网络犯罪分子却在截获并可能重新路由数据.

#### 数据包注入

网络犯罪分子创建看似正常的数据包, 并将其注入已建立的网络, 以访问和监控流量或发起 DDoS 攻击.

#### SSL 欺骗

此方法涉及**欺骗**成安全站点地址, 以让受害者浏览至那里. 网络犯罪分子劫持受害者和他们想要访问的网站的 Web 服务器之间的通信, 将恶意网站伪装成合法网站的 URL.

#### SSL BEAST

网络犯罪分子通过恶意的 JavaScript 感染用户的电脑. 然后, 恶意软件会截获网站 Cookie 和身份验证令牌以进行解密, 使受害者的整个会话暴露在网络犯罪分子面前.

#### 嗅探

嗅探攻击通过监控流量来窃取信息. 嗅探通过应用或硬件执行, 并将受害者的 Web 流量暴露给网络犯罪分子.

#### IP 欺骗

此方法涉及修改 IP 地址以将流量重新路由至攻击者的网站. 攻击者通过改变数据包头将自己伪装成合法的应用或网站来**欺骗**地址.

#### DNS 欺骗

网络犯罪分子进入网站的 DNS 服务器并修改网站的网址记录. 修改后的 DNS 记录将传入流量改为路由至网络犯罪分子的网站.

#### 会话劫持

网络犯罪分子使用会话劫持来控制 Web 或应用会话. 劫持将合法用户逐出会话, 有效地将网络犯罪分子锁定在应用或网站帐户中, 直至其获得所需的信息.

#### SSL 剥离

网络犯罪分子会截获来自应用或网站的 TLS 信号, 并对其进行修改, 使网站以不安全的连接加载 HTTP 而非 HTTPS. 这使得网络犯罪分子可以查看用户的会话, 并暴露敏感信息.

#### 公共 WiFi

最常见的 MITM 攻击方法之一是通过公共 WiFi. 公共 WiFi 通常不安全, 因此网络犯罪分子可以从连接网络的任何设备中看到 Web 流量, 并根据需要获取信息.

#### SSL 窃取浏览器 Cookies

Cookie 是您访问的网站存储在您设备上的有用网站信息. 它们对于记住网络活动和登录名称非常有用, 但网络犯罪分子可以窃取它们以获取信息, 并用于恶意目的.

### 如何防范 MITM

中间人攻击是一个(缺乏)相互认证的攻击. 大多数的加密协议都专门加入了一些特殊的认证方法以阻止中间人攻击. 例如, SSL 协议可以验证参与通讯的一方或双方使用的证书是否是由权威的受信任的数字证书认证机构颁发, 并且能执行双向身份认证. 因此一定要使用 HTTPS.

如果你的浏览器告诉你正在访问的网站有问题, 相信它. 安全证书警告可能是将凭据授予攻击者和保持安全之间的区别.

留意网络浏览器的搜索栏或 URL 栏是否有奇怪的网址. DNS 劫持可能会对常见地址进行欺骗, 通常几乎没有明显的变化. 例如, 攻击者可能会将 **www.facebook.com** 替换为 **www.faceb00k.com**. 这种欺骗方法效果出奇的好, 我们大多数人未仔细观察就放过了简单的更改.

某些形式的 MITM 攻击会导致突然、意外的网络延迟或完全断开连接. 这些可能偶尔发生, 通常不伴有网络困境或其他明显状况. 如果您在网络上经常遇到连接断开或延迟, 最好仔细查看, 以确保这不仅仅是网络问题.

不要使用公共 Wi-Fi. 如果您必须使用公共 Wi-Fi 连接, 则应下载并安装 VPN, 为您的连接添加一些安全性.

## CSP

为了解决 XSS 攻击, 浏览器中引入了内容安全策略, 称为 CSP. CSP 的核心思想是让服务器决定浏览器能够加载哪些资源, 让服务器决定浏览器是否能够执行内联 JavaScript 代码. 一个 CSP 兼容的浏览器将会仅执行从白名单域获取到的脚本文件, 忽略所有的其他脚本 (包括内联脚本和 HTML 的事件处理属性).

你可以在 HTML 中加入 meta 属性:

```html
<meta
  http-equiv=""Content-Security-Policy""
  content=""default-src 'self'; img-src https://*; child-src 'none';""
/>
```

也可以配置 Content-Security-Policy 响应头, 下面是我的网站某个接口提供的 CSP 策略, 具体配置细节可以看 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy) 中的相关文档. 值得注意的是, CSP 里面有个 report-uri 属性, 在浏览器检测到 CSP 政策错误时, 将会发送一个 POST 请求到这个地址. 你可以在这个地址接收到错误信息.

![Content-Security-Policy](https://edge.yancey.app/beg/ynnh5y12-1651332510814.jpg)

## 只允许使用 HTTPS

为防止数据包嗅探攻击, 除限制可以加载内容的域, 服务器还可指明哪种协议允许使用; 比如 (从理想化的安全角度来说), 服务器可指定所有内容必须通过 HTTPS 加载. 你可以在 cookie 上使用 secure 属性保证 cookie 只能被 HTTPS 协议的使用. 也可以加上 Strict-Transport-Security 响应头, 指定服务器只允许通过 HTTPS 协议访问.

```shell
Strict-Transport-Security: max-age=31536000; includeSubDomains
```

## WAF

传统**防火墙**工作在三层或者四层, 隔离了外网和内网, 使用预设的规则, 只允许某些特定 IP 地址和端口号的数据包通过, 拒绝不符合条件的数据流入或流出内网, 实质上是一种**网络数据过滤设备**. WAF(网络应用防火墙, Web Application Firewall) 也是一种**防火墙**, 但它工作在七层, 看到的不仅是 IP 地址和端口号, 还能看到整个 HTTP 报文, 所以就能够对报文内容做更深入细致的审核, 使用更复杂的条件, 规则来过滤数据. 换句话说, WAF 就是一种 **HTTP 入侵检测和防御系统**.

![WAF](https://edge.yancey.app/beg/lqnvac7f-1649102511012.webp)

WAF 一般应该具有以下功能:

- IP 黑名单和白名单, 拒绝黑名单上地址的访问, 或者只允许白名单上的用户访问;
- URI 黑名单和白名单, 与 IP 黑白名单类似, 允许或禁止对某些 URI 的访问;
- 防护 DDoS 攻击, 对特定的 IP 地址限连限速;
- 过滤请求报文, 防御**代码注入**攻击;
- 过滤响应报文, 防御敏感信息外泄;
- 审计日志, 记录所有检测到的入侵操作.

WAF 的基本原理就好像是平时编写程序时必须要做的函数入口参数检查, 拿到 HTTP 请求, 响应报文, 用字符串处理函数看看有没有关键字, 敏感词, 或者用正则表达式做一下模式匹配, 命中了规则就执行对应的动作, 比如返回 403/404. 比如下面的例子就是利用 **map** 指令在 Nginx 里实现 IP 地址黑名单.

```shell
map $remote_addr $blocked {
    default       0;
    ""1.2.3.4""     1;
    ""5.6.7.8""     1;
}


if ($blocked) {
    return 403 ""you are blocked."";
}
```

[ModSecurity](https://github.com/SpiderLabs/ModSecurity) 是开源的 WAF 软件, 它有两个核心组件. 第一个是**规则引擎**, 它实现了自定义的**SecRule**语言, 有自己特定的语法. 但**SecRule**主要基于正则表达式, 还是不够灵活, 所以后来也引入了 Lua, 实现了脚本化配置. 只有引擎还不够, 要让引擎运转起来, 还需要完善的防御规则, 所以 ModSecurity 的第二个核心组件就是它的**规则集**.

基本的规则集之外, ModSecurity 还额外提供一个更完善的规则集, 为网站提供全面可靠的保护. 这个规则集的全名叫**OWASP ModSecurity 核心规则集**(Open Web Application Security Project ModSecurity Core Rule Set).

![CRS](https://edge.yancey.app/beg/k94eh2lq-1649102502087.webp)

另外, ModSecurity 还有强大的审计日志(Audit Log)功能, 记录任何可疑的数据, 供事后离线分析. 但在生产环境中会遇到大量的攻击, 日志会快速增长, 消耗磁盘空间, 而且写磁盘也会影响 Nginx 的性能, 所以一般建议把它关闭:

```shell
SecAuditEngine off  #RelevantOnly
SecAuditLog /var/log/modsec_audit.log
```

因此, WAF 实质上是模式匹配与数据过滤, 所以会消耗 CPU, 增加一些计算成本, 降低服务能力, 使用时需要在安全与性能之间找到一个**平衡点**.
","2025-02-02 03:09:17.858652","2025-02-02 03:09:17.858652"
"5695e44f-e1bb-47aa-b145-a12e81b2da6f","{技术杂谈,计算机组成原理}",0,0,False,"https://edge.yancey.app/beg/r0cgm9pb-1652970533165.jpg","浅析 CPU 是如何执行二进制机器码的","《图解 Google V8》里面有门课来讲 CPU 是如何执行二进制机器码的, 遥想好几年前大学应该也学过这玩意儿, 不过早就忘没了. 这篇文章权当补补课, 也是纪念逝去的青春 💔.","## 从源码, 汇编码到机器码

```cpp
int main()
{
    int x = 1;
    int y = 2;
    int z = x + y;
    return z;
}
```

![机器码, 汇编码对照](https://edge.yancey.app/beg/lodreupk-1652967183858.webp)

以上面一段 C 代码为例, 通过 GCC 编译器将这段 C 代码编译成二进制文件, 在通过 objdump 将二进制文件反编译成汇编代码, 得到上图. 通常我们将汇编语言编写的程序转换为机器语言的过程称为“汇编”; 反之，机器语言转化为汇编语言的过程称为“反汇编”.

```shell
gcc -O0 -o code_prog code.c # 编译成二进制机器码
objdump -d code_prog # 二进制机器码反汇编成汇编码
```

图片中最左边是编译生成的**机器码**, 使用十六进制展示, 机器码每一行都是一个指令，这一大堆指令按照顺序集合在一起就组成了程序，所以程序的执行，本质上就是 CPU 按照顺序执行这一大堆指令的过程.

中间的部分是汇编代码，汇编代码采用**助记符(memonic)**来编写程序，例如原本是二进制表示的指令，在汇编代码中可以使用单词来表示，比如 mov、add 就分别表示数据的存储和相加。汇编语言和机器语言是一一对应的.

## CPU 是如何执行程序的

在了解 CPU 是如何执行程序之前, 我们看一下典型的计算机系统的硬件组织结构有哪些, 从下图可以看出, 它主要是由 CPU、主存储器、各种 IO 总线，还有一些外部设备，诸如硬盘、显示器、USB 等设备组成的。

![计算机组成](https://edge.yancey.app/beg/z30ock3b-1652967910341.webp)

### 内存

首先说一下内存, 在程序执行之前，我们的程序需要被装进内存. 比如在 Windows 系统, 当双击一个可执行文件时，系统中的程序加载器会将该文件加载到内存中。

你可以把内存看成是一个快递柜，比如当你需要寄件的时候，你可以打开快递柜中的第 100 号单元格，并存放你的物品，有时候你会收到快递，提示你在快递柜的 105 号单元格中，你就可以打开 105 号单元格取出的你的快递。这里的快递柜、快递柜中的每个单元格的编号、操作快递柜的人，你可以把它们对比成计算机中的内存、内存地址和 CPU.

也就是说，CPU 可以通过指定内存地址，从内存中读取数据，或者往内存中写入数据，有了内存地址，CPU 和内存就可以有序地交互.

此外, 内存还是一个临时存储数据的设备，之所以是临时的存储器，是因为断电之后，内存中的数据都会消失。

在内存中，每个存放字节的空间都有其唯一的地址，而且地址是按照顺序排放的. 开头的那段 C 代码，这段代码会被编译成可执行文件，可执行文件中包含了二进制的机器码，当二进制代码被加载进了内存后，那么内存中的每条二进制代码便都有了自己对应的地址. 有时候一条指令只需要一个字节就可以了，但是有时候一条指令却需要多个字节。在下图中，对于同一条指令，我们使用了相同的颜色来标记.

![加载到内存中的程序](https://edge.yancey.app/beg/i73qyljl-1652968275222.webp)

### CPU 寄存器

一旦二进制代码被装载进内存，CPU 便可以从内存中取出一条指令，然后分析该指令，最后执行该指令。我们把取出指令、分析指令、执行指令这三个过程称为一个 CPU **时钟周期**。CPU 是永不停歇的，当它执行完成一条指令之后，会立即从内存中取出下一条指令，接着分析该指令，执行该指令，CPU 一直重复执行该过程，直至所有的指令执行完成。

CPU 之所以可以从上到下依次取出每条指令来分析执行, 得利于 CPU 中的 **PC 寄存器**. 它保存了将要执行的指令地址，当二进制代码被装载进了内存之后，系统会将二进制代码中的第一条指令的地址写入到 PC 寄存器中，到了下一个时钟周期时，CPU 便会根据 PC 寄存器中的地址，从内存中取出指令。

因此, PC 寄存器中的指令取出来之后，系统要做两件事:

1. 将下一条指令的地址更新到 PC 寄存器中
2. 分析该指令，并识别出不同的类型的指令，以及各种获取操作数的方法. 在指令分析完成之后，就要执行指令了.

在了解 CPU 是如何执行指令之前，我们还需要了解 CPU 中的一个重要部件: **通用寄存器**. 通用寄存器是 CPU 中用来存放数据的设备，不同处理器中寄存器的个数也是不一样的，之所以要通用寄存器，是因为 CPU 访问内存的速度很慢，所以 CPU 就在内部添加了一些存储设备，这些设备就是通用寄存器。

你可以把通用寄存器比喻成是你身上的口袋，内存就是你的背包，而硬盘则是你的行李箱，要从背包里面拿物品会比较不方便，所以你会将常用的物品放进口袋。你身上口袋的个数通常不会太多，容量也不会太大，而背包就不同了，它的容量会非常大。

通用寄存器通常用来存放数据或者内存中某块数据的地址，我们把这个地址又称为**指针**，通常情况下寄存器对存放的数据是没有特别的限制的，比如某个通用寄存器既可以存储数据，也可以存储指针。不过一般来讲, 每种数据都有自己独特的寄存器, 比如 rbp 寄存器通常是用来存放栈帧指针的，rsp 寄存器用来存放栈顶指针的，PC 寄存器用来存放下一条要执行的指令等。

### CPU 执行指令

我们先来了解下几种常用的指令类型:

第一种是**加载的指令**，其作用是从内存中复制指定长度的内容到通用寄存器中，并覆盖寄存器中原来的内容。比如下图使用了 movl 指令，指令后面跟着的第一个参数是要拷贝数据的内存的位置，第二个参数是要拷贝到 ecx 这个寄存器。

![加载的指令](https://edge.yancey.app/beg/fxeeyo1n-1652969056899.webp)

第二种**存储的指令**，和加载类型的指令相反，其作用是将寄存器中的内容复制内存某个位置，并覆盖掉内存中的这个位置上原来的内容. 比如下图使用 movl 指令，movl 指令后面的 %ecx 就是寄存器地址，-8(%rbp) 是内存中的地址，这条指令的作用是将寄存器中的值拷贝到内存中。

![存储的指令](https://edge.yancey.app/beg/tgpahgxl-1652969159311.webp)

第三种是**更新指令**，其作用是复制两个寄存器中的内容到 ALU 中，也可以是一块寄存器和一块内存中的内容到 ALU 中，ALU 将两个字相加，并将结果存放在其中的一个寄存器中，并覆盖该寄存器中的内容。下图 addl 指令，将寄存器 eax 和 ecx 中的值传给 ALU，ALU 对它们进行相加操纵，并将计算的结果写回 ecx。

![更新指令](https://edge.yancey.app/beg/j8zel254-1652969241891.webp)

第四种是**跳转指令**，从指令本身抽取出一个字，这个字是下一条要执行的指令的地址，并将该字复制到 PC 寄存器中，并覆盖掉 PC 寄存器中原来的值。那么当执行下一条指令时，便会跳转到对应的指令了。下图是通过 jmp 来实现的，jmp 后面跟着要跳转的内存中的指令地址。

![跳转指令](https://edge.yancey.app/beg/6a6qikyh-1652969688014.webp)

除了以上指令之外，还有 IO 读 / 写指令，这些指令可以从一个 IO 设备中复制指定长度的数据到寄存器中，也可以将一个寄存器中的数据复制到指定的 IO 设备。

## 看一个实例

以最上面的 C 代码为例, CPU 会首先执行调用 main 函数，在调用 main 函数时，CPU 会保存上个栈帧上下文信息和创建当前栈帧的上下文信息，主要是通过下面这两条指令实现的. 第一条指令 pushq %rbp，是将 rbp 寄存器中的值写到内存中的栈区域。第二条指令是将 rsp 寄存器中的值写到 rbp 寄存器中。

```ts
pushq  %rbp
movq   %rsp, %rbp
```

然后将 0 写到栈帧的第一个位置，对应的汇编代码如下：

```ts
movl  $0, -4(%rbp)
```

接下来给 x 和 y 赋值，对应的代码是下面两行, 第一行指令是将常数值 1 压入到栈中，然后再将常数值 2 压入到栈中，这两个值分别对应着 x 和 y。

```ts
movl  $1, -8(%rbp)
movl  $2, -12(%rbp)
```

接下来，x 的值从栈中复制到 eax 寄存器中，对应的指令如下所示：

```ts
movl -8(%rbp), %eax
```

现在 eax 寄存器中保存了 x 的值，那么接下来，再将内存中的 y 和 eax 中的 x 相加，相加的结果再保存在 eax 中，对应的指令如下所示：

```ts
addl  -12(%rbp), %eax
```

现在 x+y 的结果保存在了 eax 中了，接下来 CPU 会将结果保存中内存中，执行如下指令：

```ts
 movl  %eax, -16(%rbp)
```

最后又将结果 z 加载到 eax 寄存器中，代码如下所示：

```ts
movl  -16(%rbp), %eax
```

注意这里的 eax 寄存器中的内容就被默认作为返回值了，执行到这里函数基本就执行结束了，然后需要继续执行一些恢复现场的操作，代码如下所示：

```ts
popq % rbp;
retq;
```
","2025-02-02 03:09:19.491825","2025-02-02 03:09:19.491825"
"6f9c2dfc-a014-4ad8-8eb6-9d6fa030f19a","{JavaScript}",0,0,False,"https://edge.yancey.app/beg/cdkoytwl-1653502181867.jpg","谈 Generator 与 async / await","生成器在日常开发中似乎并不受待见, 除了耳熟能详的 Symbol.iterator, redux-saga, 曾经大名鼎鼎的 co模块, 以及 react-scheduler 放弃使用生成器, 转而使用 postMessage 的消息, 其他情况我们用到的机会很少. 但这不妨碍它是个伟大的设计, 因为基于它和 Promise, 有了我们不可获取的 async / await. 这篇文章我们来了解生成器的语法, 协程, 以及 async / await.","## 何为迭代器

迭代器是被专用设计用于迭代的对象, 带有特定接口. 迭代器有一个 next 方法, 它返回一个对象, 对象的 value 属性是下一个值, done 属性是一个布尔值, 表示迭代是否结束. 我们很容易实现下面的代码, 只需要返回 next 闭包函数, 就可以记住迭代器的状态.

```ts
function createIterator(items) {
  let i = 0
  return {
    next() {
      const done = i >= items.length
      const value = !done ? items[i++] : undefined

      return {
        done: done,
        value: value,
      }
    },
  }
}

const iterator = createIterator([1, 2, 3])

console.log(iterator.next()) // { value: 1, done: false }
console.log(iterator.next()) // { value: 2, done: false }
console.log(iterator.next()) // { value: 3, done: false }
console.log(iterator.next()) // { value: undefined, done: true }
console.log(iterator.next()) // { value: undefined, done: true }
```

## 何为生成器

上面的代码多少有些复杂, 为此 ES6 提供了一种新的语法, 称为生成器. 生成器是一个函数, 它返回一个迭代器. 生成器的写法与迭代器的写法相似, 只是在函数名后面加上了 \* 号.

```ts
function* genDemo() {
  console.log('开始执行第一段')
  yield 'generator 2'

  console.log('开始执行第二段')
  yield 'generator 2'

  console.log('开始执行第三段')
  yield 'generator 2'

  console.log('执行结束')
  return 'generator 2'
}

console.log('main 0')
let gen = genDemo()
console.log(gen.next().value)
console.log('main 1')
console.log(gen.next().value)
console.log('main 2')
console.log(gen.next().value)
console.log('main 3')
console.log(gen.next().value)
console.log('main 4')

// main 0
// 开始执行第一段
// generator 2
// main 1
// 开始执行第二段
// generator 2
// main 2
// 开始执行第三段
// generator 2
// main 3
// 执行结束
// generator 2
// main 4
```

## 生成器与协程

要搞懂函数为何能暂停和恢复, 那首先要了解协程(Coroutine)的概念. 协程是一种比线程更加轻量级的存在. 你可以把协程看成是跑在线程上的任务, 一个线程上可以存在多个协程, 但是在线程上同时只能执行一个协程, 比如当前执行的是 A 协程, 要启动 B 协程, 那么 A 协程就需要将主线程的控制权交给 B 协程. 如果从 A 协程启动 B 协程, 我们就把 A 协程称为 B 协程的父协程.

正如一个进程可以拥有多个线程一样, 一个线程也可以拥有多个协程. 最重要的是, 协程不是被操作系统内核所管理, 而完全是由程序所控制. 带来的好处就是性能得到了很大的提升, 不会像线程切换那样消耗资源.

![生成器执行过程](https://edge.yancey.app/beg/tofvlavj-1650875423844.webp)

上图表示了这段代码的执行过程:

1. 通过调用生成器函数 genDemo 来创建一个协程 gen, 创建之后, gen 协程并没有立即执行.
2. 要让 gen 协程执行, 需要通过调用 gen.next.
3. 当协程正在执行的时候, 可以通过 yield 关键字来暂停 gen 协程的执行, 并返回主要信息给父协程.
4. 如果协程在执行期间, 遇到了 return 关键字, 那么 JavaScript 引擎会结束当前协程, 并将 return 后面的内容返回给父协程.

## 生成器与调用栈

gen 协程和父协程是在主线程上交互执行的, 并不是并发执行的, 它们之前的切换是通过 yield 和 gen.next 来配合完成的.

当在 gen 协程中调用了 yield 方法时, JavaScript 引擎会保存 gen 协程当前的调用栈信息, 并恢复父协程的调用栈信息. 同样, 当在父协程中执行 gen.next 时, JavaScript 引擎会保存父协程的调用栈信息, 并恢复 gen 协程的调用栈信息.

![生成器与调用栈](https://edge.yancey.app/beg/4eo7an2x-1650881815840.webp)

对于普通函数被调用, 它也会形成执行上下文, 但它是**被**调用的, 所以它会创建一个 caller(调用者), 由于栈是先入后出的, 因此总是立即执行这个 callee 函数的上下文. 因此所有其他上下文都在执行栈上, 而生成器的上下文(多数时间是)在栈的外面.

比如 `let tor = foo3();` 看似执行了一次 foo3, 但实际上, 只要你没有调用 `.next()`, 生成器函数体就是没被执行的. 换言之, 生成一个迭代过程, 并将该过程交给了 tor 对象. 因为 tor 是 foo3() 生成器内部迭代过程的一个句柄. 从引擎内的实现过程来说, tor 其实包括状态(state)和执行上下文(context)两个信息, 它是 GeneratorFunction.prototype 的一个实例. 这个 tor 所代表的生成器在创建出来的时候将立即被挂起, 因此状态值(state)初始化置为""启动时挂起(suspendedStart)"", 而当在调用 tor.next() 因 yield 运算而导致的挂起称为 **Yield 时挂起(suspendedYield)**.

## 可迭代对象

可迭代对象(iterable)是包含 `Symbol.iterator` 属性的对象, 像字符串, 数组, Map, Set, NodeList 都是可迭代对象. 可迭代对象可与 for-of 循环配合使用. for-of 循环在循环每次执行时会调用可迭代对象的 next() 方法, 并将结果对象的 value 值存储在一个变量上. 循环过程会持续到结果对象的 done 属性变成 true 为止.

你可以手动访问一个可迭代对象的迭代器:

```ts
const values = [1, 2, 3]
const iterator = values[Symbol.iterator]()

console.log(iterator.next()) // { value: 1, done: false }
console.log(iterator.next()) // { value: 2, done: false }
console.log(iterator.next()) // { value: 3, done: false }
console.log(iterator.next()) // { value: undefined, done: true }
console.log(iterator.next()) // { value: undefined, done: true }
```

开发者自定义对象默认情况下不是可迭代对象, 但你可以亲自指挥, 亲自部署, 创建一个包含生成器的 Symbol.iterator 属性, 让它们成为可迭代对象.

```ts
let collection = {
  items: [1, 2, 3],
  *[Symbol.iterator]() {
    for (let item of this.items) {
      yield item
    }
  },
}

for (let x of collection) {
  console.log(x)
}
```

## 集合的迭代器

数组, Map 与 Set 都拥有如下三种迭代器:

- entries(): 返回一个包含键值对的迭代器;
- values(): 返回一个包含集合中的值的迭代器;
- keys(): 返回一个包含集合中的键的迭代器.

关于这三个迭代器不去多讲, 以前写过 [Object.keys](https://js.yanceyleo.com/ecmascript/Object/keys), [Object.values](https://js.yanceyleo.com/ecmascript/Object/values), [Object.entries](https://js.yanceyleo.com/ecmascript/Object/entries), [Object.fromEntries](https://js.yanceyleo.com/ecmascript/Object/fromEntries) 这几个, 你可以参考.

```ts
let data = new Map()
data.set('title', 'Understanding ES6')
data.set('format', 'ebook')

for (let entry of data.entries()) {
  console.log(entry)
  // ['title', 'Understanding ES6']
  // ['format', 'ebook']
}

for (let value of data.values()) {
  console.log(value)
  // 'Understanding ES6'
  // 'ebook'
}

for (let key of data.keys()) {
  console.log(key)
  // title
  // format
}
```

## 迭代器高级功能

迭代器对象除了有 next 方法, 它还支持 throw 和 return 方法, 同时它还支持委托, 下面让我们一一认识认识.

### 传递参数给迭代器

我们知道 next 方法可以用来执行下一个 yield 语句, 但该方法还可以传递参数, 当一个参数被传递给 next() 方法时, 该参数就会成为生成器内部 yield 语句的值. 可以下面这个例子:

- 第一次 next 虽然传递了 100, 但因为第一句是没有上文的, 因此参数无效, 返回 1.
- 第二次 next 虽然传递了 4, 但因为压根没用到, 遂返回 2.
- 第三次 next 传递了 5 和 3, 它就代替了 first 和 second 参数, 因此返回 12

需要注意的是, 虽然 `yield first + second + 3` 这一行, first 和 second 的值来自 next 传递的参数, 似乎跟上面两句的 `let first = yield 1` 和 `let second = yield 2` 无关, 但如果你不先声明这两个变量, 就会报错 `ReferenceError: second is not defined`.

```ts
function* createIterator() {
  let first = yield 1
  let second = yield 2
  let third = yield first + second + 3
}

let iterator = createIterator()

console.log(iterator.next(100)) // { value: 1, done: false }
console.log(iterator.next(4)) // { value: 2, done: false }
console.log(iterator.next(5, 3)) // { value: 12, done: false }
console.log(iterator.next()) // { value: undefined, done: true }
```

### 在迭代器中抛出错误

除了在 next 方法中传入一个值, 还可以使用 throw 方法抛出一个异常.

```ts
function* createIterator() {
  let first = yield 1
  let second = yield first + 2
  yield second + 3
  yield 'finally'
}

let iterator = createIterator()

console.log(iterator.next()) // { value: 1, done: false }
console.log(iterator.next(4)) // { value: 6, done: false }
console.log(iterator.throw(new Error('Boom'))) // 从生成器中抛出了错误
console.log(iterator.next()) // 不再执行
```

- 第一个 yield 没什么可说的, 返回 1
- 第二行没什么可说的, 返回 6
- 注意第三个调用了 throw 方法, 错误在 `let second` 运算之前就被抛出了, 也就是说上面的 `yield first + 2` 正常执行了, 返回 6, 但赋值给变量 second 的操作凉凉了.
- 下面的所有 next 均不会执行

![实际报错出现在 second 赋值前](https://edge.yancey.app/beg/abdc7iwy-1653687591858.jpg)

基于此, 我们可以加个 try...catch.

- 第一个 yield 没什么可说的, 返回 1
- 第二个 yield, 即 `yield first + 2`, 由于我们在 next 传递了 first 是 4, 所以这句返回 6
- 但紧接着我们调用了 throw 方法, 一般情况下程序就直接崩了, 好在我们加了 try...catch, second 赋值的操作就走到了 catch 里, 即 second 被赋值成了 7, 但有趣的是, 代码会继续执行到下一个 yield 处并返回了下一个值, 也就是 10
- 之后就执行完了, 都会返回 `{ value: undefined, done: true }`

```ts
function* createIterator() {
  let first = yield 1
  let second
  try {
    second = yield first + 2
  } catch (ex) {
    second = 7
  }
  yield second + 3
}

let iterator = createIterator()

console.log(iterator.next()) // { value: 1, done: false }
console.log(iterator.next(4)) // { value: 6, done: false }
console.log(iterator.throw(new Error('Boom'))) // { value: 10, done: false }
console.log(iterator.next()) // { value: undefined, done: true }
```

### 在迭代器中返回

由于生成器是函数, 你可以在它内部使用 return 语句, 既可以让生成器早一点退出执行, 也可以指定在 next() 方法最后一次调用时的返回值.

```ts
function* createIterator() {
  yield 1
  return
  yield 2
  yield 3
}

let iterator = createIterator()

console.log(iterator.next()) // { value: 1, done: false }
console.log(iterator.next()) // { value: undefined, done: true }
```

当然你也可以 return 一个值, 比如下面的例子, return 语句返回 42, 会进入到第二次的 next 方法中, 之后便将返回 undefiend.

```ts
function* createIterator() {
  yield 1
  return 42
}

let iterator = createIterator()

console.log(iterator.next()) // { value: 1, done: false }
console.log(iterator.next()) // { value: 42, done: true }
console.log(iterator.next()) // { value: undefined, done: true }
```

### 生成器委托

在某些情况下，将两个迭代器的值合并在一起会更有用。生成器可以用星号配合 yield 这一特殊形式来委托其他的迭代器。

```ts
function* createNumberIterator() {
  yield 1
  yield 2
}

function* createColorIterator() {
  yield 'red'
  yield 'green'
}

function* createCombinedIterator() {
  yield* createNumberIterator()
  yield* createColorIterator()
  yield true
}

const iterator = createCombinedIterator()
console.log(iterator.next()) // ""{ value: 1, done: false }""
console.log(iterator.next()) // ""{ value: 2, done: false }""
console.log(iterator.next()) // ""{ value: ""red"", done: false }""
console.log(iterator.next()) // ""{ value: ""green"", done: false }""
console.log(iterator.next()) // ""{ value: true, done: false }""
console.log(iterator.next()) // ""{ value: undefined, done: true }""
```

当然生成器配合上返回是很重要的例子, 比如下面代码, createNumberIterator 返回的 3 继续被 createRepeatingIterator 使用, 换成一个现实的例子就是等待一个网络接口 fetch1 返回 3, 然后紧接着将 3 作为 fetch2 的参数, 继续串行执行异步函数.

```ts
function* createNumberIterator() {
  yield 1
  yield 2
  return 3
}

function* createRepeatingIterator(count) {
  for (let i = 0; i < count; i++) {
    yield 'repeat'
  }
}

function* createCombinedIterator() {
  let result = yield* createNumberIterator()
  yield* createRepeatingIterator(result)
}

const iterator = createCombinedIterator()
console.log(iterator.next()) // ""{ value: 1, done: false }""
console.log(iterator.next()) // ""{ value: 2, done: false }""
console.log(iterator.next()) // ""{ value: ""repeat"", done: false }""
console.log(iterator.next()) // ""{ value: ""repeat"", done: false }""
console.log(iterator.next()) // ""{ value: ""repeat"", done: false }""
console.log(iterator.next()) // ""{ value: undefined, done: true }""
```

## 当生成器遇上 Promise

迭代器最令人兴奋的莫过于可以精细控制异步逻辑. 我们设想一个例子, 假设有个异步函数 getUserID 用来获取用户 ID, 获取成功后立即调用另一个异步函数 getUserName, 获取成功后返回用户名.

如今我们来看这个例子, 相信你一定会选择 Promise 抑或 async/await, 哪怕是异步回调, 不过这次我们用生成器的方式.

让我们来分析这个过程, 由于 getUserID() 和 getUserName() 都是异步请求, 如果要实现这种线性的编码方式, 那么一个可行的方案就是执行到异步请求的时候, 暂停当前函数, 等异步请求返回了结果, 再恢复该函数. 因此:

执行到 getUserID() 时暂停 getResult 函数, 然后浏览器在后台处理实际的请求过程, 待 ID 数据返回时, 再来恢复 getResult 函数. 接下来再执行 getUserName 来获取到用户名, 由于 getUserName() 也是一个异步请求, 所以在使用 getUserName() 的同时, 依然需要暂停 getResult 函数的执行, 等到 getUserName() 返回了用户名数据, 再恢复 getResult 函数的执行, 最终 getUserName() 函数返回了 name 信息.

![当生成器遇上 Promise](https://edge.yancey.app/beg/wc05elvl-1653488802950.webp)

因此, 这套体系的关键就是实现函数**暂停执行**和**函数恢复执行**, 而生成器就是为了实现暂停函数和恢复函数而设计的. 我们可以写下如下代码:

```ts
function* getResult() {
  const userIdRes = yield fetch('/id')
  const { id } = yield userIdRes.json()

  const userNameRes = yield fetch('/name', { id })
  const { name } = yield userNameRes.json()

  console.log(name)
}

const gen = getResult()

gen
  .next()
  .value.then((response) => gen.next(response).value)
  .then((response) => gen.next(response).value)
  .then((response) => gen.next(response).value)
  .then((response) => gen.next(response).value)
```

可见我们在生成器函数 getResult 中写入各种异步函数, 然后在外面依次使用一段代码来控制生成器的暂停和恢复执行. 通常, 我们把执行生成器的代码封装成一个函数, 这个函数驱动了 getResult 函数继续往下执行, 我们把这个执行生成器代码的函数称为**执行器**, 比如著名的 [co](https://github.com/tj/co) 工具就是干这事的.

```ts
co(getResult())
```

## async / await

通过上面的代码我们看出, 使用生成器可以很好的实现""看起来""像同步的异步代码, 不过生成器依然需要使用额外的 co 函数来驱动生成器函数的执行, 这是比较麻烦的. 而 Generator + Promise 又有一套固定的模型, 且这两个组合基本涵盖了 JavaScript 大部分异步场景. 基于此, ES7 引入了 async / await 的语法糖, 这是 JavaScript 异步编程的一个重大改进, 它改进了生成器的缺点, 提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力.

```ts
async function getResult() {
  const userIdRes = await fetch('/id')
  const { id } = await userIdRes.json()

  const userNameRes = await fetch('/name', { id })
  const { name } = await userNameRes.json()

  console.log(name)
}
```

我们将上面生成器的代码改成 async / await 的形式, 虽然这种方式看起来像是同步代码, 但是实际上它又是异步执行的, 也就是说, 在执行到 await fetch 的时候, 整个函数会暂停等待 fetch 的执行结果, 等到函数返回时, 再恢复该函数, 然后继续往下执行. 而它背后的秘密**就是 Promise 和生成器应用, 往底层说, 就是微任务和协程应用**.

根据 MDN 定义, async 是一个通过**异步执行并隐式返回 Promise 作为结果的函数**. 即如果在 async 函数里面使用了 await, 那么此时 async 函数就会暂停执行, 并等待合适的时机来恢复执行, 所以说 async 是一个异步执行的函数. 那么暂停之后, 什么时机恢复 async 函数的执行呢?

通常, await 可以等待两种类型的表达式:

- 可以是任何普通表达式;
- 也可以是一个 Promise 对象的表达式.

如果 await 等待的是一个 Promise 对象, 它就会暂停执行生成器函数, 直到 Promise 对象的状态变成 resolve, 才会恢复执行, 然后得到 resolve 的值, 作为 await 表达式的运算结果. 如果使用 await 等待一个没有 resolve 的 Promise, 那么这也就意味着, async 指向的函数会一直等待下去, 比如下面这个例子:

```ts
function NeverResolvePromise() {
  return new Promise((resolve, reject) => {})
}
async function getResult() {
  let a = await NeverResolvePromise()
  console.log(a)
}
getResult()
console.log(0)
```

和生成器函数一样, 使用了 async 声明的函数在执行时, 也是一个单独的协程, 我们可以使用 await 来暂停该协程, 由于 await 等待的是一个 Promise 对象, 我们可以 resolve 来恢复该协程. 比如下面这段代码:

```ts
function HaveResolvePromise() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(100)
    }, 0)
  })
}
async function getResult() {
  console.log(1)
  let a = await HaveResolvePromise()
  console.log(a)
  console.log(2)
}
console.log(0)
getResult()
console.log(3)
```

当然, 如果 await 等待的是一个非 Promise 对象, 比如 await 100, 那么 V8 会隐式地将 await 后面的 100 包装成一个已经 resolve 的对象. 以下面这段代码为例:

```ts
async function foo() {
  console.log(1)
  let a = await 100
  console.log(a)
  console.log(2)
}
console.log(0)
foo()
console.log(3)
```

首先, 执行 `console.log(0)` 这个语句, 打印出来 0.

紧接着就是执行 foo 函数, 由于 foo 函数是被 async 标记过的, 所以当进入该函数的时候, JavaScript 引擎会保存当前的调用栈等信息, 然后执行 foo 函数中的 `console.log(1)` 语句, 并打印出 1.

然后当执行到 `await 100` 时会创建一个隐式的 Promise 对象. 在这个 promise\_ 对象创建的过程中, 我们可以看到在 executor 函数中调用了 resolve 函数, JavaScript 引擎会将该任务提交给微任务队列.

```ts
let promise_ = new Promise((resolve, reject) => {
  resolve(100)
})
```

然后 JavaScript 引擎会暂停当前协程的执行, 将主线程的控制权转交给父协程执行, 同时会将 promise\_ 对象返回给父协程. 主线程的控制权已经交给父协程了, 这时候父协程要做的一件事是调用 `promise_.then` 来监控 promise 状态的改变.

接下来继续执行父协程的流程, 这里我们执行 `console.log(3)`, 并打印出来 3. 随后父协程将执行结束, 在结束之前, 会进入微任务的检查点, 然后执行微任务队列, 微任务队列中有 `resolve(100)` 的任务等待执行, 执行到这里的时候, 会触发 `promise_.then` 中的回调函数, 如下所示:

```ts
promise_.then((value) => {
  //回调函数被激活后
  //将主线程控制权交给 foo 协程, 并将 vaule 值传给协程
})
```

该回调函数被激活以后, 会将主线程的控制权交给 foo 函数的协程, 并同时将 value 值传给该协程.

foo 协程激活之后, 会把刚才的 value 值赋给了变量 a, 然后 foo 协程继续执行后续语句, 执行完成之后, 将控制权归还给父协程.

![async/await 执行流程](https://edge.yancey.app/beg/esbotezn-1653687216081.webp)
","2025-02-02 03:09:20.684236","2025-02-02 03:09:20.684236"
"de1a22b6-1307-4862-bcbb-2181d75a1f6c","{JavaScript,V8}",0,0,False,"https://edge.yancey.app/beg/r3z6s99i-1653688802585.jpg","浅析 V8 原理","这篇文章是李兵老师《图解 Google V8》的笔记, 也当作以后读 V8 源码的参考. 至于后面到底读不读, 先 🐎 住, 后面再说嘛...","## V8 工作原理概览

V8 是 JavaScript 虚拟机的一种, 它将人类能够理解的编程语言 JavaScript, 编译成成机器能够理解的机器语言. 市面上有很多种 JavaScript 引擎, 诸如 SpiderMonkey, V8, JavaScriptCore 等. 但 V8 绝对是最牛逼的那个, 在 V8 出现之前, 所有的 JavaScript 虚拟机所采用的都是**解释执行**的方式. 而 V8 率先使用即时编译(JIT) 的双轮驱动的设计, 即使用混合编译执行和解释执行这两种手段. 换句人话, 就是对于 JavaScript 代码需要经过**编译**和**执行**两个阶段, 其中编译过程是指 **V8 将 JavaScript 代码转换为字节码或者将多次使用的热点代码转化成二进制机器代码的阶段, 而执行阶段则是指解释器解释执行字节码, 或者是 CPU 直接执行二进制机器代码的阶段**. 此外, V8 也是早于其他虚拟机引入了惰性编译, 隐藏类, 内联缓存等机制(三种机制我们下面都会说到).

![V8 工作原理概览](https://edge.yancey.app/beg/40c9w2bm-1652032140351.webp)

虚拟机通过模拟实际计算机的各种功能来实现代码的执行, 如模拟实际计算机的 CPU, 堆栈, 寄存器等, 虚拟机还具有它自己的一套指令系统. 对于 JavaScript 代码来说, V8 就是它的整个世界, 当 V8 执行 JavaScript 代码时, 我们并不需要担心现实中不同操作系统的差异, 也不需要担心不同体系结构计算机的差异, 我们只需要按照虚拟机的规范写好代码就可以了.

V8 并没有采用某种单一的编译技术, 而是混合编译执行和解释执行这两种手段, 我们把这种混合使用编译器和解释器的技术称为 **JIT(Just In Time)**. 这是一种权衡策略, 因为这两种方法都各自有各自的优缺点, 解释执行的启动速度快, 但是执行时的速度慢, 而编译执行的启动速度慢, 但是执行时的速度快.

![V8 编译流水线](https://edge.yancey.app/beg/19m6ctx7-1652029505251.webp)

首先看上图左边部分, V8 启动执行 JavaScript 之前, 它还需要准备执行 JavaScript 时所需要的一些基础环境, 这些基础环境包括了**堆空间**, **栈空间**, **全局执行上下文**, **全局作用域**, **消息循环系统**, **内置函数**等, 这些内容都是在执行 JavaScript 过程中需要使用到的.

- JavaScript 全局执行上下文就包含了执行过程中的全局信息, 比如一些内置函数, 全局变量等信息;
- 全局作用域包含了一些全局变量, 在执行过程中的数据都需要存放在内存中;
- 而 V8 是采用了经典的堆和栈的内存管理模式, 所以 V8 还需要初始化内存中的堆和栈结构;
- 另外, 想要我们的 V8 系统活起来, 还需要初始化消息循环系统, 消息循环系统包含了消息驱动器和消息队列, 它如同 V8 的心脏, 不断接受消息并决策如何处理消息.

基础环境准备好之后, 接下来就可以向 V8 提交要执行的 JavaScript 代码了. V8 会进行一系列的**结构化**操作, 即词法分析, 语法分析等等, 此时就生成了 AST 和作用域.

有了 AST 和作用域, 接下来就可以生成字节码了, 字节码是介于 AST 和机器代码的中间代码. 但是与特定类型的机器代码无关, 解释器可以直接解释执行字节码, 或者通过编译器将其编译为二进制的机器代码再执行.

生成了字节码之后, 解释器就会按照顺序解释执行字节码, 并输出执行结果.

我们在解释器附近画了个监控机器人, 这是一个监控解释器执行状态的模块, 在解释执行字节码的过程中, 如果发现了某一段代码会被重复多次执行, 那么监控机器人就会将这段代码标记为**热点代码**. 当某段代码被标记为热点代码后, V8 就会将这段字节码丢给优化编译器, 优化编译器会在后台将字节码编译为二进制代码, 然后再对编译后的二进制代码执行优化操作, 优化后的二进制机器代码的执行效率会得到大幅提升. 如果下面再执行到这段代码时, 那么 V8 会优先选择优化之后的二进制代码, 这样代码的执行速度就会大幅提升.

不过由于 JavaScript 是一门动态语言, 对象的结构和属性是可以在运行时任意修改的, 而经过优化编译器优化过的代码只能针对某种固定的结构, 一旦在执行过程中, 对象的结构被动态修改了, 那么优化之后的代码势必会变成无效的代码, 这时候优化编译器就需要执行**反优化**操作, 经过反优化的代码, 下次执行时就会回退到解释器解释执行.

## 为什么高级语言需要被编译

这里首先补点儿课, 来聊一聊为什么高级语言需要被编译. 我们知道 **CPU** 只能跟**二进制的指令**进行沟通. 比如我们给 CPU 发出 **1000100111011000** 的二进制指令, 这条指令的意思是将一个寄存器中的数据移动到另外一个寄存器中, 当处理器执行到这条指令的时候, 便会按照指令的意思去实现相关的操作.

为了能够完成复杂的任务, 工程师们为 CPU 提供了一大堆指令, 来实现各种功能, 我们就把这一大堆指令称为**指令集(Instructions)**, 也就是**机器语言**. 二进制代码难以阅读和记忆, 于是我们又将二进制指令集转换为人类可以识别和记忆的符号, 这就是**汇编指令集**. 当然汇编语言仍然不能被 CPU 直接使用, 所以如果我们使用汇编编写了一段程序, 我们还需要一个汇编编译器, 来将汇编代码编程成机器代码.

```c
1000100111011000 // 机器指令
mov ax,bx        // 汇编指令
```

即便汇编语言对机器语言做了一层抽象, 仍然难以快速写出一段代码. 除了汇编语言仍然难以记忆, 还有如下两个原因:

- 不同的 CPU 有着不同的指令集, 市面上的 CPU 有 x86 架构的, arm 架构的等等, 如果要使用机器语言或者汇编语言来实现一个功能, 那么我们需要为每种架构的 CPU 编写特定的汇编代码.
- 在编写汇编代码时, 我们还需要了解和处理器架构相关的硬件知识, 比如寄存器, 内存, 操作 CPU 等等.

因此我们需要一种屏蔽了计算机架构细节的语言, 能适应多种不同 CPU 架构的语言, 能专心处理业务逻辑的语言, 诸如 C, C++, Java, C#, Python, JavaScript 等, 这些**高级语言**就应运而生了. 和汇编语言一样, 处理器也不能直接识别由高级语言所编写的代码, 通常会有两种方式来执行这些代码.

第一种是**解释执行**, 需要先将输入的源代码通过解析器编译成中间代码, 之后直接使用解释器解释执行中间代码, 然后直接输出结果.

![解释执行](https://edge.yancey.app/beg/gbs5kchb-1652032800141.webp)

第二种是**编译执行**. 采用这种方式时, 也需要先将源代码转换为中间代码, 然后我们的编译器再将中间代码编译成机器代码. 通常编译成的机器代码是以二进制文件形式存储的, 需要执行这段程序的时候直接执行二进制文件就可以了. 还可以使用虚拟机将编译后的机器代码保存在内存中, 然后直接执行内存中的二进制代码.

![编译执行](https://edge.yancey.app/beg/rql7jlta-1652032807344.webp)

## JavaScript 的设计思想

我们知道 V8 的主要职责是用来执行 JavaScript 代码的, 在深入 V8 之前, 我们首先需要了解 JavaScript 这门语言的基本特性和设计思想.

JavaScript 借鉴了很多语言的特性, 比如 C 语言的基本语法, Java 的类型系统和内存管理, Scheme 的函数作为一等公民, 还有 Self 基于原型(prototype)的继承机制. 毫无疑问, JavaScript 是一门非常优秀的语言, 特别是**原型继承机制**和**函数是一等公民**这两个设计.

但操蛋的是, 由于历史原因, 很多错误的或者不合理的设计都被延续至今, 比如使用 new 加构造函数来创建对象, 这种方式的背后隐藏了太多的细节, 非常容易增加代码出错概率, 而且也大大增加了新手的学习成本;再比如初期的 JavaScript 没有块级作用域机制, 使得 JavaScript 需要采取变量提升的策略, 而变量提升又是非常反人性的设计.

因此在学习 V8 工作原理时, 我们就要格外关注 JavaScript 这些独特的设计思想和特性背后的实现. 比如, 为了实现函数是一等公民的特性, JavaScript 采取了基于对象的策略; 再比如为了实现原型继承, V8 为每个对象引入了 `__proto__` 属性等等.

![JavaScript 的设计思想](https://edge.yancey.app/beg/ppo5m3ha-1652029158898.webp)

我们会从函数即对象, 对象存储策略, 函数声明和函数表达式几个方面来讲述 JavaScript 的设计思想.

## 函数即对象

在 JavaScript 中, 函数是一种特殊的对象, 它和对象一样可以拥有属性和值, 但是函数和普通对象不同的是, 函数可以被调用, 所以一个函数被调用时, 它还需要关联相关的执行上下文. 并且除了使用函数名称来实现函数的调用, 还可以直接调用一个匿名函数. 在 V8 中, 会为函数对象添加了两个隐藏属性, 分别是 name 属性和 code 属性.

![函数对象具有隐藏属性](https://edge.yancey.app/beg/o859pe21-1652188558081.webp)

函数对象的默认的 name 属性值就是 anonymous, 表示该函数对象没有被设置名称, 比如立即执行函数. 其他情况我们可以通过 name 属性来获取函数的名称. 另外一个隐藏属性是 code 属性, 其值表示函数代码, 以字符串的形式存储在内存中. 当执行到一个函数调用语句时, V8 便会从函数对象中取出 code 属性值, 也就是函数代码, 然后再解释执行这段函数代码.

```ts
function foo() {
  console.log(""Hello, world!"");
}

foo.name; // 'foo'
```

## 对象存储策略

我们知道对象是由一组组属性和值的集合, 因此内部使用字典存储是再好不过的了. 不过在 V8 实现对象存储时, 并没有完全采用字典的存储方式, 这主要是出于性能的考量. 因为字典是非线性的数据结构, 查询效率会低于线性的数据结构, V8 为了提升存储和查找效率, 采用了一套复杂的存储策略.

### 常规属性(properties)和排序属性(element)

```ts
function Foo() {
  this[100] = ""test-100"";
  this[1] = ""test-1"";
  this[""B""] = ""bar-B"";
  this[50] = ""test-50"";
  this[9] = ""test-9"";
  this[8] = ""test-8"";
  this[3] = ""test-3"";
  this[5] = ""test-5"";
  this[""A""] = ""bar-A"";
  this[""C""] = ""bar-C"";
}
const bar = new Foo();

for (const key in bar) {
  console.log(`index:${key}  value:${bar[key]}`);
}
```

![打印顺序](https://edge.yancey.app/beg/ztq1tyg2-1652197279731.jpg)

在上面这段代码中, 我们利用构造函数 Foo 创建了一个 bar 对象, 在构造函数中, 我们给 bar 对象设置了很多属性, 包括了数字属性和字符串属性, 然后我们枚举出来了 bar 对象中所有的属性, 并将其一一打印. 我们看到打印的顺序并没有按照我们定义的顺序, 规律大致如下:

- 设置的数字属性被最先打印出来了, 并且是按照数字大小的顺序打印的;
- 设置的字符串属性依然是按照之前的设置顺序打印的, 比如我们是按照 B, A, C 的顺序设置的, 打印出来依然是这个顺序.

之所以出现这样的结果, 是因为在 ECMAScript 规范中定义了**数字属性应该按照索引值大小升序排列, 字符串属性根据创建时的顺序升序排列**. 在这里我们把对象中的数字属性称为**排序属性**, 在 V8 中被称为 **elements**, 字符串属性就被称为**常规属性**, 在 V8 中被称为 **properties**.

在 V8 内部, 为了有效地提升存储和访问这两种属性的性能, 分别使用了两个线性数据结构来分别保存排序属性和常规属性, 具体结构如下图所示:

![V8 内部的对象构造](https://edge.yancey.app/beg/cf3fa67s-1652197503434.webp)

通过上图我们可以发现, bar 对象包含了两个隐藏属性: elements 属性和 properties 属性, elements 属性指向了 elements 对象, 在 elements 对象中, 会按照顺序存放排序属性, properties 属性则指向了 properties 对象, 在 properties 对象中, 会按照创建时的顺序保存了常规属性.

分解成这两种线性数据结构之后, 如果执行索引操作, 那么 V8 会先从 elements 属性中按照顺序读取所有的元素, 然后再在 properties 属性中读取所有的元素, 这样就完成一次索引操作. 这也就说为什么在遍历的过程中, 会先遍历排序属性, 然后再遍历常规属性.

### 快属性和慢属性

将不同的属性分别保存到 elements 属性和 properties 属性中, 无疑简化了程序的复杂度, 但是在查找元素时, 却多了一步操作, 比如执行 `bar.B` 这个语句来查找 B 的属性值, 那么在 V8 会先查找出 properties 属性所指向的对象 properties, 然后再在 properties 对象中查找 B 属性, 这种方式在查找过程中增加了一步操作, 因此会影响到元素的查找效率.

基于这个原因, V8 采取了一个权衡的策略以加快查找属性的效率, 这个策略是将部分常规属性直接存储到对象本身, 我们把这称为**对象内属性(in-object properties)**. 对象在内存中的展现形式我们可以参看下图. 采用对象内属性之后, 常规属性就被保存到 bar 对象本身了, 这样当再次使用 `bar.B` 来查找 B 的属性值时, V8 就可以直接从 bar 对象本身去获取该值就可以了, 这种方式减少查找属性值的步骤, 增加了查找效率. 不过对象内属性的数量是固定的, 默认是 10 个, 如果添加的属性超出了对象分配的空间, 则它们将被保存在常规属性存储中.

![对象内属性](https://edge.yancey.app/beg/nyzhh27b-1652197794634.webp)

通常, 我们将保存在线性数据结构中的属性称之为**快属性**, 因为线性数据结构中只需要通过索引即可以访问到属性, 虽然访问线性结构的速度快, 但是如果从线性结构中添加或者删除大量的属性时, 则执行效率会非常低, 这会产生大量时间和内存开销.

因此, 如果一个对象的属性过多时, V8 就会采取另外一种存储策略, 那就是**慢属性**策略, 但慢属性的对象内部会有独立的非线性数据结构(词典) 作为属性存储容器. 所有的属性元信息不再是线性存储的, 而是直接保存在属性字典中.

![慢属性保存在字典中](https://edge.yancey.app/beg/m564o9ou-1652198315857.webp)

### 实践: 在 Chrome 中查看对象布局

```ts
function Foo(property_num, element_num) {
  //添加可索引属性
  for (let i = 0; i < element_num; i++) {
    this[i] = `element-${i}`;
  }
  //添加常规属性
  for (let i = 0; i < property_num; i++) {
    const str = `property-${i}`;
    this[str] = str;
  }
}

const bar = new Foo(10, 10);
```

我们首先创建 10 个常规属性和 10 个 element, 在控制台先执行一下, 然后打开 Memory tab, 录制一下, 就得到了数据内存布局. 通过下图, 我们发现:

- 10 个常规属性作为对象内属性, 存放在 bar 函数内部;
- 10 个排序属性存放在 elements 中.

![new Foo(10, 10)](https://edge.yancey.app/beg/dvs3szq6-1652199279084.jpg)

接下来我们调整一下参数, `const bar2 = new Foo(20, 10)`, 使得常规属性变成 20 个. 由于创建的常用属性超过了 10 个, 所以另外 10 个常用属性就被保存到 properties 中了, 但因为 properties 中只有 10 个属性, 所以依然是线性的数据结构, 我们可以看其都是按照创建时的顺序来排列的. 因此:

- 10 个常规属性直接存放在 bar2 的对象内;
- 10 个常规属性以线性数据结构的方式存放在 properties 属性里面;
- 10 个数字属性存放在 elements 属性里面.

![new Foo(20, 10)](https://edge.yancey.app/beg/s19hzjb8-1652199703556.jpg)

接下来我们调整一下参数, `const bar3 = new Foo(100, 10)`, 使得常规属性变成 100 个. 由于创建的常用属性超过了 10 个, 所以另外 90 个常用属性就被保存到 properties 中了, 但因为 properties 中超过了 10 个属性, 所以就不是线性的数据结构了, 因此:

- 10 个常规属性直接存放在 bar2 的对象内;
- 90 个常规属性以非线性数据结构的方式存放在 properties 属性里面;
- 10 个数字属性存放在 elements 属性里面.

![new Foo(100, 10)](https://edge.yancey.app/beg/oqyv07ku-1652200735684.jpg)

观察上面的三张图片, 除了 elements 和 properties 属性, V8 还为每个对象实现了 map 属性和 `__proto__` 属性. `__proto__` 属性就是原型, 用来实现 JavaScript 继承的; 而 map 则是隐藏类, 用于在内存中快速查找对象属性, 我们后面都会介绍到.

## 函数声明和函数表达式

我们知道函数有**函数声明**和**函数表达式**两种形式. 如下 foo 为函数声明, bar 为函数表达式.

```ts
function foo() {}

const bar = function () {};
```

首先我们谈一谈表达式和语句的区别. 简单来说, 语句是为了进行某种操作, 一般情况下不需要返回值, 而表达式都是为了得到返回值, 一定会返回一个值. 举个例子, `if (a === 1) {}`, 这个 if 声明的就是一条语句, 而里面的 `a === 1` 就是一条表达式. 因为 `a === 1` 一定返回一个 boolean 类型.

### 函数声明

我们先看看 V8 是怎么处理函数声明的. 以下面的代码为例:

```ts
var x = 5;
function foo() {
  console.log(""Foo"");
}
```

![上面这段代码的作用域](https://edge.yancey.app/beg/1shqp0m0-1652278774490.webp)

函数声明和变量声明类似, V8 在编译阶段, 都会对其执行变量提升的操作, 将它们提升到作用域中, 在执行阶段, 如果使用了某个变量, 就可以直接去作用域中去查找. 不过 V8 对于提升函数和提升变量的策略是不同的, 如果提升了一个变量, 那么 V8 在将变量提升到作用域中时, 还会为其设置默认值 undefined, 如果是函数声明, 那么 V8 会在内存中创建该函数对象, 并提升整个函数对象.

因此对于 `var x = 5;`, 在 V8 执行 var x = 5 这段代码时, 会认为它是两段代码, 一段是定义变量的语句, 一段是赋值的表达式, 如下所示:

```ts
var x = undefined;
x = 5;
```

首先, 在变量提升阶段, V8 并不会执行赋值的表达式, 该阶段只会分析基础的语句, 比如变量的定义, 函数的声明. 而这两行代码是在不同的阶段完成的, `var x` 是在编译阶段完成的, 也可以说是在变量提升阶段完成的, 而 `x = 5` 是表达式, 所有的表达式都是在执行阶段完成的. 在变量提升阶段, V8 将这些变量存放在作用域时, 还会给它们赋一个默认的 undefined 值, 所以在定义一个普通的变量之前, 使用该变量, 那么该变量的值就是 undefined.

对于一个普通的函数声明, 执行它并没有输出任何内容, 所以可以肯定, 函数声明并不是一个表达式, 而是一个语句. V8 在变量提升阶段, 如果遇到函数声明, 那么 V8 同样会对该函数声明执行变量提升操作. 函数也是一个对象, 所以在编译阶段, V8 就会将整个函数对象提升到作用域中, 但不是给该函数名称赋一个 undefined, 而是 V8 会在内存中为声明生成函数对象, 并将该对象提升到作用域中.

### 函数表达式

我们在一个表达式中使用 function 来定义一个函数, 那么就把该函数称为函数表达式. 它与函数声明有三个区别:

- 函数表达式是在表达式语句中使用 function 的, 最典型的表达式是 **a = b** 这种形式, 因为函数也是一个对象, 我们把 **a = function () {}** 这种方式称为函数表达式;
- 在函数表达式中, 可以省略函数名称, 从而创建匿名函数(anonymous functions);
- 一个函数表达式可以被用作一个即时调用的函数表达式, IIFE(Immediately Invoked Function Expression).

以下面这段代码为例:

```ts
foo();

var foo = function () {
  console.log(""foo"");
};
```

不用多数, 我们知道它肯定报错, 因为变量提升, 可以拆分成如下的形式:

```ts
var foo = undefined;
foo = function () {
  console.log(""foo"");
};
```

上面的代码中, 第一行是声明语句, 所以 V8 在解析阶段, 就会在作用域中创建该对象, 并将该对象设置为 undefined, 第二行是函数表达式, 在编译阶段, V8 并不会处理函数表达式, 所以也就不会将该函数表达式提升到作用域中了. 那么在函数表达式之前调用该函数 foo, 此时的 foo 只是指向了 undefined, 所以就相当于调用一个 undefined, 而 undefined 只是一个原生对象, 并不是函数, 所以当然会报错了.

### IIFE

现在我们知道了, 在编译阶段, V8 并不会处理函数表达式, 而 JavaScript 中的立即函数调用表达式正是使用了这个特性来实现了非常广泛的应用. 看 `(a = 3)` 这个代码, JavaScript 中有一个圆括号运算符, 圆括号里面可以放一个表达式, 整个语句也是一个表达式, 最终输出 3.

同理, 如果在小括号里面放上一段函数的定义, 因为小括号之间存放的必须是表达式, 所以如果在小括号里面定义一个函数, 那么 V8 就会把这个函数看成是函数表达式, 执行时它会返回一个函数对象. 如果我直接在表达式后面加上调用的括号, 这就称为立即调用函数表达式(IIFE)

```ts
(function () {
  //statements
})();
```

因为函数立即表达式也是一个表达式, 所以 V8 在编译阶段, 并不会为该表达式创建函数对象. **这样的一个好处就是不会污染环境, 函数和函数内部的变量都不会被其他部分的代码访问到**. 在 ES6 之前, JavaScript 中没有私有作用域的概念, 如果在多人开发的项目中, 你模块中的变量可能覆盖掉别人的变量, 所以使用函数立即表达式就可以将我们内部变量封装起来, 避免了相互之间的变量污染.

另外, 因为函数立即表达式是立即执行的, 所以将一个函数立即表达式赋给一个变量时, 不是存储 IIFE 本身, 而是存储 IIFE 执行后返回的结果. 如下所示:

```ts
var a = (function () {
  return 1;
})();

console.log(a); // 1
```

## V8 编译流水线

聊完了 JavaSript 的设计思想, 我们来聊一聊 V8 编译流水线, 即 V8 执行 JavaScript 代码的这套流程. 它涉及 JIT, 延迟解析, 隐藏类, 内联缓存等等. 这些技术决定着一段 JavaScript 代码能否正常执行, 以及代码的执行效率.

比如 V8 中使用的隐藏类(Hide Class), 这是将 JavaScript 中动态类型转换为静态类型的一种技术, 可以消除动态类型的语言执行速度过慢的问题, 那么我们在编写 JavaScript 时, 就可以充分利用好隐藏类这种强大的优化特性, 写出更加高效的代码. 再比如, V8 实现了 JavaScript 代码的惰性解析, 目的是为了加速代码的启动速度, 通过对惰性解析机制的学习, 我们可以优化代码来更加适应这个机制, 从而提高程序性能.

我们会从运行时环境, 惰性解析, 字节码, 隐藏类, 内联缓存等方面来讲述 V8 编译流水线, 此外, 我们还会使用 D8 来实战生成一段 JavaScript 源码的 AST, 作用域, 字节码.

## 运行时环境

在执行 JavaScript 代码之前, V8 就已经准备好了代码的运行时环境, 这个环境包括了堆空间和栈空间, 全局执行上下文, 全局作用域, 内置的内建函数, 宿主环境提供的扩展函数和对象, 还有消息循环系统. 准备好运行时环境之后, V8 才可以执行 JavaScript 代码, 这包括解析源码, 生成字节码, 解释执行或者编译执行这一系列操作.

在聊运行 V8 的运行时环境, 我们先聊 V8 的宿主环境. 在浏览器环境, 浏览器为 V8 提供基础的消息循环系统, 全局变量, Web API, 而 V8 的核心是实现了 ECMAScript 标准, 这相当于病毒自己的 DNA 或者 RNA, V8 只提供了 ECMAScript 定义的一些对象和一些核心的函数, 这包括了 Object, Function, String. 除此之外, V8 还提供了垃圾回收器, 协程等基础内容, 不过这些功能依然需要宿主环境的配合才能完整执行. 此外, Node.js 也是 V8 的另外一种宿主环境, 它提供了不同的宿主对象和宿主的 API, 但是整个流程依然是相同的, 比如 Node.js 也会提供一套消息循环系统, 也会提供一个运行时的主线程.

如果 V8 使用不当, 比如不规范的代码触发了频繁的垃圾回收, 或者某个函数执行时间过久, 这些都会占用宿主环境的主线程, 从而影响到程序的执行效率, 甚至导致宿主环境的卡死.

![V8 和宿主环境](https://edge.yancey.app/beg/nf369msu-1652718837225.webp)

### 构造数据存储空间: 堆空间和栈空间

由于 V8 是寄生在浏览器或者 Node.js 这些宿主中的, 因此, V8 也是被这些宿主启动的. 比如, 在 Chrome 中, 只要打开一个渲染进程, 渲染进程便会初始化 V8, 同时初始化堆空间和栈空间.

栈空间主要是用来管理 JavaScript 函数调用的, 栈是内存中连续的一块空间, 同时栈结构是**先进后出**的策略. 在函数调用过程中, 涉及到上下文相关的内容都会存放在栈上, 比如原生类型, 引用到的对象的地址, 函数的执行状态, this 值等都会存在在栈上. 当一个函数执行结束, 那么该函数的执行上下文便会被销毁掉.

栈空间的最大的特点是空间连续, 所以在栈中每个元素的地址都是固定的, 因此栈空间的查找效率非常高, 但是通常在内存中, 很难分配到一块很大的连续空间, 因此, V8 对栈空间的大小做了限制, 如果函数调用层过深, 那么 V8 就有可能抛出栈溢出的错误.

如果有一些占用内存比较大的数据, 或者不需要存储在连续空间中的数据, 使用栈空间就显得不是太合适了, 所以 V8 又使用了堆空间. 堆空间是一种树形的存储结构, 用来存储对象类型的离散的数据, 由于堆空间中的数据不是线性存储的, 所以堆空间可以存放很多数据, 但是读取的速度会比较慢. JavaScript 中除了原生类型的数据, 其他的都是对象类型, 诸如函数, 数组, 在浏览器中还有 window 对象, document 对象等, 这些都是存在堆空间的.

下面我们从函数调用角度来分析堆和栈, 以及函数调用是如何影响到内存布局的.

```ts
function foo() {
  foo();
}

function foo() {
  setTimeout(foo, 0);
}

function foo() {
  return Promise.resolve().then(foo);
}
```

上面的三段代码, 如果执行 foo 函数, 会有三种不同的结局:

1. 第一段代码是在同一个任务中重复调用嵌套的 foo 函数, V8 就会报告栈溢出的错误.
2. 第二段代码是使用 setTimeout 让 foo 函数在不同的任务中执行, 不会栈溢出, 也不会卡死. 这段代码之所以不会导致栈溢出, 是因为 setTimeout 会使得 foo 函数在消息队列后面的任务中执行, 所以不会影响到当前的栈结构
3. 第三段代码是在同一个任务中执行 foo 函数, 但是却不是嵌套执行, 不会栈溢出, 但页面会卡死. 这是因为当执行 foo 函数时, 由于 foo 函数中调用了 Promise.resolve(), 这会触发一个微任务, 那么此时, V8 会将该微任务添加进微任务队列中, 退出当前 foo 函数的执行. 然后, V8 在准备退出当前的宏任务之前, 会检查微任务队列, 发现微任务队列中有一个微任务, 于是先执行微任务. 由于这个微任务就是调用 foo 函数本身, 所以在执行微任务的过程中, 需要继续调用 foo 函数, 在执行 foo 函数的过程中, 又会触发了同样的微任务. 那么这个循环就会一直持续下去, 当前的宏任务无法退出, 也就意味着消息队列中其他的宏任务是无法被执行的, 比如通过鼠标、键盘所产生的事件. 这些事件会一直保存在消息队列中, 页面无法响应这些事件, 具体的体现就是页面的卡死. 但是由于 V8 每次执行微任务时, 都会退出当前 foo 函数的调用栈, 所以这段代码是不会造成栈溢出的.

这是因为, V8 执行这三种不同代码时, 它们的内存布局是不同的, 而不同的内存布局又会影响到代码的执行逻辑, 因此我们需要了解 JavaScript 执行时的内存布局.

在讲内存布局之前, 我们先说下大部分高级语言为什么采用栈这种结构来管理函数调用. 这与函数的特性有关:

1. 第一个特点是函数可以被调用, 你可以在一个函数中调用另外一个函数, 当函数调用发生时, 执行代码的控制权将从父函数转移到子函数, 子函数执行结束之后, 又会将代码执行控制权返还给父函数;
2. 第二个特点是函数具有作用域机制, 所谓作用域机制, 是指函数在执行的时候可以将定义在函数内部的变量和外部环境隔离, 在函数内部定义的变量我们也称为临时变量, 临时变量只能在该函数中被访问, 外部函数通常无权访问, 当函数执行结束之后, 存放在内存中的临时变量也随之被销毁.

比如下面这段 C 代码:

```cpp
int getZ()
{
    return 4;
}
int add(int x, int y)
{
    int z = getZ();
    return x + y + z;
}
int main()
{
    int x = 5;
    int y = 6;
    int ret = add(x, y);
}
```

1. 当 main 函数调用 add 函数时, 需要将代码执行控制权交给 add 函数;
2. 然后 add 函数又调用了 getZ 函数, 于是又将代码控制权转交给 getZ 函数;
3. 接下来 getZ 函数执行完成, 需要将控制权返回给 add 函数;
4. 同样当 add 函数执行结束之后, 需要将控制权返还给 main 函数;
5. 然后 main 函数继续向下执行.

通过上述分析, 我们可以得出, **函数调用者的生命周期总是长于被调用者(后进), 并且被调用者的生命周期总是先于调用者的生命周期结束(先出)**.

![嵌套调用时函数的生命周期](https://edge.yancey.app/beg/y154oy5t-1652971591868.webp)

再谈一谈作用域, 作用域机制通常表现在函数执行时, 会在内存中分配函数内部的变量, 上下文等数据, 在函数执行完成之后, 这些内部数据会被销毁掉. **所以站在函数资源分配和回收角度来看, 被调用函数的资源分配总是晚于调用函数(后进), 而函数资源的释放则总是先于调用函数(先出)**.

![函数资源分配流程](https://edge.yancey.app/beg/xlh7ysp4-1652971666001.webp)

所以既然都是后进先出的结构, 那么使用栈是再合适不过的了, 因此我们会使用栈这种数据结构来管理函数的调用过程, 我们也把管理函数调用过程的栈结构称之为**调用栈**. 我们来用栈的思想分析下面一个例子:

```cpp
int add(num1,num2){
    int x = num1;
    int y = num2;
    int ret = x + y;
    return ret;
}


int main()
{
    int x = 5;
    int y = 6;
    x = 100;
    int z = add(x,y);
    return z;
}
```

首先执行 main, 会把 x, y 压入栈中, 当执行到 `int z = add(x, y)` 时, 会把形参 num1, num2, 再把变量 x, y, ret 的值依次压栈中. 当 add 函数执行完成之后, 需要将执行代码的控制权转交给 main 函数, 这意味着需要将栈的状态恢复到 main 函数上次执行时的状态, 我们把这个过程叫**恢复现场**.

恢复现场的方法很简单, 就是在寄存器中保存一个永远指向当前栈顶的指针, 栈顶指针的作用就是告诉你应该往哪个位置添加新元素, 这个指针通常存放在 esp 寄存器中. 如果你想往栈中添加一个元素, 那么你需要先根据 esp 寄存器找到当前栈顶的位置, 然后在栈顶上方添加新元素, 新元素添加之后, 还需要将新元素的地址更新到 esp 寄存器中. 下面这个图, 在 add 函数 return ret 的时候, ret 被压入栈中, 同时 esp 寄存器也指向 ret.

![add 函数即将执行结束的状态](https://edge.yancey.app/beg/3b9f4xo5-1652972294496.webp)

因此在 add 函数执行完毕后, 将 esp 的指针向下移动到之前 main 函数执行时的地方就可以. 当然 CPU 是怎么知道要移动到这个地址呢? CPU 的解决方法是增加了另外一个 ebp 寄存器, 用来保存当前函数的起始位置, 我们把一个函数的起始位置也称为栈帧指针(每个栈帧对应着一个未运行完的函数, 栈帧中保存了该函数的返回地址和局部变量), ebp 寄存器中保存的就是当前函数的栈帧指针. 在 main 函数调用 add 函数的时候, main 函数的栈顶指针就变成了 add 函数的栈帧指针, 所以需要将 main 函数的栈顶指针保存到 ebp 中, 当 add 函数执行结束之后, 我需要销毁 add 函数的栈帧, 并恢复 main 函数的栈帧, 那么只需要取出 main 函数的栈顶指针写到 esp 中即可, 这就相当于将栈顶指针移动到 main 函数的区域.

![恢复 main 函数执行现场](https://edge.yancey.app/beg/egf81hy8-1652972303266.webp)

不过现在仍然不能执行 main 函数. 因为 main 函数也有它自己的栈帧指针, 在执行 main 函数之前, 我们还需恢复它的栈帧指针. 通常的方法是在 main 函数中调用 add 函数时, CPU 会将当前 main 函数的栈帧指针保存在栈中. 当函数调用结束之后, 就需要恢复 main 函数的执行现场了, 首先取出 ebp 中的指针, 写入 esp 中, 然后从栈中取出之前保留的 main 的栈帧地址, 将其写入 ebp 中, 到了这里 ebp 和 esp 就都恢复了, 可以继续执行 main 函数了.

![当前 main 函数的栈帧指针保存在栈](https://edge.yancey.app/beg/8xz8i998-1652972667151.webp)

> 关于 CPU, 寄存器, 内存等知识可以看[浅析 CPU 是如何执行二进制机器码的](https://www.yanceyleo.com/post/950d248c-3127-4fc9-8dfc-f460c439a38d)这篇文章.

回到上面的 JavaScript 代码, 在 JavaScript 中, 函数的执行过程也是类似的, 如果调用一个新函数, 那么 V8 会为该函数创建栈帧, 等函数执行结束之后, 销毁该栈帧, 而栈结构的容量是固定的, 所有如果重复嵌套执行一个函数, 那么就会导致栈会栈溢出.

因此, 栈有以下两个优势:

- 栈的结构和非常适合函数调用过程.
- 在栈上分配资源和销毁资源的速度非常快, 这主要归结于栈空间是连续的, 分配空间和销毁空间只需要移动下指针就可以了.

不过正是因为栈是连续的, 所以要想在内存中分配一块连续的大空间是非常难的, 因此栈空间是有限的. 因为栈空间是有限的, 这就导致我们在编写程序的时候, 经常一不小心就会导致栈溢出, 比如函数循环嵌套层次太多, 或者在栈上分配的数据过大, 都会导致栈溢出, 基于栈不方便存放大的数据, 因此我们使用了另外一种数据结构用来保存一些大数据, 这就是**堆**. 和栈空间不同, 存放在堆空间中的数据是不要求连续存放的, 从堆上分配内存块没有固定模式的, 你可以在任何时候分配和释放它.

### 全局执行上下文和全局作用域

V8 初始化了基础的存储空间之后, 接下来就需要初始化全局执行上下文和全局作用域了, 当 V8 开始执行一段可执行代码时, 会生成一个执行上下文. V8 用执行上下文来维护执行当前代码所需要的变量声明, this 指向等.

执行上下文中主要包含三部分, 变量环境, 词法环境和 this 关键字. 比如在浏览器的环境中, 全局执行上下文中就包括了 window 对象, 还有默认指向 window 的 this 关键字, 另外还有一些 Web API 函数, 诸如 setTimeout, XMLHttpRequest 等内容.

而词法环境中, 则包含了使用 let, const 等变量的内容.

全局执行上下文在 V8 的生存周期内是不会被销毁的, 它会一直保存在堆中, 这样当下次在需要使用函数或者全局变量时, 就不需要重新创建了. 另外, 当你执行了一段全局代码时, 如果全局代码中有声明的函数或者定义的变量, 那么函数对象和声明的变量都会被添加到全局执行上下文中. 比如下面这段代码, V8 在执行这段代码的过程中, 会在全局执行上下文中添加变量 x 和函数 show_x.

```ts
var x = 1;
function show_x() {
  console.log(x);
}
```

我们需要注意全局作用域和全局执行上下文的关系, 在 ES6 中, 同一个全局执行上下文中, 都能存在多个作用域. 比如下面这段代码在执行时, 就会有两个对应的作用域, 一个是全局作用域, 另外一个是括号内部的作用域, 但是这些内容都会保存到全局执行上下文中.

```ts
var x = 5;
{
  let y = 2;
  const z = 3;
}
```

当 V8 调用了一个函数时, 就会进入函数的执行上下文, 这时候全局执行上下文和当前的函数执行上下文就形成了一个栈结构. 比如执行下面这段代码:

```ts
var x = 1;
function show_x() {
  console.log(x);
}
function bar() {
  show_x();
}
bar();
```

当执行到 show_x 的时候, 其栈状态如下图所示:

![函数调用栈](https://edge.yancey.app/beg/pg7kib8z-1652719750511.webp)

### 构造事件循环系统

有了堆空间和栈空间, 生成了全局执行上下文和全局作用域, JavaScript 代码仍然是不可以被执行的, 这是因为 V8 还需要有一个主线程, 用来执行 JavaScript 和执行垃圾回收等工作. V8 是寄生在宿主环境中的, 它并没有自己的主线程, 而是使用宿主所提供的主线程, V8 所执行的代码都是在宿主的主线程上执行的.

只有一个主线程依然不行, 因为如果你开启一个线程, 在该线程执行一段代码, 那么当该线程执行完这段代码之后, 就会自动退出了, 执行过程中的一些栈上的数据也随之被销毁, 下次再执行另外一个段代码时, 你还需要重新启动一个线程, 重新初始化栈数据, 这会严重影响到程序执行时的性能.

为了在执行完代码之后, 让线程继续运行, 通常的做法是在代码中添加一个循环语句, 在循环语句中监听下个事件, 比如你要执行另外一个语句, 那么激活该循环就可以执行了. 比如下面的模拟代码, 使用了一个循环, 不同地获取新的任务, 一旦有新的任务, 便立即执行该任务.

```c++

while(1){
  Task task = GetNewTask();
  RunTask(task);
}
```

如果主线程正在执行一个任务, 这时候又来了一个新任务, 比如 V8 正在操作 DOM, 这时候浏览器的网络线程完成了一个页面下载的任务, 而且 V8 注册监听下载完成的事件, 那么这种情况下就需要引入一个消息队列, 让下载完成的事件暂存到消息队列中, 等当前的任务执行结束之后, 再从消息队列中取出正在排队的任务. 当执行完一个任务之后, 我们的事件循环系统会重复这个过程, 继续从消息队列中取出并执行下个任务. 这就是事件循环.

需要注意的是, 因为所有的任务都是运行在主线程的, 在浏览器的页面中, V8 会和页面共用主线程, 共用消息队列, 所以如果 V8 执行一个函数过久, 会影响到浏览器页面的交互性能.

## V8 的惰性解析

在编译 JavaScript 代码的过程中, V8 并不会一次性将所有的 JavaScript 解析为中间代码, 这主要是基于以下两点:

- 首先, 如果一次解析和编译所有的 JavaScript 代码, 过多的代码会增加编译时间, 这会严重影响到首次执行 JavaScript 代码的速度, 让用户感觉到卡顿. 因为有时候一个页面的 JavaScript 代码都有 10 多兆, 如果要将所有的代码一次性解析编译完成, 那么会大大增加用户的等待时间;

- 其次, 解析完成的字节码和编译之后的机器代码都会存放在内存中, 如果一次性解析和编译所有 JavaScript 代码, 那么这些中间代码和机器代码将会一直占用内存, 特别是在手机普及的年代, 内存是非常宝贵的资源.

因此, V8 是实现了**惰性解析**. 所谓惰性解析是指解析器在解析的过程中, 如果遇到函数声明, 那么会跳过函数内部的代码, 并不会为其生成 AST 和字节码, 而仅仅生成顶层代码的 AST 和字节码.

```ts
function foo(a, b) {
  var d = 100;
  var f = 10;
  return d + f + a + b;
}
var a = 1;
var c = 4;
foo(1, 5);
```

当把这段代码交给 V8 处理时, V8 会至上而下解析这段代码, 在解析过程中首先会遇到 foo 函数, 由于这只是一个函数声明语句, V8 在这个阶段只需要将该函数转换为函数对象, 但是并没有解析和编译函数内部的代码, 所以也不会为 foo 函数的内部代码生成抽象语法树. 然后继续往下解析, 由于后续的代码都是顶层代码, 所以 V8 会为它们生成抽象语法树.

代码解析完成之后, V8 便会按照顺序自上而下执行代码, 首先会先执行 `a = 1` 和 `c = 4` 这两个赋值表达式, 接下来执行 foo 函数的调用, 过程是从 foo 函数对象中取出函数代码, 然后和编译顶层代码一样, V8 会先编译 foo 函数的代码, 编译时同样需要先将其编译为抽象语法树和字节码, 然后再解释执行.

### 闭包

但是当惰性解析遇上闭包, 就要有特殊的策略了, 首先我们先复习一下闭包.

因为函数是一种特殊的对象, 所以在 JavaScript 中, 函数可以赋值给一个变量, 也可以作为函数的参数, 还可以作为函数的返回值. **如果某个编程语言的函数, 可以和这个语言的数据类型做一样的事情, 我们就把这个语言中的函数称为一等公民**. 但是由于函数的**可被调用**的特性, 使得实现函数的可赋值, 可传参和可作为返回值等特性变得有一点麻烦.

我们知道, 在执行 JavaScript 函数的过程中, 为了实现变量的查找, V8 会为其维护一个作用域链, 如果函数中使用了某个变量, 但是在函数内部又没有定义该变量, 那么函数就会沿着作用域链去外部的作用域中查找该变量, 具体流程如下图所示:

![函数作用域链](https://edge.yancey.app/beg/yteojceh-1652189472973.webp)

从图中可以看出, 当函数内部引用了外部的变量时, 使用这个函数进行赋值, 传参或作为返回值, 我们还需要保证这些被引用的外部变量是确定存在的, 这就是让函数作为一等公民麻烦的地方, 因为虚拟机还需要处理函数引用的外部变量. 我们来看一段简单的代码:

```ts
function foo() {
  var number = 1;
  function bar() {
    number++;
    console.log(number);
  }
  return bar;
}
var mybar = foo();
mybar();
```

我们在 foo 函数中定义了一个新的 bar 函数, 并且 bar 函数引用了 foo 函数中的变量 number, 当调用 foo 函数的时候, 它会返回 bar 函数. 那么所谓的**函数是一等公民**就体现在, 如果要返回函数 bar 给外部, 那么即便 foo 函数执行结束了, 其内部定义的 number 变量也不能被销毁, 因为 bar 函数依然引用了该变量. 我们也把这种将外部变量和和函数绑定起来的技术称为闭包.

### 当惰性解析遇上闭包

对于普通函数, V8 确实是这么解析的, 但由于存在闭包, 一切都变得复杂起来了. 这是因为闭包有三大特性:

- 可以在 JavaScript 函数内部定义新的函数;
- 内部函数中访问父函数中定义的变量;
- 因为 JavaScript 中的函数是一等公民, 所以函数可以作为另外一个函数的返回值.

```ts
function foo() {
  var d = 20;
  return function inner(a, b) {
    const c = a + b + d;
    return c;
  };
}
const f = foo();
```

我们考察上面这段代码.

- 当调用 foo 函数时, foo 函数会将它的内部函数 inner 返回给全局变量 f;
- 然后 foo 函数执行结束, 执行上下文被 V8 销毁;
- 虽然 foo 函数的执行上下文被销毁了, 但是依然存活的 inner 函数引用了 foo 函数作用域中的变量 d.

按照通用的做法, d 已经被 v8 销毁了, 但是由于存活的函数 inner 依然引用了 foo 函数中的变量 d, 这样就会带来两个问题:

- 当 foo 执行结束时, 变量 d 该不该被销毁？如果不应该被销毁, 那么应该采用什么策略？
- 如果采用了惰性解析, 那么当执行到 foo 函数时, V8 只会解析 foo 函数, 而不会解析内部代码, 也就是并不会解析内部的 inner 函数, 那么这时候 V8 就不知道 inner 函数中是否引用了 foo 函数的变量 d.

我们佐以下面这张图执行堆栈图来分析一下:

![堆栈图](https://edge.yancey.app/beg/zv8jkgew-1653035189629.jpeg)

从上图可以看出来, 在执行全局代码时, V8 会将全局执行上下文压入到调用栈中, 然后进入执行 foo 函数的调用过程, 这时候 V8 会为 foo 函数创建执行上下文, 执行上下文中包括了变量 d, 然后将 foo 函数的执行上下文压入栈中, foo 函数执行结束之后, foo 函数执行上下文从栈中弹出, 这时候 foo 执行上下文中的变量 d 也随之被销毁.

但是这时候, 由于 inner 函数被保存到全局变量中了, 所以 inner 函数依然存在, 最关键的地方在于 inner 函数使用了 foo 函数中的变量 d, 所以正常的处理方式应该是 foo 函数的执行上下文虽然被销毁了, 但是 inner 函数引用的 foo 函数中的变量却不能被销毁, 那么 V8 就需要为这种情况做特殊处理, 需要保证即便 foo 函数执行结束, 但是 foo 函数中的 d 变量依然保持在内存中, 不能随着 foo 函数的执行上下文被销毁掉.

基于此, V8 在执行 foo 函数的阶段, 虽然采取了惰性解析, 不会解析和执行 foo 函数中的 inner 函数, 但是 V8 还是需要判断 inner 函数是否引用了 foo 函数中的变量, 负责处理这个任务的模块叫做**预解析器**.

V8 引入预解析器, 比如当解析顶层代码的时候, 遇到了一个函数, 那么预解析器并不会直接跳过该函数, 而是对该函数做一次快速的预解析. 第一, 是判断当前函数是不是存在一些语法上的错误; 第二, 除了检查语法错误之外, 预解析器另外的一个重要的功能就是检查函数内部是否引用了外部变量, 如果引用了外部的变量, 预解析器会将栈中的变量复制到堆中, 在下次执行到该函数的时候, 直接使用堆中的引用, 这样就解决了闭包所带来的问题.

## 谈一谈字节码

所谓字节码, 是指编译过程中的中间代码, 你可以把字节码看成是机器代码的抽象, 在 V8 中, 字节码有两个作用:

- 第一个是解释器可以直接解释执行字节码;
- 第二个是优化编译器可以将字节码编译为二进制代码, 然后再执行二进制机器代码.

### 早期的 V8

早期 V8 团队认为先生成字节码再执行字节码的方式, 多了个中间环节, 多出来的中间环节会牺牲代码的执行速度. 于是在早期, V8 团队采取了非常激进的策略, 直接将 JavaScript 代码编译成没有优化的二进制的机器代码, 如果某一段二进制代码执行频率过高, 那么 V8 会将其标记为热点代码, 热点代码会被优化编译器优化, 优化后的机器代码执行效率更高.

![早期的 V8](https://edge.yancey.app/beg/l0jm4oqs-1653039036551.webp)

观察上面的执行流程图, 我们可以发现, 早期的 V8 也使用了两个编译器:

- 第一个是**基线编译器**, 它负责将 JavaScript 代码编译为**没有优化**过的机器代码.
- 第二个是**优化编译器**, 它负责将一些热点代码(执行频繁的代码）**优化**为执行效率更高的机器代码.

了解这两个编译器之后, 接下来我们再来看看早期的 V8 是怎么执行一段 JavaScript 代码的.

1. 首先, V8 会将一段 JavaScript 代码转换为抽象语法树 (AST).
2. 接下来基线编译器会将抽象语法树编译为未优化过的机器代码, 然后 V8 直接执行这些未优化过的机器代码.
3. 在执行未优化的二进制代码过程中, 如果 V8 检测到某段代码重复执行的概率过高, 那么 V8 会将该段代码标记为 HOT, 标记为 HOT 的代码会被优化编译器优化成执行效率高的二进制代码, 然后就执行该段优化过的二进制代码.
4. 不过如果优化过的二进制代码并不能满足当前代码的执行, 这也就意味着优化失败, V8 则会执行反优化操作.

### 机器代码缓存

当 JavaScript 代码在浏览器中被执行的时候, 需要先被 V8 编译, 早期的 V8 会将 JavaScript 编译成未经优化的二进制机器代码, 然后再执行这些未优化的二进制代码, 通常情况下, 编译占用了很大一部分时间. 为了能够复用编译好的二进制代码, Chrome 浏览器引入二进制代码缓存. 过把二进制代码保存在内存中来消除冗余的编译, 重用它们完成后续的调用, 这样就省去了再次编译的时间. V8 使用两种代码缓存策略来缓存生成的代码:

- 首先, 是 V8 第一次执行一段代码时, 会编译源 JavaScript 代码, 并将编译后的二进制代码缓存在内存中, 我们把这种方式称为内存缓存(in-memory cache). 然后通过 JavaScript 源文件的字符串在内存中查找对应的编译后的二进制机器码. 这样当再次执行到这段代码时, V8 就可以直接去内存中查找是否编译过这段代码. 如果内存缓存中存在这段代码所对应的二进制代码, 那么就直接执行编译好的二进制代码.
- 其次, V8 除了采用将代码缓存在内存中策略之外, 还会将代码缓存到硬盘上, 这样即便关闭了浏览器, 下次重新打开浏览器再次执行相同代码时, 也可以直接重复使用编译好的二进制代码.

从数据上看, 在浏览器中采用了二进制代码缓存的方式, 初始加载时分析和编译的时间缩短了 20%-40%.

### 为什么又采用了字节码

上面说到旧时代的 V8 将二进制机器码保存起来, 这显然是一种**空间换时间**的策略. 我们知道 Chrome 的多进程架构已经非常吃内存了, 而二进制机器码数千倍于相应的 JavaScript 代码, 在 PC 端尚可, 而在早期智能手机上 RAM 是吃不消的.

此外, 我们上面说到了惰性编译, 它除了能提升 JavaScript 启动速度, 还可以解决部分内存占用的问题(毕竟函数体内的东西在未执行前没有解析, 因此早期的 Chrome 并没有缓存函数内部的二进制代码, 只是缓存了顶层次的二进制代码). 比如下面的图片,当 V8 首次执行这段代码的过程中, 开始只是编译最外层的代码, 那些函数内部的代码, 如下图中的黄色的部分, 会推迟到第一次调用时再编译. 为了解决缓存的二进制机器代码占用过多内存的问题, 早期的 Chrome 并没有缓存函数内部的二进制代码, 只是缓存了顶层次的二进制代码, 比如上图中红色的区域.

![旧时代 V8 的惰性解析与缓存策略](https://edge.yancey.app/beg/5m2vna20-1653041696169.webp)

但是, 如果惰性编译遇到 IIFE 就没辙了, 因为按照惰性编译的策略, 如果只缓存了 IIFE 顶层, 没缓存 IIFE 内部的闭包函数, 比如看下面的代码, init, add 这些都没法被缓存.

```ts
var test_module = (function () {
  var count_;
  function init_() {
    count_ = 0;
  }
  function add_() {
    count_ = count_ + 1;
  }
  function show_() {
    console.log(count_);
  }
  return {
    init: init_,
    add: add_,
    show: show_,
  };
})();

test_module.init();
test_module.add();
test_module.show();
test_module.add();
test_module.show();
```

所以采取只缓存顶层代码的方式是不完美的, 没办法适应多种不同的情况, 因此, V8 团队对早期的 V8 架构进行了非常大的重构, 具体地讲, 抛弃之前的基线编译器和优化编译器, 引入了字节码, 解释器和新的优化编译器. **而通过引入字节码, 就能降低 V8 在执行时的内存占用**. 从下图中可以看出, 字节码虽然占用的空间比原始的 JavaScript 多, 但是相较于机器代码, 字节码还是小了太多. 有了字节码, 无论是解释器的解释执行, 还是优化编译器的编译执行, 都可以直接针对字节来进行操作. 由于字节码占用的空间远小于二进制代码, 所以浏览器就可以实现缓存所有的字节码, 而不是仅仅缓存顶层的字节码.

![源码, 字节码, 机器码大小对比](https://edge.yancey.app/beg/2gafl0kf-1653043581242.webp)

虽然采用字节码在执行速度上稍慢于机器代码, 但是整体上权衡利弊, 采用字节码也许是最优解. 之所以说是最优解, 是因为采用字节码除了降低内存之外, 还提升了代码的启动速度, 解决空间问题, 并降低了代码的复杂度, 而牺牲的仅仅是一点执行效率:

- 解决启动问题: 源码生成字节码的时间很短, 生成二进制码时间消耗较长;
- 解决空间问题: 字节码占用内存不多, 缓存字节码会大大降低内存的使用;
- 代码架构清晰: 字节码, 一般是在虚拟机上执行的代码, 可以简化程序的复杂度, 使得 V8 移植到不同的 CPU 架构平台更加容易; 而二进制代码代码在不同 CPU 上是不同的.

### 字节码如何提升代码启动速度

![字节码与机器码对比](https://edge.yancey.app/beg/o1xtfd85-1653048098946.webp)

图中可以看出, 生成机器代码比生成字节码需要花费更久的时间, 但是直接执行机器代码却比解释执行字节码要更高效, 所以在快速启动 JavaScript 代码与花费更多时间获得最优运行性能的代码之间, 我们需要找到一个平衡点.

解释器可以快速生成字节码, 但字节码通常效率不高. 相比之下, 优化编译器虽然需要更长的时间进行处理, 但最终会产生更高效的机器码, 这正是 V8 在使用的模型. 它的解释器叫 Ignition, 就原始字节码执行速度而言是所有引擎中最快的解释器. V8 的优化编译器名为 TurboFan, 最终由它生成高度优化的机器码.

### 字节码如何降低代码的复杂度

期的 V8 代码, 无论是基线编译器还是优化编译器, 它们都是基于 AST 抽象语法树来将代码转换为机器码的, 我们知道, 不同架构的机器码是不一样的, 而市面上存在不同架构的处理器又是非常之多. 这意味着基线编译器和优化编译器要针对不同的体系的 CPU 编写不同的代码, 这会大大增加代码量.

![引入了字节码之前](https://edge.yancey.app/beg/he3w0yay-1653048114252.webp)

引入了字节码, 就可以统一将字节码转换为不同平台的二进制代码. 因为字节码的执行过程和 CPU 执行二进制代码的过程类似, 相似的执行流程, 那么将字节码转换为不同架构的二进制代码的工作量也会大大降低, 这就降低了转换底层代码的工作量.

![引入了字节码之后](https://edge.yancey.app/beg/xxyd4dt0-1653048086846.webp)

### 实战: 解释器如何执行字节码的

我们知道当 V8 执行一段 JavaScript 代码时, 会先对 JavaScript 代码进行解析 (Parser), 并生成为 AST 和作用域信息, 之后 AST 和作用域信息被输入到一个称为 Ignition 的解释器中, 并将其转化为字节码, 之后字节码再由 Ignition 解释器来解释执行.

要查看 V8 中间生成的一些结构, 可以使用 V8 提供的调试工具 D8 来查看. 注意不要使用 `brew install v8` 安装, 因为这个是生产环境的 V8, 而我们需要安装 debug 版本的 V8, 才可以进行一些调试. 我们可以使用 [jsvu](https://github.com/GoogleChromeLabs/jsvu), 它是一个 JavaScript 引擎版本更新器, 我们可以通过这个工具安装 debug 版本的 V8.

![V8 debug](https://edge.yancey.app/beg/sjzukz6d-1652107415952.jpg)

然后我们在 .zshrc 或者 .bashrc 中保存如下 shell 脚本, 重启下终端就可以了.

```shell
# D8
export PATH=""${HOME}/.jsvu:${PATH}""
```

我们考察下面这段代码:

```ts
function add(x, y) {
  var z = x + y;
  return z;
}
console.log(add(1, 2));
```

#### AST

执行 `v8-debug --print-ast index.js`, 就可以获取到抽象语法树的结构.

```ts
[generating bytecode for function: add]
--- AST ---
FUNC at 12
. KIND 0
. LITERAL ID 1
. SUSPEND COUNT 0
. NAME ""add""
. PARAMS
. . VAR (0x7fa45f81ce70) (mode = VAR, assigned = false) ""x""
. . VAR (0x7fa45f81cef0) (mode = VAR, assigned = false) ""y""
. DECLS
. . VARIABLE (0x7fa45f81ce70) (mode = VAR, assigned = false) ""x""
. . VARIABLE (0x7fa45f81cef0) (mode = VAR, assigned = false) ""y""
. . VARIABLE (0x7fa45f81cf70) (mode = VAR, assigned = false) ""z""
. BLOCK NOCOMPLETIONS at -1
. . EXPRESSION STATEMENT at 31
. . . INIT at 31
. . . . VAR PROXY local[0] (0x7fa45f81cf70) (mode = VAR, assigned = false) ""z""
. . . . ADD at 33
. . . . . VAR PROXY parameter[0] (0x7fa45f81ce70) (mode = VAR, assigned = false) ""x""
. . . . . VAR PROXY parameter[1] (0x7fa45f81cef0) (mode = VAR, assigned = false) ""y""
. RETURN at 40
. . VAR PROXY local[0] (0x7fa45f81cf70) (mode = VAR, assigned = false) ""z""
```

- 第一部分为参数的声明(PARAMS), 参数声明中包括了所有的参数, 在这里主要是参数 x 和参数 y, 你可以在函数体中使用 arguments 来使用对应的参数.
- 第二部分是变量声明节点(DECLS), 参数部分你可以使用 arguments 来调用, 同样, 你也可以将这些参数作为变量来直接使用, 这体现在 DECLS 节点下面也出现了变量 x 和变量 y, 除了可以直接使用 x 和 y 之外, 我们还有一个 z 变量也在 DECLS 节点下. 你可以注意一下, 在上面生成的 AST 数据中, 参数声明节点中的 x 和变量声明节点中的 x 的地址是相同的, 都是 0x7fa45f81ce70 y 也是相同的, 都是 0x7fa45f81cef0, 这说明它们指向的是同一块数据.
- 第三部分是 `x + y` 的表达式节点, 我们可以看到, 节点 add 下面使用了 `var proxy x` 和 `var proxy x` 的语法, 它们指向了实际 x 和 y 的值.
- 第四部分是 RETURN 节点, 它指向了 z 的值, 在这里是 local[0].

#### 作用域

我们执行 `v8-debug --print-scopes index.js`, 就可以获取到作用域, 作用域中的变量都是未使用的, 默认值都是 undefined, 在执行阶段, 作用域中的变量会指向堆和栈中相应的数据.

在解析期间, 所有函数体中声明的变量和函数参数, 都被放进作用域中, 如果是普通变量, 那么默认值是 undefined, 如果是函数声明, 那么将指向实际的函数对象.

```ts
Global scope:
function add (x, y) { // (0x7fda8d80da20) (12, 51)
  // will be compiled
  // NormalFunction
  // 1 stack slots
  // local vars:
  VAR x;  // (0x7fda8d80dc70) parameter[0], never assigned
  VAR z;  // (0x7fda8d80dd70) local[0], never assigned
  VAR y;  // (0x7fda8d80dcf0) parameter[1], never assigned
}
```

#### 字节码

我们可以通过 `v8-debug --print-bytecode index.js` 来获取字节码.

```ts
[generated bytecode for function: add (0x0ad900253961 <SharedFunctionInfo add>)]
Bytecode length: 7
Parameter count 3
Register count 1
Frame size 8
Bytecode age: 0
         0xad900253b0a @    0 : 0b 04             Ldar a1
         0xad900253b0c @    2 : 39 03 00          Add a0, [0]
         0xad900253b0f @    5 : c4                Star0
         0xad900253b10 @    6 : a9                Return
Constant pool (size = 0)
Handler Table (size = 0)
Source Position Table (size = 0)
```

我们可以看到, 生成的字节码第一行提示了 **Parameter count 3**, 这是告诉我们这里有三个参数, 包括了显式地传入了 x 和 y, 还有一个隐式地传入了 this. 接下来我们先谈一谈解释器的架构设计, 然后再来逐行来了解字节码指令集的作用.

### 解释器的架构设计

字节码似乎和汇编代码有点像, 每一行表示一个特定的功能, 把这些功能拼凑在一起就构成完整的程序, 我们把每一行称为字节码的**指令集**. 如下是截取的部分指令集, 完整的你可以去 [v8 源码](https://github.com/v8/v8/blob/master/src/interpreter/bytecodes.h)里去看.

![部分字节码指令集](https://edge.yancey.app/beg/eltb52ih-1653055002715.webp)

解释器就是模拟物理机器来执行字节码的, 比如可以实现如取指令, 解析指令, 执行指令, 存储数据等, 所以解释器的执行架构和 CPU 处理机器代码的架构类似. 关于这些底层知识, 你可以参考我写的[浅析 CPU 是如何执行二进制机器码的](https://www.yanceyleo.com/post/950d248c-3127-4fc9-8dfc-f460c439a38d)这篇文章.

通常有两种类型的解释器, **基于栈(Stack-based)和基于寄存器(Register-based)**, 基于栈的解释器使用栈来保存函数参数, 中间运算结果, 变量等, 基于寄存器的虚拟机则支持寄存器的指令操作, 使用寄存器来保存参数, 中间计算结果. 基于栈的虚拟机也定义了少量的寄存器, 基于寄存器的虚拟机也有堆栈, 其区别体现在它们提供的指令集体系.

大多数解释器都是基于栈的, 比如 Java 虚拟机, .Net 虚拟机, 还有早期的 V8 虚拟机. 基于堆栈的虚拟机在处理函数调用, 解决递归问题和切换上下文时简单明快. 而**现在的 V8 虚拟机则采用了基于寄存器**的设计, 它将一些中间数据保存到寄存器中.

![基于寄存器的解释器架构](https://edge.yancey.app/beg/c3b4d01a-1653063634071.png)

基于寄存器的解释器执行时主要有四个模块, 内存中的字节码, 寄存器, 栈, 堆. 这和我们在[浅析 CPU 是如何执行二进制机器码的](https://www.yanceyleo.com/post/950d248c-3127-4fc9-8dfc-f460c439a38d)这篇文章中讲到 CPU 执行二进制机器代码的模式是类似的.

- 使用内存中的一块区域来存放字节码;
- 使用了通用寄存器 r0, r1, r2 这些寄存器用来存放一些中间数据;
- PC 寄存器用来指向下一条要执行的字节码;
- 栈顶寄存器用来指向当前的栈顶的位置.

我们先看 `Ldar a1`, Ldar(LoaD Accumulator from Register), 是**累加器**的意思, 表示将寄存器中的值加载到累加器中, `Ldar a1` 的意思就是把 a1 寄存器中的值, 加载到累加器中.

![Ldar](https://edge.yancey.app/beg/yhbfqzwv-1653063977906.png)

再看 `Star r0`, Star(Store Accumulator Register), 就是把累加器中的值保存到某个寄存器中, `Star r0` 的意思就是将累加器中的数值保存到 r0 寄存器中.

![Star](https://edge.yancey.app/beg/x63pwvr1-1653064124451.png)

接下来是 `Add a0, [0]`, `Add a0` 从 a0 寄存器加载值并将其与累加器中的值相加, 然后将结果再次放入累加器, 最终操作如下图所示. 后面的 `[0]` 称为**反馈向量槽(feedback vector slot)**, 它是一个可变数组, 解释器将解释执行过程中的一些数据类型的分析信息都保存在这个反馈向量槽中了, 目的是为了给 TurboFan 优化编译器提供优化信息, 很多字节码都会为反馈向量槽提供运行时信息.

![Add](https://edge.yancey.app/beg/tvejb163-1653064245041.png)

当然最后的 `Return` 指的是结束当前函数的执行, 并将控制权传回给调用方. 返回的值是累加器中的值.

最后让我们捋一下上面这个例子的执行过程:

- 参数对象 parameter 保存在栈中, 包含了 a0 和 a1 两个值, 在上面的代码中, 这两个值分别是 1 和 2;
- 执行字节码, `Ldar a1`, 这是将 a1 寄存器中的参数值加载到累加器中;
- 接下来执行加法操作, `Add a0, [0]`, 因为 a0 是第一个寄存器, 存放了第一个参数, `Add a0` 就是将第一个寄存器中的值和累加器中的值相加, 也就是将累加器中的 2 和通用寄存器中 a0 中的 1 进行相加, 同时将相加后的结果 3 保存到累加器中.
- 现在累加器中就保存了相加后的结果, 然后执行第四段字节码, `Star r0`, 这是将累加器中的值, 也就是 `1 + 2` 的结果 3 保存到寄存器 r0 中, 那么现在寄存器 r0 中的值就是 3 了.
- 接下来 V8 将寄存器 r0 中的值加载到累加器中, 然后执行最后一句 Return 指令, Return 指令会中断当前函数的执行, 并将累加器中的值作为返回值.

### 优化和反优化

生成字节码之后, 解释器会解释执行这段字节码, 如果重复执行了某段代码, 监控器就会将其标记为热点代码, 并提交给编译器优化执行, 如果我们想要查看那些代码被优化了, 可以使用下面的命令. 当然我们的代码太简单了, 没有被标记成热点代码的情况.

```shell
v8-debug --trace-opt index.js
```

如果要查看那些代码被反优化了, 可以使用如下命令行来查看.

```shell
pt --trace-deopt index.js
```

## 谈一谈隐藏类

我们知道 JavaScript 是一门动态语言, 其执行效率要低于静态语言. 这是因为 JavaScript 在运行时, 对象的属性是可以被修改的, 所以当 V8 访问一个对象 `point.x` 时, 它并不知道该对象中是否有 x, 也不知道 x 相对于对象的偏移量是多少, 也可以说 V8 并不知道该对象的具体的形状. 我们在上面讲快属性和慢属性时候, 假设 x 被分配到了慢属性, 这个查找过程非常的慢且耗时.

而静态语言不同, 比如 Rust, 在声明一个对象之前需要定义该对象的结构, 我们也可以称为形状, 比如 Point 结构体就是一种形状, 我们可以使用这个形状来定义具体的对象.

```rust
struct Point {
  x: i32,
  y: i32
}
```

Rust 代码在执行之前需要先被编译, 编译的时候, 每个对象的形状都是固定的, 也就是说, 在代码的执行过程中, Point 的形状是无法被改变的.

因此那么在 Rust 中访问一个对象的属性时, 自然就知道该属性相对于该对象地址的偏移值了, 比如在 Rust 中使用 `point.x` 的时候, 编译器会直接将 x 相对于 point 的地址写进汇编指令中, 那么当使用了对象 point 中的 x 属性时, CPU 就可以直接去内存地址中取出该内容即可, 没有任何中间的查找环节. 因此静态语言可以直接通过偏移量查询来查询对象的属性值, 这也就是静态语言的执行效率高的一个原因.

而 V8 也参考了这种静态的特性, 目前所采用的一个思路就是将 JavaScript 中的对象静态化, 也就是 V8 在运行 JavaScript 的过程中, 会假设 JavaScript 中的对象是静态的, 具体地讲, V8 对每个对象做如下两点假设:

- 对象创建好了之后就不会添加新的属性;
- 对象创建好了之后也不会删除属性.

V8 基于这两点假设, 为每个对象创建了一个叫做**隐藏类**的属性, 对象的隐藏类中记录了该对象一些基础的布局信息, 包括以下两点:

- 对象中所包含的所有的属性;
- 每个属性相对于对象的偏移量.

有了隐藏类之后, 那么当 V8 访问某个对象中的某个属性时, 就会先去隐藏类中查找该属性相对于它的对象的偏移量, 有了偏移量和属性类型, V8 就可以直接去内存中取出对于的属性值, 而不需要经历一系列的查找过程, 那么这就大大提升了 V8 查找对象的效率.

```ts
let point = { x: 100, y: 200 };
```

以上面这段代码为例, 当 V8 执行到这段代码时, 会先为 point 对象创建一个隐藏类, 在 V8 中, 把隐藏类又称为 **map**, 每个对象都有一个 map 属性, 其值指向内存中的隐藏类. 隐藏类描述了对象的属性布局, 它主要包括了属性名称和每个属性所对应的偏移量, 比如 point 对象的隐藏类就包括了 x 和 y 属性, x 的偏移量是 4, y 的偏移量是 8.

注意这是 point 对象的 map, 它不是 point 对象本身. 关于 point 对象和 map 之间的关系, 你可以参看下图, 在这张图中, 左边的是 point 对象在内存中的布局, 右边是 point 对象的 map, 我们可以看到, point 对象的第一个属性就指向了它的 map, 关于如何通过浏览器查看对象的 map, 我们在上面讲快属性和慢属性是时候已经讲了怎么在 Chrome Dev Tools 中查看隐藏类.

![map](https://edge.yancey.app/beg/3jbhorki-1653155216096.webp)

有了 map 之后, 当你再次使用 point.x 访问 x 属性时, V8 会查询 point 的 map 中 x 属性相对 point 对象的偏移量, 然后将 point 对象的起始位置加上偏移量, 就得到了 x 属性的值在内存中的位置, 有了这个位置也就拿到了 x 的值, 这样我们就省去了一个比较复杂的查找过程.

这就是将动态语言静态化的一个操作, V8 通过引入隐藏类, 模拟 Rust 这种静态语言的机制, 从而达到静态语言的执行效率.

我曾经翻译过一篇文章[从 React 源码谈 v8 引擎对数组的内部处理](https://www.yanceyleo.com/post/6af49c12-807b-40be-b65b-028f201e4808), 这篇文章讲 V8 对数组的优化, 有兴趣也可以看看.

### 实战: 在 D8 查看隐藏类

我们编写如下代码, DebugPrint 是 D8 内置的 API, 用来打印 debug. (操, 这玩意儿让我想起在百度写 Smarty 的恐惧感来了).

```ts
let point = { x: 100, y: 200 };
%DebugPrint(point);
```

然后执行以下脚本:

```shell
d8 --allow-natives-syntax test.js
```

下面就打印出 point 对象的基础结构了, 打印出来的结果如下所示:

```ts
DebugPrint: 0x31f1000ca021: [JS_OBJECT_TYPE]
 - map: 0x31f100287d51 <Map(HOLEY_ELEMENTS)> [FastProperties]
 - prototype: 0x31f100244401 <Object map = 0x31f1002821e9>
 - elements: 0x31f100002261 <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x31f100002261 <FixedArray[0]>
 - All own properties (excluding elements): {
    0x31f1002538dd: [String] in OldSpace: #x: 100 (const data field 0), location: in-object
    0x31f1002538ed: [String] in OldSpace: #y: 200 (const data field 1), location: in-object
 }
0x31f100287d51: [Map]
 - type: JS_OBJECT_TYPE
 - instance size: 20
 - inobject properties: 2
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 0
 - enum length: invalid
 - stable_map
 - back pointer: 0x31f100287d29 <Map(HOLEY_ELEMENTS)>
 - prototype_validity cell: 0x31f1001c45b5 <Cell value= 1>
 - instance descriptors (own) #2: 0x31f1000ca051 <DescriptorArray[2]>
 - prototype: 0x31f100244401 <Object map = 0x31f1002821e9>
 - constructor: 0x31f100244015 <JSFunction Object (sfi = 0x31f1001db471)>
 - dependent code: 0x31f1000021e9 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0
```

首先 `HOLEY_ELEMENTS` 是不是很熟? 如果你看过我写的[从 React 源码谈 v8 引擎对数组的内部处理](https://www.yanceyleo.com/post/6af49c12-807b-40be-b65b-028f201e4808)这篇文章, 一定知道是什么意思.

从这段 point 的内存结构中我们可以看到, point 对象的第一个属性就是 map, 它指向了 0x31f100287d51 这个地址, 这个地址就是 V8 为 point 对象创建的隐藏类, 除了 map 属性之外, 还有我们之前讲快属性慢属性时介绍过的 prototype 属性, elements 属性和 properties 属性.

### 多个对象共用一个隐藏类

我们上面分析 Rust 的 struct 时大抵就能猜出, 不是每个对象都有自己独一无二的隐藏类, 只要两个对象的**形状**相同, 他们就会使用同一个隐藏类. 我们仍可以用 D8 做个实现, 我们使用 Point 类新建两个实例, 分别 DebugPrint 出来.

```ts
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}

let point = new Point(1, 2);
let point1 = new Point(3, 4);
%DebugPrint(point);
%DebugPrint(point1);
```

如下是打印出来的 point 和 point1 两个对象的基础结构, 我们可以看到两个对象的隐藏类地址是同一个.

```ts
DebugPrint: 0x2e54000ca199: [JS_OBJECT_TYPE]
 - map: 0x2e5400287e41 <Map(HOLEY_ELEMENTS)> [FastProperties] // point 对象的隐藏类地址
 - prototype: 0x2e54000ca0cd <Point map = 0x2e5400287df1>
 - elements: 0x2e5400002261 <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x2e5400002261 <FixedArray[0]>
 - All own properties (excluding elements): {
    0x2e54002538dd: [String] in OldSpace: #x: 1 (const data field 0), location: in-object
    0x2e54002538ed: [String] in OldSpace: #y: 2 (const data field 1), location: in-object
 }
0x2e5400287e41: [Map]
 - type: JS_OBJECT_TYPE
 - instance size: 52
 - inobject properties: 10
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 8
 - enum length: invalid
 - stable_map
 - back pointer: 0x2e5400287e19 <Map(HOLEY_ELEMENTS)>
 - prototype_validity cell: 0x2e5400253c35 <Cell value= 0>
 - instance descriptors (own) #2: 0x2e54000ca239 <DescriptorArray[2]>
 - prototype: 0x2e54000ca0cd <Point map = 0x2e5400287df1>
 - constructor: 0x2e54000ca0ad <JSFunction Point (sfi = 0x2e54002539c9)>
 - dependent code: 0x2e54000021e9 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 6

DebugPrint: 0x2e54000ca261: [JS_OBJECT_TYPE]
 - map: 0x2e5400287e41 <Map(HOLEY_ELEMENTS)> [FastProperties] // point1 对象的隐藏类地址
 - prototype: 0x2e54000ca0cd <Point map = 0x2e5400287df1>
 - elements: 0x2e5400002261 <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x2e5400002261 <FixedArray[0]>
 - All own properties (excluding elements): {
    0x2e54002538dd: [String] in OldSpace: #x: 3 (const data field 0), location: in-object
    0x2e54002538ed: [String] in OldSpace: #y: 4 (const data field 1), location: in-object
 }
0x2e5400287e41: [Map]
 - type: JS_OBJECT_TYPE
 - instance size: 52
 - inobject properties: 10
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 8
 - enum length: invalid
 - stable_map
 - back pointer: 0x2e5400287e19 <Map(HOLEY_ELEMENTS)>
 - prototype_validity cell: 0x2e5400253c35 <Cell value= 0>
 - instance descriptors (own) #2: 0x2e54000ca239 <DescriptorArray[2]>
 - prototype: 0x2e54000ca0cd <Point map = 0x2e5400287df1>
 - constructor: 0x2e54000ca0ad <JSFunction Point (sfi = 0x2e54002539c9)>
 - dependent code: 0x2e54000021e9 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 6
```

### 重新构建隐藏类

我们上面说到 V8 为了实现隐藏类是依据两条假设的, 但在运行时, 对象的形状是可以被改变的, 如果某个对象的形状改变了, 隐藏类也会随着改变, 这意味着 V8 要为新改变的对象重新构建新的隐藏类, 这对于 V8 的执行效率来说, 是一笔大的开销. 通俗地理解, 给一个对象添加新的属性, 删除新的属性, 或者改变某个属性的数据类型都会改变这个对象的形状, 那么势必也就会触发 V8 为改变形状后的对象重建新的隐藏类. 我们看下面的代码:

```ts
let point = { x: 100, y:100 };
%DebugPrint(point);
point.z = 100;
%DebugPrint(point);
delete point.x;
%DebugPrint(point);
```

我们看到三次 map 指向的地址都不同.

```ts
DebugPrint: 0x4dd000ca069: [JS_OBJECT_TYPE]
 - map: 0x04dd00287d51 <Map(HOLEY_ELEMENTS)> [FastProperties] // 第一次
 - prototype: 0x04dd00244401 <Object map = 0x4dd002821e9>
 - elements: 0x04dd00002261 <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x04dd00002261 <FixedArray[0]>
 - All own properties (excluding elements): {
    0x4dd002538dd: [String] in OldSpace: #x: 100 (const data field 0), location: in-object
    0x4dd002538ed: [String] in OldSpace: #y: 100 (const data field 1), location: in-object
 }
0x4dd00287d51: [Map]
 - type: JS_OBJECT_TYPE
 - instance size: 20
 - inobject properties: 2
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 0
 - enum length: invalid
 - stable_map
 - back pointer: 0x04dd00287d29 <Map(HOLEY_ELEMENTS)>
 - prototype_validity cell: 0x04dd001c45b5 <Cell value= 1>
 - instance descriptors (own) #2: 0x04dd000ca099 <DescriptorArray[2]>
 - prototype: 0x04dd00244401 <Object map = 0x4dd002821e9>
 - constructor: 0x04dd00244015 <JSFunction Object (sfi = 0x4dd001db471)>
 - dependent code: 0x04dd000021e9 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0

DebugPrint: 0x4dd000ca069: [JS_OBJECT_TYPE]
 - map: 0x04dd00287d79 <Map(HOLEY_ELEMENTS)> [FastProperties]  // 第二次
 - prototype: 0x04dd00244401 <Object map = 0x4dd002821e9>
 - elements: 0x04dd00002261 <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x04dd000ca0f5 <PropertyArray[3]>
 - All own properties (excluding elements): {
    0x4dd002538dd: [String] in OldSpace: #x: 100 (const data field 0), location: in-object
    0x4dd002538ed: [String] in OldSpace: #y: 100 (const data field 1), location: in-object
    0x4dd00253915: [String] in OldSpace: #z: 100 (const data field 2), location: properties[0]
 }
0x4dd00287d79: [Map]
 - type: JS_OBJECT_TYPE
 - instance size: 20
 - inobject properties: 2
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 2
 - enum length: invalid
 - stable_map
 - back pointer: 0x04dd00287d51 <Map(HOLEY_ELEMENTS)>
 - prototype_validity cell: 0x04dd00253a75 <Cell value= 0>
 - instance descriptors (own) #3: 0x04dd000ca0c1 <DescriptorArray[3]>
 - prototype: 0x04dd00244401 <Object map = 0x4dd002821e9>
 - constructor: 0x04dd00244015 <JSFunction Object (sfi = 0x4dd001db471)>
 - dependent code: 0x04dd000021e9 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0

DebugPrint: 0x4dd000ca069: [JS_OBJECT_TYPE]
 - map: 0x04dd00285709 <Map(HOLEY_ELEMENTS)> [DictionaryProperties] // 第三次
 - prototype: 0x04dd00244401 <Object map = 0x4dd002821e9>
 - elements: 0x04dd00002261 <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x04dd000ca109 <NameDictionary[29]>
 - All own properties (excluding elements): {
   y: 100 (data, dict_index: 2, attrs: [WEC])
   z: 100 (data, dict_index: 3, attrs: [WEC])
 }
0x4dd00285709: [Map]
 - type: JS_OBJECT_TYPE
 - instance size: 12
 - inobject properties: 0
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 0
 - enum length: invalid
 - dictionary_map
 - may_have_interesting_symbols
 - back pointer: 0x04dd000023e9 <undefined>
 - prototype_validity cell: 0x04dd001c45b5 <Cell value= 1>
 - instance descriptors (own) #0: 0x04dd000021f5 <Other heap object (STRONG_DESCRIPTOR_ARRAY_TYPE)>
 - prototype: 0x04dd00244401 <Object map = 0x4dd002821e9>
 - constructor: 0x04dd00244015 <JSFunction Object (sfi = 0x4dd001db471)>
 - dependent code: 0x04dd000021e9 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0
```

### 隐藏类的最佳实践

一: 使用字面量初始化对象时, 要保证属性的顺序是一致的. 比如先通过字面量 x, y 的顺序创建了一个 point 对象, 然后通过字面量 y, x 的顺序创建一个对象 point2. 虽然创建时的对象属性一样, 但是它们初始化的顺序不一样, 这也会导致形状不同, 所以它们会有不同的隐藏类.

二: 尽量使用字面量一次性初始化完整对象属性. 因为每次为对象添加一个属性时, V8 都会为该对象重新设置隐藏类.

三: 尽量避免使用 delete 方法. delete 方法会破坏对象的形状, 同样会导致 V8 为该对象重新生成新的隐藏类.

## 谈一谈内联缓存

我们考察如下代码:

```ts
function loadX(o) {
  return o.x;
}
var o = { x: 1, y: 3 };
var o1 = { x: 3, y: 6 };
for (var i = 0; i < 90000; i++) {
  loadX(o);
  loadX(o1);
}
```

我们知道 V8 会给 o 和 o1 增加了隐藏类, 在获取 `o.x` 时, V8 会**查找对象 o 的隐藏类, 再通过隐藏类查找 x 属性偏移量, 然后根据偏移量获取属性值**. 但是如果放在一个大循环里, 意味着每次都要做这个操作. 我们有没有办法再度简化这个查找过程, 最好能一步到位查找到 x 的属性值呢?

答案是有的, V8 采用**内联缓存 (Inline Cache, 简称为 IC)**, 来加速函数执行. 我们来看一下 IC 的工作原理: V8 执行函数的过程中, 会观察函数中一些**调用点(CallSite) 上的关键的中间数据, 然后将这些数据缓存起来**, 当下次再次执行该函数的时候, V8 就可以直接利用这些中间数据, 节省了再次获取这些数据的过程, 因此 V8 利用 IC, 可以有效提升一些重复代码的执行效率.

IC 会为每个函数维护一个**反馈向量(FeedBack Vector)**, 反馈向量记录了函数在执行过程中的一些关键的中间数据. 反馈向量其实就是一个表结构, 它由很多项组成的, 每一项称为一个**插槽(Slot)**, V8 会依次将执行 loadX 函数的中间数据写入到反馈向量的插槽中.

```ts
function loadX(o) {
  o.y = 4;
  return o.x;
}
```

比如上面这个代码, 当 V8 执行这段函数的时候, 它会判断 `o.y = 4` 和 `return o.x` 这两段是调用点(CallSite), 因为它们使用了对象和属性, 那么 V8 会在 loadX 函数的反馈向量中为每个调用点分配一个插槽.

每个插槽中包括了插槽的索引 (slot index), 插槽的类型 (type), 插槽的状态 (state), 隐藏类 (map) 的地址, 还有属性的偏移量, 比如上面这个函数中的两个调用点都使用了对象 o, 那么反馈向量两个插槽中的 map 属性也都是指向同一个隐藏类的, 因此这两个插槽的 map 地址是一样的.

![插槽](https://edge.yancey.app/beg/p4ez631k-1653166791297.webp)

### 加载类型

了解插槽的数据结构后, 我们看下面一段代码.

```ts
function loadX(o) {
  return o.x;
}

loadX({ x: 1 });
```

将它转换成字节码. Return 我们上面介绍过, 就是返回累加器中的属性值.

```ts
...

Bytecode age: 0
         0x163b00253b12 @    0 : 2d 03 00 00       LdaNamedProperty a0, [0], [0]
         0x163b00253b16 @    4 : a9                Return

...
```

我们重点关注 LdaNamedProperty 这句字节码, 我们看到它有三个参数. a0 就是 loadX 的第一个参数; 第二个参数 `[0]` 表示取出对象 a0 的第一个属性值, 这两个参数很好理解. 第三个参数就和反馈向量有关了, 它表示将 LdaNamedProperty 操作的中间数据写入到反馈向量中, 方括号中间的 0 表示写入反馈向量的第一个插槽中. 下面是一个示例.

![使用 LdaNamedProperty 缓存了数据](https://edge.yancey.app/beg/b2hterhh-1653168515789.png)

- 在 map 栏, 缓存了 o 的隐藏类的地址;
- 在 offset 一栏, 缓存了属性 x 的偏移量;
- 在 type 一栏, 缓存了操作类型, 这里是 LOAD 类型. 在反馈向量中, 我们把这种通过 o.x 来访问对象属性值的操作称为 LOAD 类型.

### 存储类型和函数调用类型

V8 除了缓存 `o.x` 这种 LOAD 类型的操作以外, 还会缓存**存储(STORE)类型**和**函数调用(CALL)类型**的中间数据. 考察下面的代码:

```ts
function foo() {}
function loadX(o) {
  o.y = 4;
  foo();
  return o.x;
}
loadX({ x: 1, y: 4 });
```

字节码如下:

```ts
...

Bytecode age: 0
         0x1bfc00253bea @    0 : 0d 04             LdaSmi [4]
         0x1bfc00253bec @    2 : 32 03 00 00       StaNamedProperty a0, [0], [0]
         0x1bfc00253bf0 @    6 : 21 01 02          LdaGlobal [1], [2]
         0x1bfc00253bf3 @    9 : c4                Star r0
         0x1bfc00253bf4 @   10 : 61 fa 04          CallUndefinedReceiver0 r0, [4]
         0x1bfc00253bf7 @   13 : 2d 03 02 06       LdaNamedProperty a0, [2], [6]
         0x1bfc00253bfb @   17 : a9                Return

...
```

这段代码的流程图大致如下:

![执行流程](https://edge.yancey.app/beg/d8w6s3uh-1653169092922.png)

`o.y = 4` 对应的字节码如下, 这段代码是先使用 LdaSmi [4], 将常数 4 加载到累加器中, 然后通过 StaNamedProperty 的字节码指令, 将累加器中的 4 赋给 o.y, 这是一个存储 (STORE) 类型的操作, V8 会将操作的中间结果存放到反馈向量中的第一个插槽中.

```ts
LdaSmi [4]
StaNamedProperty a0, [0], [0]
```

`foo()` 对应的字节码如下, 解释器首先加载 foo 函数对象的地址到累加器中, 这是通过 LdaGlobal 来完成的, 然后 V8 会将加载的中间结果存放到反馈向量的第 3 个插槽中(因为索引是 2), 这是一个存储类型的操作. 接下来执行 CallUndefinedReceiver0, 来实现 foo 函数的调用, 并将执行的中间结果放到反馈向量的第 5 个插槽中(因为索引是 4), 这是一个调用 (CALL) 类型的操作.

```ts
LdaGlobal [1], [2]
Star r0
CallUndefinedReceiver0 r0, [4]
```

最后两句上面已经讲到了, `return o.x` 仅仅是加载对象中的 x 属性, 所以这是一个加载(LOAD)类型的操作. 下表是这段代码内联缓存的表格.

![内联缓存](https://edge.yancey.app/beg/haxu1wje-1653169710263.webp)

现在有了反馈向量缓存的数据, 当 V8 再次调用 loadX 函数时, 比如执行到 loadX 函数中的 `return o.x` 语句时, 它就会在对应的插槽中查找 x 属性的偏移量, 之后 V8 就能直接去内存中获取 o.x 的属性值了. 这样就大大提升了 V8 的执行效率.

### 多态和超态

```ts
function loadX(o) {
  return o.x;
}

var o = { x: 1, y: 3 };
var o1 = { x: 3, y: 6, z: 4 };

for (var i = 0; i < 90000; i++) {
  loadX(o);
  loadX(o1);
}
```

我们考察上述代码, 由于 o 和 o1 形状不同, 这导致 V8 给这两个对象创建的隐藏类也不相同.

第一次执行时 loadX 时, V8 会将 o 的隐藏类记录在反馈向量中, 并记录属性 x 的偏移量. 那么当再次调用 loadX 函数时, V8 会取出反馈向量中记录的隐藏类, 并和新的 o1 的隐藏类进行比较, 发现不是一个隐藏类, 那么此时 V8 就无法使用反馈向量中记录的偏移量信息了.

面对这种情况, V8 会选择将新的隐藏类也记录在反馈向量中, 同时记录属性值的偏移量, 这时, 反馈向量中的第一个槽里就包含了两个隐藏类和偏移量. 具体可以参看下图:

![多态](https://edge.yancey.app/beg/x5gmh7we-1653170104799.webp)

当 V8 再次执行 loadX 函数中的 `o.x` 语句时, 同样会查找反馈向量表, 发现第一个槽中记录了两个隐藏类. 这时, V8 需要额外做一件事, 那就是拿这个新的隐藏类和第一个插槽中的两个隐藏类来一一比较, 如果新的隐藏类和第一个插槽中某个隐藏类相同, 那么就使用该命中的隐藏类的偏移量. 如果没有相同的, 同样将新的信息添加到反馈向量的第一个插槽中.

现在我们知道了, 一个反馈向量的一个插槽中可以包含多个隐藏类的信息, 那么:

- 如果一个插槽中只包含 1 个隐藏类, 那么我们称这种状态为单态(monomorphic);
- 如果一个插槽中包含了 2-4 个隐藏类, 那我们称这种状态为多态(polymorphic);
- 如果一个插槽中超过 4 个隐藏类, 那我们称这种状态为超态(magamorphic).

可以预见的是, 从单态到多态到超态, 执行效率是依次降低的, 因为查找的次数变多了. 比如多态的情况 V8 使用线性结构来存储; 如果是超态, 那么 V8 会采取 hash 表的结构来存储, 这无疑会拖慢执行效率. 因此, 如果你的函数的参数是个对象, 那么就要避免多态和超态, 也就意味着尽量默认所有的对象属性是不变的, 比如你写了一个 `loadX(o)` 的函数, 那么当传递参数时, 尽量不要使用多个不同形状的 o 对象.

当然, 虽然我们分析的隐藏类和 IC 能提升代码的执行速度, 但是在实际的项目中, 影响执行性能的因素非常多, 找出那些影响性能瓶颈才是至关重要的, 你不需要过度关注微优化, 你也不需要过度担忧你的代码是否破坏了隐藏类或者 IC 的机制, 因为相对于其他的性能瓶颈, 它们对效率的影响可能是微不足道的.

就像我在[从 React 源码谈 v8 引擎对数组的内部处理](https://www.yanceyleo.com/post/6af49c12-807b-40be-b65b-028f201e4808)这篇文章最后写道的: `这就是一篇爽文, 旨在涨涨见识. 基本百分之九十以上, 后端返回给我们的数组就已经是 PACKED_ELEMENTS 的类型了`. 我想我们需要关注的, 就是对于那些可以保证是单态的代码, 我们保证它是单态的就够了, 对于其他情况, 算逑.

## 结语

关于 V8 在 Event Loop, 垃圾回收, 生成器与 async / await 相关的原理, 这篇文章不再赘述, 有兴趣可以参考我的其他三篇文章:

- [谈 Generator 与 async / await](http://js.yanceyleo.com/ecmascript/Generator/generator)
- [最后一次弄懂 Event Loop](https://www.yanceyleo.com/post/f56439a7-39af-40b1-85a8-5b33b30836f7)
- [从 JavaScript 编译原理到作用域(链)及闭包](https://www.yanceyleo.com/post/2ef92b49-b3d4-43bb-983a-771912265f6c)

下面是一段讲解 V8 的视频, 讲得不错, [Google 开源的 JavaScript 引擎——V8](https://www.zhihu.com/zvideo/1408790742785916928), 视频转载自某逼乎.

<video controls src=""https://edge.yancey.app/beg/v8.mp4""></video>

![总结](https://edge.yancey.app/beg/8fqa4v7z-1652030438219.jpeg)
","2025-02-02 03:09:22.276313","2025-02-02 03:09:22.276313"
"9fd439ad-e843-42ed-8470-04e9a87c9c26","{LLM,ChatGPT,OpenAI}",0,0,False,"https://edge.yancey.app/beg/w584crrb-1684393292890.jpg","ChatGPT Prompt Engineering for Developers","4 月 27 日, Ng 和 OpenAI 团队共同出品了 9 节 ChatGPT Prompt Engineering for Developers 课程. 作为 ChatGPT 的花式调教用户, 和不专业的 ""Prompt Engineer"", 趁着五一放假学习一下, 若有谬误共同探讨.","## Introducing Large Language Models

大语言模型分为 Base LLM 和 Instruction Tuned LLM.

基础语言模型是指只在大规模文本语料中进行了预训练的模型, 未经过指令和下游任务微调, 以及人类反馈等任何对齐优化. 它主要用于<strong>预测下一个单词</strong>.

比如你的提示词是 ""Once upon a time, there was a unicorn"", 基础语言模型可能会给你返回 ""that lived in a magical forest with all her unicorn friends"".

再比如你的提示词是 ""What is the capital of France?"", 它可能会给你返回 ""What is France's largest city? What is France's population? What is the currency of France?""

事实上, 我们仅仅想得到 ""Paris"", 但为什么会输出上面的结果呢? 因为基础语言模型的作用是预测并补全, 并非指令性的回答, 因此对于这个返回, 它可能学到的是<strong>一段关于法国知识小测验的列表</strong>.

而 Instruction(指令) 是指通过自然语言形式对任务进行描述, 它在基础语言模型的基础上进一步训练, 用输入和输入进一步微调, 这些输入和输出都是指令.

此外, 在微调时使用了从人类反馈中进行强化学习的方法(Reinforcement Learning from Human Feedback, RLHF), 这里的人类反馈其实就是人工标注数据来不断微调 LLM, 主要目的是让 LLM 学会理解人类的命令指令的含义, 使得在一般文本数据语料库上训练的语言模型能和复杂的人类价值观对齐.

![Steps to Instruction Tuned LLM](https://edge.yancey.app/beg/d8f7qywv-1682856212609.jpeg)

以 OenAI 的 GPT 为例, GPT-3 就是 Base LLM; GPT-3.5 就是 Instruction Tuned LLM; 而 ChatGPT 是在 GPT-3.5 基础上进行微调得到的, 用到了 RLHF 技术.

## Two key principals for how to write prompts effectively

### Write clear and specific instructions

首先要明确 clear 不意味着 short, 因为在很多情况下较长的提示能够提供更清晰地描述和上下文, 这也能够带来更加详细和确切的输出.

#### Tactic 1: Uses delimiters

分隔符来明确指出输入的不同部分

* Triple quotes: `""""""`
* Triple backtick: ```` ``` ````
* Triple dashes: `---`
* Angle brackets: `< >`
* XML tags: `<tag> </tag>`

举个例子, 下面是给星舰的介绍生成一句话摘要, 就可以将介绍文案包裹起来, 这里使用了 Triple backtick, 你也可以使用上述其他的分隔符. 总之这样就是<strong>告诉模型清楚的知道这是一个单独的部分</strong>.

![Starship](https://edge.yancey.app/beg/pxpsr024-1682861286776.png)
    
再举个例子, 也是我在开发 [rs_openai](https://crates.io/crates/rs_openai) 是常干的事情, 就是让 ChatGPT 帮忙生成 Rust 结构体.

```bash
Generate the json string delimited by triple quotes into rust structs with serde and default.
""""""
{
  ""id"": ""chatcmpl-123"",
  ""object"": ""chat.completion"",
  ""created"": 1677652288,
  ""choices"": [{
    ""index"": 0,
    ""message"": {
      ""role"": ""assistant"",
      ""content"": ""\n\nHello there, how may I assist you today?"",
    },
    ""finish_reason"": ""stop""
  }],
  ""usage"": {
    ""prompt_tokens"": 9,
    ""completion_tokens"": 12,
    ""total_tokens"": 21
  }
}
""""""
```

虽然当时也没用使用分隔符, ChatGPT 也足以给出优秀的答案. 不过既然看了这门课, 都听官方的. 🫡

```rust
#[derive(Debug, Deserialize, Default)]
struct ChatCompletion {
   id: String,
   object: String,
   created: i64,
   choices: Vec<Choice>,
   usage: Usage,
}
#[derive(Debug, Deserialize, Default)]
struct Choice {
    index: i32,
    message: Message,
    finish_reason: String,
}
#[derive(Debug, Deserialize, Default)]
struct Message {
    role: String,
    content: String,
}
#[derive(Debug, Deserialize, Default)]
struct Usage {
    prompt_tokens: i32,
    completion_tokens: i32,
    total_tokens: i32,
}
```

此外, 视频介绍了要避免提示词注入, 它举了如下例子. 即开头提示模型来总结 ```` ``` ```` 之间的文字, 但黄色部分又要求模型不去做总结, 转而写一首关于 cuddy panda bears 的诗. 这种语意矛盾的 prompt 即为 prompt injections, 这是我们需要避免的.

![Avoid prompt injections](https://edge.yancey.app/beg/khplnqui-1682862064317.png)

#### Tactic 2: Ask for structured output

如下面的例子, 如果不提供输出结构, 它默认给出了一个 list 形式, 而如果你主动要求一个结构化的输出, 如 JSON, HTML 等等, 这样的好处是数据在你在代码中直接可用.

![Ask for structured output](https://edge.yancey.app/beg/b7qza93v-1682870423116.png)

#### Tactic 3: Check whether conditions are satisfied

如果任务中的假设不一定被满足, 我们可以告诉模型先检查这些假设, 如果不满足, 我们指出这一点, 并在完成任务的过程中停止.

下面这个例子中, 如果指定文本是按步骤来的, 那就转换成 Step 的形式, 否则简单的返回 **No steps provided.**

第一个例子来阐述泡茶的步骤, 显然能够被转换成 Step 的形式. 并且我们看到它识别出了文本中的 <strong>If you like</strong>, 因此在 Step 5 标明了 Optional, 太牛逼了.

![Ask for structured output phrase 1](https://edge.yancey.app/beg/4min1988-1682871722526.png)

第二段话仅仅是描写天气和风景的文本, 不是步骤的形式, 那么模型直接识别 falsy 的部分, 简单返回 **No steps provided.** 即可.

![Ask for structured output phrase 2](https://edge.yancey.app/beg/emlz3z7r-1682871728569.png)

#### Tactic 4: ""Few-shot"" prompting

这个策略的意思是: 在要求模型做你想让它做的实际任务之前, 给予模型一个明确的, 成功的例子, 让模型照着这个例子输出新的文本, 从而达到一致性.

下面这个例子, 我们想让模型输出 **Answer: XXXX** 这样一种格式, 并且语气要跟示例一中的 Answer 一致. 首先喂给模型一个例子, <strong>Question: 如何促进拉新</strong>, Answer 就是从网上抄的一段互联网黑话. 在输出中, 我们看到 ChatGPT 返回了我们想要的格式, 并且模仿了互联网黑化的语气解释了<strong>如何保证留存</strong>这一话题.

![""Few-shot"" prompting](https://edge.yancey.app/beg/7e223817-1682873311723.png)

### Give the model time to ""think""

第二个原则给予模型更多的思考时间. 如果一个模型急于得出不正确的结论而出现推理错误, 你应该尝试重新设计询问, 以便在模型提供最终答案之前请求一系列相关推理.

#### Tactic 1: Specify the steps required to complete a task

具体来讲, 如果你的一个 prompt 需要完成多件事情, 最好的做法是用分步的形式来描述.

下面的例子依次是: 总结这段话; 把这段话翻译成日语; 把段落中提到的人名翻译成日语; 生成包含 japanese\_summary 和 num\_names 的 JSON 数据.

最后还要求每个答案之间用空行隔开, 这样能保证一个漂亮的输出效果.

```bash
Perform the following actions:
1 - Summarize the following text delimited by triple quotes with 1 sentence.
2 - Translate the summary into Japanese.
3 - List each name in the Japanese summary.
4 - Output a json object that contains the following keys: japanese_summary, num_names.
Separate your answers with line breaks.
Text:
""""""
In a charming village, siblings Jack and Jill set out on a quest to fetch water from a hilltop well. As they climbed, singing joyfully, misfortune struck—Jack tripped on a stone and tumbled down the hill, with Jill following suit. Though slightly battered, the pair returned home to comforting embraces. Despite the mishap, their adventurous spirits remained undimmed, and they continued exploring with delight.
""""""
```

![Specify the steps required to complete a task](https://edge.yancey.app/beg/nfw9o1iw-1684155686954.png)

但是上面这个例子有个缺点, 我们看到第三个 `List each name in the Japanese summary.` 这里, 它把 name 也翻译成了日语. 因此为了更加准确, 可以给它一个可预测的更加精确的输出形式.

下面是一个优化的例子:

```bash
Your task is to perform the following actions:
1 - Summarize the following text delimited by <> with 1 sentence.
2 - Translate the summary into Japanese.
3 - List each name in the Japanese summary.
4 - Output a json object that contains the following keys: japanese_summary, num_names.
Use the following format:
Text: <text to summarize>
Summary: <summary>
Translation: <summary translation>
Names: <list of names in Japanese summary>
Output JSON: <json with summary and num_names>
Text:
<
In a charming village, siblings Jack and Jill set out on a quest to fetch water from a hilltop well. As they climbed, singing joyfully, misfortune struck—Jack tripped on a stone and tumbled down the hill, with Jill following suit. Though slightly battered, the pair returned home to comforting embraces. Despite the mishap, their adventurous spirits remained undimmed, and they continued exploring with delight.
>
```

![Specify the steps required to complete a task optimization](https://edge.yancey.app/beg/k2qvk738-1684208011165.png)

#### Tactic 2: Instruct the model to work out its own solution before rushing to a conclusion

这条策略的意思是: 不要让模型基于对某件事下结论, 而是在得出结论前, 先得出自己的结论.

下面这个例子是出了一道题目, 并让模型判断判断学生的答案是否正确. 下面的答案显然是错的, 因为是 `and an additional $10 / square foot`, 而学生的答案写成了 100. 但很遗憾的是, 模型给出的回复是 `The student's solution is correct.`.

```bash
Determine if the student's solution is correct or not.
Question:
I'm building a solar power installation and I need help working out the financials.
- Land costs $100 / square foot
- I can buy solar panels for $250 / square foot
- I negotiated a contract for maintenance that will cost me a flat $100k per year, and an additional $10 / square foot
What is the total cost for the first year of operations as a function of the number of square feet.
Student's Solution:
Let x be the size of the installation in square feet.
Costs:
1. Land cost: 100x
2. Solar panel cost: 250x
3. Maintenance cost: 100,000 + 100x
Total cost: 100x + 250x + 100,000 + 100x = 450x + 100,000
```

![Instruct the model to work out its own solution before rushing to a conclusion](https://edge.yancey.app/beg/5fg8jycg-1684210235607.png)

为什么模型认为是对的呢? 因为你给模型的要求是判断学生的答案是否正确, 因此模型更关心学生的解决方案而非问题, 即下面这段 Prompt:

```bash
Let x be the size of the installation in square feet.
Costs:
1. Land cost: 100x
2. Solar panel cost: 250x
3. Maintenance cost: 100,000 + 100x
Total cost: 100x + 250x + 100,000 + 100x = 450x + 100,000
```

这样一条一条读下来, 从逻辑上确实能从 1 2 3 得到 Total cost, 因此模型认为是正确的.

我们改一下这个例子, 开头要求在让模型先自己解决这个问题, 然后再去判断学生的答案是否正确, 并且强调了在模型未解决这个问题之前, 不允许判断学生的答案是否正确.

```bash
Your task is to determine if the student's solution is correct or not.
To solve the problem do the following:
- First, work out your own solution to the problem.
- Then compare your solution to the student's solution and evaluate if the student's solution is correct or not.
Don't decide if the student's solution is correct until you have done the problem yourself.
Use the following format:
Question:
""""""
question here
""""""
Student's solution:
""""""
student's solution here
""""""
Actual solution:
""""""
steps to work out the solution and your solution here
""""""
Is the student's solution the same as actual solution just calculated:
""""""
yes or no
""""""
Student grade:
""""""
correct or incorrect
""""""
Question:
""""""
I'm building a solar power installation and I need help working out the financials.
- Land costs $100 / square foot
- I can buy solar panels for $250 / square foot
- I negotiated a contract for maintenance that will cost me a flat $100k per year, and an additional $10 / square foot
What is the total cost for the first year of operations as a function of the number of square feet.
""""""
Student's solution:
""""""
Let x be the size of the installation in square feet.
Costs:
1. Land cost: 100x
2. Solar panel cost: 250x
3. Maintenance cost: 100,000 + 100x
Total cost: 100x + 250x + 100,000 + 100x = 450x + 100,000
""""""
Actual solution:
```

![Instruct the model to work out its own solution before rushing to a conclusion Optmization](https://edge.yancey.app/beg/tssyyev7-1684211154354.png)

### Model Limitations

尽管语言模型在训练过程中已经接触了大量的知识, 但在其训练过程中, 它并没有完美的记住它所看到的信息, 因此它对一些知识边界并不了解, 这意味着它可能回答一些晦涩难懂的问题, 并且可以编造一些听起来有道理但实际上并不真实的事情. 我们把这些由模型编造的想法称之为幻觉(Hallucination).

比如下面这个例子, 我捏造了 BMW 旗下有一款叫做库里南的跑车, 它仍能够一本正经的胡说八道, 因此尽量保证模型不一本正经的胡说八道之前, 先保证你的 Prompt 不一本正经的胡说八道.

![Model Limitations](https://edge.yancey.app/beg/yp0djq31-1684224838949.png)

## Iterative Prompt Develelopment

没有人能够保证第一次写的 Prompt 就可以得到的想要的结果, 一如没人能保证一次算法模型训练就能达到想要的效果. Prompts 的设计亦如此, 如果第一次没达到效果, 那就在此基础上迭代优化, 总会得到想要的效果.

让我们举一个例子来描述如何反复迭代一个 Prompt, 让它最终能为我们使用. 下面这个例子提供了了一个椅子的说明书, 我们想让模型依据技术规格为之写一个营销文案.

```bash
Your task is to help a marketing team create a description for a retail website of a product based on a technical fact sheet.
Write a product description based on the information provided in the technical specifications delimited by triple quotes.
Technical specifications:
""""""
OVERVIEW
- Part of a beautiful family of mid-century inspired office furniture,
including filing cabinets, desks, bookcases, meeting tables, and more.
- Several options of shell color and base finishes.
- Available with plastic back and front upholstery (SWC-100)
or full upholstery (SWC-110) in 10 fabric and 6 leather options.
- Base finish options are: stainless steel, matte black,
gloss white, or chrome.
- Chair is available with or without armrests.
- Suitable for home or business settings.
- Qualified for contract use.
CONSTRUCTION
- 5-wheel plastic coated aluminum base.
- Pneumatic chair adjust for easy raise/lower action.
DIMENSIONS
- WIDTH 53 CM | 20.87”
- DEPTH 51 CM | 20.08”
- HEIGHT 80 CM | 31.50”
- SEAT HEIGHT 44 CM | 17.32”
- SEAT DEPTH 41 CM | 16.14”
OPTIONS
- Soft or hard-floor caster options.
- Two choices of seat foam densities:
 medium (1.8 lb/ft3) or high (2.8 lb/ft3)
- Armless or 8 position PU armrests
MATERIALS
SHELL BASE GLIDER
- Cast Aluminum with modified nylon PA6/PA66 coating.
- Shell thickness: 10 mm.
SEAT
- HD36 foam
COUNTRY OF ORIGIN
- Italy
""""""
```

![image.png](https://edge.yancey.app/beg/2kx7pco0-1684227900995.png)

第一次迭代, 效果还不错, 按照技术规格书详细描述了这把椅子. 但问题是太长了. 我们尝试一次迭代, 在 Prompt 上加上一句 `Use at most 50 words.`, 再看一下效果, 发现还不错.

```bash
Your task is to help a marketing team create a description for a retail website of a product based on a technical fact sheet.
Write a product description based on the information provided in the technical specifications delimited by triple quotes.
Use at most 50 words.
...
```

![image.png](https://edge.yancey.app/beg/g3szrb7o-1684229240237.png)

但我们通过 `string.split(' ').length` 可以看出这段话足足有 67 个单词, 并没有满足我们设想的最多 50 个单词的要求. 这里需要知道的是, 大语言模型并不能很精确的按单词数量输出答案. 所以你可以换一些近似的修辞, 如 `Use at 3 sentences.` 或者 `Use at most 280 characters.` 多次尝试总会有一个接近你想要的效果.
让我们继续迭代, 假设我们的产品介绍语是面向家具零售商, 他们更关注技术参数以及材质.

```bash
Your task is to help a marketing team create a description for a retail website of a product based on a technical fact sheet.
Write a product description based on the information provided in the technical specifications delimited by triple quotes.
The description is intended for furniture retailers, so should be technical in nature and focus on the materials the product is constructed from.
Use at most 50 words.
```

![image.png](https://edge.yancey.app/beg/h17sggl5-1684230864905.png)
这段描述语更倾向于描述产品的规格, 因此效果是不错的. 当然我们可以更进一步迭代, 让模型根据要求生成一个 HTML 的结构:

* 首先写一段给家具零售商的技术规格描述, 结尾标注上产品 ID
* 在描述后面写一个关于产品尺寸大小的 HTML 表格, 表格有两列, 第一列是尺寸名(如长, 宽, 高, 深度), 第二列是数值, 用英寸表示.

```bash
Your task is to help a marketing team create a description for a retail website of a product based on a technical fact sheet.
Write a product description based on the information provided in the technical specifications delimited by triple quotes.
The description is intended for furniture retailers, so should be technical in nature and focus on the materials the product is constructed from.
At the end of the description, include every 7-character Product ID in the technical specification.
After the description, include a table that gives the product's dimensions. The table should have two columns.
In the first column include the name of the dimension.
In the second column include the measurements in inches only.
Give the table the title 'Product Dimensions'.
Format everything as HTML that can be used in a website.
Place the description in a <div> element.
...
```

![image.png](https://edge.yancey.app/beg/novgupfl-1684297928838.png)

最终的结果看起来还不错, 这启发我们要想达到一个完成一个不错的 Prompt, 是一个持续迭代的过程, 不可能一次性就能做到完美, 当效果不符合预期时, 可以尝试分析下哪些描述写的不好, 并试图基于模型一个更清晰的定义.

* Try something
* Analyze where the result does not give what you want
* Clarify instructions, give more time to think
* Refine prompts with a batch of examples

## Summarize

文本总结是 nlp 领域的另一个亮点, 它能够把一个长文本精炼到几句话甚至一句话. 试想这么一个场景, 我们每天能够收到大量的用户调研信息, 如果能把这些调研信息加以总结和聚类, 是可以大幅降低产运分析成本.

比如我们有下面一段用户对宝马七系的评价, 要求<strong>生成一篇产品评论的简短摘要，摘要不超过 30 个单词</strong>。

```bash
型号: 宝马7系 2023款 735Li M运动套装
最满意: 这个宝马已经是我想了很久的款，为了买它还专门跑了省城。这个车动力确实很好，我提车开回来的时候在成都市区有点堵车，但是不管是方向灵动性还是加速超车性能，这个车都可以说是我开过的车里数一数一的。而且到现在为止，油耗也只有13个多，还是比较满意的，应该过了磨合期还要低一些。外观非常满意，从侧身看过去，车子程修长型，高调的修身感，让整个车子看上去都很高端大气。
最不满意: 比较不满意的点基本都是些小问题。例如新车提了车内还是有些味道的，首开的时候高速上我都是开了点窗户的。再一个就是遇到过两三次降速的过程中有顿挫感的时候。其他的就都是满意项。
空间: 这个车子内部不止前排位置元收，后排位置也一样不局限人，后排的扶手功能充实，方便实用，也让后面的位置一分为二，显得更大气。我身高体重偏中等，坐后面还有两拳宽的样子头部空间也预留得不错。后备箱放东西的能力也可以，至少正常家用或者商务足够。
驾驶感受: 3.0T发动机的加持之下，这C车的动力是很好的，特别是我我第一次开这个车回去的时候一上告诉油门一踩那个劲一下就上来了，反应之迅速。加上足够快的提速性，几乎是瞬间就能感受到推背感的强烈。但是这个车的隔音效果一般，特别是胎噪声比较大。然后在降速的时候遇到过顿挫感。档位这些的实体键做得很高端，使用起来舒适感也挺强。
油耗: 油耗我是满意的，一个五米多车长，还很重的车，在磨合期内能到13个油左右我是觉得挺不错了。
外观: 外观好看，时尚，科技感满满。看看车尾这个有棱有角的设计很霸气，颇有点大师风范。车头不必细说，家族式设计。
内饰: 用料很良心，这个要好评。颜色搭配很亮眼，特别是局部的木纹肌理感。中控台设计最好看，加上高档屏幕，非常亮眼。
性价比: 性价比还不错吧，这么价位没什么优惠力度，但是能接受。
配置: 倒车影像啊，车机系统啊，屏幕啊，隐形把手啊，都是高端配置的提现。
```

整体的摘要如下, 效果还是不错的.

![image.png](https://edge.yancey.app/beg/5jmdt38w-1684301668002.png)

当然你可以突出这篇摘要的目的, 比如<strong>生成一篇产品评论的简短摘要给发动机研发团队，摘要不超过 30 个单词</strong>, 它就会更强调跟动力油耗相关, 如: 宝马 7 系 2023 款 735Li M 运动套装，动力无可挑剔，油耗满意，外观高端大气，后排空间宽敞，配置高端。唯一不足是一些小问题。

再比如可以给用于定价团队, 它会更强调与价格相关的术语, 如: 这篇评论高度赞扬了宝马 7 系 2023 款的强劲引擎、燃油效率、宽敞的内部空间和高端的设计。评论者注意到了一些小问题，但总体认为这辆车的价值足以抵消其价格。

除了生成摘要, 还可以从指定的段落中<strong>提取</strong>信息, 比如<strong>提取这篇评论有关产品设计的信息</strong>, 它可能给你反馈如: 设计部门应该对外观和内饰设计感到满意，尤其是流畅而高端的外观，优质材料和引人注目的颜色组合。

## Inferring

除了能够总结和提取, LLM 模型的另一大用途就是推断, 比如上面那段关于宝马七系产品的用户反馈, 模型可以推断用户对于这个产品整体感情是正向的还是负向的. 如:

请识别出如下产品反馈的用户情感, 该反馈使用三个反引号分隔. ​ """""" ... ​ 型号: 宝马7系 2023款 735Li M运动套装 ​ ... """"""
最终给予的结果是满意, 是符合预期的.

当然很多时候, 我们绝不仅仅只分析一个用户的情感, 当我们需要分析一系列用户产品反馈时, 最好能让模型给予一个特定的输出, 比如:

除了能够总结和提取, LLM 模型的另一大用途就是推断, 比如上面那段关于宝马七系产品的用户反馈, 模型可以推断用户对于这个产品整体感情是正向的还是负向的. 如:

```bash
请识别出如下产品反馈的用户情感, 该反馈使用三个反引号分隔.
""""""
...
型号: 宝马7系 2023款 735Li M运动套装
...
""""""
```

最终给予的结果是满意, 是符合预期的.

![image.png](https://edge.yancey.app/beg/trx4ngnu-1684394800917.png)

当然很多时候, 我们绝不仅仅只分析一个用户的情感, 当我们需要分析一系列用户产品反馈时, 最好能让模型给予一个特定的输出, 比如:

```bash
请识别出如下产品反馈的用户情感, 该反馈使用三个反引号分隔. 如果用户满意输出 1, 否则输出 0.
""""""
...
型号: 宝马7系 2023款 735Li M运动套装
...
""""""
```

最终给予的结果是 1, 这样我们就很轻松的计算出这一批用户反馈中, 正向的占比是多少, 负向的占比又是多少.

上述做法中, 模型只是给予了一种非黑即白的反馈, 有时候你需要在这个用户反馈中推断出几个关键词, 可以像下面这样做:

```bash
找出如下用户产品反馈所表达的情绪列表, 不超过 5 项, 将答案用逗号分开, 该用户产品反馈使用三个反引号分隔.
""""""
...
型号: 宝马7系 2023款 735Li M运动套装
...
""""""
```

它给予了如下 5 个关键词, 整体效果是不错的.

![image.png](https://edge.yancey.app/beg/bxzjx8ec-1684395521130.png)

此外, 你还可以预置一种情绪, 来让模型判断是否有这种情绪:

```bash
请识别出如下产品反馈的情感, 用户是否对该产品感到生气, 该反馈使用三个反引号分隔.
""""""
...
型号: 宝马7系 2023款 735Li M运动套装
...
""""""
```

它给予的反馈是情感积极, 没有生气的情绪, 这在客服系统是很有用的, 用于整体把控用户的情绪, 来派发不同的话术.

![image.png](https://edge.yancey.app/beg/1vfajfka-1684395870900.png)

除了推断情绪, 还可以推断一段文本的主题(或者说关键词), 我们仍然用宝马七系这个例子:

```bash
确定以下文本中正在讨论的五个主题, 每个主题不超过 10 个字, 并把主题词存储到一个 Rust Vec 中. 该文本由三个反引号分隔.
""""""
...
型号: 宝马7系 2023款 735Li M运动套装
...
""""""
```

![image.png](https://edge.yancey.app/beg/f9olyv4u-1684403031609.png)

## Transforming

文本转换是另一个重要的功能, 常见的如文本翻译, 文本拼写/语法检查, 文本语调转换, 文本格式转换.

### Translation

很多开发者开始通过 ChatGPT 来构建翻译应用, 我们看看如何写好一个翻译的 Prompt.

下面这个例子是把这段日语文本翻译成中文繁体和英语.

![image.png](https://edge.yancey.app/beg/8tuo6aq6-1684410891241.png)

你也可以尝试询问它是什么语言.

![image.png](https://edge.yancey.app/beg/mpg95mf6-1684411058493.png)

### Tone Transformation

它还可以进行文本语调转换, 比如调整语言的正式性和非正式性, 这块对于写邮件很有帮助.

![image.png](https://edge.yancey.app/beg/26ahb2pg-1684414202490.png)

### Format Conversion

我们在 Tactic 1: Uses delimiters 那里通过一段 JSON 字符串转换成 Rust structs, 这就是所谓的格式转换, 这里就不赘述了.

### Spellcheck/Grammar check

最后我们在看一下拼写/语法检查, 从事实上来讲, ChatGPT 的出现, 直接把 [Grammarly](https://www.grammarly.com/) 这类平台干倒闭了, 让我们看看怎么写好一个拼写/语法检查的 Prompt.

很简单, 你可以直接告诉他**将这段文本校正成正确的版本**即可, 当然为了充分考虑边界情况, 在文本没有语法错误时, 输出 ""No errros found"".

![image.png](https://edge.yancey.app/beg/z5mnvlae-1684416352082.png)

此外, 你可以做一些很酷的事情, 比如下面这段话, 让模型修正之后得到如下反馈.

![image.png](https://edge.yancey.app/beg/889v0ky3-1684468836875.png)

你可以通过一些三方库, 比如 redlines, 就可以得到如下效果:

![image.png](https://edge.yancey.app/beg/t2zhp8vy-1684468779459.png)

## Expanding

文本扩写是将一较短的文本进行扩写, 如一套指示或者主题列表, 并让大语言模型生成一段较长的文本, 比如一封文件或者一篇关于某个主题的文章, 也可能根据几个关键词, 让模型帮忙头脑风暴.

下面这个例子, 我们让模型扮演客服 AI 助理, 使用简洁且专业的语调回复用户的反馈邮件, 邮件开头要表达对用户反馈的
感谢. 然后分析用户这篇反馈的情绪是正向的还是负向的:

- 如果是正向的, 表达感谢并正常扩写邮件, 来对他们的评论进行感谢
- 如果是负向的, 表达抱歉并引导客户联系客服

最终的署名是 AI customer agent

```bash
You are a customer service AI assistant.
Your task is to send an email reply to a valued customer.
Given the customer email delimited by """""", Generate a reply to thank the customer for their review.
Firstly, inffer the sentiment of the email.
If the sentiment is positive or neutral, thank them for their review.
If the sentiment is negative, apologize and suggest that they can reach out to customer service.
Make sure to use specific details from the review.
Write in a and professional tone.
Sign the email as `AI customer agent`.
Customer review:
...
```

首先我们挑选一个正向的反馈:

```bash
Worth the money!!!
This phone was purchased for my wife after I had purchase an iPhone 13 Pro, 256GB, from the Apple Store. My wife was not sure about purchasing a refurb phone but this was from Amazon so she gave it a try. She has been very happy with the purchase. Her friends were surprised with the phone being in such nice shape and were amazed my wife got double the memory for less money than their IPhone Purchase price from different carriers.
The battery is fine. There are no scratches. Everything works as it did on my Apple Store phone. This is unlocked and all we had to do is insert the SIM from my wife’s old android phone to go live and use the IPhone. We did go down to our carrier’s store and get an updated, current SIM when it was convenient.
When I upgrade I think I will go with an Amazon refurbished IPhone next time which can cost less money. My wife is happy!! What more can I say?
```

下面是最终的邮件效果, 整体看起来是很不错的.

![image.png](https://edge.yancey.app/beg/sg8b6h95-1684472335686.png)

然后我们在来一个相对负向的反馈:

```bash
I got this phone but when I try set it up, it’s making me do the latest iOS update.
Since this is an unlocked phone, I assumed it would have came with the latest update. I cannot get strong enough internet to update it as I work at sea on a cruise ship and all the stops we go to, I get off for a few hours for wifi and still it won’t install the update.
I am extremely disappointed by this as i was so excited for the phone, now I have nothing.
```

基本上也是符合预期的, 首先表达歉意, 然后引导联系客服.

![image.png](https://edge.yancey.app/beg/0z8gs5zb-1684472772698.png)

### Temperature

我们知道 OpenAI 为我们提供了诸多 API, 其中创建聊天也是如此: [Create chat completion](https://platform.openai.com/docs/api-reference/chat/create). 我们常用的参数最主要就 prompt, 这里我们介绍另外一
个参数: Temperature.

这个参数的取值在 0 - 2 之间, 默认是 1, 如果取较高的值将使输出更加随机, 而较低的值将使输出更加集中和确定. 下面给出了一个事例, 假设你输入 **my facorite food is**, 它预测的下一个词可能是 pizza, sushi, tacos, 其中 pizza 比例为 
53%, sushi 次之, tacos 更少.

如果你使用 `Temperature = 0`, 在多次请求后, 它都会给你输出 pizza, 因为这是**最可预测的**.

随着 Temperature 变大, 每次拿到的数据就会越随机, 可以看下面这张图.

![image.png](https://edge.yancey.app/beg/kj7eq0uj-1684501382385.png)

因此, 如果你想构建一个稳定, 可预测的系统, 比如上述邮件助理系统, 我们肯定希望从格式, 内容上更加一致, 那就把 Temperature 调小; 如果你希望模型能提供更多有创意的东西, 就可以将它调的大一些, 当然从人类的角度来讲, 此时的模型会变的不稳定且容易分心.

## ChatBot

最后, 也是我们最感兴趣的 ChatBot, 我们从 System 和 Context 两个角度来阐述如何构建高效的聊天机器人.

### System

ChatGPT 的 API 中 messages 参数接受一个数组, 它支持传入多个消息, 如:

```python
messages =  [  
  {'role':'system', 'content':'You are friendly chatbot.'},    
  {'role':'user', 'content':'Hi, my name is Isa'}  
]
```

其中 `role` 参数支持 `system`, `user`, or `assistant` 三种枚举, 一般我们的角色就是 user, 但在一些特定的场景, 提前预置 `system` 可以给整个聊天定一个基调, 比如 `You are an assistant that speaks like Shakespeare.`, 那它后续就会以莎士比亚的口吻来回答, 这在一些特定客服环境很有用.

### Context

我们在使用 ChatGPT 网页端的时候会发现他有记忆功能, 也就是说你在某个回话中已经交流过的内容, 会作为新的会话的参考. 比如我们询问模型一个问题, 我对它回答的结果不满意, 它会基于上面已给出的答案进行优化和修改. 这个技术便叫做 Context.

比如我有如下 prompt, 在没有上下文的情况下, 显然模型不知道我的名字, 于是它给出了 I'm sorry, but as a chatbot, I don't have access to your name unless you tell me what it is. 这样的回答.

```python
messages =  [  
{'role':'system', 'content':'You are friendly chatbot.'},    
{'role':'user', 'content':'Yes,  can you remind me, What is my name?'}  
]
```

但如果我们给出足够的上下文, 如下这个例子, 模型就能知道你的名字: Of course! Your name is Isa. It's a pleasure to assist you, Isa.

```python
messages =  [  
{'role':'system', 'content':'You are friendly chatbot.'},
{'role':'user', 'content':'Hi, my name is Isa'},
{'role':'assistant', 'content': ""Hi Isa! It's nice to meet you. Is there anything I can help you with today?""},
{'role':'user', 'content':'Yes, you can remind me, What is my name?'}  
]
```

因此, 我们在设计 ChatBot 时, 也可以在每次提交时, 带上前几个会话的上下文信息. 不过由于有 token 数量限制, 你带的历史上下文信息多了, 可能就会报错, 因此需要具体问题具体分析, 比如带上最新三个到五个历史回会话. 抑或通过 [langchain](https://python.langchain.com/en/latest/index.html) 这样的库进行精细化分割.

### Example

下面举一个例子, 比如让 Bot 扮演一个卖披萨的机器人:

1. 首先问侯客户, 然后收集订单, 接下来询问客户堂食还是外卖.
2. 等到收集完订单后对订单做一个总结, 并询问客户是否需要其他的.
3. 如果客户选择外卖, 询问客户地址信息.
4. 最后计算金额.

```python
[ {'role':'system', 'content':""""""
You are OrderBot, an automated service to collect orders for a pizza restaurant. \
You first greet the customer, then collects the order, \
and then asks if it's a pickup or delivery. \
You wait to collect the entire order, then summarize it and check for a final \
time if the customer wants to add anything else. \
If it's a delivery, you ask for an address. \
Finally you collect the payment.\
Make sure to clarify all options, extras and sizes to uniquely \
identify the item from the menu.\
You respond in a short, very conversational friendly style. \
The menu includes \
pepperoni pizza  12.95, 10.00, 7.00 \
cheese pizza   10.95, 9.25, 6.50 \
eggplant pizza   11.95, 9.75, 6.75 \
fries 4.50, 3.50 \
greek salad 7.25 \
Toppings: \
extra cheese 2.00, \
mushrooms 1.50 \
sausage 3.00 \
canadian bacon 3.50 \
AI sauce 1.50 \
peppers 1.00 \
Drinks: \
coke 3.00, 2.00, 1.00 \
sprite 3.00, 2.00, 1.00 \
bottled water 5.00 \
""""""} ] 
```

![pintu-fulicat.com-1686632795722.jpg](https://edge.yancey.app/beg/g2g590am-1686632837399.jpg)

当然更进一步, 你可以将上面的订单结果生成 JSON 代码, 那就完全可以替代人类完成询问 - 下单 - 入库等一系列流程了. 当然为了让输出更加可预测, 我们可以选择将 temperature 设置得足够小.

![image.png](https://edge.yancey.app/beg/04pnbnp2-1686636342767.png)

## Conclusion

在这门课中, 我们学到了 prompt 的两个基准原则:

- Write clear and specific instructions
- Give the model time to ""think""

接着我们学到了 Iterative Prompt Develelopment, 即没有人能一次就写出完美的 prompt, 二十需要通过不断迭代和优化, 使结果更好的为我们利用.

此外, 我们学到了 LLM 模型的一些能力, 如总结, 推断, 转换, 扩写.

最后我们学到了如何通过 system 和 context 两大原则建立一个定制化的订单机器人.

## Appendix: Implement stream in JavaScript

最后作为附录, 奉上如何使用 ChatGPT 的 stream 模式构建你的用户交互.

```ts
import { FC, useState } from 'react'
import classNames from 'classnames'
import ReactMarkdown from 'react-markdown'
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter'
import { oneDark as mdCodeTheme } from 'react-syntax-highlighter/dist/esm/styles/prism'
import rehypeMathjax from 'rehype-mathjax'
import remarkGfm from 'remark-gfm'
import remarkMath from 'remark-math'
import Card from '@mui/material/Card'
import CardContent from '@mui/material/CardContent'
import Button from '@mui/material/Button'
import Input from '@mui/material/Input'
export interface OpenAIChatDelta {
  role?: string
  content?: string
}
export interface OpenAIChatChoice {
  delta: OpenAIChatDelta
  index: number
  finish_reason: string | null
}
export interface OpenAIChatResponse {
  id: string
  object: string
  created: number
  model: string
  choices: OpenAIChatChoice[]
}
const ChatGPT: FC = () => {
  const [prompt, setPrompt] = useState('')
  const [anwser, setAnwser] = useState<string>('')
  const resolveData = async (
    reader: ReadableStreamDefaultReader<Uint8Array>
  ): Promise<void> => {
    const { done, value } = await reader.read()
    if (done) {
      return reader.releaseLock()
    }
    const decoder = new TextDecoder('utf-8')
    const chunk = decoder.decode(value, { stream: true })
    const chunks: OpenAIChatResponse[] = chunk
      .split('data:')
      .map((data) => {
        const trimData = data.trim()
        if (trimData === '') return undefined
        if (trimData === '[DONE]') return undefined
        return JSON.parse(data.trim())
      })
      .filter((data) => data)
    chunks.forEach((data) => {
      const token = data.choices[0].delta.content
      if (token !== undefined) {
        setAnwser((prevState) => prevState + token)
      }
    })
    return resolveData(reader)
  }
  const resolveError = async (
    reader: ReadableStreamDefaultReader<Uint8Array>
  ) => {
    const { value } = await reader.read()
    const decoder = new TextDecoder('utf-8')
    const chunk = decoder.decode(value, { stream: true })
    const errorData = JSON.parse(chunk)
    console.log(errorData)
    return
  }
  const createChatCompletion = async () => {
    const chat = await fetch('https://api.openai.com/v1/chat/completions', {
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${import.meta.env.VITE_OPENAI_SECRET_KEY}`
      },
      method: 'POST',
      body: JSON.stringify({
        messages: [
          {
            role: 'user',
            content: prompt
          }
        ],
        model: 'gpt-3.5-turbo',
        stream: true
      })
    })
    const reader = chat.body?.getReader()
    if (!reader) return
    if (chat.status !== 200) {
      resolveError(reader)
    }
    await resolveData(reader)
    reader.releaseLock()
  }
  return (
    <section>
      <section className=""flex"">
        <Input
          value={prompt}
          onChange={(e) => setPrompt(e.target.value)}
          sx={{
            width: 400,
            marginRight: 2
          }}
        />
        <Button
          variant=""contained""
          onClick={createChatCompletion}
          disabled={!prompt.trim()}
        >
          Search
        </Button>
      </section>
      {anwser && (
        <Card sx={{ maxWidth: 800, marginTop: 2, marginBottom: 2 }}>
          <CardContent>
            <ReactMarkdown
              remarkPlugins={[remarkGfm, remarkMath]}
              rehypePlugins={[rehypeMathjax]}
              components={{
                code({ inline, className, children }) {
                  const match = /language-(\w+)/.exec(className || '')
                  return !inline ? (
                    <SyntaxHighlighter
                      style={mdCodeTheme}
                      language={match ? match[1] : ''}
                      PreTag=""div""
                      customStyle={{ borderRadius: 0, margin: 0 }}
                    >
                      {String(children).replace(/\n$/, '')}
                    </SyntaxHighlighter>
                  ) : (
                    <code className={classNames('font-semibold', className)}>
                      `{children}`
                    </code>
                  )
                },
                p({ className, children }) {
                  return (
                    <p className={classNames(className, 'mb-4')}>{children}</p>
                  )
                },
                pre({ className, children }) {
                  return (
                    <pre className={classNames(className, 'mb-4 text-sm')}>
                      {children}
                    </pre>
                  )
                },
                ol({ className, children }) {
                  return (
                    <ol
                      className={classNames(className, 'mb-4 pl-4 list-disc')}
                    >
                      {children}
                    </ol>
                  )
                },
                ul({ className, children }) {
                  return (
                    <ul
                      className={classNames(
                        className,
                        'mb-4 pl-4 list-decimal'
                      )}
                    >
                      {children}
                    </ul>
                  )
                },
                li({ className, children }) {
                  return (
                    <li className={classNames(className, 'mb-4')}>
                      {children}
                    </li>
                  )
                }
              }}
            >
              {anwser}
            </ReactMarkdown>
          </CardContent>
        </Card>
      )}
    </section>
  )
}
export default ChatGPT
```","2025-02-02 03:09:25.424696","2025-02-02 03:09:25.424696"
"350e375f-f32c-4244-8812-86627dbdc9b2","{""HSBC 银行卡申请"",数字移民,金融}",0,0,False,"https://edge.yancey.app/beg/sa7an3a5-1686506161155.jpg","教你在中国大陆足不出户开通境外汇丰银行卡","这段时间陆续申请了汇丰中国, 新家坡, 美国的卓越理财银行卡, 把心得记录下来, 希望能帮到数字移民, 或者即将肉身移民的朋友们.","## 为什么要办境外卡

这段时间风头最劲的便是 OpenAI, 但是投胎在中国大陆的小伙伴确实很难受, 因为遭到了""两头堵"". 一是众所周知的原因 OpenAI 的 IP 被墙掉了, 二是 OpenAI 的风控也在有意识的阻止来自中国大陆, 香港等国家的访问, 甚至殃及了其他亚洲国家.

当然凭借大家的实力这些都是小意思. 最麻烦的还是购买 OpenAI 的服务(如 OpenAI Plus), 而 OpenAI 目前明令禁止来自中国大陆, 香港的支付, 这让我很难相信香港怎么这么快就沦陷成这个样子了.

![chatgpt](https://edge.yancey.app/beg/vj0aproq-1686499971324.png)

此外, 有了境外卡还可以买美股啥的也比较方便, 万一赚了呢? 

## 汇丰中国

虽然有一些其他的歪门斜道, 比如虚拟信用卡, USDT 转账. 但我觉得只有主动拥抱这个世界的主流价值观才是正确的. 于是花了一些时间做研究, 发现汇丰有个**卓越理财**服务: 当你申请了中国大陆的卓越理财银行卡, 就可以申请其他国家的卓越理财银行卡, 从而享受**一地卓越，全球卓越**的**汇丰环球金融**服务.

具体来讲, 你可以扫描如下二维码, 按要求填入你的个人信息, 或者直接线下去中国大陆任意网点办理, 我是在线填写的资料, 然后去了线下网点见证, 这样省了很多线下见证的时间. 当然它有个小小的门槛, 就是保证日均余额保持在 50w 人民币或其他等值外币即可. 

![申请汇丰中国银行卡 ](https://edge.yancey.app/beg/yt7t942l-1686501008761.png)

当然你可能会考虑 50w 在里面放着太浪费了, 你可以买他们家的理财或者保险啥的, 也会算在 50w 额度内, 当然投资有风险, 这个见仁见智.

于是当天在支行做了个简单的见证(其实就是想让我买理财), 就开通了手机银行, 网上银行, 绑定了汇丰的微信小程序啥的. 由于需要在银行卡刻上你的名字, 当日是不能取实体卡的, 大约过了一周才寄到, 不过不影响网上银行的使用.

![汇丰中国手机银行](https://edge.yancey.app/beg/utylcqez-1686502377201.png)

## 汇丰新加坡

由于我的目的是申请国外卡, 于是就直接让客户经理帮忙申请了, 其实我想申请美国的, 不过他说申请香港和新加坡的比较快,  遂果断申请了新加坡的. 

很快, 不到一周, 就收到新加坡那边的视频见证邀请, 约定了个下午的时间, 具体就是先电话吧啦吧啦半个小时, 了解你办卡的动机, 财力, 住址, 工作情况等一大堆. 当然为什么这么麻烦, 这是因为当时中国大陆的客户经理只是帮我提交申请, 但没提交个人信息, 如果我提前填了那一堆表单, 就会节省很多时间. 这些问完后, 会和你约定一个 zoom 视频, 让你现场签名, 并拍摄你和你的护照的合影让他截图即可. 

应该也就一周的时间, 就陆续收到了来自新加坡的两个 DHL 邮件, 一个是激活 PIN 码, 另一个就是实体卡. 拿到后要激活卡片才能使用, 邮件里有教程, 拨打一个新加坡的电话, 按照指令激活即可, 然而我的英文水平限制了我的发挥, 没听明白, 遂找了中国大陆的客服, 让他转接新加坡的客服, 让新加坡的客服提供中文激活服务, 这才搞定.

又过了一周多, 我的新加坡的客户经理联系上了我, 要教我激活. 然后我已经激活了, 并转过去了一些美金进去了. 估计后面就是推理财产品啥的了.

## 汇丰美国

事情都到这个份上了, 当然是要搞张美国卡了. 你可以访问 [汇丰美国](https://www.us.hsbc.com/checking-accounts/products/premier/#get-started) 往下翻到 Apply online, 点击进去.

![汇丰美国申请页](https://edge.yancey.app/beg/5a9maiq5-1686503869170.png)

首先提前准备好**永久地址证明**和**护照个人页照片**, 因为在填写表单的时候要上传, 如果等的时间久了, session 很容易过期, 前面填写的就白填了. 我一开始提供的最近三个月银行卡账单, 但开户经理邮件提醒我不足以证明永久地址, 下面是邮件原文.

```bash
Dear XXX,
 
Thank you for your interest in banking with HSBC USA.  I am reviewing your account there are a few items needed before I am able to proceed.
 
First, I need a document that shows your permanent address on it.  This needs to be in your name and dated within the last 90 days.  This does not have to be in English.
I can accept a bank statement, credit card statement (does not need to be from HSBC), or utility bill.
 
Once I have received this document, we can schedule an appointment to meet on zoom and verify your passport.
 
I look forward to your response and processing your request.
 
Warm regards,
 
 
XXX
```


于是我提供了招行最近三个月信用卡的对账单, 从实践看中文是没问题了, 你可以去掌上生活 APP 搜索账单补寄即可.

![招行信用卡账单](https://edge.yancey.app/beg/1girev4o-1686504603502.jpg)

准备好材料就可以来填表单了, 你可以参考这个 [Youtube](https://www.youtube.com/watch?v=AZwAhgPcSPs) 视频来填写申请, 这个视频跟实际表单有些出入, 但大体都能对得上. 这里讲一下什么叫 Checking account(支票账户) 和 Savings account(储蓄账户). 

支票账户（Checking Account）：支票账户是用于日常交易和支付的账户。它通常与支票簿和借记卡关联。支票账户允许持有人通过支票、借记卡、在线转账或电子支付等方式进行支付和取款。支票账户通常没有或者有很少的利息收入，因为其主要用途是便捷地进行交易和支付。支票账户适用于频繁的资金转移和交易。

储蓄账户（Savings Account）：储蓄账户是用于存储和积累资金的账户。它通常具有一定的利率，允许账户持有人获得一定程度的利息收入。储蓄账户主要用于储蓄和长期积累资金，因此通常不支持支票支付。根据美国法律规定，每个储蓄账户在一个月内最多可以进行6次电子或网上转账，超过限制将可能面临额外费用或账户冻结。储蓄账户适用于累积储蓄、紧急备用金和短期投资。

总之，支票账户适合日常交易和支付，提供便捷的资金转移方式，而储蓄账户则适合长期储蓄和积累资金，提供利息收入的机会。

![填写申请表单](https://edge.yancey.app/beg/j9vcppp1-1686503914414.png)

这里我们选择都开通即可, 后面的就不赘述了, 相信大家的英文水平. 很快美国那边就审核通过了, 于是约你进行视频认证. 点击下面的日历, 选一个时间, 我选了个晚上 8 点半的, 后来才想明白这是美东时间早晨 8 点半, 挺不好意思的...

![预约视频时间](https://edge.yancey.app/beg/l0wmsdhv-1686505167338.png)

由于有了新家坡的经历, 我以为视频沟通也得折腾一个小时, 于是特意回了封邮件, 说 I don't speak English well, please provide an appointment in Chinese. 然后回复我说我说中文就好, 他有翻译软件, 这我才放心.

然而, 到时候就不是那回事了, 根本就没有翻译软件, 全程英文... 幸亏是我提前填了表单, 这次视频见证只是验证我的身份, 并不是新加坡那种一聊一个小时, 所以问的问题还是很简单, 大体就是说一下姓名, 生日, 邮箱, 然后发给我一个邮件, 进去之后手写签名, 上传护照, 然后和护照放一起让他截图啥的... 虽然磕磕巴巴, 但也勉强完成了. 期间英语说的烂成狗, 但一直被鼓励, 还是很感动的. 事后用 ChatGPT 写了封邮件表示感谢. 😂 

![表达个感谢😂](https://edge.yancey.app/beg/3e85ysdy-1686505897701.JPG)

视频完毕, 美国申请成功的邮件就发过来了, 让我直接去美国官网注册网银和手机银行, 速度确实出乎预料. 接下来就是等实体卡从美国寄过来了.

大约过了半个月, 就收到了美国寄过来的 DHL 邮件, 和新加坡不同的是, 美国卡不需要两个快递(也就是不需要 PIN 码), 收到后当晚直接按邮件里的指南打电话激活即可.

![美国卡邮件](https://edge.yancey.app/beg/e1rysn68-1689443467595.jpg)
这块也注意下, 邮件指南里的电话号码是美国的, 直接打的话会生成国际长途, 建议拨打汇丰中国的专线, 让他转接美国即可.

## WIP

正在申请 HSBC US Credit Card 中, 成功后会把踩坑记录补上~

## 最后

最后当然是奉上全家福了(从上至下依次是美国, 中国大陆, 新加坡), 好了, 滚去学英语了.

![全家福](https://edge.yancey.app/beg/asgtlidd-1689442533870.jpg)","2025-02-02 03:09:28.079058","2025-02-02 03:09:28.079058"
"3e955d46-43c2-4314-8537-3d64a56e2f96","{AIGC,""Hyper Chat"",ChatBot,OpenAI,ChatGPT}",0,0,False,"https://edge.yancey.app/beg/9jmivb3i-1701008542969.png","Introducing Hyper Chat","最近借着 AIGC 的潮流, 用 Tauri 做了个基于 OpenAI 和 Azure OpenAI Service 的聊天机器人, 目前正式版已经放出, 欢迎大家去 https://hyperchat.yancey.app/ 下载和使用. 代码放在了 https://github.com/orgs/HyperChatBot, 欢迎一起建设和优化.","## Functions
Hyper Chat 的跨平台基于 tauri, 老实说比起 electron, 虽然 tauri 无需安装笨重的 chromium, 但 webkit 本身缺失了太多的功能, 如 `window.navigator.onLine`, `onCompositionStart` 等等, 所以在实现上一些效果并不令人满意.‘
Hyper Chat 的初衷是绝不收集用户信息, 如 OpenAI Secret Key 和聊天记录. 因此我们使用 indexedDB 来存储数据. 在设置中, 我们支持导入和导出数据. 当然如果你有兴趣提供一个服务端, 前端代码也是很容易修改的, 你只需要将 `src/hooks/useDB.ts` 中的函数换成你的 API 接口即可.
![import-export-db](https://edge.yancey.app/beg/7qdfxtme-1691048273432.png)
在大前端上, 主要使用了 React + Vite + TailwindCSS + Recoil 的组合. 这也是我第一次使用 TailwindCSS, 从抵触到真香, 往往只有一步之遥.
此外, 我们支持 OpenAI 和 Azure OpenAI Service 两种接口, 后续会考虑增加 Claude 2 和 Google Bard. 我们还支持亮色, 暗色, 以及跟随系统主题视觉效果. 为提高趣味性, 在聊天框中, 我们支持修改助理的头像.
![settings](https://edge.yancey.app/beg/m2b4c1uo-1691048543013.png)
### Customizable ChatBox
在聊天框区域, 对于每种模型 API, 我们都有和官方一致的配置参数可供用户选择.
![configuration](https://edge.yancey.app/beg/h2x64eyd-1691049298908.png)
此外是一些零零散散的小功能, 如支持修改会话的头像和标题, 删除会话, 添加会话等.
![other-configuration](https://edge.yancey.app/beg/g54fg3s4-1691049397740.png)
### Chat Completion
![chat-completions](https://edge.yancey.app/beg/frflci8f-1690808815033.png)
Hyper Chat 最核心的功能是支持 Chat Completion, 整个 APP 最花心思的便是这个模块. 和 ChatGPT 网页效果一样, 我们默认支持 stream 模式. 此外, 我们采用贪心策略, 每次回话中尽可能多的带上下文:
```ts
// 获取用户 prompt 的 token 数
const userMessageTokensCount = getTokensCount(prompt, model);
// 总的 token 数等于用户 prompt 的 token 数 + 系统消息的 token 数 + 本次希望 Assistant 返回的最大 token 数
let tokensCount = userMessageTokensCount + systemMessageTokensCount + maxTokens;
// 获取当前模型最大支持的 token 数, 如 GPT-3.5-turbo 最多支持 4097 个 token
const tokensLimit = models.find((m) => m.name === model)?.tokensLimit || 0;
// 如果用户输入的 prompt 的 token 数已经超过阈值, 就提示错误
if (tokensCount > tokensLimit) {
  toast.error(
    `This model's maximum context length is ${tokensLimit} tokens. However, you requested ${tokensCount} tokens (${
      tokensCount - maxTokens
    } in the messages, ${maxTokens} in the completion). Please reduce the length of the prompt.`
  );
  return;
}
// 从新到旧依次遍历过往的 message, 尽可能的多的将上下文交给模型处理
const context: CreateChatCompletionRequest[""messages""] = [];
currConversation.messages
  .slice()
  .reverse()
  .forEach(({ tokensCount: historyTokensCount, content, role }) => {
    tokensCount += historyTokensCount;
    if (tokensCount > tokensLimit) return;
    context.unshift({
      role,
      content,
    });
  });
```
### Text Completion
![text-completion](https://edge.yancey.app/beg/9syfyonp-1690808800955.png)
我们也支持 Text Completion, 不过 OpenAI 最新官方文档表示这个 API 属于 legacy, 可能后面就废弃了, 且用且珍惜.
### Audio Transparent and Translation
虽然 OpenAI 早已开源了 Whisper-1, 但我们还是接入了它的接口, 我们支持音频的转录和翻译. 在右下角先选择音频文件, 再敲击回车即可提交, 你也可以输入 prompt, 不过在 Audio 中, 它是可选的.
![audio-transparent-and-translation](https://edge.yancey.app/beg/ajh4qoaa-1690808795519.png)
### Image Generation
我们支持基于 DALL-E 的图片生成接口, 建议在配置中选择更小尺寸的图片, 这样生成起来会比较快. 此外, 图片有过期时间(约为 1 天), 请及时将生成的图片下载到本地.
![image-generation](https://edge.yancey.app/beg/uo6x2952-1690808769662.png)
## 最后
欢迎大家体验和使用, 有任何建议都可以通过 [Official Discussion](https://github.com/orgs/HyperChatBot/discussions/71) 一起讨论.","2025-02-02 03:09:31.684044","2025-02-02 03:09:31.684044"
"f2baa8f4-4e07-4863-a834-f7097ca4c4d5","{Vite}",0,0,False,"https://edge.yancey.app/beg/cpkx3shx-1698215295101.jpg","Vite 源码解析(1) - 配置篇","欢迎来到 Vite 源码解析系列. Vite 作为新时代的打包神器, 缝合了, 哦不, 集成了 ES Module, bundleless, esbulid, rollup 等优秀思想和特性. 本系列假设你已经使用过 Vite, 对 Vite 配置, 插件机制有一定了解. 并且对 esbuild, rollup 的配置有一定了解.","## createServer
在讲 vite 如何处理用户配置参数时, 我们先大概总览一下 `createServer` 函数, 这个函数是 vite 处理整个开发
- 获取 config 配置
- 创建 http 服务器 httpServer
- 创建 WebSocket 服务器 ws
- 通过 chokidar 创建监听器 watcher
- 创建一个兼容 rollup 钩子函数的对象 container
- 创建模块依赖图实例 moduleGraph
- 声明 server 对象
- 注册 watcher 回调
- 执行插件中的 configureServer 钩子函数(注册用户定义的前置中间件), 并收集用户定义的后置中间件
- 注册中间件
- 注册用户定义的后置中间件
- 注册转换 html 文件的中间件和未找到文件的 404 中间件
- 重写 httpServer.listen
- 返回 server 对象
```ts
export async function createServer(inlineConfig) {
  // 获取 config 配置
  const config = await resolveConfig(inlineConfig, ""serve"", ""development"");
  // 获取项目根路径
  const root = config.root;
  // 获取本地服务器相关的配置
  const serverConfig = config.server;
  // 创建中间件实例
  const middlewares = connect() as Connect.Server;
  // 创建 http 服务器
  const httpServer = await resolveHttpServer(
    serverConfig,
    middlewares,
    httpsOptions
  );
  // 创建 WebSocket 服务器
  const ws = createWebSocketServer(httpServer, config, httpsOptions);
  // ignored: 忽略监听的文件;
  // watchOptions: 对应 server.watch 配置, 传递给 chokidar 的文件系统监视器选项
  const { ignored = [], ...watchOptions } = serverConfig.watch || {};
  // 通过 chokidar 监听文件
  const watcher = chokidar.watch(path.resolve(root), {
    ignored: [
      ""**/node_modules/**"",
      ""**/.git/**"",
      ...(Array.isArray(ignored) ? ignored : [ignored]),
    ],
    ignoreInitial: true,
    ignorePermissionErrors: true,
    disableGlobbing: true,
    ...watchOptions,
  }) as FSWatcher;
  // 获取 所有插件
  const plugins = config.plugins;
  // 创建插件容器, 是一个对象, 对象的属性是 vite 支持的 rollup 的钩子函数, 后面会介绍
  // 比如 options, resolveId, load, transform
  const container = await createPluginContainer(config, watcher);
  // 创建Vite 的 ModuleGraph 实例, 后面也会介绍
  const moduleGraph = new ModuleGraph(container);
  // 声明 server 对象
  const server: ViteDevServer = {
    config, // 包含命令行传入的配置 和 配置文件的配置
    middlewares,
    get app() {
      return middlewares;
    },
    httpServer, // http 服务器
    watcher, // 通过 chokidar 监听文件
    pluginContainer: container, // vite 支持的 rollup 的钩子函数
    ws, // WebSocket 服务器
    moduleGraph, // ModuleGraph 实例
    transformWithEsbuild,
    transformRequest(url, options) {},
    listen(port?: number, isRestart?: boolean) {},
    _optimizeDepsMetadata: null,
    _isRunningOptimizer: false,
    _registerMissingImport: null,
    _pendingReload: null,
    _pendingRequests: Object.create(null),
  };
  // 被监听文件发生变化时触发
  watcher.on(""change"", async (file) => {});
  // 添加文件时触发
  watcher.on(""add"", (file) => {});
  watcher.on(""unlink"", (file) => {});
  // 执行插件中的 configureServer 钩子函数
  // configureServer: https://vitejs.cn/guide/api-plugin.html#configureserver
  const postHooks: ((() => void) | void)[] = [];
  for (const plugin of plugins) {
    if (plugin.configureServer) {
      // configureServer 可以注册前置中间件, 就是在内部中间件之前执行; 也可以注册后置中间件
      // 如果configureServer 返回一个函数, 这个函数内部就是注册后置中间件, 并将这些函数收集到 postHooks 中
      postHooks.push(await plugin.configureServer(server));
    }
  }
  // 接下来就是注册中间件
  // base
  if (config.base !== ""/"") {
    middlewares.use(baseMiddleware(server));
  }
  // ...
  // 主要转换中间件
  middlewares.use(transformMiddleware(server));
  // ...
  // 如果请求路径是 /结尾, 则将路径修改为 /index.html
  if (!middlewareMode || middlewareMode === ""html"") {
    middlewares.use(spaFallbackMiddleware(root));
  }
  // 调用用户定义的后置中间件
  postHooks.forEach((fn) => fn && fn());
  if (!middlewareMode || middlewareMode === ""html"") {
    // 如果请求的url是 html 则调用插件中所有的 transformIndexHtml 钩子函数, 转换html, 并将转换后的 html 代码发送给客户端
    middlewares.use(indexHtmlMiddleware(server));
    // handle 404s
    middlewares.use(function vite404Middleware(_, res) {
      res.statusCode = 404;
      res.end();
    });
  }
  if (!middlewareMode && httpServer) {
    // 重写 httpServer.listen, 在服务器启动前预构建
    const listen = httpServer.listen.bind(httpServer);
    httpServer.listen = (async (port: number, ...args: any[]) => {}) as any;
  } else {
    // ...
  }
  return server;
}
```
## resolveConfig
`createServer` 中调用的第一个函数是 `resolveConfig`, 也就是解析用户配置. 和其他的构建工具一样, vite 也提供 `vite.config.js` 来作为它的配置文件, 因此 vite 首要目标是要读取和解析配置文件. vite 的配置分为共享配置, 开发服务器配置, 构建选项配置, 依赖优化选项配置, ssr 选项配置和 worker 配置.
该函数第一个参数是 `inlineConfig`, 也就是我们在命令行中指定的配置; 第二个参数是指定的命令模式, 有 `serve` 和 `build` 两种, 开发环境显然是前者; 第三个参数是指定的环境.
```ts
export async function resolveConfig(
  inlineConfig: InlineConfig,
  command: ""build"" | ""serve"", // 命令
  defaultMode = ""development"" // 环境
): Promise<ResolvedConfig> {
  let config = inlineConfig; // 命令行中的配置项
  let configFileDependencies: string[] = [];
  let mode = inlineConfig.mode || defaultMode;
  const configEnv = {
    mode, // 环境, 开发环境下是 development
    command, // 命令, 开发环境下是 serve
  };
  let { configFile } = config; // 配置文件路径
  // ...
}
```
## loadConfigFromFile
在 `resolveConfig` 函数中, 首先执行的函数是 `loadConfigFromFile`, 这个函数是用来加载配置文件的. 可以看到, 如果你不显式的将 `configFile` 设为 `false`, 它会执行 `loadConfigFromFile` 函数, 配置文件可能来自用户指定的文件, 也可能是缺省配置文件, 比如 `vite.config.js`.
```ts
const loadResult = await loadConfigFromFile(
  configEnv,
  configFile,
  config.root,
  config.logLevel
);
```
### 判断是否为 ESM
在 `loadConfigFromFile` 函数中, 它首先去寻找你工程根目录下的 `package.json` 文件, 如果配置了 `module` 属性, 说明你的项目支持 ESM 规范, 故把内部变量 `isESM` 设为 `true`.
```ts
try {
  const pkg = lookupFile(configRoot, [""package.json""]);
  if (pkg && JSON.parse(pkg).type === ""module"") {
    isESM = true;
  }
} catch (e) {}
```
### 解析配置文件路径
接下来, 在 `loadConfigFromFile` 函数中, 如果你手动提供了配置文件的(相对)路径, 则直接获取这个配置文件的绝对路径, 否则, 它会读取是否有缺省的配置文件路径, 比如 `vite.config.js`, `vite.config.mjs`, `vite.config.ts`, `vite.config.cjs`.
```ts
if (configFile) {
  // explicit config path is always resolved from cwd
  resolvedPath = path.resolve(configFile);
  isTS = configFile.endsWith("".ts"");
  if (configFile.endsWith("".mjs"")) {
    isESM = true;
  }
} else {
  // implicit config file loaded from inline root (if present)
  // otherwise from cwd
  const jsconfigFile = path.resolve(configRoot, ""vite.config.js"");
  if (fs.existsSync(jsconfigFile)) {
    resolvedPath = jsconfigFile;
  }
  if (!resolvedPath) {
    const mjsconfigFile = path.resolve(configRoot, ""vite.config.mjs"");
    if (fs.existsSync(mjsconfigFile)) {
      resolvedPath = mjsconfigFile;
      isESM = true;
    }
  }
  if (!resolvedPath) {
    const tsconfigFile = path.resolve(configRoot, ""vite.config.ts"");
    if (fs.existsSync(tsconfigFile)) {
      resolvedPath = tsconfigFile;
      isTS = true;
    }
  }
  if (!resolvedPath) {
    const cjsConfigFile = path.resolve(configRoot, ""vite.config.cjs"");
    if (fs.existsSync(cjsConfigFile)) {
      resolvedPath = cjsConfigFile;
      isESM = false;
    }
  }
}
```
### 加载/解析配置文件
在读取到了配置文件的绝对路径之后就要开始解析了, 源码如下所示.
由于上面 vite 区分了 isESM, isTS, 抑或着普通的 js 文件. 因此如果明确了 isESM, 就可以使用 `dynamicImport` 函数进行加载(当然后面 vite 应该会换成原生的 `import()`). 而对于 isTS, 稍微 hack 了一下, 先打包编译成 js, 然后再将这个 js 代码写入磁盘, 再加载这个被编译后的 js 文件, 完成后删除这个临时 js 文件.
```ts
try {
  let userConfig: UserConfigExport | undefined;
  if (isESM) {
    const fileUrl = pathToFileURL(resolvedPath); // 拿到 file:/// 的路径
    const bundled = await bundleConfigFile(resolvedPath, true); // 用 esbuild 打包配置文件, 如 vite.config.js
    // bundleConfigFile 内调用的 esbuild 的配置, 然后设置了 metafile: true 用于生成依赖关系
    // 并且使用插件 externalize-dep 来保证不会将第三方库打包在 bundle 中, 即生成的依赖也不会包含第三方库
    // 所以这里的 dependencies 内容, 只包含用户自己写的文件
    // 具体 bundleConfigFile 函数下面会讲到
    dependencies = bundled.dependencies;
    if (isTS) {
      // before we can register loaders without requiring users to run node
      // with --experimental-loader themselves, we have to do a hack here:
      // bundle the config file w/ ts transforms first, write it to disk,
      // load it with native Node ESM, then delete the file.
      fs.writeFileSync(resolvedPath + "".js"", bundled.code); // 写入磁盘
      userConfig = (await dynamicImport(`${fileUrl}.js?t=${Date.now()}`))
        .default; // 加载
      fs.unlinkSync(resolvedPath + "".js""); // 删除
      debug(`TS + native esm config loaded in ${getTime()}`, fileUrl);
    } else {
      // 使用 Function 来避免被 TS/Rollup 编译掉附加一个查询,
      // 以便我们在服务器重启的情况下强制重新加载新配置
      // using Function to avoid this from being compiled away by TS/Rollup
      // append a query so that we force reload fresh config in case of
      // server restart
      userConfig = (await dynamicImport(`${fileUrl}?t=${Date.now()}`)).default;
      debug(`native esm config loaded in ${getTime()}`, fileUrl);
    }
  }
  if (!userConfig) {
    // Bundle config file and transpile it to cjs using esbuild.
    const bundled = await bundleConfigFile(resolvedPath);
    dependencies = bundled.dependencies;
    // 对于普通的 cjs, 就使用 module 下的模块加载
    userConfig = await loadConfigFromBundledFile(resolvedPath, bundled.code);
    debug(`bundled config file loaded in ${getTime()}`);
  }
  // 我们知道 vite 的配置文件可以是 defineConfig({}) 的形式
  // 也可以是普通的对象, 不管怎样, 都应该返回一个对象才对
  const config = await(
    typeof userConfig === ""function"" ? userConfig(configEnv) : userConfig
  );
  if (!isObject(config)) {
    throw new Error(`config must export or return an object.`);
  }
  return {
    // 对路径进行了规范化处理, 在解析路径时使用 POSIX 分隔符, 兼容 win32 分割符
    path: normalizePath(resolvedPath),
    config,
    dependencies,
  };
} catch (e) {
  createLogger(logLevel).error(
    colors.red(`failed to load config from ${resolvedPath}`),
    { error: e }
  );
  throw e;
}
```
### 讲一讲 pathToFileURL
首先看 `pathToFileURL`, 它来自 `node:url` 中的原生函数, 用来转换路径为 `file:` 协议, 并且可以对路径进行 encode. 我们看下面这个例子:
```ts
import { pathToFileURL } from ""url"";
pathToFileURL(""/hello/おはよう/🦙.txt"");
// URL {
//   href: 'file:///hello/%E3%81%8A%E3%81%AF%E3%82%88%E3%81%86/%F0%9F%A6%99.txt',
//   origin: 'null',
//   protocol: 'file:',
//   username: '',
//   password: '',
//   host: '',
//   hostname: '',
//   port: '',
//   pathname: '/hello/%E3%81%8A%E3%81%AF%E3%82%88%E3%81%86/%F0%9F%A6%99.txt',
//   search: '',
//   searchParams: URLSearchParams {},
//   hash: ''
// }
```
可以看到, 它返回的是 URL 类型. 没错, 就是我们在浏览器中看到的那个 URL.
![URL](https://edge.yancey.app/beg/eoqtlli0-1655641710727.png)
当然 `node:url` 也有个 URL 构造函数, 但比起 `pathToFileURL`, 它无法对路径进行 encode, 这也大抵是 core team 不选择 URL 的原因. 我们看一下官方的例子:
```ts
import { pathToFileURL } from ""node:url"";
new URL(""/foo#1"", ""file:""); // Incorrect: file:///foo#1
pathToFileURL(""/foo#1""); // Correct:   file:///foo%231 (POSIX)
new URL(""/some/path%.c"", ""file:""); // Incorrect: file:///some/path%.c
pathToFileURL(""/some/path%.c""); // Correct:   file:///some/path%25.c (POSIX)
```
最后再说一点, `pathToFileURL` 的返回值是 URL 类型, 可以对它使用 `toString` 函数, 就能获得 URL 中的 href 属性. 因此, vite 源码中直接使用模板字面量, 也就是 `${fileUrl}.js?t=${Date.now()}`, 就把 `fileUrl` 转换成了字符串了.
### 用 esbuild 解析配置文件
`bundleConfigFile` 使用 esbuild 来编译配置文件, 这需要你有一定的 esbuild 知识储备才行. 这块代码难度不大, 直接写在注释里, 具体代码如下:
```ts
async function bundleConfigFile(
  fileName: string,
  isESM = false
): Promise<{ code: string; dependencies: string[] }> {
  const importMetaUrlVarName = ""__vite_injected_original_import_meta_url"";
  const result = await build({
    absWorkingDir: process.cwd(), // 绝对根路径
    entryPoints: [fileName], // 配置文件的绝对路径
    outfile: ""out.js"", // 输出的文件名
    write: false, // 不写入到磁盘, 仅仅能拿到编译结果即可
    platform: ""node"", // 编译到的目标平台, 'browser' | 'node' | 'neutral', 这里显然是 node
    bundle: true, // 是否打包
    format: isESM ? ""esm"" : ""cjs"", // 通过上一步拿到的 isESM 判断打包成的形式
    sourcemap: ""inline"", // 内联 sourcemap
    metafile: true, // 元信息, 一般这个用做打包分析, 类似于 webpack 中的 `stats.json`
    define: {
      // import.meta 是原生 ESM 中的 API, 下面是一个例子
      // <script type=""module"" src=""my-module.mjs""></script>
      // console.log(import.meta.url); // ""file:///home/user/my-module.mjs""
      ""import.meta.url"": importMetaUrlVarName,
    },
    plugins: [
      {
        // 在解析时查找哪些是三方依赖, 标记上 external, 不把它们打包进来
        // 比如下面这段配置:
        /* 
        import { defineConfig } from 'vite'
        import react from '@vitejs/plugin-react'
        // https://vitejs.dev/config/
        export default defineConfig({
          plugins: [react()],
        })
        */
        // 就可以拿到以下三个依赖, 显然应该被打上 external 的是后两个
        // ./vite.config.js
        // vite
        // @vitejs/plugin-react
        name: ""externalize-deps"",
        setup(build) {
          build.onResolve({ filter: /.*/ }, (args) => {
            const id = args.path;
            if (id[0] !== ""."" && !path.isAbsolute(id)) {
              return {
                external: true,
              };
            }
          });
        },
      },
      {
        // 在加载时注入一些额外代码
        // 需要注意的是, 由于 __filename, __dirname 以及 import.meta.url 被这个 plugin 替换了.
        // 如果使用这些名称作为变量名可能会导致代码报错.
        name: ""inject-file-scope-variables"",
        setup(build) {
          build.onLoad({ filter: /\.[jt]s$/ }, async (args) => {
            const contents = await fs.promises.readFile(args.path, ""utf8"");
            const injectValues =
              `const __dirname = ${JSON.stringify(path.dirname(args.path))};` +
              `const __filename = ${JSON.stringify(args.path)};` +
              `const ${importMetaUrlVarName} = ${JSON.stringify(
                pathToFileURL(args.path).href
              )};`;
            return {
              loader: args.path.endsWith("".ts"") ? ""ts"" : ""js"",
              contents: injectValues + contents,
            };
          });
        },
      },
    ],
  });
  const { text } = result.outputFiles[0];
  return {
    code: text, // 被编译后的代码的文本
    dependencies: result.metafile ? Object.keys(result.metafile.inputs) : [], //  这里用来获取 vite.config.js 中导入的非第三方文件列表(比如自定义插件, 方法文件等)
  };
}
```
### dynamicImport
接下来, 我们看到有一个 `dynamicImport` 函数, 比较有意思. 它的作用是动态加载代码, 并且返回一个 Promise, 这个 Promise 就是模块的加载结果.
```ts
export const dynamicImport = usingDynamicImport
  ? new Function(""file"", ""return import(file)"")
  : _require;
```
它有两种方式, 一个是原生 `node:module` 下的 `createRequire` 函数, 我写个例子如下. NodeJS 官网写 [Must be a file URL object, file URL string, or absolute path string.](https://nodejs.org/api/module.html#modulecreaterequirefilename), 不过我看着写相对路径也 OJBK.
```ts
import { createRequire } from ""module"";
const _require = createRequire(import.meta.url);
const siblingModule = _require(""./hello.ts"");
console.log(siblingModule); // 打印出 hello.ts 中的代码
```
第二种方式你可以看到在 `new Function` 的参数里面注入了代码字符串, 如果你不熟悉这种语法的话, 想必也能联想的 eval, 没错, `new Function` 执行代码字符串性能, 安全性要比 eval 高的高, 具体可以看 [never_use_eval](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#never_use_eval!) 这篇文章.
其实 vite 早期代码, 尤大也是用 eval 写的, 后来才改成了 Function. 具体 MR 可以看 [fix: use Function instead of eval to dynamically import config files (#5213)](https://github.com/vitejs/vite/pull/5213)
```ts
async function dynamicImport() {
  const _require = new Function(""file"", ""return import(file)"");
  await _require(""./hello.js"");
}
dynamicImport();
```
### loadConfigFromBundledFile
而对于普通的 cjs 配置文件, 它的解析就类似于上面所说的 `createRequire` 方式.
这里开始使用 `fs.realpathSync` 是为了打平万恶的 Windows 路径格式, 具体可以看 [Vite cannot load configuration files in the link directory (#4180)](https://github.com/vitejs/vite/issues/4180) 这个 issue.
下面就是一些骚操作了. 使用了 `_require.extensions["".js""]`, 也就是以 js 的方式处理模块, 不过最新版的 NodeJS 已经要把 `extensions` 废弃了(看不懂的借口), 总之这玩意儿就是解析 `vite.config.js`.
```ts
const _require = createRequire(import.meta.url);
async function loadConfigFromBundledFile(
  fileName: string,
  bundledCode: string
): Promise<UserConfig> {
  const realFileName = fs.realpathSync(fileName);
  const defaultLoader = _require.extensions["".js""];
  _require.extensions["".js""] = (module: NodeModule, filename: string) => {
    if (filename === realFileName) {
      (module as NodeModuleWithCompile)._compile(bundledCode, filename);
    } else {
      defaultLoader(module, filename);
    }
  };
  // clear cache in case of server restart
  delete _require.cache[_require.resolve(fileName)];
  const raw = _require(fileName);
  _require.extensions["".js""] = defaultLoader;
  return raw.__esModule ? raw.default : raw;
}
```
## mergeConfig
当配置解析完成后, 会通过 `mergeConfig` 函数将配置文件中的配置和 `inlineConfig` 合并, 最终为 vite 提供运行时的框架配置. 该函数会递归地调用 `mergeConfigRecursively` 函数.
```ts
if (loadResult) {
  config = mergeConfig(loadResult.config, config); // 合并配置
  configFile = loadResult.path; // 获取配置文件绝对路径
  configFileDependencies = loadResult.dependencies; // 获取 vite.config.js 中导入的非第三方文件列表(比如自定义插件, 方法文件等)
}
```
关于 `mergeConfigRecursively`, 大抵来讲就是把内联的配置跟配置文件合并到一起, 看到递归就头大, 直接看注释吧.
```ts
function mergeConfigRecursively(
  defaults: Record<string, any>, // 配置文件
  overrides: Record<string, any>, // 内联配置
  rootPath: string
) {
  const merged: Record<string, any> = { ...defaults };
  for (const key in overrides) {
    const value = overrides[key];
    if (value == null) {
      continue;
    }
    const existing = merged[key];
    if (existing == null) {
      merged[key] = value;
      continue;
    }
    // alias 是给 `@rollup/plugin-alias` 传参, vite 需要 format 一下
    // 这是 aliasa 的签名: Record<string, string> | Array<{ find: string | RegExp, replacement: string, customResolver?: ResolverFunction | ResolverObject }>
    //
    // 下面是一个例子:
    //  alias({
    //   entries: [
    //     { find: 'utils', replacement: '../../../utils' },
    //     { find: 'batman-1.0.0', replacement: './joker-1.5.0' }
    //   ]
    // })
    if (key === ""alias"" && (rootPath === ""resolve"" || rootPath === """")) {
      merged[key] = mergeAlias(existing, value);
      continue;
      // merge 资源类型, 常见的像 jpg, webp, mp3 等等
    } else if (key === ""assetsInclude"" && rootPath === """") {
      merged[key] = [].concat(existing, value);
      continue;
    } else if (
      key === ""noExternal"" &&
      rootPath === ""ssr"" &&
      (existing === true || value === true)
    ) {
      merged[key] = true;
      continue;
    }
    // 数组的直接 merge 过来
    if (Array.isArray(existing) || Array.isArray(value)) {
      merged[key] = [...arraify(existing ?? []), ...arraify(value ?? [])];
      continue;
    }
    // 对象继续递归下去
    if (isObject(existing) && isObject(value)) {
      merged[key] = mergeConfigRecursively(
        existing,
        value,
        rootPath ? `${rootPath}.${key}` : key
      );
      continue;
    }
    merged[key] = value;
  }
  return merged;
}
```
## 对插件的前置处理
接下来我们看一下对 plugin 的处理, 这也是本篇比较重点的地方. 由于 vite 的 plugins 的签名是 `(Plugin | Plugin[])[]`, 因此需要先打平成一层操作. 然后过滤掉那些无效的插件, 接下来, 由于插件存在 apply 属性(签名如下):
```ts
apply?: 'serve' | 'build' | ((config: UserConfig, env: ConfigEnv) => boolean)
```
- 如果没提供该属性, 说明开发/生产环境都可用该插件
- 如果是个函数, 那就看看它在当前环境(`'serve' | 'build'`)是否应该存在
- 否则给它赋上当前的环境(`'serve' | 'build'`)
接下来是 `sortUserPlugins` 函数, 由于 vite plugin 提供了 `enforce` 参数, 该参数的值可以是 `pre` 或 `post`, 这个函数就是用来给插件排排坐.
最后就好说了, 就是遍历所有合法的, 已排序的好插件数组, 逐一执行每个插件的 `config` 函数, 并注入 configEnv, 因为 config 钩子函数可以修改配置项, 并返回新的配置项, 拿到新的配置项之后, 让新的配置项和老的配置项合并.
需要注意的是, [`config`](https://vitejs.dev/guide/api-plugin.html#config) 函数在解析 vite 配置前调用. 钩子接收原始用户配置(命令行选项指定的会与配置文件合并)和一个描述配置环境的变量.
走一遍 config 函数之后, 再合并到配置中.
```ts
// resolve plugins
const rawUserPlugins = (config.plugins || []).flat(Infinity).filter((p) => {
  if (!p) {
    return false;
  } else if (!p.apply) {
    // 如果没提供 apply, 说明开发/生产环境都可用该插件
    return true;
  } else if (typeof p.apply === ""function"") {
    return p.apply({ ...config, mode }, configEnv); // 如果是个函数, 那就看看它在当前环境(`'serve' | 'build'`)是否应该存在
  } else {
    return p.apply === command; // 否则给它赋上当前的环境(`'serve' | 'build'`)
  }
}) as Plugin[];
const [prePlugins, normalPlugins, postPlugins] =
  sortUserPlugins(rawUserPlugins); // 排排坐
// run config hooks
const userPlugins = [...prePlugins, ...normalPlugins, ...postPlugins];
for (const p of userPlugins) {
  if (p.config) {
    const res = await p.config(config, configEnv); // 执行插件的 config 钩子, 它执行于在解析 vite 配置前
    if (res) {
      config = mergeConfig(config, res); // 合并到配置中
    }
  }
}
```
接下来, 我们看到一个内置的 resolver, 也就是 `createResolver`, 它主要调用了:
- `createPluginContainer`, 这个函数用于创建插件容器, 是一个对象, 对象的属性是 vite 支持的 rollup 的钩子函数, 比如 options, resolveId, load, transform, 简单说就是 vite 打通 rollup 插件系统的桥梁, 这个我们下一篇重点说.
- `aliasPlugin`: 不多说, 这是 rollup 体系下的一个插件, 我们上面说到了用户可以传递 alias 到 vite, 而这个插件就是把上面解析的 alias 透传给 rollup
```ts
// create an internal resolver to be used in special scenarios, e.g.
// optimizer & handling css @imports
const createResolver: ResolvedConfig[""createResolver""] = (options) => {
  let aliasContainer: PluginContainer | undefined;
  let resolverContainer: PluginContainer | undefined;
  return async (id, importer, aliasOnly, ssr) => {
    let container: PluginContainer;
    if (aliasOnly) {
      container =
        aliasContainer ||
        (aliasContainer = await createPluginContainer({
          ...resolved,
          plugins: [aliasPlugin({ entries: resolved.resolve.alias })],
        }));
    } else {
      container =
        resolverContainer ||
        (resolverContainer = await createPluginContainer({
          ...resolved,
          plugins: [
            aliasPlugin({ entries: resolved.resolve.alias }),
            resolvePlugin({
              ...resolved.resolve,
              root: resolvedRoot,
              isProduction,
              isBuild: command === ""build"",
              ssrConfig: resolved.ssr,
              asSrc: true,
              preferRelative: false,
              tryIndex: true,
              ...options,
            }),
          ],
        }));
    }
    return (await container.resolveId(id, importer, { ssr }))?.id;
  };
};
```
## 对环境变量的处理
由于 vite 使用了 ESM, 因此它使用 `import.meta.env`, 来注入内置环境变量:
- `import.meta.env.MODE`: {string} 应用运行的模式.
- `import.meta.env.BASE_URL`: {string} 部署应用时的基本 URL. 他由 base 配置项决定.
- `import.meta.env.PROD`: {boolean} 应用是否运行在生产环境.
- `import.meta.env.DEV`: {boolean} 应用是否运行在开发环境 (永远与 `import.meta.env.PROD` 相反).
和 create-react-app 一样, vite 也支持用户自建的环境变量文件, 与内置的进行合并或者替换. 其中优先级也是 `.env.xxx.local` > `.env.xxx` > `.env.local` > `.env`, 并且为了防止意外地将一些环境变量泄漏到客户端, 只有以 `VITE_` 为前缀的变量才会暴露给经过 vite 处理的代码. 关于环境变量的文档可以参考官网 [env-variables-and-modes](https://vitejs.dev/guide/env-and-mode.html#env-variables-and-modes).
```ts
// load .env files
const envDir = config.envDir
  ? normalizePath(path.resolve(resolvedRoot, config.envDir))
  : resolvedRoot;
const userEnv =
  inlineConfig.envFile !== false &&
  loadEnv(mode, envDir, resolveEnvPrefix(config));
```
我们详细看一下 `loadEnv` 这个函数.
首先看下 `mode`, 官网写的很清楚, 其实就是环境变量的名称, 不限于我们常用的 `development`, `production`. 你可以根据需要起名叫 `testing`, `staging`. 但是它不能叫 `local`, 要不 `.env.xxx(local)` 和 `.env.local` 就重复了.
然后和 CRA 一样, 只取环境变量中 `VITE_` 开头或者用户自定义前缀的, 暴露到客户端, 这样保证隐私字段(非 `VITE_` 开头的)不会被注入.
vite 用到了 [dotenvExpand](https://github.com/motdotla/dotenv-expand) 这个三方库, 它负责将 env 文件中的环境变量注入到 `process.env` 或者合并到某个指定对象中. 注意 vite 设置了 `ignoreProcessEnv: true`, 我们看下面一个例子就知道它是做什么的了:
```ts
const dotenv = {
  ignoreProcessEnv: true,
  parsed: {
    SHOULD_NOT_EXIST: ""testing"",
  },
};
const obj = dotenvExpand.expand(dotenv).parsed;
console.log(obj.SHOULD_NOT_EXIST); // testing
console.log(process.env.SHOULD_NOT_EXIST); // undefined
```
下面我们过一遍源码:
```ts
import fs from ""fs"";
import dotenv from ""dotenv"";
import dotenvExpand from ""dotenv-expand"";
import { arraify, lookupFile } from ""./utils"";
import type { UserConfig } from ""./config"";
export function loadEnv(
  mode: string,
  envDir: string,
  prefixes: string | string[] = ""VITE_""
): Record<string, string> {
  if (mode === ""local"") {
    throw new Error(
      `""local"" cannot be used as a mode name because it conflicts with ` +
        `the .local postfix for .env files.`
    );
  }
  prefixes = arraify(prefixes);
  const env: Record<string, string> = {};
  const envFiles = [
    /** mode local file */ `.env.${mode}.local`,
    /** mode file */ `.env.${mode}`,
    /** local file */ `.env.local`,
    /** default file */ `.env`,
  ];
  // check if there are actual env variables starting with VITE_*
  // these are typically provided inline and should be prioritized
  // 先把 process.env 中 VITE_ 开头的收集一波
  for (const key in process.env) {
    if (
      prefixes.some((prefix) => key.startsWith(prefix)) &&
      env[key] === undefined
    ) {
      env[key] = process.env[key] as string;
    }
  }
  for (const file of envFiles) {
    const path = lookupFile(envDir, [file], {
      pathOnly: true,
      rootDir: envDir,
    });
    if (path) {
      // 用 dotenv 解析 env 文件, 这个库太常见了, 不多说.
      const parsed = dotenv.parse(fs.readFileSync(path), {
        debug: process.env.DEBUG?.includes(""vite:dotenv"") || undefined,
      });
      // let environment variables use each other
      // 合并环境变量配置, 但不把环境变量注入到 process.env 中
      dotenvExpand({
        parsed,
        // prevent process.env mutation
        ignoreProcessEnv: true,
      } as any);
      // only keys that start with prefix are exposed to client
      // 再过滤掉非 VITE_ 开头的
      for (const [key, value] of Object.entries(parsed)) {
        if (
          prefixes.some((prefix) => key.startsWith(prefix)) &&
          env[key] === undefined
        ) {
          env[key] = value;
        } else if (
          key === ""NODE_ENV"" &&
          process.env.VITE_USER_NODE_ENV === undefined
        ) {
          // NODE_ENV override in .env file
          process.env.VITE_USER_NODE_ENV = value;
        }
      }
    }
  }
  return env;
}
```
## 一些杂项的处理
接下来有一些杂项需要处理, 虽说是杂项, 就是代码不是特别复杂, 所以没必要分开写了, 直接看注释.
```ts
// 创建一个 Logger 的实例
const logger = createLogger(config.logLevel, {
  allowClearScreen: config.clearScreen,
  customLogger: config.customLogger,
});
// 由于 vite 支持 worker, 所以处理一些 worker 的配置
// https://vitejs.dev/config/#worker-options
const resolvedWorkerOptions: ResolveWorkerOptions = {
  format: config.worker?.format || ""iife"", // worker 文件默认打包成立即执行函数的形式
  plugins: [],
  rollupOptions: config.worker?.rollupOptions || {},
};
// resolve root
// 拿到根目录路径, 默认是 process.cwd(), 也就是项目路径
// normalizePath 上面讲了, 主要是为了兼容 Windows
const resolvedRoot = normalizePath(
  config.root ? path.resolve(config.root) : process.cwd()
);
// 上面我们讲到了 alias, 这里是给内置的两个包加上 alias
const clientAlias = [
  { find: /^[\/]?@vite\/env/, replacement: () => ENV_ENTRY }, // ENV_ENTRY => dist/client/env.mjs
  { find: /^[\/]?@vite\/client/, replacement: () => CLIENT_ENTRY }, // CLIENT_ENTRY => dist/client/client.mjs
];
// resolve alias with internal client alias
// 然后将用户传的, 和内置的 alias 合并到一起
const resolvedAlias = normalizeAlias(
  mergeAlias(
    // @ts-ignore because @rollup/plugin-alias' type doesn't allow function
    // replacement, but its implementation does work with function values.
    clientAlias,
    config.resolve?.alias || []
  )
);
const resolveOptions: ResolvedConfig[""resolve""] = {
  ...config.resolve,
  alias: resolvedAlias,
};
// Note it is possible for user to have a custom mode, e.g. `staging` where
// production-like behavior is expected. This is indicated by NODE_ENV=production
// loaded from `.staging.env` and set by us as VITE_USER_NODE_ENV
// 不多说, 统一下 NODE_ENV 环境变量
const isProduction =
  (process.env.NODE_ENV || process.env.VITE_USER_NODE_ENV || mode) ===
  ""production"";
if (isProduction) {
  // in case default mode was not production and is overwritten
  process.env.NODE_ENV = ""production"";
}
// 处理 build options
// 具体字段可以看 https://vitejs.dev/config/#build-target
const resolvedBuildOptions = resolveBuildOptions(config.build);
// resolve cache directory
// ok, 讲到这里我们终于看到了 node_modules/.vite 这个文件夹
// 没错, 这就是 vite 的一大杀器: 预构建
// 具体原理我们后面说, 这里只是讲下配置
const pkgPath = lookupFile(resolvedRoot, [`package.json`], { pathOnly: true });
const cacheDir = config.cacheDir
  ? path.resolve(resolvedRoot, config.cacheDir)
  : pkgPath
  ? path.join(path.dirname(pkgPath), `node_modules/.vite`)
  : path.join(resolvedRoot, `.vite`);
const { publicDir } = config;
// 解析静态文件 dir, 默认是根目录下的 public 文件夹
const resolvedPublicDir =
  publicDir !== false && publicDir !== """"
    ? path.resolve(
        resolvedRoot,
        typeof publicDir === ""string"" ? publicDir : ""public""
      )
    : """";
// 解析 server 配置, 也就是 开发服务, hmr, ws 那一套, 下一篇我们着重来讲
// 具体配置可以看 https://vitejs.dev/config/#server-options
const server = resolveServerOptions(resolvedRoot, config.server, logger);
// 解析 ssr 相关, 因为截止到当前版本 ssr 还不够稳定, 本系列可能讲的会比较少, 看情况吧
// 具体配置可以看 https://vitejs.dev/config/#ssr-options
const ssr = resolveSSROptions(config.ssr);
// 拿到优化配置, 有 vite 本身的优化配置, 也有 esbuild 的.
const optimizeDeps = config.optimizeDeps || {};
```
## 对插件的后置处理
在一系列操作之后, 其他配置解析的差不多了, 于是 vite 会对插件进行后置处理. 首先 vite 会对 worker 的插件进行处理, 和普通用户插件一样, worker 的插件也需要经过 `sortUserPlugins` 分治的过程.
```ts
// Some plugins that aren't intended to work in the bundling of workers (doing post-processing at build time for example).
// And Plugins may also have cached that could be corrupted by being used in these extra rollup calls.
// So we need to separate the worker plugin from the plugin that vite needs to run.
const [workerPrePlugins, workerNormalPlugins, workerPostPlugins] =
  sortUserPlugins(config.worker?.plugins as Plugin[]);
const workerResolved: ResolvedConfig = {
  ...resolved,
  isWorker: true,
  mainConfig: resolved,
};
```
然后分别对 worker, user 两组插件进行 resolve, 使用的是 `resolvePlugins` 方法. 该方法根据 plugin 的执行顺序, 和内置通用插件进行融合.
我们知道 vite 插件有个 [`configResolved`](https://vitejs.dev/guide/api-plugin.html#configresolved) 钩子, 它在解析 vite 配置后调用. 使用这个钩子读取和存储最终解析的配置. 当插件需要根据运行的命令做一些不同的事情时, 它很有用. 所以在所有配置 resolve 之后, 会统一执行这个函数.
```ts
resolved.worker.plugins = await resolvePlugins(
  workerResolved,
  workerPrePlugins,
  workerNormalPlugins,
  workerPostPlugins
);
// call configResolved worker plugins hooks
// 在解析 vite 配置后调用. 使用这个钩子读取和存储最终解析的配置
await Promise.all(
  resolved.worker.plugins.map((p) => p.configResolved?.(workerResolved))
);
(resolved.plugins as Plugin[]) = await resolvePlugins(
  resolved,
  prePlugins,
  normalPlugins,
  postPlugins
);
// call configResolved hooks
await Promise.all(userPlugins.map((p) => p.configResolved?.(resolved)));
```
最后放一下 `resolvePlugins` 函数, 很明显 vite 运行依赖一些内置插件, 而用户插件可能有顺序要求(enforce), 于是就把用户插件插到适当的位置. 关于详细的插件系统, 我们放到下一篇文章讲解.
```ts
export async function resolvePlugins(
  config: ResolvedConfig,
  prePlugins: Plugin[],
  normalPlugins: Plugin[],
  postPlugins: Plugin[]
): Promise<Plugin[]> {
  const isBuild = config.command === ""build"";
  const isWatch = isBuild && !!config.build.watch;
  const buildPlugins = isBuild
    ? (await import(""../build"")).resolveBuildPlugins(config)
    : { pre: [], post: [] };
  return [
    isWatch ? ensureWatchPlugin() : null,
    isBuild ? metadataPlugin() : null,
    isBuild ? null : preAliasPlugin(config),
    aliasPlugin({ entries: config.resolve.alias }),
    ...prePlugins, // 前置插件
    config.build.polyfillModulePreload
      ? modulePreloadPolyfillPlugin(config)
      : null,
    ...(isDepsOptimizerEnabled(config)
      ? [
          isBuild
            ? optimizedDepsBuildPlugin(config)
            : optimizedDepsPlugin(config),
        ]
      : []),
    resolvePlugin({
      ...config.resolve,
      root: config.root,
      isProduction: config.isProduction,
      isBuild,
      packageCache: config.packageCache,
      ssrConfig: config.ssr,
      asSrc: true,
      getDepsOptimizer: () => getDepsOptimizer(config),
      shouldExternalize:
        isBuild && config.build.ssr && config.ssr?.format !== ""cjs""
          ? (id) => shouldExternalizeForSSR(id, config)
          : undefined,
    }),
    htmlInlineProxyPlugin(config),
    cssPlugin(config),
    config.esbuild !== false ? esbuildPlugin(config.esbuild) : null,
    jsonPlugin(
      {
        namedExports: true,
        ...config.json,
      },
      isBuild
    ),
    wasmHelperPlugin(config),
    webWorkerPlugin(config),
    assetPlugin(config),
    ...normalPlugins, // 普通插件
    wasmFallbackPlugin(),
    definePlugin(config),
    cssPostPlugin(config),
    config.build.ssr ? ssrRequireHookPlugin(config) : null,
    isBuild && buildHtmlPlugin(config),
    workerImportMetaUrlPlugin(config),
    ...buildPlugins.pre,
    dynamicImportVarsPlugin(config),
    importGlobPlugin(config),
    ...postPlugins, // 后置插件
    ...buildPlugins.post,
    // internal server-only plugins are always applied after everything else
    ...(isBuild
      ? []
      : [clientInjectionsPlugin(config), importAnalysisPlugin(config)]),
  ].filter(Boolean) as Plugin[];
}
```
## 总结
最后我们贴一下最终解析的配置, 我们做一个复习:
```ts
const resolved: ResolvedConfig = {
  ...config,
  configFile: configFile ? normalizePath(configFile) : undefined, // 配置文件路径
  configFileDependencies: configFileDependencies.map((name) =>
    normalizePath(path.resolve(name))
  ), // vite.config.js 中非第三方包的导入, 比如自定义插件
  inlineConfig, // 命令行中的配置
  root: resolvedRoot, // 项目根目录
  base: BASE_URL, // 公共基础路径,  /my-app/index.html
  resolve: resolveOptions, // 文件解析时的相关配置
  publicDir: resolvedPublicDir, // 静态资源服务的文件夹
  cacheDir, // 缓存目录, 默认 node_modules/.vite
  command, // serve | build
  mode, // development | production
  ssr,
  isWorker: false,
  mainConfig: null,
  isProduction, // 是否是生产环境
  plugins: userPlugins, // 自定义 plugins
  server,
  build: resolvedBuildOptions,
  preview: resolvePreviewOptions(config.preview, server),
  env: {
    ...userEnv,
    BASE_URL,
    MODE: mode,
    DEV: !isProduction,
    PROD: isProduction,
  },
  assetsInclude(file: string) {
    return DEFAULT_ASSETS_RE.test(file) || assetsFilter(file);
  },
  logger,
  packageCache: new Map(),
  createResolver, // 特殊场景中使用的内部解析器, 预构建文件中会说到
  optimizeDeps: {
    // 由于优化依赖(也就是依赖预构建)使用了 esbuild, 这里基本就是透传 esbuild 的配置, 当然也有一些 vite 自己的配置: https://vitejs.dev/config/#dep-optimization-options
    ...optimizeDeps,
    esbuildOptions: {
      preserveSymlinks: config.resolve?.preserveSymlinks,
      ...optimizeDeps.esbuildOptions,
    },
  },
  worker: resolvedWorkerOptions,
  spa: config.spa ?? true,
};
```
1. 使用 `mode` 和 `command` 构造出核心的环境对象 `configEnv`
2. 使用 `loadConfigFromFile` 读取配置文件, 并使用 `mergeConfig` 和 `inlineConfig` 进行递归合并
3. 将插打平, 通过 `apply` 过滤出当前环境(`serve|build`) 需要的插件
4. 使用 `sortUserPlugins`, 根据 `enforce` 字段将所有插件排排队, 存放在 `prePlugins`, `normalPlugins` 和 `postPlugins` 三个数组中
5. 然后将排好队的插件执行插件中的 `config` 方法, config 方法是 vite 独有的钩子方法, 它是在解析 vite 配置前调用. 执行完毕后, 再使用 `mergeConfig` 和当前配置进行递归合并
6. 创建 `createResolver`, 特殊场景中使用的内部解析器, 预构建文件中会说到. 这个方法主要使用了 `createPluginContainer` 函数来连接 rollup 插件系统, 这个下一篇会说
7. 处理 rootPath; 合并内置和用户自定义的 alias; 处理 env 配置; 处理 baseUrl; 处理 public 文件夹; 处理预解析缓存(`node_modules/.vite`)目录; 解析 assetsInclude 指定文件类型作为静态资源处理; 解析 [server 配置](https://vitejs.dev/config/#server-options)和 [ssr 配置](https://vitejs.dev/config/#ssr-options);
8. 创建 createResolver 方法用于内部指定场景的解析器, 比如 optimizer 或处理 css @import
9. 执行 `resolvePlugins`, 合并用户配置的 plugin 和内部已有的 plugin
10. 依次执行排好序的插件的 `configResolved` 函数(该函数在解析 vite 配置后调用. 使用这个钩子读取和存储最终解析的配置)
11. 返回最终 resolved","2025-02-02 03:09:33.149605","2025-02-02 03:09:33.149605"
"bc9c8fd0-276c-4072-b898-9420cf0374a6","{Vite}",0,0,False,"https://edge.yancey.app/beg/fhmlkpmr-1698216644928.jpg","Vite 源码解析(2) - 模块依赖图","由于现代前端都是模块化开发, 因此各个模块之间会产生各种各样多对多的依赖关系. 为此, 各个打包器都要以 entry 作为起点, 去寻找整个 APP 的模块依赖图. vite 也不例外, 我们这篇文章就来学习下 vite 的 ModuleGraph 是如何实现的.","## ModuleGraph 实例
在 createServer 中, 我们看到会创建一个 ModuleGraph 实例, 并把它作为参数传递到 `createPluginContainer`(我们下一章重点来讲 vite 的插件机制) 函数中, 供一些插件使用. 此外, 该实例也会传递到 `devServer`(我们下下章重点来讲 vite 的开发服务及中间件机制) 对象中, 供后续的 HMR 等使用.
```ts
const moduleGraph: ModuleGraph = new ModuleGraph((url, ssr) =>
  container.resolveId(url, undefined, { ssr })
);
const container = await createPluginContainer(config, moduleGraph, watcher);
const server: ViteDevServer = {
  config,
  middlewares,
  httpServer,
  watcher,
  pluginContainer: container,
  ws,
  moduleGraph,
  // ...
};
```
## ModuleNode
ModuleNode 是每个模块节点的原子信息, vite 正是通过它将所有的模块关联起来, 形成模块依赖图. 下面我们来简单介绍下各个属性.
```ts
export class ModuleNode {
  url: string; // 以 / 开头的相对路径
  id: string | null = null; // 模块的绝对路径, 但可能带着 hash 和 query
  file: string | null = null; // 模块的绝对路径, 不带 hash 和 query
  type: ""js"" | ""css""; // 如果路径上带着 &direct, 则为 css, 否则为 js
  info?: ModuleInfo; // 模块信息, 来自 rollup, 有 ast, 源码字符串等, 详情: https://rollupjs.org/guide/en/#thisgetmoduleinfo
  meta?: Record<string, any>; // 自定义的元信息
  importers = new Set<ModuleNode>(); // 导入当前模块的模块的集合
  importedModules = new Set<ModuleNode>(); // 当前模块的导入模块集合(或者说谁用到)
  acceptedHmrDeps = new Set<ModuleNode>(); // 接收的热更新依赖的集合, 我们放在热更新那一章来讲
  isSelfAccepting?: boolean; // 是否为模块自更新
  transformResult: TransformResult | null = null; // 通过插件构建后的结果
  ssrTransformResult: TransformResult | null = null;
  ssrModule: Record<string, any> | null = null;
  ssrError: Error | null = null;
  lastHMRTimestamp = 0; // HMR 最后更新时间, 也就给给模块 url 上附上 &t=xxxxxxxxxxxxx 的那个时间戳
  lastInvalidationTimestamp = 0; // 最后失效的时间, 如果你的模块时间戳超过它, 说明就过期了
  constructor(url: string) {
    this.url = url;
    this.type = isDirectCSSRequest(url) ? ""css"" : ""js""; // 判断是 js 还是 css, 注意这里的 css 也可能是 sass, less 等等
    // #7870
    // The `isSelfAccepting` value is set by importAnalysis, but some
    // assets don't go through importAnalysis.
    // 过滤掉 html 文件和不需要被导入分析的模块(json, sourcemap, direct css)
    // 这些模块不需要关注自更新
    if (isHTMLRequest(url) || canSkipImportAnalysis(url)) {
      this.isSelfAccepting = false;
    }
  }
}
```
## ModuleGraph 各个属性, 方法一览
```ts
export class ModuleGraph {
  urlToModuleMap: Map<string, ModuleNode>; //  key 为相对路径, value 为 ModuleNode 的集合
  idToModuleMap: Map<string, ModuleNode>; // key 为模块的绝对路径(但可能带着 hash 和 query), value 为 ModuleNode 的集合
  fileToModulesMap: Map<string, Set<ModuleNode>>; // key 为模块的绝对路径(不带 hash 和 query), value 为 ModuleNode 的集合
  safeModulesPath: Set<string>; // 哪些模块是安全模块, 后面讲 importAnalysis 插件时再做讲解
  constructor(
    private resolveId: (
      url: string,
      ssr: boolean
    ) => Promise<PartialResolvedId | null>
  );
  async getModuleByUrl(
    rawUrl: string,
    ssr?: boolean
  ): Promise<ModuleNode | undefined>;
  getModuleById(id: string): ModuleNode | undefined;
  getModulesByFile(file: string): Set<ModuleNode> | undefined;
  onFileChange(file: string): void;
  invalidateModule(
    mod: ModuleNode,
    seen?: Set<ModuleNode>,
    timestamp?: number
  ): void;
  invalidateAll(): void;
  async updateModuleInfo(
    mod: ModuleNode,
    importedModules: Set<string | ModuleNode>,
    acceptedModules: Set<string | ModuleNode>,
    isSelfAccepting: boolean,
    ssr?: boolean
  ): Promise<Set<ModuleNode> | undefined>;
  async ensureEntryFromUrl(rawUrl: string, ssr?: boolean): Promise<ModuleNode>;
  createFileOnlyEntry(file: string): ModuleNode;
  resolveUrl(url: string, ssr?: boolean): Promise<ResolvedUrl>;
}
```
## urlToModuleMap
![urlToModuleMap](https://edge.yancey.app/beg/a06erl0e-1662381583472.png)
## idToModuleMap
![idToModuleMap](https://edge.yancey.app/beg/mkavjro0-1662371863129.png)
## fileToModulesMap
![fileToModulesMap](https://edge.yancey.app/beg/aabdi50e-1662380041318.png)
## safeModulesPath
![safeModulesPath](https://edge.yancey.app/beg/976f0ng8-1662380109196.png)
## getModuleByUrl
根据一个 url 获取对应的 ModuleNode. url 为模块的相对路径.
```ts
export class ModuleGraph {
  async getModuleByUrl(
    rawUrl: string,
    ssr?: boolean
  ): Promise<ModuleNode | undefined> {
    const [url] = await this.resolveUrl(rawUrl, ssr);
    return this.urlToModuleMap.get(url);
  }
}
```
## getModuleById
根据一个 id 获取对应的 ModuleNode. id 为模块的绝对路径(可能带着 hash 和 query)
```ts
export class ModuleGraph {
  getModuleById(id: string): ModuleNode | undefined {
    // 我们知道 vite 为了判断源码模块的新鲜度. 给 url 加了一个 ?t=xxxxxxxxxxxxx
    // removeTimestampQuery 就是把这个 query 去掉
    return this.idToModuleMap.get(removeTimestampQuery(id));
  }
}
```
## getModulesByFile
根据一个 file 获取对应的 ModuleNode 集合. file 为模块的绝对路径(不带 hash 和 query).
```ts
export class ModuleGraph {
  getModulesByFile(file: string): Set<ModuleNode> | undefined {
    return this.fileToModulesMap.get(file);
  }
}
```
## onFileChange
当文件发生变化时, 就把旧的文件批量过期掉.
```ts
export class ModuleGraph {
  onFileChange(file: string): void {
    const mods = this.getModulesByFile(file);
    if (mods) {
      const seen = new Set<ModuleNode>();
      mods.forEach((mod) => {
        this.invalidateModule(mod, seen);
      });
    }
  }
}
```
## invalidateModule
将模块过期, 思路很简单, 把时间改了即可.
```ts
export class ModuleGraph {
  invalidateModule(
    mod: ModuleNode,
    seen: Set<ModuleNode> = new Set(),
    timestamp: number = Date.now()
  ): void {
    // Save the timestamp for this invalidation, so we can avoid caching the result of possible already started
    // processing being done for this module
    // lastInvalidationTimestamp 上面说了, 是最后失效的时间, 如果你的模块时间戳超过它, 说明就过期了
    // 所以把当前模块时间戳赋值给 lastInvalidationTimestamp, 那这个模块就过期了
    mod.lastInvalidationTimestamp = timestamp;
    // Don't invalidate mod.info and mod.meta, as they are part of the processing pipeline
    // Invalidating the transform result is enough to ensure this module is re-processed next time it is requested
    // 把经过插件转换后的结果废弃掉
    mod.transformResult = null;
    mod.ssrTransformResult = null;
    invalidateSSRModule(mod, seen);
  }
}
```
## invalidateAll
没啥说的, 循环废掉当前 id 下的所有模块.
```ts
export class ModuleGraph {
  invalidateAll(): void {
    const timestamp = Date.now();
    const seen = new Set<ModuleNode>();
    this.idToModuleMap.forEach((mod) => {
      this.invalidateModule(mod, seen, timestamp);
    });
  }
}
```
## updateModuleInfo
当导入关系发生变化时, 需要更新模块之间的关系. 这也是 ModuleGraph 最重要的一个方法.
```ts
export class ModuleGraph {
  /**
   * Update the module graph based on a module's updated imports information
   * If there are dependencies that no longer have any importers, they are
   * returned as a Set.
   */
  async updateModuleInfo(
    mod: ModuleNode, // 当前模块对应的 ModuleNode 对象
    importedModules: Set<string | ModuleNode>, // 当前模块导入的模块
    acceptedModules: Set<string | ModuleNode>, // 当前模块接收热更新模块的合集
    isSelfAccepting: boolean, // 如果是自身更新则为 true
    ssr?: boolean
  ): Promise<Set<ModuleNode> | undefined> {
    mod.isSelfAccepting = isSelfAccepting;
    // 先把 importedModules(当前模块导入的模块集合) 保存一份
    const prevImports = mod.importedModules;
    // 创建一个空的 Set
    const nextImports = (mod.importedModules = new Set());
    // 不再导入的模块集合
    let noLongerImported: Set<ModuleNode> | undefined;
    // update import graph
    // 遍历新的导入的 modules
    for (const imported of importedModules) {
      const dep =
        typeof imported === ""string""
          ? await this.ensureEntryFromUrl(imported, ssr)
          : imported;
      // 将当前模块(mod)添加到被导入模块(dep) 的 importer 上
      dep.importers.add(mod);
      // 把这个被导入的模块(dep) 添加到 nextImports 中
      nextImports.add(dep);
    }
    // remove the importer from deps that were imported but no longer are.
    prevImports.forEach((dep) => {
      // 如果 nextImports 中没有这个 dep
      if (!nextImports.has(dep)) {
        // 反过来说明 dep 没在当前模块中导入, 所以把 dep 的 importers 删除掉当前 mod
        dep.importers.delete(mod);
        // 如果 dep 的 importers 为空
        if (!dep.importers.size) {
          // 说明 dep 没有被任何模块导入, 于是把它归类到 noLongerImported 中
          // dependency no longer imported
          (noLongerImported || (noLongerImported = new Set())).add(dep);
        }
      }
    });
    // update accepted hmr deps
    // 将 import.meta.hot.accept() 中设置的模块添加到 mod.acceptedModules 中
    const deps = (mod.acceptedHmrDeps = new Set());
    for (const accepted of acceptedModules) {
      const dep =
        typeof accepted === ""string""
          ? await this.ensureEntryFromUrl(accepted, ssr)
          : accepted;
      deps.add(dep);
    }
    // 返回不再被任何模块导入的模块的集合
    return noLongerImported;
  }
}
```
## ensureEntryFromUrl
目的就是如果找到这个模块, 就把这个模块返回, 否则创建一个新的 ModuleNode, 并放置到 urlToModuleMap, idToModuleMap, fileToModulesMap.
```ts
export class ModuleGraph {
  async ensureEntryFromUrl(rawUrl: string, ssr?: boolean): Promise<ModuleNode> {
    const [url, resolvedId, meta] = await this.resolveUrl(rawUrl, ssr);
    let mod = this.urlToModuleMap.get(url);
    // 如果没获取 mod
    if (!mod) {
      // new 一个新的 ModuleNode
      mod = new ModuleNode(url);
      if (meta) mod.meta = meta;
      // 加入到 urlToModuleMap
      this.urlToModuleMap.set(url, mod);
      mod.id = resolvedId;
      // 加入到 idToModuleMap
      this.idToModuleMap.set(resolvedId, mod);
      // 清除掉 hash, query 作为 file
      const file = (mod.file = cleanUrl(resolvedId));
      let fileMappedModules = this.fileToModulesMap.get(file);
      // 如果没有 fileMappedModules Set
      if (!fileMappedModules) {
        // 初始化一个
        fileMappedModules = new Set();
        this.fileToModulesMap.set(file, fileMappedModules);
      }
      // 否则添加进去即可
      fileMappedModules.add(mod);
    }
    // 返回 mod
    return mod;
  }
}
```
## createFileOnlyEntry
对于像 @import 这种也要放在模块依赖图中.
```ts
export class ModuleGraph {
  // some deps, like a css file referenced via @import, don't have its own
  // url because they are inlined into the main css import. But they still
  // need to be represented in the module graph so that they can trigger
  // hmr in the importing css file.
  createFileOnlyEntry(file: string): ModuleNode {
    file = normalizePath(file);
    let fileMappedModules = this.fileToModulesMap.get(file);
    if (!fileMappedModules) {
      fileMappedModules = new Set();
      this.fileToModulesMap.set(file, fileMappedModules);
    }
    const url = `${FS_PREFIX}${file}`;
    for (const m of fileMappedModules) {
      if (m.url === url || m.id === file) {
        return m;
      }
    }
    const mod = new ModuleNode(url);
    mod.file = file;
    fileMappedModules.add(mod);
    return mod;
  }
}
```
## resolveUrl
```ts
export class ModuleGraph {
  // for incoming urls, it is important to:
  // 1. remove the HMR timestamp query (?t=xxxx)
  // 2. resolve its extension so that urls with or without extension all map to
  // the same module
  // 1. 去掉热更新带着的 import=xxxx 和 ?t=xxxxxx 参数
  // 2. 解析其扩展名，以便带有或不带有扩展名的 url 都映射到同一个模块
  async resolveUrl(url: string, ssr?: boolean): Promise<ResolvedUrl> {
    url = removeImportQuery(removeTimestampQuery(url));
    // resolveId 是 rollup 插件体系的, 它就是获取当前模块在文件系统的绝对路径, 下一章讲插件会说到
    const resolved = await this.resolveId(url, !!ssr);
    const resolvedId = resolved?.id || url;
    const ext = extname(cleanUrl(resolvedId));
    const { pathname, search, hash } = parseUrl(url);
    if (ext && !pathname!.endsWith(ext)) {
      url = pathname + ext + (search || """") + (hash || """");
    }
    return [url, resolvedId, resolved?.meta];
  }
}
```","2025-02-02 03:09:35.474342","2025-02-02 03:09:35.474342"
"64b2f9ac-8ae8-44fd-a6ab-b5bc47eca83c","{BitCoin,BlockChain}",0,0,False,"https://edge.yancey.app/beg/ks9p4z8s-1734947821515.jpg","An Overview of Blockchain","An Overview of Blockchain","An Overview of Blockchain","2025-02-02 03:09:48.313409","2025-02-02 03:09:48.313409"
